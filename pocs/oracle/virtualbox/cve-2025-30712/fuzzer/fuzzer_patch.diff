diff --git a/AutoConfig.kmk b/AutoConfig.kmk
index e5c0b5cb..1d9a437c 100644
--- a/AutoConfig.kmk
+++ b/AutoConfig.kmk
@@ -36,6 +36,8 @@ SDK_VBoxLibCurl_LIBS           := curl
 SDK_VBoxLibCurl_INCS           := 
 SDK_VBoxLibVpx_INCS            := 
 SDK_VBoxLibVpx_LIBS            := vpx m
+SDK_VBoxLibLzma_INCS           := 
+SDK_VBoxLibLzma_LIBS           := lzma
 SDK_VBoxLibPng_LIBS            := png
 SDK_VBoxLibPng_INCS            := 
 LIB_SDK_LIBSDL_SDL             := SDL
@@ -55,7 +57,7 @@ VBOX_WITH_PYTHON               := 1
 VBOX_PATH_PYTHON_INC           := /usr/include/python3.12
 VBOX_LIB_PYTHON                := /usr/lib/x86_64-linux-gnu/libpython3.12.so
 VBOX_WITH_AUDIO_PULSE          := 1
-VBOX_LINUX_SRC                 := /lib/modules/6.8.0-51-generic/build
+VBOX_LINUX_SRC                 := /lib/modules/6.11.0-29-generic/build
 VBOX_WITH_DEVMAPPER            := 1
 VBOX_MAKESELF                  := /usr/bin/makeself
 VBOX_WITH_WEBSERVICES          := 
diff --git a/Config.kmk b/Config.kmk
index bdcbd398..9f213285 100644
--- a/Config.kmk
+++ b/Config.kmk
@@ -2000,19 +2000,19 @@ ifndef VBOX_GCC_TOOL
    TOOL_GXX3PLAIN_LD_SYSMOD ?= /usr/ccs/bin/ld
   endif
  else
-  VBOX_GCC_TOOL := GXX3
+  VBOX_GCC_TOOL := CLANG
   ifeq ($(KBUILD_TARGET_ARCH).$(KBUILD_HOST_ARCH),x86.amd64) ## @todo mixing target/host here!
-   VBOX_GCC_TOOL := GXX32
+   VBOX_GCC_TOOL := CLANG
    VBOX_WITH_VBOXDRV =
   else ifeq ($(KBUILD_TARGET_ARCH).$(KBUILD_HOST_ARCH),amd64.x86)
-   VBOX_GCC_TOOL := GXX64
+   VBOX_GCC_TOOL := CLANG
    VBOX_WITH_VBOXDRV =
   endif
  endif
 endif
 ifndef VBOX_GCC32_TOOL
  ifeq ($(KBUILD_TARGET_ARCH),x86)
-  VBOX_GCC32_TOOL := $(VBOX_GCC_TOOL)
+  VBOX_GCC32_TOOL := CLANG
  else ifeq ($(KBUILD_TARGET),win)
   VBOX_GCC32_TOOL := MINGW32
  else
@@ -2020,6 +2020,8 @@ ifndef VBOX_GCC32_TOOL
  endif
 endif
 
+VBOX_GCC32_TOOL := CLANG
+
 #
 # Decide which Visual C++ compiler version we're using by default.
 #
@@ -2070,7 +2072,7 @@ endif
 # Default tool nonsense.
 #
 ## @todo Remove the default tool crap here!
-TOOL = $(VBOX_GCC_TOOL)
+TOOL = CLANG
 TOOL.win.x86 = $(VBOX_VCC_TOOL_STEM)X86
 TOOL.win.amd64 = $(VBOX_VCC_TOOL_STEM)AMD64
 ASTOOL := $(VBOX_ASTOOL)
@@ -2107,6 +2109,7 @@ DEFS.solaris     = RT_OS_SOLARIS _FILE_OFFSET_BITS=64
 DEFS.win         = RT_OS_WINDOWS __WIN__
 DEFS.win.x86     = __WIN32__
 DEFS.win.amd64   = __WIN64__
+
 # optional defines (use environment or make commandline)
 ifdef VBOX_WITH_STATISTICS
  DEFS += VBOX_WITH_STATISTICS
@@ -3699,6 +3702,10 @@ ifndef VBOX_VCC_std
  endif
 endif
 
+ifeq ($(KMOONSHINE_FUZZER), yes)
+   VBOX_GCC_std := -std=c++17
+endif
+
 
 #
 # Compiler warning control.
@@ -5650,7 +5657,7 @@ ifeq ($(VBOX_LDR_FMT),pe)
 endif # pe
 
 ifeq ($(VBOX_LDR_FMT),elf)
- TEMPLATE_VBoxR0_TOOL               = $(VBOX_GCC_TOOL)
+ TEMPLATE_VBoxR0_TOOL               = CLANG
  TEMPLATE_VBoxR0_CFLAGS             = -fno-pie -nostdinc -g $(VBOX_GCC_pipe) $(VBOX_GCC_WERR) $(VBOX_GCC_PEDANTIC_C) \
  	$(VBOX_GCC_Wno-variadic-macros) $(VBOX_GCC_R0_OPT) $(VBOX_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions \
  	$(VBOX_GCC_fno-stack-protector) -fno-common -ffreestanding $(VBOX_GCC_fvisibility-hidden) -std=gnu99 $(VBOX_GCC_IPRT_FMT_CHECK)
@@ -6107,7 +6114,7 @@ ifeq ($(KBUILD_TARGET),freebsd)
  ## The FreeBSD /usr/include.
  VBOX_FREEBSD_SYS_INCS ?= /usr/include
 
- TEMPLATE_VBoxR0Drv_TOOL               = $(VBOX_GCC_TOOL)
+ TEMPLATE_VBoxR0Drv_TOOL               = CLANG
  TEMPLATE_VBoxR0Drv_LDTOOL             = FreeBsdKModLd
  TEMPLATE_VBoxR0Drv_DEFS              += _KERNEL KLD_MODULE
  if $(VBOX_GCC_VERSION_CC) < 30400
@@ -6193,7 +6200,7 @@ ifeq ($(KBUILD_TARGET),netbsd)
 
  VBOX_NETBSD_TARGET_SRC = $(VBOX_NETBSD_SRC)/sys/arch/$(VBOX_NETBSD_TARGET_ARCH)
 
- TEMPLATE_VBoxR0Drv_TOOL               = $(VBOX_GCC_TOOL)
+ TEMPLATE_VBoxR0Drv_TOOL               = CLANG
  TEMPLATE_VBoxR0Drv_DEFS              += _KERNEL _MODULE
  if $(VBOX_GCC_VERSION_CC) < 30400
   TEMPLATE_VBoxR0Drv_DEFS             += RT_WITHOUT_PRAGMA_ONCE
@@ -6474,7 +6481,7 @@ ifeq ($(KBUILD_TARGET),win)
  endif
 
 else # the gcc guys
- TEMPLATE_VBoxR3Exe_TOOL               = $(VBOX_GCC_TOOL)
+ TEMPLATE_VBoxR3Exe_TOOL               = CLANG
  if $(VBOX_GCC_VERSION_CC) < 30400
   TEMPLATE_VBoxR3Exe_DEFS             += RT_WITHOUT_PRAGMA_ONCE
  endif
@@ -6933,7 +6940,7 @@ ifeq ($(KBUILD_TARGET),win)
  TEMPLATE_VBoxR3StaticNonPedantic_CXXFLAGS = $(TEMPLATE_VBoxR3Static_CXXFLAGS) $(VBOX_VCC_NON_PEDANTIC)
  TEMPLATE_VBoxR3StaticNonPedantic_PCHFLAGS = $(TEMPLATE_VBoxR3Static_PCHFLAGS) $(VBOX_VCC_NON_PEDANTIC)
 else # gcc:
- TEMPLATE_VBoxR3StaticNonPedantic_TOOL     = $(VBOX_GCC_TOOL)
+ TEMPLATE_VBoxR3StaticNonPedantic_TOOL     = CLANG
  TEMPLATE_VBoxR3StaticNonPedantic_CFLAGS   = $(filter-out $(VBOX_GCC_WERR) $(VBOX_GCC_WARN_MASOCHISTIC) $(VBOX_GCC_PEDANTIC_C)  ,$(TEMPLATE_VBoxR3Static_CFLAGS)) \
  	$(VBOX_GCC_NON_PEDANTIC_CXX)
  TEMPLATE_VBoxR3StaticNonPedantic_CXXFLAGS = $(filter-out $(VBOX_GCC_WERR) $(VBOX_GCC_WARN_MASOCHISTIC) $(VBOX_GCC_PEDANTIC_CXX),$(TEMPLATE_VBoxR3Static_CXXFLAGS)) \
@@ -7213,7 +7220,7 @@ ifeq ($(KBUILD_TARGET),win)
  TEMPLATE_VBoxR3DllNonPedantic_CXXFLAGS     = $(TEMPLATE_VBoxR3DllBase_CXXFLAGS) $(VBOX_VCC_NON_PEDANTIC)
  TEMPLATE_VBoxR3DllNonPedantic_PCHFLAGS     = $(TEMPLATE_VBoxR3DllBase_PCHFLAGS) $(VBOX_VCC_NON_PEDANTIC)
 else # gcc:
- TEMPLATE_VBoxR3DllNonPedantic_TOOL         = $(VBOX_GCC_TOOL)
+ TEMPLATE_VBoxR3DllNonPedantic_TOOL         = CLANG
  TEMPLATE_VBoxR3DllNonPedantic_CFLAGS       = $(filter-out $(VBOX_GCC_WERR) $(VBOX_GCC_WARN_MASOCHISTIC) $(VBOX_GCC_PEDANTIC_C)  ,$(TEMPLATE_VBoxR3DllBase_CFLAGS)) \
  	$(VBOX_GCC_NON_PEDANTIC_C)
  TEMPLATE_VBoxR3DllNonPedantic_CXXFLAGS     = $(filter-out $(VBOX_GCC_WERR) $(VBOX_GCC_WARN_MASOCHISTIC) $(VBOX_GCC_PEDANTIC_CXX),$(TEMPLATE_VBoxR3DllBase_CXXFLAGS)) \
@@ -7447,7 +7454,7 @@ ifeq ($(KBUILD_TARGET),win)
 
 else # the GCC guys:
 
- TEMPLATE_VBoxMainExe_TOOL               = $(VBOX_GCC_TOOL)
+ TEMPLATE_VBoxMainExe_TOOL               = CLANG
  if $(VBOX_GCC_VERSION_CC) < 30400
   TEMPLATE_VBoxMainExe_DEFS             += RT_WITHOUT_PRAGMA_ONCE
  endif
@@ -8099,7 +8106,7 @@ ifdef VBOX_WITH_QTGUI
   TEMPLATE_VBoxQtGuiExe_ORDERDEPS     = $(VBOX_SIGN_IMAGE_CMDS_ORDERDEPS)
 
  else # the gcc guys:
-  TEMPLATE_VBoxQtGuiExe_TOOL = $(VBOX_GCC_TOOL)
+  TEMPLATE_VBoxQtGuiExe_TOOL = CLANG
   if $(VBOX_GCC_VERSION_CC) < 30400
    TEMPLATE_VBoxQtGuiExe_DEFS += RT_WITHOUT_PRAGMA_ONCE
   endif
diff --git a/Fuzzing/DevVGA/Makefile b/Fuzzing/DevVGA/Makefile
new file mode 100644
index 00000000..df6a715b
--- /dev/null
+++ b/Fuzzing/DevVGA/Makefile
@@ -0,0 +1,309 @@
+TOOL = clang-14
+SOURCES = main.cpp noop.cpp fuzzed_data_provider.cpp  # Now main is also .cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA-cmd.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-dx-savedstate.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-dx-shader.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-dx.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-glHlp.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-hlp.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-info.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-ogl.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-savedstate.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d-shared.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA-SVGA3d.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA_VBVA.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/DevVGA_VDMA.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/HGSMI/HGSMIHost.cpp
+SOURCES += ../../src/VBox/Devices/Graphics/HGSMI/SHGSMIHost.cpp
+
+SOURCES += ../../src/VBox/GuestHost/HGSMI/HGSMICommon.cpp
+SOURCES += ../../src/VBox/GuestHost/HGSMI/HGSMIMemAlloc.cpp
+
+SOURCES += ../../src/VBox/Runtime/VBox/RTAssertShouldPanic-vbox.cpp
+SOURCES += ../../src/VBox/Runtime/VBox/log-vbox.cpp
+SOURCES += ../../src/VBox/Runtime/VBox/logbackdoor.cpp
+SOURCES += ../../src/VBox/Runtime/common/alloc/alloc.cpp
+SOURCES += ../../src/VBox/Runtime/common/alloc/heapoffset.cpp
+SOURCES += ../../src/VBox/Runtime/common/alloc/heapsimple.cpp
+SOURCES += ../../src/VBox/Runtime/common/alloc/memcache.cpp
+SOURCES += ../../src/VBox/Runtime/common/checksum/crc32.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbg.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgcfg.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmod.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmodcodeview.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmodcontainer.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmoddeferred.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmoddwarf.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmodexports.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmodldr.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmodmapsym.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgmodnm.cpp
+SOURCES += ../../src/VBox/Runtime/common/dbg/dbgstackdumpself.cpp
+SOURCES += ../../src/VBox/Runtime/common/err/RTErrConvertFromErrno.cpp
+SOURCES += ../../src/VBox/Runtime/common/err/errinfo.cpp
+SOURCES += ../../src/VBox/Runtime/common/err/errinfolog.cpp
+SOURCES += ../../src/VBox/Runtime/common/err/errmsg.cpp
+SOURCES += ../../src/VBox/Runtime/common/err/errmsgxpcom.cpp
+SOURCES += ../../src/VBox/Runtime/common/fs/pdbvfs.cpp
+SOURCES += ../../src/VBox/Runtime/common/ldr/ldr.cpp
+SOURCES += ../../src/VBox/Runtime/common/ldr/ldrEx.cpp
+SOURCES += ../../src/VBox/Runtime/common/ldr/ldrFile.cpp
+SOURCES += ../../src/VBox/Runtime/common/ldr/ldrNative.cpp
+SOURCES += ../../src/VBox/Runtime/common/log/log.cpp
+SOURCES += ../../src/VBox/Runtime/common/log/logellipsis.cpp
+SOURCES += ../../src/VBox/Runtime/common/log/logformat.cpp
+SOURCES += ../../src/VBox/Runtime/common/log/logrel.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/RTAssertMsg1Weak.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/RTAssertMsg2.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/RTAssertMsg2AddWeak.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/RTAssertMsg2AddWeakV.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/RTAssertMsg2Weak.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/RTAssertMsg2WeakV.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/RTFileModeToFlags.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/RTMemWipeThoroughly.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/assert.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/lockvalidator.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/once.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/req.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/reqpool.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/reqqueue.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/sg.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/term.cpp
+SOURCES += ../../src/VBox/Runtime/common/misc/thread.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathAbsDup.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathAbsEx.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathAbsExDup.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathAppend.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathAppendEx.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathChangeToUnixSlashes.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathEnsureTrailingSeparator.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathExt.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathFilename.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathHasExt.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathHasPath.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathJoin.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathJoinA.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathJoinEx.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathParse.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathParseSimple.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathParsedReassemble.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathSplit.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathSplitA.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathSplitReassemble.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathStartsWithRoot.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathStripFilename.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathStripTrailingSlash.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/RTPathTraverseList.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/comparepaths.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/rtPathRootSpecLen.cpp
+SOURCES += ../../src/VBox/Runtime/common/path/rtPathVolumeSpecLen.cpp
+SOURCES += ../../src/VBox/Runtime/common/rand/rand.cpp
+SOURCES += ../../src/VBox/Runtime/common/rand/randadv.cpp
+SOURCES += ../../src/VBox/Runtime/common/rand/randparkmiller.cpp
+SOURCES += ../../src/VBox/Runtime/common/sort/shellsort.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrCat.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrCmp.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrCopy.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrCopyEx.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrCopyP.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrEnd.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrFormat.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrICmpAscii.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrIStartsWith.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrNCmp.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTStrNLen.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/RTUtf16CopyAscii.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/straprintf.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strcache.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strformat.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strformatfloat.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strformatnum.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strformatrt.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strformattype.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strhash1.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/stringalloc.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strprintf-ellipsis.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strprintf.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strprintf2-ellipsis.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strprintf2.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strspace.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strstrip.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/strtonum.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/unidata-flags.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/unidata-lower.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/unidata-upper.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/utf-16-printf.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/utf-16.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/utf-8-case.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/utf-8-case2.cpp
+SOURCES += ../../src/VBox/Runtime/common/string/utf-8.cpp
+SOURCES += ../../src/VBox/Runtime/common/time/time.cpp
+SOURCES += ../../src/VBox/Runtime/common/time/timeprog.cpp
+SOURCES += ../../src/VBox/Runtime/common/time/timesup.cpp
+SOURCES += ../../src/VBox/Runtime/common/time/timesupref.cpp
+SOURCES += ../../src/VBox/Runtime/common/vfs/vfsbase.cpp
+SOURCES += ../../src/VBox/Runtime/common/vfs/vfschain.cpp
+SOURCES += ../../src/VBox/Runtime/common/vfs/vfsiosmisc.cpp
+SOURCES += ../../src/VBox/Runtime/common/vfs/vfsstddir.cpp
+SOURCES += ../../src/VBox/Runtime/common/vfs/vfsstdfile.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTDirQueryInfo-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTDirSetTimes-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTEnvDupEx-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTFileCopy-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTFileCopyAttributes-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTFileCopyByHandlesEx-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTFileCopyEx-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTFileReadAllByHandle-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTFileReadAllByHandleEx-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTFileReadAllFree-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTLogWriteDebugger-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTLogWriteStdErr-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTLogWriteStdOut-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTLogWriteVmm-stub-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTPathGetCurrentDrive-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTPathGetCurrentOnDrive-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTPathIsSame-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTRandAdvCreateSystemFaster-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTSemEventMultiWait-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/RTSemEventMultiWaitNoResume-2-ex-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/critsect-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/critsectrw-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/env-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/mempool-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/rtStrFormatKernelAddress-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/semfastmutex-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/semrw-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/semxroads-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/spinlock-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/system-page-size-generic.cpp
+SOURCES += ../../src/VBox/Runtime/generic/uuid-generic.cpp
+SOURCES += ../../src/VBox/Runtime/r3/alloc.cpp
+SOURCES += ../../src/VBox/Runtime/r3/dir.cpp
+SOURCES += ../../src/VBox/Runtime/r3/fileio.cpp
+SOURCES += ../../src/VBox/Runtime/r3/fs.cpp
+SOURCES += ../../src/VBox/Runtime/r3/generic/dirrel-r3-generic.cpp
+SOURCES += ../../src/VBox/Runtime/r3/generic/semspinmutex-r3-generic.cpp
+SOURCES += ../../src/VBox/Runtime/r3/init-data.cpp
+SOURCES += ../../src/VBox/Runtime/r3/init.cpp
+SOURCES += ../../src/VBox/Runtime/r3/linux/RTFileCopyPartEx-linux.cpp
+SOURCES += ../../src/VBox/Runtime/r3/linux/RTFileSetAllocationSize-linux.cpp
+SOURCES += ../../src/VBox/Runtime/r3/linux/rtProcInitExePath-linux.cpp
+SOURCES += ../../src/VBox/Runtime/r3/linux/sched-linux.cpp
+SOURCES += ../../src/VBox/Runtime/r3/linux/semevent-linux.cpp
+SOURCES += ../../src/VBox/Runtime/r3/linux/time-linux.cpp
+SOURCES += ../../src/VBox/Runtime/r3/mempage-heap.cpp
+SOURCES += ../../src/VBox/Runtime/r3/path.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/RTMemProtect-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/RTSystemQueryOSInfo-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/RTTimeNow-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/dir-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/env-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/errvars-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/fileio-at-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/fileio-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/fileio2-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/fs-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/fs2-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/fs3-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/ldrNative-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/mempage-native-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/path-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/path2-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/pathhost-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/pipe-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/process-creation-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/process-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/semeventmulti-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/semmutex-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/symlink-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/thread-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/thread2-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/posix/utf8-posix.cpp
+SOURCES += ../../src/VBox/Runtime/r3/process-data.cpp
+SOURCES += ../../src/VBox/Runtime/r3/process.cpp
+SOURCES += ../../src/VBox/Runtime/r3/socket.cpp
+SOURCES += ../../src/VBox/Runtime/r3/stream.cpp
+
+SOURCES += ../../src/VBox/VMM/VMMR3/PDMDevHlp.cpp
+
+# maybe remove this if the host drivers support libarary becomes too painful.
+SOURCES += ../../src/VBox/HostDrivers/Support/SUPLib.cpp
+SOURCES += ../../src/VBox/HostDrivers/Support/SUPLibAll.cpp
+SOURCES += ../../src/VBox/HostDrivers/Support/SUPLibLdr.cpp
+SOURCES += ../../src/VBox/HostDrivers/Support/SUPR3HardenedIPRT.cpp
+SOURCES += ../../src/VBox/HostDrivers/Support/SUPR3HardenedVerify.cpp
+SOURCES += ../../src/VBox/HostDrivers/Support/linux/SUPLib-linux.cpp
+
+SOURCES += ../../out/linux.amd64/debug/obj/VgaBiosBin/VgaBiosBin8086.c
+SOURCES += ../../out/linux.amd64/debug/obj/VgaBiosBin/VgaBiosBin286.c
+SOURCES += ../../out/linux.amd64/debug/obj/VgaBiosBin/VgaBiosBin386.c
+SOURCES += ../../out/linux.amd64/debug/obj/VgaDefBiosLogo/VgaDefBiosLogo.c
+
+ASM_SRC = ../../src/VBox/Runtime/common/asm/ASMMemFirstMismatchingU8.asm
+ASM_SRC += ../../out/linux.amd64/debug/obj/VBoxDD/VBoxSVGA3DLazyLoad.asm
+ASM_SRC += ../../src/VBox/Runtime/common/dbg/dbgstackdumpself-amd64-x86.asm
+ASM_SRC += ../../src/VBox/Runtime/common/misc/zero.asm
+
+# All the functions of AV trees are defined here... and the function
+# naames are generated by macros so it was quite hard to find the definition.
+SOURCES += $(wildcard ../../src/VBox/Runtime/common/table/*.cpp)
+
+OUTPUT = vga_fuzzer
+DEFINES = -DIN_RING3 -DVBOX_WITH_VMSVGA  # Add all your -D flags here
+DEFINES += -DVBOX -DVBOX_WITH_WDDM -DVBOX_WITH_HGSMI 
+DEFINES += -DVBOX_WITH_VDMA -DMOONSHINE_FUZZING -DRT_OS_LINUX
+DEFINES += -DVBOX_WITH_VMSVGA3D -DVMSVGA3D_OPENGL
+DEFINES += -DVMSVGA3D_DX -DVBOX_WITH_VDMA
+DEFINES += -DVBOX_IN_VMM -DUSING_VMM_COMMON_DEFS
+CFLAGS = -g $(DEFINES)  # Combined C flags
+
+INCLUDE_DIR = ../../include
+VBOX_VIDEO_INCLUDE_DIR = ../../include/VBox/Graphics
+OUT_INCLUDE_DIR = ../../out/linux.amd64/debug/
+VMSVGA_INCLUDE_DIR = ../../src/VBox/Devices/Graphics/vmsvga_include
+RUNTIME_INCLUDE_DIR = ../../src/VBox/Runtime/include/
+AVL_INCLUDE_DIR = ../../src/VBox/Runtime/common/table/
+VGABIOSBIN_INCLUDE_DIR = ../../out/linux.amd64/debug/obj/VgaBiosBin/
+DEVICES_INCLUDE_DIR = ../../src/VBox/Devices/build
+RUNTIME_OUT_INCLUDE_DIR = ../../out/linux.amd64/debug/obj/Runtime/
+VGA_INCLUDE_DIR = ../../src/VBox/Devices/Graphics/
+VMM_INCLUDE_DIR = ../../src/VBox/VMM/include/
+DTRACE_INCLUDE_DIR = ../../out/linux.amd64/debug/obj/VBoxVMM/dtrace
+
+HEADERS = $(wildcard $(INCLUDE_DIR)/**/*.h)
+
+CFLAGS += -I$(INCLUDE_DIR) -I$(VBOX_VIDEO_INCLUDE_DIR) -I$(OUT_INCLUDE_DIR)
+CFLAGS += -I$(VMSVGA_INCLUDE_DIR) -I$(RUNTIME_INCLUDE_DIR)
+CFLAGS += -I$(VGABIOSBIN_INCLUDE_DIR) -I$(DEVICES_INCLUDE_DIR) -I$(AVL_INCLUDE_DIR)
+CFLAGS += -I$(RUNTIME_OUT_INCLUDE_DIR) -I$(VGA_INCLUDE_DIR)
+CFLAGS += -I$(VMM_INCLUDE_DIR) -I$(DTRACE_INCLUDE_DIR)
+CFLAGS += -fsanitize=address,undefined -fsanitize-link-c++-runtime -Wno-everything 
+
+OBJECTS = $(SOURCES:.cpp=.o) # <--- Key change: .cpp to .o
+
+OBJECTS += $(ASM_SRC:.asm=.o) # Add the object file to the list of objects
+LINK_LIBRARIES = -L/usr/X11R6/lib -L/usr/X11R6/lib64 -L/usr/local/lib -lXext -lX11 -lGL -I/usr/local/include 
+LINK_LIBRARIES += -lubsan -lstdc++
+
+all: $(OUTPUT)
+
+$(OUTPUT): $(OBJECTS) $(HEADERS)
+	$(TOOL) $(CFLAGS) $(OBJECTS) -o $@ $(LINK_LIBRARIES) 
+%.o: %.cpp $(HEADERS)  # Single rule for all .cpp files
+	$(TOOL) $(CFLAGS) -c $< -o $@  
+
+clean:
+	rm -f $(OUTPUT) $(OBJECTS)
+
+%.o: %.asm
+	yasm -i $(INCLUDE_DIR) -f elf64 -dARCH_BITS=64 -dRT_ARCH_AMD64 $< -o $@
+
+.PHONY: all clean
+
+# Debugging (Optional - Highly Recommended)
+#$(info SOURCES are $(SOURCES))
+#$(info OBJECTS are $(OBJECTS))
+#$(info HEADERS are $(HEADERS))
diff --git a/defs.h b/defs.h
new file mode 100644
index 00000000..5b9e90cf
--- /dev/null
+++ b/defs.h
@@ -0,0 +1,31 @@
+#include <stdint.h>
+
+typedef enum SVGAMobFormat {
+   SVGA3D_MOBFMT_INVALID     = SVGA3D_INVALID_ID,
+   SVGA3D_MOBFMT_PTDEPTH_0   = 0,
+   SVGA3D_MOBFMT_MIN         = 0,
+   SVGA3D_MOBFMT_PTDEPTH_1   = 1,
+   SVGA3D_MOBFMT_PTDEPTH_2   = 2,
+   SVGA3D_MOBFMT_RANGE       = 3,
+   SVGA3D_MOBFMT_PTDEPTH64_0 = 4,
+   SVGA3D_MOBFMT_PTDEPTH64_1 = 5,
+   SVGA3D_MOBFMT_PTDEPTH64_2 = 6,
+   SVGA3D_MOBFMT_PREDX_MAX   = 7,
+   SVGA3D_MOBFMT_EMPTY       = 7,
+   SVGA3D_MOBFMT_MAX,
+
+   /*
+    * This isn't actually used by the guest, but is a mob-format used
+    * internally by the SVGA device (and is therefore not binary compatible).
+    */
+   SVGA3D_MOBFMT_HB,
+} SVGAMobFormat;
+
+typedef
+struct SVGA3dCmdDefineGBMob {
+   uint32_t mobid;
+   SVGAMobFormat ptDepth;
+   uint32_t base;
+   uint32_t sizeInBytes;
+}
+SVGA3dCmdDefineGBMob;   /* SVGA_3D_CMD_DEFINE_GB_MOB */
diff --git a/include/VBox/VMMDevCoreTypes.h b/include/VBox/VMMDevCoreTypes.h
index eb8c1cb6..1a052f94 100644
--- a/include/VBox/VMMDevCoreTypes.h
+++ b/include/VBox/VMMDevCoreTypes.h
@@ -511,7 +511,7 @@ typedef struct
     int GetUInt32(uint32_t *pu32)
     {
         AssertMsgReturnStmt(type == VMMDevHGCMParmType_32bit, ("type=%d\n", type),
-                            *pu32 = UINT32_MAX /* shut up gcc */, VERR_WRONG_PARAMETER_TYPE)
+                            *pu32 = UINT32_MAX /* shut up gcc */, VERR_WRONG_PARAMETER_TYPE);
         *pu32 = u.value32;
         return VINF_SUCCESS;
     }
diff --git a/include/iprt/assert.h b/include/iprt/assert.h
index a363652a..f3fbb7fe 100644
--- a/include/iprt/assert.h
+++ b/include/iprt/assert.h
@@ -631,6 +631,7 @@ RT_C_DECLS_END
         } \
     } while (0)
 #else
+
 # define AssertMsg(expr, a)  do { } while (0)
 #endif
 
diff --git a/include/iprt/assertcompile.h b/include/iprt/assertcompile.h
index d7ec6626..77ffdda0 100644
--- a/include/iprt/assertcompile.h
+++ b/include/iprt/assertcompile.h
@@ -135,6 +135,10 @@ RT_C_DECLS_END
  * build.
  * @param   expr    Expression which should be true.
  */
+#ifdef MOONSHINE_FUZZING
+#  define AssertCompile(expr) 
+#else
+
 #ifdef RTASSERT_HAVE_STATIC_ASSERT
 # ifdef __cplusplus
 #  define AssertCompile(expr)    static_assert(!!(expr), #expr)
@@ -145,6 +149,8 @@ RT_C_DECLS_END
 # define AssertCompile(expr)    AssertCompileNS(expr)
 #endif
 
+#endif
+
 /** @def RTASSERT_OFFSET_OF()
  * A offsetof() macro suitable for compile time assertions.
  * Both GCC v4 and VisualAge for C++ v3.08 has trouble using RT_OFFSETOF.
diff --git a/include/iprt/cdefs.h b/include/iprt/cdefs.h
index db067101..c4468ede 100644
--- a/include/iprt/cdefs.h
+++ b/include/iprt/cdefs.h
@@ -4727,6 +4727,10 @@
  * If you want assertions which are not subject to compile time options use
  * the AssertRelease*() flavors.
  */
+#ifdef MOONSHINE_FUZZING
+#define RT_NO_STRICT
+#endif
+
 #if !defined(RT_STRICT) && defined(DEBUG)
 # define RT_STRICT
 #endif
diff --git a/include/iprt/mangling.h b/include/iprt/mangling.h
index 4527d6ce..4b01bfc1 100644
--- a/include/iprt/mangling.h
+++ b/include/iprt/mangling.h
@@ -783,8 +783,12 @@
 # define RTDbgModSymbolByOrdinalA                       RT_MANGLER(RTDbgModSymbolByOrdinalA)
 # define RTDbgModSymbolCount                            RT_MANGLER(RTDbgModSymbolCount)
 # define RTDbgModUnwindFrame                            RT_MANGLER(RTDbgModUnwindFrame)
+
+#ifndef MOONSHINE_FUZZING
 # define RTDbgStackDumpSelf                             RT_MANGLER(RTDbgStackDumpSelf)
 # define RTDbgStackDumpSelf_EndProc                     RT_MANGLER(RTDbgStackDumpSelf_EndProc)
+#endif
+
 # define RTDbgSymbolAlloc                               RT_MANGLER(RTDbgSymbolAlloc)
 # define RTDbgSymbolDup                                 RT_MANGLER(RTDbgSymbolDup)
 # define RTDbgSymbolFree                                RT_MANGLER(RTDbgSymbolFree)
diff --git a/kBuild/tools/CLANG.kmk b/kBuild/tools/CLANG.kmk
new file mode 100644
index 00000000..b2696ef5
--- /dev/null
+++ b/kBuild/tools/CLANG.kmk
@@ -0,0 +1,402 @@
+# $Id: CLANG.kmk 3567 2022-06-26 20:00:02Z bird $
+## @file
+# kBuild Tool Config - Generic GCC v3.2+ using the system GCC and Binutils, for building C++ code.
+#
+
+#
+# Copyright (c) 2004-2017 knut st. osmundsen <bird-kBuild-spam-xviiv@anduin.net>
+#
+# This file is part of kBuild.
+#
+# kBuild is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# kBuild is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with kBuild; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#
+#
+# As a special exception you are granted permission to include this file, via
+# the kmk include directive, as you wish without this in itself causing the
+# resulting makefile, program or whatever to be covered by the GPL license.
+# This exception does not however invalidate any other reasons why the makefile,
+# program, whatever should not be covered the GPL.
+#
+#
+
+TOOL_CLANG := Generic GCC v3.2.x or later using the system GCC and Binutils, for building C++ code.
+
+# Tool Specific Properties
+ifndef TOOL_CLANG_PREFIX
+ TOOL_CLANG_PREFIX   :=
+endif
+ifndef TOOL_CLANG_SUFFIX
+ TOOL_CLANG_SUFFIX   := $(HOSTSUFF_EXE)
+endif
+if1of ($(KBUILD_HOST), solaris)
+ TOOL_CLANG_PREFIX2  ?= g
+else
+ TOOL_CLANG_PREFIX2  ?=
+endif
+TOOL_CLANG_SUFFIX2   ?= $(HOSTSUFF_EXE)
+TOOL_CLANG_PREFIX3   ?=
+TOOL_CLANG_SUFFIX3   ?= $(HOSTSUFF_EXE)
+
+TOOL_CLANG_CC        ?= $(TOOL_CLANG_PREFIX)clang$(TOOL_CLANG_SUFFIX)
+TOOL_CLANG_CXX       ?= $(TOOL_CLANG_PREFIX)clang++$(TOOL_CLANG_SUFFIX)
+
+TOOL_CLANG_PCH       ?= $(TOOL_CLANG_CXX)
+TOOL_CLANG_AS        ?= $(TOOL_CLANG_PREFIX)clang$(TOOL_CLANG_SUFFIX)
+TOOL_CLANG_AR        ?= $(TOOL_CLANG_PREFIX2)ar$(TOOL_CLANG_SUFFIX2)
+ifeq ($(KBUILD_TARGET),os2)
+ TOOL_CLANG_AR_IMP   ?= $(TOOL_CLANG_PREFIX3)emximp$(TOOL_CLANG_SUFFIX3)
+else
+ TOOL_CLANG_AR_IMP   ?= $(ECHO) not supported!
+endif
+TOOL_CLANG_LD        ?= $(TOOL_CLANG_PREFIX)clang++$(TOOL_CLANG_SUFFIX)
+if1of ($(KBUILD_HOST), solaris)
+ TOOL_CLANG_LD_SYSMOD ?= $(TOOL_CLANG_PREFIX3)ld$(TOOL_CLANG_SUFFIX3)
+else
+ TOOL_CLANG_LD_SYSMOD ?= $(TOOL_CLANG_PREFIX2)ld$(TOOL_CLANG_SUFFIX2)
+endif
+ifndef TOOL_CLANG_LDFLAGS.$(KBUILD_TARGET)
+ TOOL_CLANG_LDFLAGS.dll   ?= -shared
+else
+ TOOL_CLANG_LDFLAGS.dll   ?= $(TOOL_CLANG_LDFLAGS.$(KBUILD_TARGET))
+endif
+TOOL_CLANG_LDFLAGS.sysmod ?= -r
+TOOL_CLANG_LD_SONAME      ?= -Wl,-soname=$(firstword $($(1)_SONAME.$(KBUILD_TARGET).$(KBUILD_TYPE)) $($(1)_SONAME.$(KBUILD_TARGET)) $($(1)_SONAME.$(KBUILD_TYPE)) $($(1)_SONAME) $(notdir $(2)))
+ifeq ($(KBUILD_TARGET),os2)
+ TOOL_CLANG_LD_MAP        ?= -Zmap=$(1)
+ TOOL_CLANG_LD_SYSMOD_MAP ?= -Zmap=$(1)
+else
+ TOOL_CLANG_LD_MAP        ?=
+ TOOL_CLANG_LD_SYSMOD_MAP ?=
+endif
+TOOL_CLANG_OBJCOPY ?= $(TOOL_CLANG_PREFIX)objcopy$(TOOL_CLANG_SUFFIX)
+
+# General Properties used by kBuild
+TOOL_CLANG_COBJSUFF         ?= .o
+
+ifeq ($(KMOONSHINE_FUZZER), yes)
+    TOOL_CLANG_CFLAGS           ?= -DMOONSHINE_FUZZING -fsanitize=address,undefined
+else
+    TOOL_CLANG_CFLAGS           ?= -DMOONSHINE_FUZZING
+endif
+TOOL_CLANG_CFLAGS.debug     ?= -g
+TOOL_CLANG_CFLAGS.profile   ?= -O2 #-g -pg
+TOOL_CLANG_CFLAGS.release   ?= -O2
+TOOL_CLANG_CINCS            ?=
+TOOL_CLANG_CDEFS            ?=
+
+TOOL_CLANG_CXXOBJSUFF       ?= .o
+ifeq ($(KMOONSHINE_FUZZER), yes)
+    TOOL_CLANG_CXXFLAGS           ?= -DMOONSHINE_FUZZING -fsanitize=address,undefined,fuzzer
+else
+    TOOL_CLANG_CXXFLAGS           ?= -DMOONSHINE_FUZZING
+endif
+
+TOOL_CLANG_CXXFLAGS.debug   ?= -g
+TOOL_CLANG_CXXFLAGS.profile ?= -O2 #-g -pg
+TOOL_CLANG_CXXFLAGS.release ?= -O2
+TOOL_CLANG_CXXINCS          ?=
+TOOL_CLANG_CXXDEFS          ?=
+
+TOOL_CLANG_PCHOBJSUFF       ?= .h.gch
+TOOL_CLANG_PCHFLAGS         ?= $(TOOL_CLANG_CXXFLAGS)
+TOOL_CLANG_PCHFLAGS.debug   ?= $(TOOL_CLANG_CXXFLAGS.debug)
+TOOL_CLANG_PCHFLAGS.profile ?= $(TOOL_CLANG_CXXFLAGS.profile)
+TOOL_CLANG_PCHFLAGS.release ?= $(TOOL_CLANG_CXXFLAGS.release)
+TOOL_CLANG_PCHINCS          ?= $(TOOL_CLANG_CXXINCS)
+TOOL_CLANG_PCHDEFS          ?= $(TOOL_CLANG_CXXDEFS)
+
+TOOL_CLANG_ASFLAGS          ?= -x assembler-with-cpp
+TOOL_CLANG_ASFLAGS.debug    ?= -g
+TOOL_CLANG_ASFLAGS.profile  ?= -g
+TOOL_CLANG_ASOBJSUFF        ?= .o
+
+TOOL_CLANG_ARFLAGS          ?= cr
+TOOL_CLANG_ARLIBSUFF        ?= .a
+
+ifeq ($(KMOONSHINE_FUZZER), yes)
+    TOOL_CLANG_LDFLAGS           ?= -fsanitize=address,undefined,fuzzer -fprofile-instr-generate -fcoverage-mapping
+else
+    TOOL_CLANG_LDFLAGS           ?=
+endif
+
+TOOL_CLANG_LDFLAGS.debug    ?= -g
+TOOL_CLANG_LDFLAGS.profile  ?= -g
+
+
+## Compile C source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+#
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_CLANG_COMPILE_C_DEPEND =
+TOOL_CLANG_COMPILE_C_DEPORD =
+TOOL_CLANG_COMPILE_C_OUTPUT         = $(if-expr "$(use_objcache)" != "",$(outbase).i,)
+TOOL_CLANG_COMPILE_C_USES_KOBJCACHE = $(if-expr "$(use_objcache)" != "",1,)
+define TOOL_CLANG_COMPILE_C_CMDS
+if "$(use_objcache)" != ""
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).i\
+		$(TOOL_CLANG_CC) -E -o -\
+		$(flags) $(qaddprefix sh,-I, $(incs)) $(qaddprefix sh,-D, $(defs))\
+		-Wp,-MD,$(dep) -Wp,-MT,$(obj) -Wp,-MP\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_CLANG_CC) -c\
+		$(flags) -fpreprocessed -x c\
+		-o $(obj)\
+		-
+else
+	$(QUIET)$(TOOL_CLANG_CC) -c\
+		$(flags) $(qaddprefix sh,-I, $(incs)) $(qaddprefix sh,-D, $(defs))\
+		-Wp,-MD,$(dep) -Wp,-MT,$(obj) -Wp,-MP\
+		-o $(obj)\
+		$(abspath $(source))
+endif
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+
+
+## Compile C++ source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)      Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_CLANG_COMPILE_CXX_OUTPUT         = $(if-expr "$(use_objcache)" != "",$(outbase).ii,)
+TOOL_CLANG_COMPILE_CXX_DEPEND         = $($(target)_1_GCC_PCH_FILE)
+TOOL_CLANG_COMPILE_CXX_DEPORD         =
+TOOL_CLANG_COMPILE_CXX_USES_KOBJCACHE = $(if-expr "$(use_objcache)" != "",1,)
+define TOOL_CLANG_COMPILE_CXX_CMDS
+if "$(use_objcache)" != ""
+	$(QUIET)$(KOBJCACHE) -f $(outbase).koc -d $(PATH_OBJCACHE) -t $(bld_trg).$(bld_trg_arch) -p\
+		--kObjCache-cpp $(outbase).ii\
+		$(TOOL_CLANG_CXX) -E -o - $(if-expr defined($(target)_PCH_HDR)\
+		,-fpch-preprocess -Winvalid-pch -I$($(target)_1_GCC_PCH_DIR) -include $(basename $($(target)_1_GCC_PCH_FILE)),)\
+		$(flags) $(qaddprefix sh,-I, $(incs)) $(qaddprefix sh,-D, $(defs))\
+		-Wp,-MD,$(dep) -Wp,-MT,$(obj) -Wp,-MP\
+		$(abspath $(source))\
+		--kObjCache-cc $(obj)\
+		$(TOOL_CLANG_CXX) -c\
+		$(flags) -fpreprocessed $(if-expr defined($(target)_PCH_HDR),-fpch-preprocess,) -x c++\
+		-o $(obj)\
+		-
+else
+	$(QUIET)$(TOOL_CLANG_CXX) -c\
+		$(flags) $(qaddprefix sh,-I, $($(target)_1_GCC_PCH_DIR) $(incs)) $(qaddprefix sh,-D, $(defs))\
+		-Wp,-MD,$(dep) -Wp,-MT,$(obj) -Wp,-MP\
+		-o $(obj) $(if-expr defined($(target)_PCH_HDR) \
+		,-Winvalid-pch -include $(basename $($(target)_1_GCC_PCH_FILE)),) \
+		$(abspath $(source))
+endif
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+
+
+## Precompile C++ header.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)	    Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+TOOL_CLANG_COMPILE_PCH_OUTPUT = $($(target)_1_GCC_PCH_FILE)
+TOOL_CLANG_COMPILE_PCH_DEPEND =
+TOOL_CLANG_COMPILE_PCH_DEPORD = $($(target)_1_GCC_PCH_DIR)
+define TOOL_CLANG_COMPILE_PCH_CMDS
+	$(QUIET)$(TOOL_CLANG_PCH) -c\
+		$(flags) $(qaddprefix sh,-I, $($(target)_1_GCC_PCH_DIR) $(incs)) $(qaddprefix sh,-D, $(defs))\
+		-Wp,-MD,$(dep) -Wp,-MT,$(obj) -Wp,-MP\
+		-o $(obj)\
+		$(abspath $(source))
+	$(INSTALL) --hard-link-files-when-possible -m 0644 -- "$(obj)" "$($(target)_1_GCC_PCH_FILE)"
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+
+
+## Compile Assembly source.
+# @param    $(target)   Normalized main target name.
+# @param    $(source)   Source filename (relative).
+# @param    $(obj)      Object file name. This shall be (re)created by the compilation.
+# @param    $(dep)      Dependcy file. This shall be (re)created by the compilation.
+# @param    $(flags)    Flags.
+# @param    $(defs)     Definitions. No -D or something.
+# @param    $(incs)     Includes. No -I or something.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+# @param    $(objsuff)  Object suffix.
+#
+TOOL_CLANG_COMPILE_AS_OUTPUT =
+TOOL_CLANG_COMPILE_AS_DEPEND =
+TOOL_CLANG_COMPILE_AS_DEPORD =
+define TOOL_CLANG_COMPILE_AS_CMDS
+	$(QUIET)$(TOOL_CLANG_AS) -c\
+		$(flags) $(qaddprefix sh,-I, $(incs)) $(qaddprefix sh,-D, $(defs))\
+		-Wp,-MD,$(dep) -Wp,-MT,$(obj) -Wp,-MP\
+		-o $(obj)\
+		$(abspath $(source))
+	$(QUIET)$(APPEND) -n "$(dep)" "" "$(source):" ""
+endef
+
+
+## Link library
+# @param    $(target)   Normalized main target name.
+# @param    $(out)      Library name.
+# @param    $(objs)     Object files to put in the library.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)     Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_CLANG_LINK_LIBRARY_OUTPUT = $(out).ar-script
+TOOL_CLANG_LINK_LIBRARY_OUTPUT_MAYBE = $(outbase).imp.a
+TOOL_CLANG_LINK_LIBRARY_DEPEND = $(othersrc)
+TOOL_CLANG_LINK_LIBRARY_DEPORD =
+define TOOL_CLANG_LINK_LIBRARY_CMDS
+	$(QUIET)$(APPEND) $(out).ar-script 'CREATE $(out)'
+	$(QUIET)$(APPEND) -n $(out).ar-script \
+		$(foreach o,$(filter-out %.h.gch,$(objs)), 'ADDMOD $(o)') \
+		$(foreach o,$(filter-out %.def %.imp %.dll,$(othersrc)), 'ADDLIB $(o)')
+	$(if $(filter %.def %.imp %.dll,$(othersrc))\
+		,$(TOOL_CLANG_AR_IMP) -o $(outbase).imp.a $(filter %.def %.imp %.dll,$(othersrc))\
+		 $(NL)$(TAB)$(QUIET)$(APPEND) $(out).ar-script 'ADDLIB $(outbase).imp.a')
+	$(QUIET)$(APPEND) $(out).ar-script 'SAVE'
+	$(QUIET)$(APPEND) $(out).ar-script 'END'
+	$(QUIET)$(REDIRECT) -rti $(out).ar-script -- $(TOOL_CLANG_AR) -M
+endef
+
+
+## Link program
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_CLANG_LINK_PROGRAM_OUTPUT =
+TOOL_CLANG_LINK_PROGRAM_OUTPUT_MAYBE = $(outbase).map
+TOOL_CLANG_LINK_PROGRAM_OUTPUT_DEBUG = $(outbase).debug
+TOOL_CLANG_LINK_PROGRAM_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_CLANG_LINK_PROGRAM_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_CLANG_LINK_PROGRAM_DEPORD =
+define TOOL_CLANG_LINK_PROGRAM_CMDS
+	$(QUIET)$(TOOL_CLANG_LD) $(flags) -o $(out) $(filter-out %.h.gch,$(objs))\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_CLANG_LD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(QUIET)$(TOOL_CLANG_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(QUIET)$(CHMOD) a-x $(outbase).debug
+	$(QUIET)$(TOOL_CLANG_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
+
+## Link DLL
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		Program name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_CLANG_LINK_DLL_OUTPUT =
+TOOL_CLANG_LINK_DLL_OUTPUT_MAYBE = $(outbase).map
+TOOL_CLANG_LINK_DLL_OUTPUT_DEBUG = $(outbase).debug
+TOOL_CLANG_LINK_DLL_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_CLANG_LINK_DLL_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_CLANG_LINK_DLL_DEPORD =
+define TOOL_CLANG_LINK_DLL_CMDS
+	$(QUIET)$(TOOL_CLANG_LD) $(TOOL_CLANG_LDFLAGS.dll) $(flags) -o $(out)\
+		$(if $(filter-out win os2, $(KBUILD_TARGET)),$(call TOOL_CLANG_LD_SONAME,$(target),$(out)))\
+		$(filter-out %.h.gch,$(objs))\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_CLANG_LD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(QUIET)$(TOOL_CLANG_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(QUIET)$(CHMOD) a-x $(outbase).debug
+	$(QUIET)$(TOOL_CLANG_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
+
+## Link system module (windows aka driver, linux aka kernel module)
+# @param    $(target)   Normalized main target name.
+# @param    $(out)		System module name.
+# @param    $(objs)     Object files to link together.
+# @param    $(libs)     Libraries to search.
+# @param    $(libpath)  Library search paths.
+# @param    $(flags)    Flags.
+# @param    $(dirdep)   Directory creation dependency.
+# @param    $(deps)		Other dependencies.
+# @param    $(othersrc) Unhandled sources.
+# @param    $(custom_pre)   Custom step invoked before linking.
+# @param    $(custom_post)  Custom step invoked after linking.
+# @param    $(outbase)  Output basename (full). Use this for list files and such.
+TOOL_CLANG_LINK_SYSMOD_OUTPUT =
+TOOL_CLANG_LINK_SYSMOD_OUTPUT_MAYBE = $(outbase).map
+TOOL_CLANG_LINK_SYSMOD_OUTPUT_DEBUG = $(outbase).debug
+TOOL_CLANG_LINK_SYSMOD_DEBUG_INSTALL_FN = $(2).debug=>$(basename $(3)).debug
+TOOL_CLANG_LINK_SYSMOD_DEPEND = $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib)))\
+		$(filter %.def, $(othersrc))
+TOOL_CLANG_LINK_SYSMOD_DEPORD =
+define TOOL_CLANG_LINK_SYSMOD_CMDS
+	$(QUIET)$(TOOL_CLANG_LD_SYSMOD) $(TOOL_CLANG_LDFLAGS.sysmod) $(flags) -o $(out) $(filter-out %.h.gch,$(objs))\
+		$(filter %.def, $(othersrc))\
+		$(foreach p,$(libpath), -L$(p))\
+		$(foreach lib,$(libs), $(if $(findstring $(lib),$(subst /,x,$(lib))), -l$(patsubst lib%,%,$(lib)), $(lib)))\
+		$(call TOOL_CLANG_LD_SYSMOD_MAP,$(outbase).map)
+ ifeq ($(ld_debug),split)
+	$(QUIET)$(TOOL_CLANG_OBJCOPY) --only-keep-debug $(out) $(outbase).debug
+	$(QUIET)$(CHMOD) a-x $(outbase).debug
+	$(QUIET)$(TOOL_CLANG_OBJCOPY) --strip-debug --strip-unneeded --add-gnu-debuglink=$(outbase).debug $(out)
+ endif
+endef
+
diff --git a/src/Fuzzing/DevVGA/Makefile.kmk b/src/Fuzzing/DevVGA/Makefile.kmk
new file mode 100644
index 00000000..e6200a29
--- /dev/null
+++ b/src/Fuzzing/DevVGA/Makefile.kmk
@@ -0,0 +1,77 @@
+SUB_DEPTH = ../..
+include $(KBUILD_PATH)/subheader.kmk
+
+PROGRAMS = DevVGAFuzzer
+DevVGAFuzzer_Name = dev_vga_fuzzer
+DevVGAFuzzer_SOURCES = main.cpp command_generator.h mock_driver.h dev_vga_fuzzer.h mock_helper.h
+DevVGAFuzzer_TOOL = CLANG
+DevVGAFuzzer_INCS = $(PATH_ROOT)/include
+DevVGAFuzzer_INCS += $(PATH_ROOT)/include/VBox/Graphics
+DevVGAFuzzer_INCS += $(PATH_ROOT)/src/VBox/Devices/Graphics
+DevVGAFuzzer_INCS += $(PATH_ROOT)/src/VBox/VMM/include
+DevVGAFuzzer_INCS += $(PATH_ROOT)/src/VBox/Devices/Graphics/vmsvga_include
+
+DevVGAFuzzer_CXXFLAGS = -Wno-everything
+
+DevVGAFuzzer_DEFS = VBOX_IN_VMM
+ifdef VBOXWDDM_TEST_UHGSMI
+  DevVGAFuzzer_DEFS           += VBOXWDDM_TEST_UHGSMI
+ endif
+ ifdef VBOXWDDM_WITH_VBVA
+  DevVGAFuzzer_DEFS           += VBOXWDDM_WITH_VBVA
+ endif
+ ifdef VBOX_WITH_VIDEOHWACCEL
+  DevVGAFuzzer_DEFS           += VBOX_WITH_VIDEOHWACCEL
+ endif
+
+ ifdef VBOX_WITH_HGSMI
+  DevVGAFuzzer_DEFS           += VBOX_WITH_HGSMI
+ endif
+
+ ifdef VBOX_WITH_WDDM
+  DevVGAFuzzer_DEFS           += VBOX_WITH_WDDM
+ endif
+
+ ifdef VBOX_WITH_VMSVGA
+  DevVGAFuzzer_DEFS           += VBOX_WITH_VMSVGA
+ endif
+ ifdef VBOX_WITH_VMSVGA3D
+  if1of ($(KBUILD_TARGET), linux win)
+   # Dynamically load 3D library (opengl32, libGL).
+   # This is a temporary solution. In future the 3D backend will be in a separate library.
+   VBOX_WITH_VMSVGA3D_DYNAMIC_LOAD = 1
+  endif
+  DevVGAFuzzer_DEFS           += VBOX_WITH_VMSVGA3D
+  ifdef VBOX_WITH_VMSVGA3D_DX
+   DevVGAFuzzer_DEFS          += VMSVGA3D_DX
+   if "$(KBUILD_TARGET)" == "win" || defined(VBOX_WITH_DXVK)
+    DevVGAFuzzer_DEFS         += VMSVGA3D_DX_BACKEND
+   endif
+  endif
+  if "$(KBUILD_TARGET)" == "win" && !defined(VBOX_WITH_VMSVGA3D_USE_OPENGL)
+   DevVGAFuzzer_DEFS           += VMSVGA3D_DIRECT3D
+  else
+   DevVGAFuzzer_DEFS          += VMSVGA3D_OPENGL
+
+   ifdef VBOX_WITH_VMSVGA3D_DYNAMIC_LOAD
+    DevVGAFuzzer_DEFS         += VMSVGA3D_DYNAMIC_LOAD
+   endif
+   DevVGAFuzzer_DEFS.darwin    += VBOX_VMSVGA3D_DUAL_OPENGL_PROFILE
+  endif
+ endif
+
+ ifdef VBOX_WITH_VDMA
+  DevVGAFuzzer_DEFS           += VBOX_WITH_VDMA
+ endif
+
+ ifdef VBOX_WITH_PXE_ROM
+  DevVGAFuzzer_DEFS           += VBOX_WITH_PXE_ROM
+ endif
+
+
+DevVGAFuzzer_LIBS = $(VBoxDD_1_TARGET)
+DevVGAFuzzer_LIBS += $(VBoxVMM_1_TARGET)
+DevVGAFuzzer_LIBS += $(VBoxRT_1_TARGET)
+DevVGAFuzzer_LIBS += $(VBoxDDU_1_TARGET)
+
+include $(FILE_KBUILD_SUB_FOOTER)
diff --git a/src/Fuzzing/DevVGA/command_generator.h b/src/Fuzzing/DevVGA/command_generator.h
new file mode 100644
index 00000000..86acf305
--- /dev/null
+++ b/src/Fuzzing/DevVGA/command_generator.h
@@ -0,0 +1,2978 @@
+#include <memory>
+#include <string>
+#include <fuzzer/FuzzedDataProvider.h>
+
+#include <vmsvga_include/svga_reg.h>
+
+#define BASE_SIZE 1024
+
+uint32_t kCommandArray[] = {
+    SVGA_CMD_INVALID_CMD           ,
+    SVGA_CMD_UPDATE                ,
+    SVGA_CMD_RECT_COPY             ,
+    SVGA_CMD_RECT_ROP_COPY         ,
+    SVGA_CMD_DEFINE_CURSOR         ,
+    SVGA_CMD_DEFINE_ALPHA_CURSOR   ,
+    SVGA_CMD_UPDATE_VERBOSE        ,
+    SVGA_CMD_FRONT_ROP_FILL        ,
+    SVGA_CMD_FENCE                 ,
+    SVGA_CMD_ESCAPE                ,
+    SVGA_CMD_DEFINE_SCREEN         ,
+    SVGA_CMD_DESTROY_SCREEN        ,
+    SVGA_CMD_DEFINE_GMRFB          ,
+    SVGA_CMD_BLIT_GMRFB_TO_SCREEN  ,
+    SVGA_CMD_BLIT_SCREEN_TO_GMRFB  ,
+    SVGA_CMD_ANNOTATION_FILL       ,
+    SVGA_CMD_ANNOTATION_COPY       ,
+    SVGA_CMD_DEFINE_GMR2           ,
+    SVGA_CMD_REMAP_GMR2            ,
+    SVGA_CMD_DEAD                  ,
+    SVGA_CMD_DEAD_2                ,
+    SVGA_CMD_NOP                   ,
+    SVGA_CMD_NOP_ERROR             ,
+    SVGA_3D_CMD_SURFACE_DEFINE                             ,
+    SVGA_3D_CMD_SURFACE_DESTROY                            ,
+    SVGA_3D_CMD_SURFACE_COPY                               ,
+    SVGA_3D_CMD_SURFACE_STRETCHBLT                         ,
+    SVGA_3D_CMD_SURFACE_DMA                                ,
+    SVGA_3D_CMD_CONTEXT_DEFINE                             ,
+    SVGA_3D_CMD_CONTEXT_DESTROY                            ,
+    SVGA_3D_CMD_SETTRANSFORM                               ,
+    SVGA_3D_CMD_SETZRANGE                                  ,
+    SVGA_3D_CMD_SETRENDERSTATE                             ,
+    SVGA_3D_CMD_SETRENDERTARGET                            ,
+    SVGA_3D_CMD_SETTEXTURESTATE                            ,
+    SVGA_3D_CMD_SETMATERIAL                                ,
+    SVGA_3D_CMD_SETLIGHTDATA                               ,
+    SVGA_3D_CMD_SETLIGHTENABLED                            ,
+    SVGA_3D_CMD_SETVIEWPORT                                ,
+    SVGA_3D_CMD_SETCLIPPLANE                               ,
+    SVGA_3D_CMD_CLEAR                                      ,
+    SVGA_3D_CMD_PRESENT                                    ,
+    SVGA_3D_CMD_SHADER_DEFINE                              ,
+    SVGA_3D_CMD_SHADER_DESTROY                             ,
+    SVGA_3D_CMD_SET_SHADER                                 ,
+    SVGA_3D_CMD_SET_SHADER_CONST                           ,
+    SVGA_3D_CMD_DRAW_PRIMITIVES                            ,
+    SVGA_3D_CMD_SETSCISSORRECT                             ,
+    SVGA_3D_CMD_BEGIN_QUERY                                ,
+    SVGA_3D_CMD_END_QUERY                                  ,
+    SVGA_3D_CMD_WAIT_FOR_QUERY                             ,
+    SVGA_3D_CMD_PRESENT_READBACK                           ,
+    SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN                     ,
+    SVGA_3D_CMD_SURFACE_DEFINE_V2                          ,
+    SVGA_3D_CMD_GENERATE_MIPMAPS                           ,
+    SVGA_3D_CMD_DEAD4                                      ,
+    SVGA_3D_CMD_DEAD5                                      ,
+    SVGA_3D_CMD_DEAD6                                      ,
+    SVGA_3D_CMD_DEAD7                                      ,
+    SVGA_3D_CMD_DEAD8                                      ,
+    SVGA_3D_CMD_DEAD9                                      ,
+    SVGA_3D_CMD_DEAD10                                     ,
+    SVGA_3D_CMD_DEAD11                                     ,
+    SVGA_3D_CMD_ACTIVATE_SURFACE                           ,
+    SVGA_3D_CMD_DEACTIVATE_SURFACE                         ,
+    SVGA_3D_CMD_SCREEN_DMA                                 ,
+    SVGA_3D_CMD_VB_DX_CLEAR_RENDERTARGET_VIEW_REGION       ,
+    SVGA_3D_CMD_DEAD2                                      ,
+    SVGA_3D_CMD_DEAD12                                     ,
+    SVGA_3D_CMD_DEAD13                                     ,
+    SVGA_3D_CMD_DEAD14                                     ,
+    SVGA_3D_CMD_DEAD15                                     ,
+    SVGA_3D_CMD_DEAD16                                     ,
+    SVGA_3D_CMD_DEAD17                                     ,
+    SVGA_3D_CMD_SET_OTABLE_BASE                            ,
+    SVGA_3D_CMD_READBACK_OTABLE                            ,
+    SVGA_3D_CMD_DEFINE_GB_MOB                              ,
+    SVGA_3D_CMD_DESTROY_GB_MOB                             ,
+    SVGA_3D_CMD_DEAD3                                      ,
+    SVGA_3D_CMD_UPDATE_GB_MOB_MAPPING                      ,
+    SVGA_3D_CMD_DEFINE_GB_SURFACE                          ,
+    SVGA_3D_CMD_DESTROY_GB_SURFACE                         ,
+    SVGA_3D_CMD_BIND_GB_SURFACE                            ,
+    SVGA_3D_CMD_COND_BIND_GB_SURFACE                       ,
+    SVGA_3D_CMD_UPDATE_GB_IMAGE                            ,
+    SVGA_3D_CMD_UPDATE_GB_SURFACE                          ,
+    SVGA_3D_CMD_READBACK_GB_IMAGE                          ,
+    SVGA_3D_CMD_READBACK_GB_SURFACE                        ,
+    SVGA_3D_CMD_INVALIDATE_GB_IMAGE                        ,
+    SVGA_3D_CMD_INVALIDATE_GB_SURFACE                      ,
+    SVGA_3D_CMD_DEFINE_GB_CONTEXT                          ,
+    SVGA_3D_CMD_DESTROY_GB_CONTEXT                         ,
+    SVGA_3D_CMD_BIND_GB_CONTEXT                            ,
+    SVGA_3D_CMD_READBACK_GB_CONTEXT                        ,
+    SVGA_3D_CMD_INVALIDATE_GB_CONTEXT                      ,
+    SVGA_3D_CMD_DEFINE_GB_SHADER                           ,
+    SVGA_3D_CMD_DESTROY_GB_SHADER                          ,
+    SVGA_3D_CMD_BIND_GB_SHADER                             ,
+    SVGA_3D_CMD_SET_OTABLE_BASE64                          ,
+    SVGA_3D_CMD_BEGIN_GB_QUERY                             ,
+    SVGA_3D_CMD_END_GB_QUERY                               ,
+    SVGA_3D_CMD_WAIT_FOR_GB_QUERY                          ,
+    SVGA_3D_CMD_NOP                                        ,
+    SVGA_3D_CMD_ENABLE_GART                                ,
+    SVGA_3D_CMD_DISABLE_GART                               ,
+    SVGA_3D_CMD_MAP_MOB_INTO_GART                          ,
+    SVGA_3D_CMD_UNMAP_GART_RANGE                           ,
+    SVGA_3D_CMD_DEFINE_GB_SCREENTARGET                     ,
+    SVGA_3D_CMD_DESTROY_GB_SCREENTARGET                    ,
+    SVGA_3D_CMD_BIND_GB_SCREENTARGET                       ,
+    SVGA_3D_CMD_UPDATE_GB_SCREENTARGET                     ,
+    SVGA_3D_CMD_READBACK_GB_IMAGE_PARTIAL                  ,
+    SVGA_3D_CMD_INVALIDATE_GB_IMAGE_PARTIAL                ,
+    SVGA_3D_CMD_SET_GB_SHADERCONSTS_INLINE                 ,
+    SVGA_3D_CMD_GB_SCREEN_DMA                              ,
+    SVGA_3D_CMD_BIND_GB_SURFACE_WITH_PITCH                 ,
+    SVGA_3D_CMD_GB_MOB_FENCE                               ,
+    SVGA_3D_CMD_DEFINE_GB_SURFACE_V2                       ,
+    SVGA_3D_CMD_DEFINE_GB_MOB64                            ,
+    SVGA_3D_CMD_REDEFINE_GB_MOB64                          ,
+    SVGA_3D_CMD_NOP_ERROR                                  ,
+    SVGA_3D_CMD_SET_VERTEX_STREAMS                         ,
+    SVGA_3D_CMD_SET_VERTEX_DECLS                           ,
+    SVGA_3D_CMD_SET_VERTEX_DIVISORS                        ,
+    SVGA_3D_CMD_DRAW                                       ,
+   SVGA_3D_CMD_DX_DEFINE_CONTEXT                          ,
+   SVGA_3D_CMD_DX_DESTROY_CONTEXT                         ,
+   SVGA_3D_CMD_DX_BIND_CONTEXT                            ,
+   SVGA_3D_CMD_DX_READBACK_CONTEXT                        ,
+   SVGA_3D_CMD_DX_INVALIDATE_CONTEXT                      ,
+   SVGA_3D_CMD_DX_SET_SINGLE_CONSTANT_BUFFER              ,
+   SVGA_3D_CMD_DX_SET_SHADER_RESOURCES                    ,
+   SVGA_3D_CMD_DX_SET_SHADER                              ,
+   SVGA_3D_CMD_DX_SET_SAMPLERS                            ,
+   SVGA_3D_CMD_DX_DRAW                                    ,
+   SVGA_3D_CMD_DX_DRAW_INDEXED                            ,
+   SVGA_3D_CMD_DX_DRAW_INSTANCED                          ,
+   SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED                  ,
+   SVGA_3D_CMD_DX_DRAW_AUTO                               ,
+   SVGA_3D_CMD_DX_SET_INPUT_LAYOUT                        ,
+   SVGA_3D_CMD_DX_SET_VERTEX_BUFFERS                      ,
+   SVGA_3D_CMD_DX_SET_INDEX_BUFFER                        ,
+   SVGA_3D_CMD_DX_SET_TOPOLOGY                            ,
+   SVGA_3D_CMD_DX_SET_RENDERTARGETS                       ,
+   SVGA_3D_CMD_DX_SET_BLEND_STATE                         ,
+   SVGA_3D_CMD_DX_SET_DEPTHSTENCIL_STATE                  ,
+   SVGA_3D_CMD_DX_SET_RASTERIZER_STATE                    ,
+   SVGA_3D_CMD_DX_DEFINE_QUERY                            ,
+   SVGA_3D_CMD_DX_DESTROY_QUERY                           ,
+   SVGA_3D_CMD_DX_BIND_QUERY                              ,
+   SVGA_3D_CMD_DX_SET_QUERY_OFFSET                        ,
+   SVGA_3D_CMD_DX_BEGIN_QUERY                             ,
+   SVGA_3D_CMD_DX_END_QUERY                               ,
+   SVGA_3D_CMD_DX_READBACK_QUERY                          ,
+   SVGA_3D_CMD_DX_SET_PREDICATION                         ,
+   SVGA_3D_CMD_DX_SET_SOTARGETS                           ,
+   SVGA_3D_CMD_DX_SET_VIEWPORTS                           ,
+   SVGA_3D_CMD_DX_SET_SCISSORRECTS                        ,
+   SVGA_3D_CMD_DX_CLEAR_RENDERTARGET_VIEW                 ,
+   SVGA_3D_CMD_DX_CLEAR_DEPTHSTENCIL_VIEW                 ,
+   SVGA_3D_CMD_DX_PRED_COPY_REGION                        ,
+   SVGA_3D_CMD_DX_PRED_COPY                               ,
+   SVGA_3D_CMD_DX_PRESENTBLT                              ,
+   SVGA_3D_CMD_DX_GENMIPS                                 ,
+   SVGA_3D_CMD_DX_UPDATE_SUBRESOURCE                      ,
+   SVGA_3D_CMD_DX_READBACK_SUBRESOURCE                    ,
+   SVGA_3D_CMD_DX_INVALIDATE_SUBRESOURCE                  ,
+   SVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW              ,
+   SVGA_3D_CMD_DX_DESTROY_SHADERRESOURCE_VIEW             ,
+   SVGA_3D_CMD_DX_DEFINE_RENDERTARGET_VIEW                ,
+   SVGA_3D_CMD_DX_DESTROY_RENDERTARGET_VIEW               ,
+   SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW                ,
+   SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_VIEW               ,
+   SVGA_3D_CMD_DX_DEFINE_ELEMENTLAYOUT                    ,
+   SVGA_3D_CMD_DX_DESTROY_ELEMENTLAYOUT                   ,
+   SVGA_3D_CMD_DX_DEFINE_BLEND_STATE                      ,
+   SVGA_3D_CMD_DX_DESTROY_BLEND_STATE                     ,
+   SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_STATE               ,
+   SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_STATE              ,
+   SVGA_3D_CMD_DX_DEFINE_RASTERIZER_STATE                 ,
+   SVGA_3D_CMD_DX_DESTROY_RASTERIZER_STATE                ,
+   SVGA_3D_CMD_DX_DEFINE_SAMPLER_STATE                    ,
+   SVGA_3D_CMD_DX_DESTROY_SAMPLER_STATE                   ,
+   SVGA_3D_CMD_DX_DEFINE_SHADER                           ,
+   SVGA_3D_CMD_DX_DESTROY_SHADER                          ,
+   SVGA_3D_CMD_DX_BIND_SHADER                             ,
+   SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT                     ,
+   SVGA_3D_CMD_DX_DESTROY_STREAMOUTPUT                    ,
+   SVGA_3D_CMD_DX_SET_STREAMOUTPUT                        ,
+   SVGA_3D_CMD_DX_SET_COTABLE                             ,
+   SVGA_3D_CMD_DX_READBACK_COTABLE                        ,
+   SVGA_3D_CMD_DX_BUFFER_COPY                             ,
+   SVGA_3D_CMD_DX_TRANSFER_FROM_BUFFER                    ,
+   SVGA_3D_CMD_DX_SURFACE_COPY_AND_READBACK               ,
+   SVGA_3D_CMD_DX_MOVE_QUERY                              ,
+   SVGA_3D_CMD_DX_BIND_ALL_QUERY                          ,
+   SVGA_3D_CMD_DX_READBACK_ALL_QUERY                      ,
+   SVGA_3D_CMD_DX_PRED_TRANSFER_FROM_BUFFER               ,
+   SVGA_3D_CMD_DX_MOB_FENCE_64                            ,
+   SVGA_3D_CMD_DX_BIND_ALL_SHADER                         ,
+   SVGA_3D_CMD_DX_HINT                                    ,
+   SVGA_3D_CMD_DX_BUFFER_UPDATE                           ,
+   SVGA_3D_CMD_DX_SET_VS_CONSTANT_BUFFER_OFFSET           ,
+   SVGA_3D_CMD_DX_SET_PS_CONSTANT_BUFFER_OFFSET           ,
+   SVGA_3D_CMD_DX_SET_GS_CONSTANT_BUFFER_OFFSET           ,
+   SVGA_3D_CMD_DX_SET_HS_CONSTANT_BUFFER_OFFSET           ,
+   SVGA_3D_CMD_DX_SET_DS_CONSTANT_BUFFER_OFFSET           ,
+   SVGA_3D_CMD_DX_SET_CS_CONSTANT_BUFFER_OFFSET           ,
+   SVGA_3D_CMD_DX_COND_BIND_ALL_SHADER                    ,
+   SVGA_3D_CMD_DX_MAX                                     ,
+   SVGA_3D_CMD_SCREEN_COPY                                ,
+   SVGA_3D_CMD_RESERVED1                                  ,
+   SVGA_3D_CMD_RESERVED2                                  ,
+   SVGA_3D_CMD_RESERVED3                                  ,
+   SVGA_3D_CMD_RESERVED4                                  ,
+   SVGA_3D_CMD_RESERVED5                                  ,
+   SVGA_3D_CMD_RESERVED6                                  ,
+   SVGA_3D_CMD_RESERVED7                                  ,
+   SVGA_3D_CMD_RESERVED8                                  ,
+   SVGA_3D_CMD_GROW_OTABLE                                ,
+   SVGA_3D_CMD_DX_GROW_COTABLE                            ,
+   SVGA_3D_CMD_INTRA_SURFACE_COPY                         ,
+   SVGA_3D_CMD_DEFINE_GB_SURFACE_V3                       ,
+   SVGA_3D_CMD_DX_RESOLVE_COPY                            ,
+   SVGA_3D_CMD_DX_PRED_RESOLVE_COPY                       ,
+   SVGA_3D_CMD_DX_PRED_CONVERT_REGION                     ,
+   SVGA_3D_CMD_DX_PRED_CONVERT                            ,
+   SVGA_3D_CMD_WHOLE_SURFACE_COPY                         ,
+   SVGA_3D_CMD_DX_DEFINE_UA_VIEW                          ,
+   SVGA_3D_CMD_DX_DESTROY_UA_VIEW                         ,
+   SVGA_3D_CMD_DX_CLEAR_UA_VIEW_UINT                      ,
+   SVGA_3D_CMD_DX_CLEAR_UA_VIEW_FLOAT                     ,
+   SVGA_3D_CMD_DX_COPY_STRUCTURE_COUNT                    ,
+   SVGA_3D_CMD_DX_SET_UA_VIEWS                            ,
+   SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED_INDIRECT         ,
+   SVGA_3D_CMD_DX_DRAW_INSTANCED_INDIRECT                 ,
+   SVGA_3D_CMD_DX_DISPATCH                                ,
+   SVGA_3D_CMD_DX_DISPATCH_INDIRECT                       ,
+   SVGA_3D_CMD_WRITE_ZERO_SURFACE                         ,
+   SVGA_3D_CMD_HINT_ZERO_SURFACE                          ,
+   SVGA_3D_CMD_DX_TRANSFER_TO_BUFFER                      ,
+   SVGA_3D_CMD_DX_SET_STRUCTURE_COUNT                     ,
+   SVGA_3D_CMD_LOGICOPS_BITBLT                            ,
+   SVGA_3D_CMD_LOGICOPS_TRANSBLT                          ,
+   SVGA_3D_CMD_LOGICOPS_STRETCHBLT                        ,
+   SVGA_3D_CMD_LOGICOPS_COLORFILL                         ,
+   SVGA_3D_CMD_LOGICOPS_ALPHABLEND                        ,
+   SVGA_3D_CMD_LOGICOPS_CLEARTYPEBLEND                    ,
+   SVGA_3D_CMD_RESERVED2_1                                ,
+   SVGA_3D_CMD_RESERVED2_2                                ,
+   SVGA_3D_CMD_DEFINE_GB_SURFACE_V4                       ,
+   SVGA_3D_CMD_DX_SET_CS_UA_VIEWS                         ,
+   SVGA_3D_CMD_DX_SET_MIN_LOD                             ,
+   SVGA_3D_CMD_RESERVED2_3                                ,
+   SVGA_3D_CMD_RESERVED2_4                                ,
+   SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW_V2             ,
+   SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT_WITH_MOB            ,
+   SVGA_3D_CMD_DX_SET_SHADER_IFACE                        ,
+   SVGA_3D_CMD_DX_BIND_STREAMOUTPUT                       ,
+   SVGA_3D_CMD_SURFACE_STRETCHBLT_NON_MS_TO_MS            ,
+   SVGA_3D_CMD_DX_BIND_SHADER_IFACE                       ,
+   SVGA_3D_CMD_DX_DEFINE_RASTERIZER_STATE_V2              ,
+   VBSVGA_3D_CMD_DX_DEFINE_VIDEO_PROCESSOR                ,
+   VBSVGA_3D_CMD_DX_DEFINE_VIDEO_DECODER_OUTPUT_VIEW      ,
+   VBSVGA_3D_CMD_DX_DEFINE_VIDEO_DECODER                  ,
+   VBSVGA_3D_CMD_DX_VIDEO_DECODER_BEGIN_FRAME             ,
+   VBSVGA_3D_CMD_DX_VIDEO_DECODER_SUBMIT_BUFFERS          ,
+   VBSVGA_3D_CMD_DX_VIDEO_DECODER_END_FRAME               ,
+   VBSVGA_3D_CMD_DX_DEFINE_VIDEO_PROCESSOR_INPUT_VIEW     ,
+   VBSVGA_3D_CMD_DX_DEFINE_VIDEO_PROCESSOR_OUTPUT_VIEW    ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_BLT                   ,
+   VBSVGA_3D_CMD_DX_DESTROY_VIDEO_DECODER                 ,
+   VBSVGA_3D_CMD_DX_DESTROY_VIDEO_DECODER_OUTPUT_VIEW     ,
+   VBSVGA_3D_CMD_DX_DESTROY_VIDEO_PROCESSOR               ,
+   VBSVGA_3D_CMD_DX_DESTROY_VIDEO_PROCESSOR_INPUT_VIEW    ,
+   VBSVGA_3D_CMD_DX_DESTROY_VIDEO_PROCESSOR_OUTPUT_VIEW   ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_TARGET_RECT ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_BACKGROUND_COLOR ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_COLOR_SPACE ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_ALPHA_FILL_MODE ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_CONSTRICTION ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_STEREO_MODE ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_FRAME_FORMAT ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_COLOR_SPACE ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_OUTPUT_RATE ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_SOURCE_RECT ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_DEST_RECT  ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_ALPHA      ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_PALETTE    ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_PIXEL_ASPECT_RATIO ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_LUMA_KEY   ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_STEREO_FORMAT ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_AUTO_PROCESSING_MODE ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_FILTER     ,
+   VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_ROTATION   ,
+   VBSVGA_3D_CMD_DX_GET_VIDEO_CAPABILITY                  ,
+   VBSVGA_3D_CMD_DX_CLEAR_RTV                             ,
+   VBSVGA_3D_CMD_DX_CLEAR_UAV                             ,
+   VBSVGA_3D_CMD_DX_CLEAR_VDOV                            ,
+   VBSVGA_3D_CMD_DX_CLEAR_VPIV                            ,
+   VBSVGA_3D_CMD_DX_CLEAR_VPOV                            
+};
+
+uint8_t* InternalCommandAlloc(FuzzedDataProvider *fdp, uint32_t& total_length, uint32_t& pos, uint8_t* result, void* cmd, uint32_t cmd_size, uint32_t cmdId, bool is_3d) {
+    total_length += cmd_size + sizeof(uint32_t);
+
+    if (is_3d)
+        total_length += sizeof(uint32_t);
+
+    if (total_length > BASE_SIZE)
+        result = (uint8_t*)realloc(result, total_length);
+
+    if (result == nullptr) return nullptr;
+
+    *(uint32_t*)(result + pos) = cmdId;
+    pos += sizeof(uint32_t);
+
+    if (is_3d){
+        *(uint32_t*)(result + pos) = cmd_size;
+        pos += sizeof(uint32_t);
+    }
+
+    memset(cmd, 0, cmd_size);
+    std::vector<uint8_t> cmd_bytes = fdp->ConsumeBytes<uint8_t>(cmd_size);
+
+    if (cmd_bytes.data() != nullptr) {
+        memcpy(cmd, cmd_bytes.data(), cmd_bytes.size());
+        memcpy(result + pos, cmd, cmd_size);
+    }
+    pos += cmd_size;
+    return result;
+}
+
+uint8_t* AllocateRandomCommands(FuzzedDataProvider *fdp, uint32_t& commands_length) {
+    uint8_t *result = (uint8_t*)malloc(BASE_SIZE);
+    uint32_t pos = 0;
+    //uint8_t command_count = fdp->ConsumeIntegral<uint8_t>();
+    //Experiment with only one command at a time.
+    uint8_t command_count = 1;
+    if (command_count == 0) return nullptr;
+    uint32_t total_length = 0;
+    while (command_count > 0) {
+        command_count--;
+        uint32_t cmdId = fdp->ConsumeIntegral<uint32_t>() % (sizeof(kCommandArray)/sizeof(uint32_t));
+        cmdId = kCommandArray[cmdId];
+        switch (cmdId) {
+            case SVGA_CMD_INVALID_CMD: 
+                {
+                    continue;
+                }
+
+            case SVGA_CMD_FENCE:
+                {
+                    SVGAFifoCmdFence cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdFence);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_UPDATE:
+                {
+                    SVGAFifoCmdUpdate cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdUpdate);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_UPDATE_VERBOSE:
+                {
+                    SVGAFifoCmdUpdateVerbose cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdUpdateVerbose);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_DEFINE_CURSOR:
+                {
+                    SVGAFifoCmdDefineCursor cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdDefineCursor);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_DEFINE_ALPHA_CURSOR:
+                {
+                    SVGAFifoCmdDefineAlphaCursor cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdDefineAlphaCursor);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_MOVE_CURSOR:
+                {
+                    SVGAFifoCmdMoveCursor cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdMoveCursor);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_CMD_DISPLAY_CURSOR:
+                {
+                    SVGAFifoCmdDisplayCursor cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdDisplayCursor);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_RECT_FILL:
+                {
+                    SVGAFifoCmdRectFill cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdRectFill);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_RECT_COPY:
+                {
+                    SVGAFifoCmdRectCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdRectCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_RECT_ROP_COPY:
+                {
+                    SVGAFifoCmdRectRopCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdRectRopCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_ESCAPE:
+                {
+                    /* Followed by 'size' bytes of data. */
+                    SVGAFifoCmdEscape cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdEscape);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+            case SVGA_CMD_DEFINE_GMR2:
+                {
+                    SVGAFifoCmdDefineGMR2 cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdDefineGMR2);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_REMAP_GMR2:
+                {
+                    SVGAFifoCmdRemapGMR2 cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdRemapGMR2);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+            case SVGA_CMD_DEFINE_SCREEN:
+                {
+                    SVGAFifoCmdDefineScreen cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdDefineScreen);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_DESTROY_SCREEN:
+                {
+                    SVGAFifoCmdDestroyScreen cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdDestroyScreen);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_DEFINE_GMRFB:
+                {
+                    SVGAFifoCmdDefineGMRFB cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdDefineGMRFB);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_BLIT_GMRFB_TO_SCREEN:
+                {
+                    SVGAFifoCmdBlitGMRFBToScreen cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdBlitGMRFBToScreen);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_BLIT_SCREEN_TO_GMRFB:
+                {
+                    SVGAFifoCmdBlitScreenToGMRFB cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdBlitScreenToGMRFB);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_ANNOTATION_FILL:
+                {
+                    SVGAFifoCmdAnnotationFill cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdAnnotationFill);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_CMD_ANNOTATION_COPY:
+                {
+                    SVGAFifoCmdAnnotationCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGAFifoCmdAnnotationCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, false);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+            case SVGA_3D_CMD_SURFACE_DEFINE:
+                {
+                    SVGA3dCmdDefineSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+                }
+
+            case SVGA_3D_CMD_SURFACE_DEFINE_V2:
+                {
+                    SVGA3dCmdDefineSurface_v2 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineSurface_v2);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SURFACE_DESTROY:
+                {
+                    SVGA3dCmdDestroySurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDestroySurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SURFACE_COPY:
+                {
+                    SVGA3dCmdSurfaceCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSurfaceCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SURFACE_STRETCHBLT:
+                {
+                    SVGA3dCmdSurfaceStretchBlt cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSurfaceStretchBlt);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SURFACE_DMA:
+                {
+                    SVGA3dCmdSurfaceDMA cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSurfaceDMA);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN:
+                {
+                    SVGA3dCmdBlitSurfaceToScreen cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdBlitSurfaceToScreen);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_CONTEXT_DEFINE:
+                {
+                    SVGA3dCmdDefineContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_CONTEXT_DESTROY:
+                {
+                    SVGA3dCmdDestroyContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDestroyContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETTRANSFORM:
+                {
+                    SVGA3dCmdSetTransform cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetTransform);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETZRANGE:
+                {
+                    SVGA3dCmdSetZRange cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetZRange);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETRENDERSTATE:
+                {
+                    SVGA3dCmdSetRenderState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetRenderState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETRENDERTARGET:
+                {
+                    SVGA3dCmdSetRenderTarget cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetRenderTarget);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETTEXTURESTATE:
+                {
+                    SVGA3dCmdSetTextureState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetTextureState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETMATERIAL:
+                {
+                    SVGA3dCmdSetMaterial cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetMaterial);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETLIGHTDATA:
+                {
+                    SVGA3dCmdSetLightData cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetLightData);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETLIGHTENABLED:
+                {
+                    SVGA3dCmdSetLightEnabled cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetLightEnabled);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETVIEWPORT:
+                {
+                    SVGA3dCmdSetViewport cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetViewport);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETCLIPPLANE:
+                {
+                    SVGA3dCmdSetClipPlane cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetClipPlane);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_CLEAR:
+                {
+                    SVGA3dCmdClear cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdClear);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_PRESENT:
+            case SVGA_3D_CMD_PRESENT_READBACK: /** @todo SVGA_3D_CMD_PRESENT_READBACK isn't quite the same as present... */
+                {
+                    SVGA3dCmdPresent cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdPresent);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SHADER_DEFINE:
+                {
+                    SVGA3dCmdDefineShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SHADER_DESTROY:
+                {
+                    SVGA3dCmdDestroyShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDestroyShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SET_SHADER:
+                {
+                    SVGA3dCmdSetShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SET_SHADER_CONST:
+                {
+                    SVGA3dCmdSetShaderConst cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetShaderConst);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DRAW_PRIMITIVES:
+                {
+                    SVGA3dCmdDrawPrimitives cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDrawPrimitives);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SETSCISSORRECT:
+                {
+                    SVGA3dCmdSetScissorRect cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetScissorRect);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_BEGIN_QUERY:
+                {
+                    SVGA3dCmdBeginQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdBeginQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_END_QUERY:
+                {
+                    SVGA3dCmdEndQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdEndQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_WAIT_FOR_QUERY:
+                {
+                    SVGA3dCmdWaitForQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdWaitForQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_GENERATE_MIPMAPS:
+                {
+                    SVGA3dCmdGenerateMipmaps cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdGenerateMipmaps);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SCREEN_DMA:
+                {
+                    SVGA3dCmdScreenDMA cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdScreenDMA);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+                /* case SVGA_3D_CMD_DEAD1: New SVGA_3D_CMD_VB_DX_CLEAR_RENDERTARGET_VIEW_REGION */
+
+            case SVGA_3D_CMD_SET_OTABLE_BASE:
+                {
+                    SVGA3dCmdSetOTableBase cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetOTableBase);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_READBACK_OTABLE:
+                {
+                    SVGA3dCmdReadbackOTable cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdReadbackOTable);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_MOB:
+                {
+                    SVGA3dCmdDefineGBMob cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBMob);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DESTROY_GB_MOB:
+                {
+                    SVGA3dCmdDestroyGBMob cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDestroyGBMob);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_UPDATE_GB_MOB_MAPPING:
+                {
+                    SVGA3dCmdUpdateGBMobMapping cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdUpdateGBMobMapping);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_SURFACE:
+                {
+                    SVGA3dCmdDefineGBSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DESTROY_GB_SURFACE:
+                {
+                    SVGA3dCmdDestroyGBSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDestroyGBSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_BIND_GB_SURFACE:
+                {
+                    SVGA3dCmdBindGBSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdBindGBSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_COND_BIND_GB_SURFACE:
+                {
+                    SVGA3dCmdCondBindGBSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdCondBindGBSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_UPDATE_GB_IMAGE:
+                {
+                    SVGA3dCmdUpdateGBImage cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdUpdateGBImage);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_UPDATE_GB_SURFACE:
+                {
+                    SVGA3dCmdUpdateGBSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdUpdateGBSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_READBACK_GB_IMAGE:
+                {
+                    SVGA3dCmdReadbackGBImage cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdReadbackGBImage);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_READBACK_GB_SURFACE:
+                {
+                    SVGA3dCmdReadbackGBSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdReadbackGBSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_INVALIDATE_GB_IMAGE:
+                {
+                    SVGA3dCmdInvalidateGBImage cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdInvalidateGBImage);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_INVALIDATE_GB_SURFACE:
+                {
+                    SVGA3dCmdInvalidateGBSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdInvalidateGBSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_CONTEXT:
+                {
+                    SVGA3dCmdDefineGBContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DESTROY_GB_CONTEXT:
+                {
+                    SVGA3dCmdDestroyGBContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDestroyGBContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_BIND_GB_CONTEXT:
+                {
+                    SVGA3dCmdBindGBContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdBindGBContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_READBACK_GB_CONTEXT:
+                {
+                    SVGA3dCmdReadbackGBContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdReadbackGBContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_INVALIDATE_GB_CONTEXT:
+                {
+                    SVGA3dCmdInvalidateGBContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdInvalidateGBContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_SHADER:
+                {
+                    SVGA3dCmdDefineGBShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DESTROY_GB_SHADER:
+                {
+                    SVGA3dCmdDestroyGBShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDestroyGBShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_BIND_GB_SHADER:
+                {
+                    SVGA3dCmdBindGBShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdBindGBShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SET_OTABLE_BASE64:
+                {
+                    SVGA3dCmdSetOTableBase64 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetOTableBase64);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_BEGIN_GB_QUERY:
+                {
+                    SVGA3dCmdBeginGBQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdBeginGBQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_END_GB_QUERY:
+                {
+                    SVGA3dCmdEndGBQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdEndGBQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_WAIT_FOR_GB_QUERY:
+                {
+                    SVGA3dCmdWaitForGBQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdWaitForGBQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_NOP:
+                {
+                    /* Apparently there is nothing to do. */
+                    break;
+                }
+
+            case SVGA_3D_CMD_ENABLE_GART:
+                {
+                    SVGA3dCmdEnableGart cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdEnableGart);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_MAP_MOB_INTO_GART:
+                {
+                    SVGA3dCmdMapMobIntoGart cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdMapMobIntoGart);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_UNMAP_GART_RANGE:
+                {
+                    SVGA3dCmdUnmapGartRange cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdUnmapGartRange);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_SCREENTARGET:
+                {
+                    SVGA3dCmdDefineGBScreenTarget cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBScreenTarget);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DESTROY_GB_SCREENTARGET:
+                {
+                    SVGA3dCmdDestroyGBScreenTarget cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDestroyGBScreenTarget);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_BIND_GB_SCREENTARGET:
+                {
+                    SVGA3dCmdBindGBScreenTarget cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdBindGBScreenTarget);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_UPDATE_GB_SCREENTARGET:
+                {
+                    SVGA3dCmdUpdateGBScreenTarget cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdUpdateGBScreenTarget);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_READBACK_GB_IMAGE_PARTIAL:
+                {
+                    SVGA3dCmdReadbackGBImagePartial cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdReadbackGBImagePartial);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_INVALIDATE_GB_IMAGE_PARTIAL:
+                {
+                    SVGA3dCmdInvalidateGBImagePartial cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdInvalidateGBImagePartial);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SET_GB_SHADERCONSTS_INLINE:
+                {
+                    SVGA3dCmdSetGBShaderConstInline cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetGBShaderConstInline);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_GB_SCREEN_DMA:
+                {
+                    SVGA3dCmdGBScreenDMA cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdGBScreenDMA);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_BIND_GB_SURFACE_WITH_PITCH:
+                {
+                    SVGA3dCmdBindGBSurfaceWithPitch cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdBindGBSurfaceWithPitch);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_GB_MOB_FENCE:
+                {
+                    SVGA3dCmdGBMobFence cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdGBMobFence);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_SURFACE_V2:
+                {
+                    SVGA3dCmdDefineGBSurface_v2 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBSurface_v2);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_MOB64:
+                {
+                    SVGA3dCmdDefineGBMob64 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBMob64);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_REDEFINE_GB_MOB64:
+                {
+                    SVGA3dCmdRedefineGBMob64 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdRedefineGBMob64);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_NOP_ERROR:
+                {
+                    /* Apparently there is nothing to do. */
+                    break;
+                }
+
+            case SVGA_3D_CMD_SET_VERTEX_STREAMS:
+                {
+                    SVGA3dCmdSetVertexStreams cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetVertexStreams);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SET_VERTEX_DECLS:
+                {
+                    SVGA3dCmdSetVertexDecls cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetVertexDecls);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+
+            case SVGA_3D_CMD_SET_VERTEX_DIVISORS:
+                {
+                    SVGA3dCmdSetVertexDivisors cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSetVertexDivisors);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+
+                    break;
+
+                }
+            case SVGA_3D_CMD_DX_DEFINE_CONTEXT:
+                {
+                    SVGA3dCmdDXDefineContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_CONTEXT:
+                {
+                    SVGA3dCmdDXDestroyContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BIND_CONTEXT:
+                {
+                    SVGA3dCmdDXBindContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBindContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_READBACK_CONTEXT:
+                {
+                    SVGA3dCmdDXReadbackContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXReadbackContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_INVALIDATE_CONTEXT:
+                {
+                    SVGA3dCmdDXInvalidateContext cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXInvalidateContext);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_SINGLE_CONSTANT_BUFFER:
+                {
+                    SVGA3dCmdDXSetSingleConstantBuffer cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetSingleConstantBuffer);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_SHADER_RESOURCES:
+                {
+                    SVGA3dCmdDXSetShaderResources cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetShaderResources);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_SHADER:
+                {
+                    SVGA3dCmdDXSetShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_SAMPLERS:
+                {
+                    SVGA3dCmdDXSetSamplers cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetSamplers);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DRAW:
+                {
+                    SVGA3dCmdDXDraw cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDraw);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DRAW_INDEXED:
+                {
+                    SVGA3dCmdDXDrawIndexed cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDrawIndexed);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DRAW_INSTANCED:
+                {
+                    SVGA3dCmdDXDrawInstanced cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDrawInstanced);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED:
+                {
+                    SVGA3dCmdDXDrawIndexedInstanced cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDrawIndexedInstanced);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DRAW_AUTO:
+                {
+                    SVGA3dCmdDXDrawAuto cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDrawAuto);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_INPUT_LAYOUT:
+                {
+                    SVGA3dCmdDXSetInputLayout cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetInputLayout);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_VERTEX_BUFFERS:
+                {
+                    SVGA3dCmdDXSetVertexBuffers cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetVertexBuffers);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_INDEX_BUFFER:
+                {
+                    SVGA3dCmdDXSetIndexBuffer cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetIndexBuffer);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_TOPOLOGY:
+                {
+                    SVGA3dCmdDXSetTopology cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetTopology);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_RENDERTARGETS:
+                {
+                    SVGA3dCmdDXSetRenderTargets cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetRenderTargets);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_BLEND_STATE:
+                {
+                    SVGA3dCmdDXSetBlendState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetBlendState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_DEPTHSTENCIL_STATE:
+                {
+                    SVGA3dCmdDXSetDepthStencilState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetDepthStencilState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_RASTERIZER_STATE:
+                {
+                    SVGA3dCmdDXSetRasterizerState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetRasterizerState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_QUERY:
+                {
+                    SVGA3dCmdDXDefineQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_QUERY:
+                {
+                    SVGA3dCmdDXDestroyQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BIND_QUERY:
+                {
+                    SVGA3dCmdDXBindQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBindQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_QUERY_OFFSET:
+                {
+                    SVGA3dCmdDXSetQueryOffset cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetQueryOffset);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BEGIN_QUERY:
+                {
+                    SVGA3dCmdDXBeginQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBeginQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_END_QUERY:
+                {
+                    SVGA3dCmdDXEndQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXEndQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_READBACK_QUERY:
+                {
+                    SVGA3dCmdDXReadbackQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXReadbackQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_PREDICATION:
+                {
+                    SVGA3dCmdDXSetPredication cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetPredication);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_SOTARGETS:
+                {
+                    SVGA3dCmdDXSetSOTargets cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetSOTargets);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_VIEWPORTS:
+                {
+                    SVGA3dCmdDXSetViewports cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetViewports);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_SCISSORRECTS:
+                {
+                    SVGA3dCmdDXSetScissorRects cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetScissorRects);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_CLEAR_RENDERTARGET_VIEW:
+                {
+                    SVGA3dCmdDXClearRenderTargetView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXClearRenderTargetView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_CLEAR_DEPTHSTENCIL_VIEW:
+                {
+                    SVGA3dCmdDXClearDepthStencilView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXClearDepthStencilView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_PRED_COPY_REGION:
+                {
+                    SVGA3dCmdDXPredCopyRegion cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXPredCopyRegion);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_PRED_COPY:
+                {
+                    SVGA3dCmdDXPredCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXPredCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_PRESENTBLT:
+                {
+                    SVGA3dCmdDXPresentBlt cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXPresentBlt);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_GENMIPS:
+                {
+                    SVGA3dCmdDXGenMips cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXGenMips);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_UPDATE_SUBRESOURCE:
+                {
+                    SVGA3dCmdDXUpdateSubResource cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXUpdateSubResource);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_READBACK_SUBRESOURCE:
+                {
+                    SVGA3dCmdDXReadbackSubResource cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXReadbackSubResource);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_INVALIDATE_SUBRESOURCE:
+                {
+                    SVGA3dCmdDXInvalidateSubResource cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXInvalidateSubResource);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_SHADERRESOURCE_VIEW:
+                {
+                    SVGA3dCmdDXDefineShaderResourceView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineShaderResourceView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_SHADERRESOURCE_VIEW:
+                {
+                    SVGA3dCmdDXDestroyShaderResourceView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyShaderResourceView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_RENDERTARGET_VIEW:
+                {
+                    SVGA3dCmdDXDefineRenderTargetView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineRenderTargetView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_RENDERTARGET_VIEW:
+                {
+                    SVGA3dCmdDXDestroyRenderTargetView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyRenderTargetView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW:
+                {
+                    SVGA3dCmdDXDefineDepthStencilView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineDepthStencilView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_VIEW:
+                {
+                    SVGA3dCmdDXDestroyDepthStencilView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyDepthStencilView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_ELEMENTLAYOUT:
+                {
+                    SVGA3dCmdDXDefineElementLayout cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineElementLayout);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_ELEMENTLAYOUT:
+                {
+                    SVGA3dCmdDXDestroyElementLayout cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyElementLayout);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_BLEND_STATE:
+                {
+                    SVGA3dCmdDXDefineBlendState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineBlendState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_BLEND_STATE:
+                {
+                    SVGA3dCmdDXDestroyBlendState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyBlendState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_STATE:
+                {
+                    SVGA3dCmdDXDefineDepthStencilState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineDepthStencilState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_DEPTHSTENCIL_STATE:
+                {
+                    SVGA3dCmdDXDestroyDepthStencilState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyDepthStencilState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_RASTERIZER_STATE:
+                {
+                    SVGA3dCmdDXDefineRasterizerState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineRasterizerState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_RASTERIZER_STATE:
+                {
+                    SVGA3dCmdDXDestroyRasterizerState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyRasterizerState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_SAMPLER_STATE:
+                {
+                    SVGA3dCmdDXDefineSamplerState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineSamplerState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_SAMPLER_STATE:
+                {
+                    SVGA3dCmdDXDestroySamplerState cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroySamplerState);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_SHADER:
+                {
+                    SVGA3dCmdDXDefineShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_SHADER:
+                {
+                    SVGA3dCmdDXDestroyShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BIND_SHADER:
+                {
+                    SVGA3dCmdDXBindShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBindShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT:
+                {
+                    SVGA3dCmdDXDefineStreamOutput cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineStreamOutput);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_STREAMOUTPUT:
+                {
+                    SVGA3dCmdDXDestroyStreamOutput cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyStreamOutput);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_STREAMOUTPUT:
+                {
+                    SVGA3dCmdDXSetStreamOutput cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetStreamOutput);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_COTABLE:
+                {
+                    SVGA3dCmdDXSetCOTable cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetCOTable);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_READBACK_COTABLE:
+                {
+                    SVGA3dCmdDXReadbackCOTable cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXReadbackCOTable);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BUFFER_COPY:
+                {
+                    SVGA3dCmdDXBufferCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBufferCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_TRANSFER_FROM_BUFFER:
+                {
+                    SVGA3dCmdDXTransferFromBuffer cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXTransferFromBuffer);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SURFACE_COPY_AND_READBACK:
+                {
+                    SVGA3dCmdDXSurfaceCopyAndReadback cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSurfaceCopyAndReadback);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_MOVE_QUERY:
+                {
+                    SVGA3dCmdDXMoveQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXMoveQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BIND_ALL_QUERY:
+                {
+                    SVGA3dCmdDXBindAllQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBindAllQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_READBACK_ALL_QUERY:
+                {
+                    SVGA3dCmdDXReadbackAllQuery cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXReadbackAllQuery);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_PRED_TRANSFER_FROM_BUFFER:
+                {
+                    SVGA3dCmdDXPredTransferFromBuffer cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXPredTransferFromBuffer);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_MOB_FENCE_64:
+                {
+                    SVGA3dCmdDXMobFence64 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXMobFence64);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BIND_ALL_SHADER:
+                {
+                    SVGA3dCmdDXBindAllShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBindAllShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_HINT:
+                {
+                    SVGA3dCmdDXHint cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXHint);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BUFFER_UPDATE:
+                {
+                    SVGA3dCmdDXBufferUpdate cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBufferUpdate);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_VS_CONSTANT_BUFFER_OFFSET:
+                {
+                    SVGA3dCmdDXSetVSConstantBufferOffset cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetVSConstantBufferOffset);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_PS_CONSTANT_BUFFER_OFFSET:
+                {
+                    SVGA3dCmdDXSetPSConstantBufferOffset cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetPSConstantBufferOffset);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_GS_CONSTANT_BUFFER_OFFSET:
+                {
+                    SVGA3dCmdDXSetGSConstantBufferOffset cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetGSConstantBufferOffset);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_HS_CONSTANT_BUFFER_OFFSET:
+                {
+                    SVGA3dCmdDXSetHSConstantBufferOffset cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetHSConstantBufferOffset);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_DS_CONSTANT_BUFFER_OFFSET:
+                {
+                    SVGA3dCmdDXSetDSConstantBufferOffset cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetDSConstantBufferOffset);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_CS_CONSTANT_BUFFER_OFFSET:
+                {
+                    SVGA3dCmdDXSetCSConstantBufferOffset cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetCSConstantBufferOffset);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_COND_BIND_ALL_SHADER:
+                {
+                    SVGA3dCmdDXCondBindAllShader cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXCondBindAllShader);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_SCREEN_COPY:
+                {
+                    SVGA3dCmdScreenCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdScreenCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED1:
+                {
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED2:
+                {
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED3:
+                {
+                    
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED4:
+                {
+                    
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED5:
+                {
+                    
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED6:
+                {
+                    
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED7:
+                {
+                    
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED8:
+                {
+                    
+                    break;
+                }
+
+            case SVGA_3D_CMD_GROW_OTABLE:
+                {
+                    SVGA3dCmdGrowOTable cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdGrowOTable);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_GROW_COTABLE:
+                {
+                    SVGA3dCmdDXGrowCOTable cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXGrowCOTable);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_INTRA_SURFACE_COPY:
+                {
+                    SVGA3dCmdIntraSurfaceCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdIntraSurfaceCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_SURFACE_V3:
+                {
+                    SVGA3dCmdDefineGBSurface_v3 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBSurface_v3);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_RESOLVE_COPY:
+                {
+                    SVGA3dCmdDXResolveCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXResolveCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_PRED_RESOLVE_COPY:
+                {
+                    SVGA3dCmdDXPredResolveCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXPredResolveCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_PRED_CONVERT_REGION:
+                {
+                    SVGA3dCmdDXPredConvertRegion cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXPredConvertRegion);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_PRED_CONVERT:
+                {
+                    SVGA3dCmdDXPredConvert cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXPredConvert);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_WHOLE_SURFACE_COPY:
+                {
+                    SVGA3dCmdWholeSurfaceCopy cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdWholeSurfaceCopy);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_UA_VIEW:
+                {
+                    SVGA3dCmdDXDefineUAView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineUAView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DESTROY_UA_VIEW:
+                {
+                    SVGA3dCmdDXDestroyUAView cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDestroyUAView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_CLEAR_UA_VIEW_UINT:
+                {
+                    SVGA3dCmdDXClearUAViewUint cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXClearUAViewUint);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_CLEAR_UA_VIEW_FLOAT:
+                {
+                    SVGA3dCmdDXClearUAViewFloat cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXClearUAViewFloat);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_COPY_STRUCTURE_COUNT:
+                {
+                    SVGA3dCmdDXCopyStructureCount cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXCopyStructureCount);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_UA_VIEWS:
+                {
+                    SVGA3dCmdDXSetUAViews cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetUAViews);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DRAW_INDEXED_INSTANCED_INDIRECT:
+                {
+                    SVGA3dCmdDXDrawIndexedInstancedIndirect cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDrawIndexedInstancedIndirect);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DRAW_INSTANCED_INDIRECT:
+                {
+                    SVGA3dCmdDXDrawInstancedIndirect cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDrawInstancedIndirect);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DISPATCH:
+                {
+                    SVGA3dCmdDXDispatch cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDispatch);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DISPATCH_INDIRECT:
+                {
+                    SVGA3dCmdDXDispatchIndirect cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDispatchIndirect);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_WRITE_ZERO_SURFACE:
+                {
+                    SVGA3dCmdWriteZeroSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdWriteZeroSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_HINT_ZERO_SURFACE:
+                {
+                    SVGA3dCmdHintZeroSurface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdHintZeroSurface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_TRANSFER_TO_BUFFER:
+                {
+                    SVGA3dCmdDXTransferToBuffer cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXTransferToBuffer);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_STRUCTURE_COUNT:
+                {
+                    SVGA3dCmdDXSetStructureCount cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetStructureCount);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_LOGICOPS_BITBLT:
+                {
+                    SVGA3dCmdLogicOpsBitBlt cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdLogicOpsBitBlt);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_LOGICOPS_TRANSBLT:
+                {
+                    SVGA3dCmdLogicOpsTransBlt cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdLogicOpsTransBlt);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_LOGICOPS_STRETCHBLT:
+                {
+                    SVGA3dCmdLogicOpsStretchBlt cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdLogicOpsStretchBlt);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_LOGICOPS_COLORFILL:
+                {
+                    SVGA3dCmdLogicOpsColorFill cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdLogicOpsColorFill);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_LOGICOPS_ALPHABLEND:
+                {
+                    SVGA3dCmdLogicOpsAlphaBlend cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdLogicOpsAlphaBlend);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_LOGICOPS_CLEARTYPEBLEND:
+                {
+                    SVGA3dCmdLogicOpsClearTypeBlend cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdLogicOpsClearTypeBlend);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED2_1:
+                {
+                    
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED2_2:
+                {
+                    break;
+                }
+
+            case SVGA_3D_CMD_DEFINE_GB_SURFACE_V4:
+                {
+                    SVGA3dCmdDefineGBSurface_v4 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDefineGBSurface_v4);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_CS_UA_VIEWS:
+                {
+                    SVGA3dCmdDXSetCSUAViews cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetCSUAViews);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_MIN_LOD:
+                {
+                    SVGA3dCmdDXSetMinLOD cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetMinLOD);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED2_3:
+                {
+                    break;
+                }
+
+            case SVGA_3D_CMD_RESERVED2_4:
+                {
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_DEPTHSTENCIL_VIEW_V2:
+                {
+                    SVGA3dCmdDXDefineDepthStencilView_v2 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineDepthStencilView_v2);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_STREAMOUTPUT_WITH_MOB:
+                {
+                    SVGA3dCmdDXDefineStreamOutputWithMob cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineStreamOutputWithMob);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_SET_SHADER_IFACE:
+                {
+                    SVGA3dCmdDXSetShaderIface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXSetShaderIface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BIND_STREAMOUTPUT:
+                {
+                    SVGA3dCmdDXBindStreamOutput cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBindStreamOutput);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_SURFACE_STRETCHBLT_NON_MS_TO_MS:
+                {
+                    SVGA3dCmdSurfaceStretchBltNonMSToMS cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdSurfaceStretchBltNonMSToMS);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_BIND_SHADER_IFACE:
+                {
+                    SVGA3dCmdDXBindShaderIface cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXBindShaderIface);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_VB_DX_CLEAR_RENDERTARGET_VIEW_REGION:
+                {
+                    SVGA3dCmdVBDXClearRenderTargetViewRegion cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdVBDXClearRenderTargetViewRegion);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case SVGA_3D_CMD_DX_DEFINE_RASTERIZER_STATE_V2:
+                {
+                    SVGA3dCmdDXDefineRasterizerState_v2 cmd;
+                    uint32_t cmd_size = sizeof(SVGA3dCmdDXDefineRasterizerState_v2);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DEFINE_VIDEO_PROCESSOR:
+                {
+                    VBSVGA3dCmdDXDefineVideoProcessor cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDefineVideoProcessor);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DEFINE_VIDEO_DECODER_OUTPUT_VIEW:
+                {
+                    VBSVGA3dCmdDXDefineVideoDecoderOutputView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDefineVideoDecoderOutputView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DEFINE_VIDEO_DECODER:
+                {
+                    VBSVGA3dCmdDXDefineVideoDecoder cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDefineVideoDecoder);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_DECODER_BEGIN_FRAME:
+                {
+                    VBSVGA3dCmdDXVideoDecoderBeginFrame cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoDecoderBeginFrame);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_DECODER_SUBMIT_BUFFERS:
+                {
+                    VBSVGA3dCmdDXVideoDecoderSubmitBuffers cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoDecoderSubmitBuffers);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_DECODER_END_FRAME:
+                {
+                    VBSVGA3dCmdDXVideoDecoderEndFrame cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoDecoderEndFrame);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DEFINE_VIDEO_PROCESSOR_INPUT_VIEW:
+                {
+                    VBSVGA3dCmdDXDefineVideoProcessorInputView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDefineVideoProcessorInputView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DEFINE_VIDEO_PROCESSOR_OUTPUT_VIEW:
+                {
+                    VBSVGA3dCmdDXDefineVideoProcessorOutputView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDefineVideoProcessorOutputView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_BLT:
+                {
+                    VBSVGA3dCmdDXVideoProcessorBlt cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorBlt);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DESTROY_VIDEO_DECODER:
+                {
+                    VBSVGA3dCmdDXDestroyVideoDecoder cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDestroyVideoDecoder);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DESTROY_VIDEO_DECODER_OUTPUT_VIEW:
+                {
+                    VBSVGA3dCmdDXDestroyVideoDecoderOutputView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDestroyVideoDecoderOutputView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DESTROY_VIDEO_PROCESSOR:
+                {
+                    VBSVGA3dCmdDXDestroyVideoProcessor cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDestroyVideoProcessor);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DESTROY_VIDEO_PROCESSOR_INPUT_VIEW:
+                {
+                    VBSVGA3dCmdDXDestroyVideoProcessorInputView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDestroyVideoProcessorInputView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_DESTROY_VIDEO_PROCESSOR_OUTPUT_VIEW:
+                {
+                    VBSVGA3dCmdDXDestroyVideoProcessorOutputView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXDestroyVideoProcessorOutputView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_TARGET_RECT:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetOutputTargetRect cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetOutputTargetRect);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_BACKGROUND_COLOR:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetOutputBackgroundColor cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetOutputBackgroundColor);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_COLOR_SPACE:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetOutputColorSpace cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetOutputColorSpace);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_ALPHA_FILL_MODE:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetOutputAlphaFillMode cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetOutputAlphaFillMode);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_CONSTRICTION:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetOutputConstriction cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetOutputConstriction);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_OUTPUT_STEREO_MODE:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetOutputStereoMode cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetOutputStereoMode);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_FRAME_FORMAT:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamFrameFormat cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamFrameFormat);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_COLOR_SPACE:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamColorSpace cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamColorSpace);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_OUTPUT_RATE:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamOutputRate cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamOutputRate);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_SOURCE_RECT:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamSourceRect cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamSourceRect);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_DEST_RECT:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamDestRect cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamDestRect);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_ALPHA:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamAlpha cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamAlpha);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_PALETTE:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamPalette cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamPalette);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_PIXEL_ASPECT_RATIO:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamPixelAspectRatio cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamPixelAspectRatio);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_LUMA_KEY:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamLumaKey cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamLumaKey);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_STEREO_FORMAT:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamStereoFormat cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamStereoFormat);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_AUTO_PROCESSING_MODE:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamAutoProcessingMode cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamAutoProcessingMode);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_FILTER:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamFilter cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamFilter);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_VIDEO_PROCESSOR_SET_STREAM_ROTATION:
+                {
+                    VBSVGA3dCmdDXVideoProcessorSetStreamRotation cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXVideoProcessorSetStreamRotation);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_GET_VIDEO_CAPABILITY:
+                {
+                    VBSVGA3dCmdDXGetVideoCapability cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXGetVideoCapability);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_CLEAR_RTV:
+                {
+                    VBSVGA3dCmdDXClearView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXClearView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_CLEAR_UAV:
+                {
+                    VBSVGA3dCmdDXClearView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXClearView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_CLEAR_VDOV:
+                {
+                    VBSVGA3dCmdDXClearView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXClearView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_CLEAR_VPIV:
+                {
+                    VBSVGA3dCmdDXClearView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXClearView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+
+            case VBSVGA_3D_CMD_DX_CLEAR_VPOV:
+                {
+                    VBSVGA3dCmdDXClearView cmd;
+                    uint32_t cmd_size = sizeof(VBSVGA3dCmdDXClearView);
+                    result = InternalCommandAlloc(fdp, total_length, pos, result, &cmd, cmd_size, cmdId, true);
+                    if (result == nullptr) return result;
+                    break;
+                }
+            default: 
+                continue;
+
+        }
+    }
+    commands_length = total_length;
+    return result;
+}
diff --git a/src/Fuzzing/DevVGA/dev_vga_fuzzer.h b/src/Fuzzing/DevVGA/dev_vga_fuzzer.h
new file mode 100644
index 00000000..46d1b493
--- /dev/null
+++ b/src/Fuzzing/DevVGA/dev_vga_fuzzer.h
@@ -0,0 +1,77 @@
+#ifndef DEV_VGA_FUZZER_H_
+#define DEV_VGA_FUZZER_H_
+
+#include <VBox/types.h>
+#include <VBox/vmm/pdmthread.h>
+#include <VBox/vmm/pdmsrv.h>
+#include <VBox/vmm/pdmdev.h>
+#include <VBoxVideo.h>
+#include <DevVGA.h>
+#include <DevVGA-SVGA3d.h>
+#include <DevVGA-SVGA-internal.h>
+#include <DevVGA-SVGA.h>
+#include <PDMInternal.h>
+#include <fuzzer/FuzzedDataProvider.h>
+
+typedef struct VGADeviceState {
+    PDMDEVINSR3 service_instance;
+    char padding[sizeof(VGASTATER3)];
+} VGADeviceState;
+
+enum class Operation {
+    kPIO,
+    kCommand,
+    kMaxValue
+};
+
+extern void ResetVGA(PPDMDEVINS pDevIns);
+
+class DevVGAFuzzer {
+    public:
+        DevVGAFuzzer() {
+           Init();
+        }
+        ~DevVGAFuzzer() {
+         ResetVGA(&device_state_.service_instance);
+         ResetCmdBufCtx();
+         if (svga_state_->apCmdBufCtxs[0] != nullptr) {
+             free(svga_state_->apCmdBufCtxs[0]);
+             svga_state_->apCmdBufCtxs[0] = nullptr;
+         }
+
+         if (svga_state_->apCmdBufCtxs[1] != nullptr) {
+             free(svga_state_->apCmdBufCtxs[1]);
+             svga_state_->apCmdBufCtxs[1] = nullptr;
+         }
+
+         free(ptr_vga_state_cc_->svga.pau32FIFO);
+         free(ptr_vga_state_cc_->pbVRam);
+         free(ptr_vga_state_cc_->pDrv);
+         free(p3dState_);
+
+         vmsvgaR3Destruct(&device_state_.service_instance);
+        }
+        void Init();
+        void Fuzz(const uint8_t *data, size_t size);
+        void InitCmdBufCtx();
+        void ResetCmdBufCtx();
+        FuzzedDataProvider* GetFdp();
+    private:
+        PDMTHREAD thread_;
+        PDMDEVHLPR3 noop_helper_;
+        struct VGAState vga_state_;
+        VMSVGAR3STATE *svga_state_;
+        VMSVGA3DBACKENDFUNCSGBO *pFuncsGBO_;
+        VGADeviceState device_state_;
+        PVGASTATER3 ptr_vga_state_cc_;
+
+        PVMSVGA3DSTATE p3dState_;
+        // Commands go here.
+        VMSVGACMDBUF *cmd_buf_;
+        std::unique_ptr<FuzzedDataProvider> fdp_;
+};
+
+extern DevVGAFuzzer *fuzzer;
+extern std::string *output_filename;
+
+#endif
diff --git a/src/Fuzzing/DevVGA/main.cpp b/src/Fuzzing/DevVGA/main.cpp
new file mode 100644
index 00000000..94649ca8
--- /dev/null
+++ b/src/Fuzzing/DevVGA/main.cpp
@@ -0,0 +1,379 @@
+#include <memory>
+#include <string>
+#include <fuzzer/FuzzedDataProvider.h>
+#include <sys/random.h>
+#include <iostream>
+#include <fstream>
+
+#include <iprt/list.h>
+#include <VBox/types.h>
+#include <VBox/vmm/pdmthread.h>
+#include <VBox/vmm/pdmsrv.h>
+#include <VBox/vmm/pdmdev.h>
+#include <VBoxVideo.h>
+#include <DevVGA.h>
+#include <DevVGA-SVGA3d.h>
+#include <DevVGA-SVGA3d-internal.h>
+#include <DevVGA-SVGA-internal.h>
+#include <DevVGA-SVGA.h>
+#include <PDMInternal.h>
+
+#include "dev_vga_fuzzer.h"
+#include "command_generator.h"
+#include "mock_driver.h"
+#include "mock_helper.h"
+
+uint32_t kPorts[] = {
+    SVGA_REG_ID ,
+    SVGA_REG_ENABLE ,
+    SVGA_REG_WIDTH ,
+    SVGA_REG_HEIGHT ,
+    SVGA_REG_MAX_WIDTH ,
+    SVGA_REG_MAX_HEIGHT ,
+    SVGA_REG_DEPTH ,
+    SVGA_REG_BITS_PER_PIXEL ,       /* Current bpp in the guest */
+    SVGA_REG_PSEUDOCOLOR ,
+    SVGA_REG_RED_MASK ,
+    SVGA_REG_GREEN_MASK ,
+    SVGA_REG_BLUE_MASK ,
+    SVGA_REG_BYTES_PER_LINE ,
+    SVGA_REG_FB_START ,            /* (Deprecated) */
+    SVGA_REG_FB_OFFSET ,
+    SVGA_REG_VRAM_SIZE ,
+    SVGA_REG_FB_SIZE ,
+
+    /* ID 0 implementation only had the above registers, then the palette */
+    SVGA_REG_ID_0_TOP ,
+
+    SVGA_REG_CAPABILITIES ,
+    SVGA_REG_MEM_START ,           /* (Deprecated) */
+    SVGA_REG_MEM_SIZE ,
+    SVGA_REG_CONFIG_DONE ,         /* Set when memory area configured */
+    SVGA_REG_SYNC ,                /* See "FIFO Synchronization Registers" */
+    SVGA_REG_BUSY ,                /* See "FIFO Synchronization Registers" */
+    SVGA_REG_GUEST_ID ,            /* (Deprecated) */
+    SVGA_REG_DEAD ,                /* Drivers should never write this. */
+    SVGA_REG_CURSOR_X ,            /* (Deprecated) */
+    SVGA_REG_CURSOR_Y ,            /* (Deprecated) */
+    SVGA_REG_CURSOR_ON ,           /* (Deprecated) */
+    SVGA_REG_HOST_BITS_PER_PIXEL , /* (Deprecated) */
+    SVGA_REG_SCRATCH_SIZE ,        /* Number of scratch registers */
+    SVGA_REG_MEM_REGS ,            /* Number of FIFO registers */
+    SVGA_REG_NUM_DISPLAYS ,        /* (Deprecated) */
+    SVGA_REG_PITCHLOCK ,           /* Fixed pitch for all modes */
+    SVGA_REG_IRQMASK ,             /* Interrupt mask */
+
+    /* Legacy multi-monitor support */
+    SVGA_REG_NUM_GUEST_DISPLAYS ,/* Number of guest displays in X/Y direction */
+    SVGA_REG_DISPLAY_ID ,        /* Display ID for the following display attributes */
+    SVGA_REG_DISPLAY_IS_PRIMARY ,/* Whether this is a primary display */
+    SVGA_REG_DISPLAY_POSITION_X ,/* The display position x */
+    SVGA_REG_DISPLAY_POSITION_Y ,/* The display position y */
+    SVGA_REG_DISPLAY_WIDTH ,     /* The display's width */
+    SVGA_REG_DISPLAY_HEIGHT ,    /* The display's height */
+
+    /* See "Guest memory regions" below. */
+    SVGA_REG_GMR_ID ,
+    SVGA_REG_GMR_DESCRIPTOR ,
+    SVGA_REG_GMR_MAX_IDS ,
+    SVGA_REG_GMR_MAX_DESCRIPTOR_LENGTH ,
+
+    SVGA_REG_TRACES ,            /* Enable trace-based updates even when FIFO is on */
+    SVGA_REG_GMRS_MAX_PAGES ,    /* Maximum number of 4KB pages for all GMRs */
+    SVGA_REG_MEMORY_SIZE ,       /* Total dedicated device memory excluding FIFO */
+    SVGA_REG_COMMAND_LOW ,       /* Lower 32 bits and submits commands */
+    SVGA_REG_COMMAND_HIGH ,      /* Upper 32 bits of command buffer PA */
+
+    /*
+     * Max primary memory.
+     * See SVGA_CAP_NO_BB_RESTRICTION.
+     */
+    SVGA_REG_MAX_PRIMARY_MEM ,
+    SVGA_REG_MAX_PRIMARY_BOUNDING_BOX_MEM ,
+
+    /*
+     * Legacy version of SVGA_REG_GBOBJECT_MEM_SIZE_KB for drivers that
+     * don't know how to convert to a 64-bit byte value without overflowing.
+     * (See SVGA_REG_GBOBJECT_MEM_SIZE_KB).
+     */
+    SVGA_REG_SUGGESTED_GBOBJECT_MEM_SIZE_KB ,
+
+    SVGA_REG_DEV_CAP ,           /* Write dev cap index, read value */
+    SVGA_REG_CMD_PREPEND_LOW ,
+    SVGA_REG_CMD_PREPEND_HIGH ,
+    SVGA_REG_SCREENTARGET_MAX_WIDTH ,
+    SVGA_REG_SCREENTARGET_MAX_HEIGHT ,
+    SVGA_REG_MOB_MAX_SIZE ,
+    SVGA_REG_BLANK_SCREEN_TARGETS ,
+    SVGA_REG_CAP2 ,
+    SVGA_REG_DEVEL_CAP ,
+
+    SVGA_REG_GUEST_DRIVER_ID ,
+    SVGA_REG_GUEST_DRIVER_VERSION1 ,
+    SVGA_REG_GUEST_DRIVER_VERSION2 ,
+    SVGA_REG_GUEST_DRIVER_VERSION3 ,
+    SVGA_REG_CURSOR_MOBID ,
+    SVGA_REG_CURSOR_MAX_BYTE_SIZE ,
+    SVGA_REG_CURSOR_MAX_DIMENSION ,
+
+    SVGA_REG_FIFO_CAPS ,
+    SVGA_REG_FENCE ,
+
+    SVGA_REG_RESERVED1 ,
+    SVGA_REG_RESERVED2 ,
+    SVGA_REG_RESERVED3 ,
+    SVGA_REG_RESERVED4 ,
+    SVGA_REG_RESERVED5 ,
+    SVGA_REG_SCREENDMA ,
+
+
+    SVGA_REG_GBOBJECT_MEM_SIZE_KB ,
+
+
+    SVGA_REG_REGS_START_HIGH32 ,
+    SVGA_REG_REGS_START_LOW32 ,
+    SVGA_REG_FB_START_HIGH32 ,
+    SVGA_REG_FB_START_LOW32 ,
+
+
+    SVGA_REG_MSHINT ,
+
+    SVGA_REG_IRQ_STATUS ,
+    SVGA_REG_DIRTY_TRACKING ,
+
+    SVGA_REG_TOP ,
+
+};
+
+void FuzzVGACmd(PPDMDEVINS pDevIns, PPDMTHREAD pThread);
+void FuzzVGAPio(PPDMDEVINS pDevIns, uint32_t port, uint32_t value);
+struct VGAState;
+
+
+void DevVGAFuzzer::Init() {
+    memset(&noop_helper_, 0, sizeof(PDMDEVHLPR3));
+    noop_helper_.pfnSUPSemEventSignal = &pfnSupSemEventSignalNoop;
+    noop_helper_.pfnPCIPhysWrite = &pfnPCIPhysWriteNoop;
+
+    noop_helper_.pfnCritSectEnter = &pfnCritSectEnterNoop;
+    noop_helper_.pfnCritSectLeave = &pfnCritSectLeaveNoop;
+    noop_helper_.pfnCritSectLeave = &pfnCritSectLeaveNoop;
+    noop_helper_.pfnPCISetIrq = &pfnPCISetIrqNoop;
+    noop_helper_.pfnThreadDestroy = &pfnThreadDestroyNoop;
+    noop_helper_.pfnMmio2ControlDirtyPageTracking = &pfnMmio2ControlDirtyPageTrackingNoop;
+    noop_helper_.pfnSUPSemEventClose = &pfnSUPSemEventCloseNoop;
+
+    // Read from the guest is the only one that is not actually noop but that
+    // feeds in random data.
+    noop_helper_.pfnPCIPhysRead = &pfnPCIPhysReadNoop;
+    noop_helper_.pfnPhysRead = &pfnPhysReadNoop;
+
+    noop_helper_.pfnPhysWrite = &pfnPhysWriteNoop;
+
+    thread_.enmState = PDMTHREADSTATE_RUNNING;
+    vga_state_.svga.fEnabled = true;
+    vga_state_.svga.f3DEnabled = true;
+    vga_state_.svga.fConfigured = true;
+    vga_state_.svga.cbFIFO = 2048;
+
+    memset(&device_state_, 0, sizeof(VGADeviceState));
+    svga_state_ = (VMSVGAR3STATE*)malloc(sizeof(VMSVGAR3STATE));
+    memset(svga_state_, 0, sizeof(VMSVGAR3STATE));
+    ptr_vga_state_cc_ = (PVGASTATER3) (void*)&device_state_.service_instance.achInstanceData[0];
+    ptr_vga_state_cc_->svga.pSvgaR3State = svga_state_;
+    ptr_vga_state_cc_->svga.pau32FIFO = (uint32_t*)malloc(vga_state_.svga.cbFIFO);
+    ptr_vga_state_cc_->svga.pFIFOIOThread = &thread_;
+
+    ptr_vga_state_cc_->svga.pbVgaFrameBufferR3 = (uint8_t*)malloc(VMSVGA_VGA_FB_BACKUP_SIZE);
+    ptr_vga_state_cc_->pbVRam = (uint8_t*)malloc(VMSVGA_VGA_FB_BACKUP_SIZE);
+
+
+    pFuncsGBO_ = (VMSVGA3DBACKENDFUNCSGBO *)malloc(sizeof(VMSVGA3DBACKENDFUNCSGBO));
+    pFuncsGBO_->pfnScreenTargetBind = &pfnScreenTargetBindNoop;
+    pFuncsGBO_->pfnScreenTargetUpdate = &pfnScreenTargetUpdateNoop;
+    svga_state_->pFuncsGBO = pFuncsGBO_;
+
+
+    struct PDMIDISPLAYCONNECTOR *mock_driver =  CreateDriver();
+    ptr_vga_state_cc_->pDrv = mock_driver;
+
+
+    p3dState_ = (PVMSVGA3DSTATE)malloc(sizeof(VMSVGA3DSTATE));
+    memset(p3dState_, 0, sizeof(VMSVGA3DSTATE));
+    ptr_vga_state_cc_->svga.p3dState = p3dState_; 
+
+
+    device_state_.service_instance.pvInstanceDataR3 = &vga_state_;
+    device_state_.service_instance.pHlpR3 = &noop_helper_;
+
+    // Setting up the command buffers.
+    svga_state_->apCmdBufCtxs[0] = nullptr;
+    svga_state_->apCmdBufCtxs[1] = nullptr;
+    InitCmdBufCtx();
+
+    memset(&svga_state_->CmdBufCtxDC, 0 , sizeof(VMSVGACMDBUFCTX));
+    svga_state_->CmdBufCtxDC.listSubmitted.pNext = &svga_state_->CmdBufCtxDC.listSubmitted;
+    svga_state_->CmdBufCtxDC.listSubmitted.pPrev = &svga_state_->CmdBufCtxDC.listSubmitted;
+    svga_state_->CmdBufCtxDC.cSubmitted = 0;
+
+    vmsvgaR3Reset(&device_state_.service_instance);
+
+}
+
+void DevVGAFuzzer::ResetCmdBufCtx() {
+    if (svga_state_->apCmdBufCtxs[0] != nullptr)  {
+        auto ptr = svga_state_->apCmdBufCtxs[0]->listSubmitted.pNext;
+        for(int i = 0; i < svga_state_->apCmdBufCtxs[0]->cSubmitted; i++) {
+            auto next = ptr->pNext;
+            free(ptr);
+            ptr = next;
+        }
+        free(svga_state_->apCmdBufCtxs[0]);
+        svga_state_->apCmdBufCtxs[0] = nullptr;
+    }
+    if (svga_state_->apCmdBufCtxs[1] != nullptr)  {
+        auto ptr = svga_state_->apCmdBufCtxs[1]->listSubmitted.pNext;
+        for(int i = 0; i < svga_state_->apCmdBufCtxs[1]->cSubmitted; i++) {
+            auto next = ptr->pNext;
+            free(((VMSVGACMDBUF*)ptr)->pvCommands);
+            free(ptr);
+            ptr = next;
+        }
+        free(svga_state_->apCmdBufCtxs[1]);
+        svga_state_->apCmdBufCtxs[1] = nullptr;
+    }
+    InitCmdBufCtx();
+}
+
+void DevVGAFuzzer::InitCmdBufCtx() {
+    if (svga_state_->apCmdBufCtxs[0] == nullptr) {
+        svga_state_->apCmdBufCtxs[0] = (VMSVGACMDBUFCTX*) malloc(sizeof(VMSVGACMDBUFCTX));
+        memset(svga_state_->apCmdBufCtxs[0], 0 , sizeof(VMSVGACMDBUFCTX));
+        svga_state_->apCmdBufCtxs[0]->listSubmitted.pNext = &svga_state_->apCmdBufCtxs[0]->listSubmitted;
+        svga_state_->apCmdBufCtxs[0]->listSubmitted.pPrev = &svga_state_->apCmdBufCtxs[0]->listSubmitted;
+        svga_state_->apCmdBufCtxs[0]->cSubmitted = 0;
+    }
+
+    if (svga_state_->apCmdBufCtxs[1] == nullptr) {
+        svga_state_->apCmdBufCtxs[1] = (VMSVGACMDBUFCTX*) malloc(sizeof(VMSVGACMDBUFCTX));
+        memset(svga_state_->apCmdBufCtxs[1], 0 , sizeof(VMSVGACMDBUFCTX));
+        svga_state_->apCmdBufCtxs[1]->listSubmitted.pNext = &svga_state_->apCmdBufCtxs[1]->listSubmitted;
+        svga_state_->apCmdBufCtxs[1]->listSubmitted.pPrev = &svga_state_->apCmdBufCtxs[1]->listSubmitted;
+        svga_state_->apCmdBufCtxs[1]->cSubmitted = 0;
+    }
+}
+
+
+FuzzedDataProvider* DevVGAFuzzer::GetFdp() {
+    return fdp_.get();
+}
+
+void DevVGAFuzzer::Fuzz(const uint8_t *data, size_t size) {
+    if (size == 0) {
+        return;
+    }
+
+    fdp_ = std::make_unique<FuzzedDataProvider>(data, size);
+
+    uint8_t operation_count = fdp_->ConsumeIntegralInRange<uint8_t>(1, 30);
+
+    while (operation_count > 0) {
+        operation_count--;
+        auto op =fdp_->ConsumeEnum<Operation>();
+        InitCmdBufCtx();
+
+        switch (op) {
+            case Operation::kPIO: {
+                                      uint32_t port = fdp_->ConsumeIntegral<uint32_t>() % (sizeof(kPorts)/sizeof(uint32_t));
+                                      port = kPorts[port];
+                                      uint32_t value = fdp_->ConsumeIntegral<uint32_t>();
+
+                                      /*
+                                      // Write the reproducer file:
+                                      // [4 byte operation kPIO] [ 4 byte port ] [4 byte value]
+                                      std::ofstream file(*output_filename, std::ios::binary | std::ios::app);
+                                      if (!file.is_open()) {
+                                          printf("could not open file, aborting fuzzer\n");
+                                          exit(-1);
+                                      }
+
+                                      file.write(reinterpret_cast<const char*>(&op), sizeof(int32_t));
+                                      file.write(reinterpret_cast<const char*>(&port), sizeof(int32_t));
+                                      file.write(reinterpret_cast<const char*>(&value), sizeof(int32_t));
+
+                                      file.close();
+                                      */
+
+                                      FuzzVGAPio(&device_state_.service_instance, port, value);
+
+                                      break;
+                                  }
+            case Operation::kCommand: {
+                                          ResetCmdBufCtx();
+                                          if( svga_state_->apCmdBufCtxs[0] == NULL) return;
+                                          cmd_buf_ = (VMSVGACMDBUF*)malloc(sizeof(VMSVGACMDBUF));
+                                          memset(cmd_buf_, 0, sizeof(VMSVGACMDBUF));
+
+                                          RTListAppend(&svga_state_->apCmdBufCtxs[0]->listSubmitted, &cmd_buf_->nodeBuffer);
+                                          svga_state_->apCmdBufCtxs[0]->cSubmitted++;
+
+                                          cmd_buf_->nodeBuffer.pPrev = &svga_state_->apCmdBufCtxs[0]->listSubmitted;
+                                          cmd_buf_->nodeBuffer.pNext = &svga_state_->apCmdBufCtxs[0]->listSubmitted;
+
+                                          uint32_t total_length = 0;
+                                          uint8_t *cmd_buf = AllocateRandomCommands(fdp_.get(), total_length);
+                                          if (cmd_buf == nullptr) {
+                                              free(cmd_buf_);
+                                              return;
+                                          }
+
+                                          /*
+
+                                          std::ofstream file(*output_filename, std::ios::binary | std::ios::app);
+                                          if (!file.is_open()) {
+                                              printf("could not open file, aborting fuzzer\n");
+                                              exit(-1);
+                                          }
+
+                                          file.write(reinterpret_cast<const char*>(&op), sizeof(int32_t));
+                                          file.write(reinterpret_cast<const char*>(&total_length), sizeof(int32_t));
+                                          file.write(reinterpret_cast<const char*>(cmd_buf), total_length);
+
+                                          file.close();
+                                          */
+
+                                          cmd_buf_->hdr.length = total_length;
+                                          cmd_buf_->pvCommands = cmd_buf;
+                                          FuzzVGACmd(&device_state_.service_instance, &thread_);
+                                          break;
+                                      }
+            default:
+                                      break;
+        }
+    }
+}
+
+DevVGAFuzzer *fuzzer = nullptr;
+std::string *output_filename = nullptr;
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+    //int main() {
+    if (fuzzer == nullptr)
+        fuzzer = new DevVGAFuzzer();
+    /*
+    if (output_filename == nullptr) {
+        output_filename = new std::string();
+        uint32_t rand;
+        getrandom(&rand, sizeof(uint32_t), 0);
+        char filename[32];
+        memset(filename, 0, 32);
+        sprintf(filename, "fuzzer-%u.input", rand);
+        *output_filename = filename;
+        printf("output file: %s\n", filename);
+    }
+    */
+    fuzzer->Fuzz(data,size);
+    delete fuzzer;
+    fuzzer = nullptr;
+    return 0;
+}
diff --git a/src/Fuzzing/DevVGA/mock_driver.h b/src/Fuzzing/DevVGA/mock_driver.h
new file mode 100644
index 00000000..e1edbf2d
--- /dev/null
+++ b/src/Fuzzing/DevVGA/mock_driver.h
@@ -0,0 +1,128 @@
+#include <VBox/vmm/pdmifs.h>
+
+#define NO_THROW __attribute__((nothrow))
+
+int pfnResizeMock(PPDMIDISPLAYCONNECTOR pInterface, uint32_t cBits, void *pvVRAM, uint32_t cbLine,
+                                         uint32_t cx, uint32_t cy) NO_THROW {
+    return 0;
+}
+
+
+void pfnUpdateRectMock(PPDMIDISPLAYCONNECTOR pInterface, uint32_t x, uint32_t y, uint32_t cx, uint32_t cy) NO_THROW {
+    return;
+}
+
+
+void pfnRefreshMock(PPDMIDISPLAYCONNECTOR pInterface) NO_THROW {
+    return;
+}
+
+
+void pfnResetMock(PPDMIDISPLAYCONNECTOR pInterface) NO_THROW {
+    return;
+}
+
+
+void pfnLFBModeChangeMock(PPDMIDISPLAYCONNECTOR pInterface, bool fEnabled) NO_THROW {
+    return;
+}
+
+
+void pfnProcessAdapterDataMock(PPDMIDISPLAYCONNECTOR pInterface, void *pvVRAM, uint32_t u32VRAMSize) NO_THROW {
+    return;
+}
+
+
+void pfnProcessDisplayDataMock(PPDMIDISPLAYCONNECTOR pInterface, void *pvVRAM, unsigned uScreenId) NO_THROW {
+    return;
+}
+
+
+int pfnVHWACommandProcessMock(PPDMIDISPLAYCONNECTOR pInterface, int enmCmd, bool fGuestCmd,
+                                                     VBOXVHWACMD RT_UNTRUSTED_VOLATILE_GUEST *pCmd) NO_THROW {
+    return 0;
+}
+
+
+int pfnVBVAEnableMock(PPDMIDISPLAYCONNECTOR pInterface, unsigned uScreenId,
+                                             struct VBVAHOSTFLAGS RT_UNTRUSTED_VOLATILE_GUEST *pHostFlags) NO_THROW {
+    return 0;
+}
+
+
+void pfnVBVADisableMock(PPDMIDISPLAYCONNECTOR pInterface, unsigned uScreenId) NO_THROW {
+    return;
+}
+
+void pfnVBVAUpdateBeginMock(PPDMIDISPLAYCONNECTOR pInterface, unsigned uScreenId) NO_THROW {
+    return;
+}
+
+
+void pfnVBVAUpdateProcessMock(PPDMIDISPLAYCONNECTOR pInterface, unsigned uScreenId,
+                                                     struct VBVACMDHDR const RT_UNTRUSTED_VOLATILE_GUEST *pCmd, size_t cbCmd) NO_THROW {
+    return;
+}
+
+
+void pfnVBVAUpdateEndMock(PPDMIDISPLAYCONNECTOR pInterface, unsigned uScreenId, int32_t x, int32_t y,
+                                                 uint32_t cx, uint32_t cy) NO_THROW {
+    return;
+}
+
+
+int pfnVBVAResizeMock(PPDMIDISPLAYCONNECTOR pInterface, PCVBVAINFOVIEW pView, PCVBVAINFOSCREEN pScreen,
+                                             void *pvVRAM, bool fResetInputMapping) NO_THROW {
+    return 0;
+}
+
+
+int pfnVBVAMousePointerShapeMock(PPDMIDISPLAYCONNECTOR pInterface, bool fVisible, bool fAlpha,
+                                                        uint32_t xHot, uint32_t yHot, uint32_t cx, uint32_t cy, const void *pvShape) NO_THROW {
+    return 0;
+}
+
+
+void pfnVBVAGuestCapabilityUpdateMock(PPDMIDISPLAYCONNECTOR pInterface, uint32_t fCapabilities) NO_THROW {
+    return;
+}
+
+
+void pfnVBVAInputMappingUpdateMock(PPDMIDISPLAYCONNECTOR pInterface, int32_t xOrigin, int32_t yOrigin, uint32_t cx, uint32_t cy) NO_THROW {
+    return;
+}
+
+
+void pfnVBVAReportCursorPositionMock(PPDMIDISPLAYCONNECTOR pInterface, uint32_t fFlags, uint32_t uScreen, uint32_t x, uint32_t y) NO_THROW {
+    return;
+}
+
+
+int pfn3DNotifyProcessMock(PPDMIDISPLAYCONNECTOR pInterface, VBOX3DNOTIFY *p3DNotify) NO_THROW {
+    return 0;
+}
+
+struct PDMIDISPLAYCONNECTOR* CreateDriver() {
+    struct PDMIDISPLAYCONNECTOR *res = (struct PDMIDISPLAYCONNECTOR*)malloc(sizeof(PDMIDISPLAYCONNECTOR));
+    memset(res, 0, sizeof(PDMIDISPLAYCONNECTOR));
+    res->pfnResize = &pfnResizeMock;
+    res->pfnUpdateRect = &pfnUpdateRectMock;
+    res->pfnRefresh = &pfnRefreshMock;
+    res->pfnReset = &pfnResetMock;
+    res->pfnLFBModeChange = &pfnLFBModeChangeMock;
+    res->pfnProcessAdapterData = &pfnProcessAdapterDataMock;
+    res->pfnProcessDisplayData = &pfnProcessDisplayDataMock;
+    res->pfnVHWACommandProcess = &pfnVHWACommandProcessMock;
+    res->pfnVBVAEnable = &pfnVBVAEnableMock;
+    res->pfnVBVADisable = &pfnVBVADisableMock;
+    res->pfnVBVAUpdateBegin = &pfnVBVAUpdateBeginMock;
+    res->pfnVBVAUpdateProcess = &pfnVBVAUpdateProcessMock;
+    res->pfnVBVAUpdateEnd = &pfnVBVAUpdateEndMock;
+    res->pfnVBVAResize = &pfnVBVAResizeMock;
+    res->pfnVBVAMousePointerShape = &pfnVBVAMousePointerShapeMock;
+    res->pfnVBVAGuestCapabilityUpdate = &pfnVBVAGuestCapabilityUpdateMock;
+    res->pfnVBVAInputMappingUpdate = &pfnVBVAInputMappingUpdateMock;
+    res->pfnVBVAReportCursorPosition = &pfnVBVAReportCursorPositionMock;
+    res->pfn3DNotifyProcess = &pfn3DNotifyProcessMock;
+    return res;
+}
diff --git a/src/Fuzzing/DevVGA/mock_helper.h b/src/Fuzzing/DevVGA/mock_helper.h
new file mode 100644
index 00000000..611ff1bc
--- /dev/null
+++ b/src/Fuzzing/DevVGA/mock_helper.h
@@ -0,0 +1,81 @@
+#ifndef MOCK_HELPER_H_
+#define MOCK_HELPER_H_
+
+#include <vector>
+
+#include "dev_vga_fuzzer.h"
+
+#define NO_THROW __attribute__((nothrow))
+
+
+int pfnThreadDestroyNoop(PPDMTHREAD pThread, int *pRcThread) NO_THROW {
+    return 0;
+}
+
+int pfnMmio2ControlDirtyPageTrackingNoop(PPDMDEVINS pDevIns, PGMMMIO2HANDLE hRegion, bool fEnabled) NO_THROW {
+    return 0;
+}
+
+int pfnPCIPhysReadNoop(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev, RTGCPHYS GCPhys, void *pvBuf, size_t cbRead, uint32_t fFlags) NO_THROW {
+   // For this one not actually make a noop but plug in random data from the fuzzer.
+   if (fuzzer == nullptr) {
+       return 0;
+   }
+   std::vector<uint8_t> bytes = fuzzer->GetFdp()->ConsumeBytes<uint8_t>(cbRead);
+   if (bytes.size() == 0) return 0;
+   memcpy(pvBuf, bytes.data(), bytes.size());
+   return 0;
+}
+
+
+int pfnPhysReadNoop(PPDMDEVINS pDevIns, RTGCPHYS GCPhys, void *pvBuf, size_t cbRead, uint32_t fFlags) NO_THROW {
+   // For this one not actually make a noop but plug in random data from the fuzzer.
+   if (fuzzer == nullptr) {
+       return 0;
+   }
+   std::vector<uint8_t> bytes = fuzzer->GetFdp()->ConsumeBytes<uint8_t>(cbRead);
+   if (bytes.size() == 0) return 0;
+   memcpy(pvBuf, bytes.data(), bytes.size());
+   return 0;
+}
+
+
+int pfnPhysWriteNoop(PPDMDEVINS pDevIns, RTGCPHYS GCPhys, const void *pvBuf, size_t cbWrite, uint32_t fFlags) NO_THROW {
+    return 0;
+}
+
+int pfnSupSemEventSignalNoop(PPDMDEVINS pDevIns, SUPSEMEVENT hEvent) NO_THROW {
+    return 0;
+}
+
+int pfnPCIPhysWriteNoop(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev, RTGCPHYS GCPhys, const void *pvBuf, size_t cbWrite, uint32_t fFlags) NO_THROW {
+    return 0;
+}
+
+int pfnCritSectEnterNoop(PPDMDEVINS pDevIns, PPDMCRITSECT pCritSect, int rcBusy) NO_THROW {
+    return 0;
+}
+
+int pfnCritSectLeaveNoop(PPDMDEVINS pDevIns, PPDMCRITSECT pCritSect) NO_THROW {
+    return 0;
+}
+
+
+void pfnPCISetIrqNoop(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev, int iIrq, int iLevel) NO_THROW {
+    return;
+}
+
+
+int pfnSUPSemEventCloseNoop(PPDMDEVINS pDevIns, SUPSEMEVENT hEvent) NO_THROW {
+    return 0;
+}
+
+
+int pfnScreenTargetBindNoop(PVGASTATECC pThisCC, VMSVGASCREENOBJECT *pScreen, uint32_t sid) NO_THROW {
+    return 0;
+}
+int pfnScreenTargetUpdateNoop(PVGASTATECC pThisCC, VMSVGASCREENOBJECT *pScreen, SVGA3dRect const *pRect) NO_THROW {
+    return 0;
+}
+
+#endif
diff --git a/src/Fuzzing/test.cpp b/src/Fuzzing/test.cpp
new file mode 100644
index 00000000..4ece772c
--- /dev/null
+++ b/src/Fuzzing/test.cpp
@@ -0,0 +1,18 @@
+#include <stdio.h>
+#include <stdint.h>
+
+#include <VBox/types.h>
+#include <VBox/vmm/pdmthread.h>
+#include <VBox/vmm/pdmsrv.h>
+#include <VBox/vmm/pdmdev.h>
+#include <VBoxVideo.h>
+#include <DevVGA.h>
+#include <PDMInternal.h>
+
+extern void FuzzCmdBufLoop(PPDMDEVINS pDevIns, PPDMTHREAD pThread);
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size){
+    FuzzCmdBufLoop(nullptr, nullptr);
+    printf("hello world\n");
+    return 0;
+}
diff --git a/src/Makefile.kmk b/src/Makefile.kmk
index f526aa15..950fe65f 100644
--- a/src/Makefile.kmk
+++ b/src/Makefile.kmk
@@ -28,6 +28,7 @@
 SUB_DEPTH = ..
 include $(KBUILD_PATH)/subheader.kmk
 
+include $(PATH_SUB_CURRENT)/Fuzzing/DevVGA/Makefile.kmk
 include $(PATH_SUB_CURRENT)/bldprogs/Makefile.kmk
 include $(PATH_SUB_CURRENT)/VBox/Makefile.kmk
 if !defined(VBOX_ONLY_SDK) || "$(KBUILD_TARGET)" != "win"
diff --git a/src/VBox/Devices/Graphics/.DevVGA-SVGA3d.cpp.swp b/src/VBox/Devices/Graphics/.DevVGA-SVGA3d.cpp.swp
new file mode 100644
index 00000000..0bd559d1
Binary files /dev/null and b/src/VBox/Devices/Graphics/.DevVGA-SVGA3d.cpp.swp differ
diff --git a/src/VBox/Devices/Graphics/DevVGA-SVGA-cmd.cpp b/src/VBox/Devices/Graphics/DevVGA-SVGA-cmd.cpp
index 9a71a6c7..ccf860b7 100644
--- a/src/VBox/Devices/Graphics/DevVGA-SVGA-cmd.cpp
+++ b/src/VBox/Devices/Graphics/DevVGA-SVGA-cmd.cpp
@@ -441,6 +441,10 @@ static int vmsvgaR3GboCreate(PVMSVGAR3STATE pSvgaR3State, SVGAMobFormat ptDepth,
     pGbo->cTotalPages = (sizeInBytes + X86_PAGE_SIZE - 1) >> X86_PAGE_SHIFT;
 
     /* Allocate the maximum amount possible (everything non-continuous) */
+#ifdef MOONSHINE_FUZZING
+    // BUG BUG BUG HERE!!!
+if (pGbo->cTotalPages == 0) return VERR_INVALID_PARAMETER;
+#endif
     PVMSVGAGBODESCRIPTOR paDescriptors = (PVMSVGAGBODESCRIPTOR)RTMemAlloc(pGbo->cTotalPages * sizeof(VMSVGAGBODESCRIPTOR));
     AssertReturn(paDescriptors, VERR_NO_MEMORY);
 
@@ -1701,6 +1705,10 @@ static int vmsvgaR3TransferSurfaceLevel(PVGASTATECC pThisCC,
         rc = vmsvga3dGetBoxDimensions(pThisCC, pImage, pBox, &dims);
         if (RT_SUCCESS(rc))
         {
+#ifdef MOONSHINE_FUZZING
+            // avoid hanging
+            if (map.box.d > 0x1000) return 0;
+#endif
             for (uint32_t z = 0; z < map.box.d; ++z)
             {
                 uint8_t *pu8Map = (uint8_t *)map.pvData + z * map.cbDepthPitch;
@@ -1785,6 +1793,11 @@ static void vmsvga3dCmdUpdateGBSurface(PVGASTATECC pThisCC, SVGA3dCmdUpdateGBSur
     SVGAOTableSurfaceEntry entrySurface;
     int rc = vmsvgaR3OTableRead(pSvgaR3State, &pSvgaR3State->aGboOTables[SVGA_OTABLE_SURFACE],
                             pCmd->sid, SVGA3D_OTABLE_SURFACE_ENTRY_SIZE, &entrySurface, sizeof(entrySurface));
+#ifdef MOONSHINE_FUZZING
+    // To avoid this hanging...
+    if (entrySurface.numMipLevels > 1024) return;
+#endif
+
     if (RT_SUCCESS(rc))
     {
         PVMSVGAMOB pMob = vmsvgaR3MobGet(pSvgaR3State, entrySurface.mobid);
@@ -1847,6 +1860,11 @@ static void vmsvga3dCmdReadbackGBSurface(PVGASTATECC pThisCC, SVGA3dCmdReadbackG
     SVGAOTableSurfaceEntry entrySurface;
     int rc = vmsvgaR3OTableRead(pSvgaR3State, &pSvgaR3State->aGboOTables[SVGA_OTABLE_SURFACE],
                             pCmd->sid, SVGA3D_OTABLE_SURFACE_ENTRY_SIZE, &entrySurface, sizeof(entrySurface));
+
+#ifdef MOONSHINE_FUZZING
+    // To avoid this hanging...
+    if (entrySurface.numMipLevels > 1024) return;
+#endif
     if (RT_SUCCESS(rc))
     {
         PVMSVGAMOB pMob = vmsvgaR3MobGet(pSvgaR3State, entrySurface.mobid);
diff --git a/src/VBox/Devices/Graphics/DevVGA-SVGA.cpp b/src/VBox/Devices/Graphics/DevVGA-SVGA.cpp
index fa467164..adcbcf24 100644
--- a/src/VBox/Devices/Graphics/DevVGA-SVGA.cpp
+++ b/src/VBox/Devices/Graphics/DevVGA-SVGA.cpp
@@ -188,6 +188,10 @@
 #include "DevVGA-SVGA-internal.h"
 #endif
 
+#ifdef MOONSHINE_FUZZING
+#define VBOXDD_EXPORT __attribute__((visibility("default")))
+#endif
+
 
 /*********************************************************************************************************************************
 *   Defined Constants And Macros                                                                                                 *
@@ -3372,9 +3376,13 @@ static SVGACBStatus vmsvgaR3CmdBufDCPreempt(PPDMDEVINS pDevIns, PVMSVGAR3STATE p
     /* Remove buffers from the processing queue of the specified context. */
     if (pCmd->context >= RT_ELEMENTS(pSvgaR3State->apCmdBufCtxs))
         return SVGA_CB_STATUS_COMMAND_ERROR;
+
     RT_UNTRUSTED_VALIDATED_FENCE();
 
     PVMSVGACMDBUFCTX const pCmdBufCtx = pSvgaR3State->apCmdBufCtxs[pCmd->context];
+
+    if (pCmdBufCtx == nullptr)
+        return SVGA_CB_STATUS_COMMAND_ERROR;
     RTLISTANCHOR listPreempted;
 
     int rc = RTCritSectEnter(&pSvgaR3State->CritSectCmdBuf);
@@ -3753,6 +3761,10 @@ static SVGACBStatus vmsvgaR3CmdBufProcessCommands(PPDMDEVINS pDevIns, PVGASTATE
         uint32_t const cmdId = *(uint32_t *)pu8Cmd;
         uint32_t cbCmd = sizeof(uint32_t);
 
+#ifdef MOONSHINE_FUZZING
+        if (cbCmd == 0) break;
+#endif
+
         LogFlowFunc(("[cid=%d] %s %u\n", (int32_t)idDXContext, vmsvgaR3FifoCmdToString(cmdId), cmdId));
 # ifdef LOG_ENABLED
 #  ifdef VBOX_WITH_VMSVGA3D
@@ -3760,7 +3772,7 @@ static SVGACBStatus vmsvgaR3CmdBufProcessCommands(PPDMDEVINS pDevIns, PVGASTATE
             || (cmdId >= VBSVGA_3D_CMD_BASE && cmdId < VBSVGA_3D_CMD_MAX))
         {
             SVGA3dCmdHeader const *header = (SVGA3dCmdHeader *)pu8Cmd;
-            svga_dump_command(cmdId, (uint8_t *)&header[1], header->size);
+            //svga_dump_command(cmdId, (uint8_t *)&header[1], header->size);
         }
         else if (cmdId == SVGA_CMD_FENCE)
         {
@@ -4120,6 +4132,10 @@ static SVGACBStatus vmsvgaR3CmdBufProcessCommands(PPDMDEVINS pDevIns, PVGASTATE
         if (CBstatus != SVGA_CB_STATUS_COMPLETED)
             break;
 
+
+#ifdef MOONSHINE_FUZZING
+        if (cbCmd == 0) break;
+#endif
         pu8Cmd += cbCmd;
         cbRemain -= cbCmd;
 
@@ -5564,6 +5580,30 @@ static DECLCALLBACK(int) vmsvgaR3CmdBufLoop(PPDMDEVINS pDevIns, PPDMTHREAD pThre
     return VINF_SUCCESS;
 }
 
+#ifdef MOONSHINE_FUZZING
+static int vmsvgaR3StateInit(PPDMDEVINS pDevIns, PVGASTATE pThis, PVMSVGAR3STATE pSVGAState);
+VBOXDD_EXPORT void FuzzVGACmd(PPDMDEVINS pDevIns, PPDMTHREAD pThread) {
+    PVGASTATE       pThis      = PDMDEVINS_2_DATA(pDevIns, PVGASTATE);
+    PVGASTATER3     pThisCC    = PDMDEVINS_2_DATA_CC(pDevIns, PVGASTATECC);
+    PVMSVGAR3STATE  pSVGAState = pThisCC->svga.pSvgaR3State;
+    vmsvgaR3CmdBufProcessBuffers(pDevIns, pThis, pThisCC, pThread);
+}
+
+VBOXDD_EXPORT void FuzzVGAPio(PPDMDEVINS pDevIns, uint32_t port, uint32_t value) {
+    PVGASTATE       pThis      = PDMDEVINS_2_DATA(pDevIns, PVGASTATE);
+    PVGASTATER3     pThisCC    = PDMDEVINS_2_DATA_CC(pDevIns, PVGASTATECC);
+    vmsvgaWritePort(pDevIns, pThis, pThisCC, port, value);
+}
+
+VBOXDD_EXPORT void ResetVGA(PPDMDEVINS pDevIns) {
+    PVGASTATE       pThis      = PDMDEVINS_2_DATA(pDevIns, PVGASTATE);
+    PVGASTATER3     pThisCC    = PDMDEVINS_2_DATA_CC(pDevIns, PVGASTATECC);
+    vmsvgaR3ResetSvgaState(pThis,pThisCC);
+}
+
+
+#endif
+
 
 /**
  * @callback_method_impl{PFNPDMTHREADWAKEUPDEV,
@@ -7166,7 +7206,7 @@ static void vmsvgaR3InitFIFO3D(PVGASTATE pThis, PVGASTATECC pThisCC)
  * @returns VBox status code.
  * @param   pDevIns     The device instance.
  */
-int vmsvgaR3Reset(PPDMDEVINS pDevIns)
+VBOXDD_EXPORT int vmsvgaR3Reset(PPDMDEVINS pDevIns)
 {
     PVGASTATE       pThis      = PDMDEVINS_2_DATA(pDevIns, PVGASTATE);
     PVGASTATECC     pThisCC    = PDMDEVINS_2_DATA_CC(pDevIns, PVGASTATECC);
@@ -7238,7 +7278,7 @@ int vmsvgaR3Reset(PPDMDEVINS pDevIns)
  * @returns VBox status code.
  * @param   pDevIns     The device instance.
  */
-int vmsvgaR3Destruct(PPDMDEVINS pDevIns)
+VBOXDD_EXPORT int vmsvgaR3Destruct(PPDMDEVINS pDevIns)
 {
     PVGASTATE   pThis   = PDMDEVINS_2_DATA(pDevIns, PVGASTATE);
     PVGASTATECC pThisCC = PDMDEVINS_2_DATA_CC(pDevIns, PVGASTATECC);
diff --git a/src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp b/src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp
index ef3a7246..aa0ba11c 100644
--- a/src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp
+++ b/src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp
@@ -92,6 +92,99 @@ static void *MyNSGLGetProcAddress(const char *pszSymbol)
 
 #else
 # define OGLGETPROCADDRESS MyGLXGetProcAddress
+#ifdef MOONSHINE_FUZZING
+static uintptr_t* MyGLXGetProcAddress(const char *pszSymbol)
+{
+    int rc;
+
+    static RTLDRMOD s_hGL = NULL;
+    if (s_hGL == NULL)
+    {
+        static const char s_szLibGL[] = "libGL.so.1";
+        rc = RTLdrLoadEx(s_szLibGL, &s_hGL, RTLDRLOAD_FLAGS_GLOBAL | RTLDRLOAD_FLAGS_NO_UNLOAD, NULL);
+        if (RT_FAILURE(rc))
+        {
+            LogRel(("VMSVGA3d: failed to load %s: %Rrc\n", s_szLibGL, rc));
+            s_hGL = NULL;
+            return NULL;
+        }
+    }
+
+    typedef PFNRT (* PFNGLXGETPROCADDRESS)(const GLubyte * procName);
+    static PFNGLXGETPROCADDRESS s_glXGetProcAddress = NULL;
+    if (s_glXGetProcAddress == NULL)
+    {
+        rc = RTLdrGetSymbol(s_hGL, "glXGetProcAddress", (void **)&s_glXGetProcAddress);
+        if (RT_FAILURE(rc))
+        {
+            LogRel(("VMSVGA3d: failed to get glXGetProcAddress: %Rrc\n", rc));
+            s_glXGetProcAddress = NULL;
+            return NULL;
+        }
+    }
+
+    PFNRT p = s_glXGetProcAddress((const GLubyte *)pszSymbol);
+    if (RT_VALID_PTR(p))
+        return reinterpret_cast<uintptr_t*>(p);
+
+    /* Might be an exported symbol. */
+    rc = RTLdrGetSymbol(s_hGL, pszSymbol, (void **)&p);
+    if (RT_SUCCESS(rc))
+        return reinterpret_cast<uintptr_t*>(p);
+
+    return NULL;
+}
+
+static uintptr_t* MyX11GetProcAddress(const char *pszSymbol)
+{
+    int rc;
+
+    static RTLDRMOD s_hX11 = NULL;
+    if (s_hX11 == NULL)
+    {
+        static const char s_szLibX11[] = "libX11.so.6";
+        rc = RTLdrLoadEx(s_szLibX11, &s_hX11, RTLDRLOAD_FLAGS_LOCAL | RTLDRLOAD_FLAGS_NO_UNLOAD, NULL);
+        if (RT_FAILURE(rc))
+        {
+            LogRel(("VMSVGA3d: failed to load %s: %Rrc\n", s_szLibX11, rc));
+            s_hX11 = NULL;
+            return NULL;
+        }
+    }
+
+    PFNRT p = NULL;
+    rc = RTLdrGetSymbol(s_hX11, pszSymbol, (void **)&p);
+    if (RT_SUCCESS(rc))
+        return reinterpret_cast<uintptr_t*>(p);
+
+    return NULL;
+}
+
+#define X11GETPROC_(ProcName) do { \
+    *(uintptr_t **)&pfn_##ProcName  = MyX11GetProcAddress(#ProcName); \
+    pfnRet = reinterpret_cast<PFNRT>(pfn_##ProcName); \
+    if (pfnRet) { /* likely */ } \
+    else \
+    { \
+        AssertLogRelMsg(pfnRet, ("%s missing\n", #ProcName)); \
+        return PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, \
+                                   "Missing libX11 symbol '%s'\n", #ProcName); \
+    } \
+} while(0)
+
+#define GLGETPROC_(ProcName, NameSuffix) do { \
+    *(uintptr_t **)&pfn_##ProcName  = OGLGETPROCADDRESS(#ProcName); \
+    pfnRet = reinterpret_cast<PFNRT>(pfn_##ProcName); \
+    if (pfnRet) { /* likely */ } \
+    else \
+    { \
+        AssertLogRelMsg(pfnRet, ("%s missing\n", #ProcName NameSuffix)); \
+        return PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, \
+                                   "Missing OpenGL symbol '%s'\n", #ProcName NameSuffix); \
+    } \
+} while(0)
+
+#else
 static PFNRT MyGLXGetProcAddress(const char *pszSymbol)
 {
     int rc;
@@ -133,7 +226,6 @@ static PFNRT MyGLXGetProcAddress(const char *pszSymbol)
 
     return NULL;
 }
-
 static PFNRT MyX11GetProcAddress(const char *pszSymbol)
 {
     int rc;
@@ -169,7 +261,8 @@ static PFNRT MyX11GetProcAddress(const char *pszSymbol)
                                    "Missing libX11 symbol '%s'\n", #ProcName); \
     } \
 } while(0)
-#endif
+
+
 
 #define GLGETPROC_(ProcName, NameSuffix) do { \
     *(PFNRT *)&pfn_##ProcName = pfnRet = OGLGETPROCADDRESS(#ProcName NameSuffix); \
@@ -182,6 +275,11 @@ static PFNRT MyX11GetProcAddress(const char *pszSymbol)
     } \
 } while(0)
 
+#endif
+
+#endif
+
+
 int glLdrInit(PPDMDEVINS pDevIns)
 {
     /** @todo r=bird: Perhaps make this template include file driven? See
@@ -415,7 +513,11 @@ int glLdrInit(PPDMDEVINS pDevIns)
 
 PFNRT glLdrGetProcAddress(const char *pszSymbol)
 {
+#ifdef MOONSHINE_FUZZING
+    return reinterpret_cast<PFNRT>(OGLGETPROCADDRESS(pszSymbol));
+#else
     return OGLGETPROCADDRESS(pszSymbol);
+#endif
 }
 
 int glLdrGetExtFunctions(PPDMDEVINS pDevIns)
diff --git a/src/VBox/Devices/Graphics/DevVGA-SVGA3d.cpp b/src/VBox/Devices/Graphics/DevVGA-SVGA3d.cpp
index 9b53b11a..d3e8e276 100644
--- a/src/VBox/Devices/Graphics/DevVGA-SVGA3d.cpp
+++ b/src/VBox/Devices/Graphics/DevVGA-SVGA3d.cpp
@@ -267,7 +267,14 @@ int vmsvga3dSurfaceDefine(PVGASTATECC pThisCC, uint32_t sid, SVGA3dSurfaceAllFla
             vmsvga3dSurfaceMipBufferSize(format, mipmapSize, pSurface->surfaceDesc.multisampleCount,
                                          &cBlocksX, &cBlocksY, &cbSurfacePitch, &cbSurfacePlane, &cbSurface);
             AssertBreakStmt(cbMemRemaining >= cbSurface, rc = VERR_INVALID_PARAMETER);
-
+#ifdef MOONSHINE_FUZZING
+            // BUG BUG BUG
+            AssertBreakStmt(cbSurface > 0, rc = VERR_INVALID_PARAMETER);
+            if (cbSurface == 0 ) {
+                rc = VERR_INVALID_PARAMETER;
+                return rc;
+            }
+#endif
             PVMSVGA3DMIPMAPLEVEL pMipmapLevel = &pSurface->paMipmapLevels[iMipmap];
             pMipmapLevel->mipmapSize     = mipmapSize;
             pMipmapLevel->cBlocksX       = cBlocksX;
@@ -276,6 +283,7 @@ int vmsvga3dSurfaceDefine(PVGASTATECC pThisCC, uint32_t sid, SVGA3dSurfaceAllFla
             pMipmapLevel->cbSurfacePitch = cbSurfacePitch;
             pMipmapLevel->cbSurfacePlane = cbSurfacePlane;
             pMipmapLevel->cbSurface      = cbSurface;
+
             pMipmapLevel->pSurfaceData   = NULL;
 
             cbMemRemaining -= cbSurface;
@@ -938,6 +946,7 @@ int vmsvga3dSurfaceBlitToScreen(PVGASTATE pThis, PVGASTATECC pThisCC, uint32_t i
                                 SVGA3dSurfaceImageId srcImage, SVGASignedRect srcRect, uint32_t cRects, SVGASignedRect *pRect)
 {
     /* Requires SVGA_FIFO_CAP_SCREEN_OBJECT support */
+#ifndef MOONSHINE_FUZZING
     LogFunc(("dest=%d (%d,%d)(%d,%d) sid=%u (face=%d, mipmap=%d) (%d,%d)(%d,%d) cRects=%d\n",
              idDstScreen, destRect.left, destRect.top, destRect.right, destRect.bottom, srcImage.sid, srcImage.face, srcImage.mipmap,
              srcRect.left, srcRect.top, srcRect.right, srcRect.bottom, cRects));
@@ -946,6 +955,7 @@ int vmsvga3dSurfaceBlitToScreen(PVGASTATE pThis, PVGASTATECC pThisCC, uint32_t i
         LogFunc(("clipping rect[%d] (%d,%d)(%d,%d)\n", i, pRect[i].left, pRect[i].top, pRect[i].right, pRect[i].bottom));
     }
 
+#endif
     VMSVGASCREENOBJECT *pScreen = vmsvgaR3GetScreenObject(pThisCC, idDstScreen);
     AssertReturn(pScreen, VERR_INTERNAL_ERROR);
 
diff --git a/src/VBox/Devices/Graphics/DevVGA-SVGA3d.h b/src/VBox/Devices/Graphics/DevVGA-SVGA3d.h
index a0e2da3c..b277eb10 100644
--- a/src/VBox/Devices/Graphics/DevVGA-SVGA3d.h
+++ b/src/VBox/Devices/Graphics/DevVGA-SVGA3d.h
@@ -134,10 +134,17 @@ int vmsvga3dChangeMode(PVGASTATECC pThisCC);
 int vmsvga3dDefineScreen(PVGASTATE pThis, PVGASTATECC pThisCC, VMSVGASCREENOBJECT *pScreen);
 int vmsvga3dDestroyScreen(PVGASTATECC pThisCC, VMSVGASCREENOBJECT *pScreen);
 
+#ifdef MOONSHINE_FUZZING
+int vmsvga3dScreenUpdate(PVGASTATECC pThisCC, uint32_t idDstScreen, const SVGASignedRect& dstRect,
+                         const SVGA3dSurfaceImageId& srcImage, const SVGASignedRect& srcRect,
+                         uint32_t cDstClipRects, SVGASignedRect *paDstClipRect);
+#else
 int vmsvga3dScreenUpdate(PVGASTATECC pThisCC, uint32_t idDstScreen, SVGASignedRect const &dstRect,
                          SVGA3dSurfaceImageId const &srcImage, SVGASignedRect const &srcRect,
                          uint32_t cDstClipRects, SVGASignedRect *paDstClipRect);
 
+#endif
+
 int vmsvga3dSetTransform(PVGASTATECC pThisCC, uint32_t cid, SVGA3dTransformType type, float matrix[16]);
 int vmsvga3dSetZRange(PVGASTATECC pThisCC, uint32_t cid, SVGA3dZRange zRange);
 int vmsvga3dSetRenderState(PVGASTATECC pThisCC, uint32_t cid, uint32_t cRenderStates, SVGA3dRenderState *pRenderState);
diff --git a/src/VBox/Devices/Graphics/DevVGA.h b/src/VBox/Devices/Graphics/DevVGA.h
index 58c80568..1add3f28 100644
--- a/src/VBox/Devices/Graphics/DevVGA.h
+++ b/src/VBox/Devices/Graphics/DevVGA.h
@@ -265,7 +265,6 @@ typedef struct vga_retrace_s {
 /* bird: Since we've changed types, reordered members, done alignment
          paddings and more, VGA_STATE_COMMON was added directly to the
          struct to make it more readable and easier to handle. */
-
 struct VGAState;
 typedef int FNGETBPP(struct VGAState *s);
 typedef void FNGETOFFSETS(struct VGAState *s, uint32_t *pline_offset, uint32_t *pstart_addr, uint32_t *pline_compare);
@@ -290,7 +289,6 @@ typedef struct _VBOX_VHWA_PENDINGCMD
 } VBOX_VHWA_PENDINGCMD;
 #endif
 
-
 /**
  * The shared VGA state data.
  */
@@ -764,7 +762,7 @@ int vboxVDMASaveLoadDone(struct VBOXVDMAHOST *pVdma);
 # ifdef VBOX_WITH_VMSVGA
 int vgaR3UnregisterVRAMHandler(PPDMDEVINS pDevIns, PVGASTATE pThis);
 int vgaR3RegisterVRAMHandler(PPDMDEVINS pDevIns, PVGASTATE pThis, uint64_t cbFrameBuffer);
-int vgaR3UpdateDisplay(PVGASTATE pThis, unsigned xStart, unsigned yStart, unsigned width, unsigned height);
+//int vgaR3UpdateDisplay(PVGASTATE pThis, unsigned xStart, unsigned yStart, unsigned width, unsigned height);
 # endif
 
 #ifndef VBOX
diff --git a/src/VBox/Devices/Graphics/HGSMI/HGSMIHost.cpp b/src/VBox/Devices/Graphics/HGSMI/HGSMIHost.cpp
index db07422a..3c86c3b6 100644
--- a/src/VBox/Devices/Graphics/HGSMI/HGSMIHost.cpp
+++ b/src/VBox/Devices/Graphics/HGSMI/HGSMIHost.cpp
@@ -1310,6 +1310,15 @@ DECLHIDDEN(int) HGSMIHostLoadStateExec(PCPDMDEVHLPR3 pHlp, PHGSMIINSTANCE pIns,
                     Assert(!pIns->hostHeap.cRefs);
                     pIns->hostHeap.cRefs = 0;
 
+#ifdef MOONSHINE_FUZZING
+                    rc = hgsmiHostHeapRelocate(&pIns->hostHeap,
+                                               u32HeapType,
+                                               pIns->area.pu8Base+offHeap,
+                                               off,
+                                               (uintptr_t)(pIns->area.pu8Base) - (uintptr_t)(oldMem),
+                                               cbHeap,
+                                               offHeap);
+#else
                     rc = hgsmiHostHeapRelocate(&pIns->hostHeap,
                                                u32HeapType,
                                                pIns->area.pu8Base+offHeap,
@@ -1317,6 +1326,7 @@ DECLHIDDEN(int) HGSMIHostLoadStateExec(PCPDMDEVHLPR3 pHlp, PHGSMIINSTANCE pIns,
                                                uintptr_t(pIns->area.pu8Base) - uintptr_t(oldMem),
                                                cbHeap,
                                                offHeap);
+#endif
 
                     hgsmiHostHeapUnlock(pIns);
                 }
diff --git a/src/VBox/Devices/Graphics/HGSMI/HGSMIHost.h b/src/VBox/Devices/Graphics/HGSMI/HGSMIHost.h
index 35179bfe..976101b6 100644
--- a/src/VBox/Devices/Graphics/HGSMI/HGSMIHost.h
+++ b/src/VBox/Devices/Graphics/HGSMI/HGSMIHost.h
@@ -94,7 +94,7 @@ DECLHIDDEN(HGSMIOFFSET) HGSMIHostRead(PHGSMIINSTANCE pIns);
 DECLHIDDEN(void) HGSMIHostWrite(PHGSMIINSTANCE pIns, HGSMIOFFSET offBuffer);
 
 DECLHIDDEN(void) HGSMISetHostGuestFlags(PHGSMIINSTANCE pIns, uint32_t flags);
-DECLHIDDEN(uint32_t) HGSMIGetHostGuestFlags(HGSMIINSTANCE *pIns);
+DECLHIDDEN(uint32_t) HGSMIGetHostGuestFlags(struct HGSMIINSTANCE *pIns);
 
 DECLHIDDEN(void) HGSMIClearHostGuestFlags(PHGSMIINSTANCE pIns, uint32_t flags);
 
diff --git a/src/VBox/Devices/Graphics/svgadump/svga_dump.c b/src/VBox/Devices/Graphics/svgadump/svga_dump.c
index 6985ce75..6d9d7a16 100644
--- a/src/VBox/Devices/Graphics/svgadump/svga_dump.c
+++ b/src/VBox/Devices/Graphics/svgadump/svga_dump.c
@@ -2272,544 +2272,14 @@ case SVGA_3D_CMD_DX_##CommandCode: \
    break
 
 void            
-svga_dump_command(uint32_t cmd_id, const void *data, uint32_t size)
-{
-   const uint8_t *body = (const uint8_t *)data;
-   const uint8_t *next = body + size;
-  
-   switch(cmd_id) {
-   SVGA3D_DUMP_CASE_BASIC(BindContext, BIND_CONTEXT);
-   SVGA3D_DUMP_CASE_LIST(SetViewports, SET_VIEWPORTS, SVGA3dViewport);
-   SVGA3D_DUMP_CASE_BASIC(SetShader, SET_SHADER);
-   SVGA3D_DUMP_CASE_LIST(SetSamplers, SET_SAMPLERS, SVGA3dSamplerId);
-   SVGA3D_DUMP_CASE_BASIC(SetBlendState, SET_BLEND_STATE);
-   SVGA3D_DUMP_CASE_BASIC(SetDepthStencilState, SET_DEPTHSTENCIL_STATE);
-   SVGA3D_DUMP_CASE_BASIC(SetRasterizerState, SET_RASTERIZER_STATE);
-   SVGA3D_DUMP_CASE_BASIC(SetPredication, SET_PREDICATION);
-   SVGA3D_DUMP_CASE_LIST(SetSOTargets, SET_SOTARGETS, SVGA3dSoTarget);
-   SVGA3D_DUMP_CASE_LIST(SetScissorRects, SET_SCISSORRECTS, SVGASignedRect);
-   SVGA3D_DUMP_CASE_BASIC(SetStreamOutput, SET_STREAMOUTPUT);
-   SVGA3D_DUMP_CASE_BASIC(SetSingleConstantBuffer, SET_SINGLE_CONSTANT_BUFFER);
-   SVGA3D_DUMP_CASE_BASIC(Draw, DRAW);
-   SVGA3D_DUMP_CASE_BASIC(DrawIndexed, DRAW_INDEXED);
-   SVGA3D_DUMP_CASE_BASIC(DrawInstanced, DRAW_INSTANCED);
-   SVGA3D_DUMP_CASE_BASIC(DrawIndexedInstanced, DRAW_INDEXED_INSTANCED);
-   SVGA3D_DUMP_CASE_BASIC(DrawAuto, DRAW_AUTO);
-   SVGA3D_DUMP_CASE_BASIC(DefineQuery, DEFINE_QUERY);
-   SVGA3D_DUMP_CASE_BASIC(DestroyQuery, DESTROY_QUERY);
-   SVGA3D_DUMP_CASE_BASIC(BindAllQuery, BIND_ALL_QUERY);
-   SVGA3D_DUMP_CASE_BASIC(BindQuery, BIND_QUERY);
-   SVGA3D_DUMP_CASE_BASIC(MoveQuery, MOVE_QUERY);
-   SVGA3D_DUMP_CASE_BASIC(ReadbackAllQuery, READBACK_ALL_QUERY);
-   SVGA3D_DUMP_CASE_BASIC(SetQueryOffset, SET_QUERY_OFFSET);
-   SVGA3D_DUMP_CASE_BASIC(BeginQuery, BEGIN_QUERY);
-   SVGA3D_DUMP_CASE_BASIC(EndQuery, END_QUERY);
-   SVGA3D_DUMP_CASE_BASIC(ClearRenderTargetView, CLEAR_RENDERTARGET_VIEW);
-   SVGA3D_DUMP_CASE_BASIC(ClearDepthStencilView, CLEAR_DEPTHSTENCIL_VIEW);
-   SVGA3D_DUMP_CASE_BASIC(DefineShaderResourceView, DEFINE_SHADERRESOURCE_VIEW);
-   SVGA3D_DUMP_CASE_LIST(SetShaderResources, SET_SHADER_RESOURCES, SVGA3dShaderResourceViewId);
-   SVGA3D_DUMP_CASE_BASIC(DestroyShaderResourceView, DESTROY_SHADERRESOURCE_VIEW);
-   SVGA3D_DUMP_CASE_BASIC(DefineRenderTargetView, DEFINE_RENDERTARGET_VIEW);
-   SVGA3D_DUMP_CASE_BASIC(DestroyRenderTargetView, DESTROY_RENDERTARGET_VIEW);
-   SVGA3D_DUMP_CASE_BASIC(DefineDepthStencilView, DEFINE_DEPTHSTENCIL_VIEW);
-   SVGA3D_DUMP_CASE_BASIC(DestroyDepthStencilView, DESTROY_DEPTHSTENCIL_VIEW);
-   SVGA3D_DUMP_CASE_LIST(DefineElementLayout, DEFINE_ELEMENTLAYOUT, SVGA3dInputElementDesc);
-   SVGA3D_DUMP_CASE_BASIC(DestroyElementLayout, DESTROY_ELEMENTLAYOUT);
-   SVGA3D_DUMP_CASE_BASIC(DefineBlendState, DEFINE_BLEND_STATE);
-   SVGA3D_DUMP_CASE_BASIC(DestroyBlendState, DESTROY_BLEND_STATE);
-   SVGA3D_DUMP_CASE_BASIC(DefineDepthStencilState, DEFINE_DEPTHSTENCIL_STATE);
-   SVGA3D_DUMP_CASE_BASIC(DestroyDepthStencilState, DESTROY_DEPTHSTENCIL_STATE);
-   SVGA3D_DUMP_CASE_BASIC(DefineRasterizerState, DEFINE_RASTERIZER_STATE);
-   SVGA3D_DUMP_CASE_BASIC(DestroyRasterizerState, DESTROY_RASTERIZER_STATE);
-   SVGA3D_DUMP_CASE_BASIC(DefineSamplerState, DEFINE_SAMPLER_STATE);
-   SVGA3D_DUMP_CASE_BASIC(DestroySamplerState, DESTROY_SAMPLER_STATE);
-   SVGA3D_DUMP_CASE_BASIC(DefineShader, DEFINE_SHADER);
-   SVGA3D_DUMP_CASE_BASIC(DestroyShader, DESTROY_SHADER);
-   SVGA3D_DUMP_CASE_BASIC(BindShader, BIND_SHADER);
-   SVGA3D_DUMP_CASE_BASIC(DefineStreamOutput, DEFINE_STREAMOUTPUT);
-   SVGA3D_DUMP_CASE_BASIC(DestroyStreamOutput, DESTROY_STREAMOUTPUT);
-   SVGA3D_DUMP_CASE_BASIC(SetInputLayout, SET_INPUT_LAYOUT);
-   SVGA3D_DUMP_CASE_LIST(SetVertexBuffers, SET_VERTEX_BUFFERS, SVGA3dVertexBuffer);
-   SVGA3D_DUMP_CASE_BASIC(SetTopology, SET_TOPOLOGY);
-   SVGA3D_DUMP_CASE_BASIC(SetIndexBuffer, SET_INDEX_BUFFER);
-
-   SVGA3D_DUMP_CASE_BASIC(PredCopy, PRED_COPY);
-   SVGA3D_DUMP_CASE_BASIC(UpdateSubResource, UPDATE_SUBRESOURCE);
-   SVGA3D_DUMP_CASE_BASIC(ReadbackSubResource, READBACK_SUBRESOURCE);
-   SVGA3D_DUMP_CASE_BASIC(PredCopyRegion, PRED_COPY_REGION);
-   SVGA3D_DUMP_CASE_BASIC(BufferCopy, BUFFER_COPY);
-   SVGA3D_DUMP_CASE_BASIC(BufferUpdate, BUFFER_UPDATE);
-   SVGA3D_DUMP_CASE_BASIC(GenMips, GENMIPS);
-   SVGA3D_DUMP_CASE_BASIC(TransferFromBuffer, TRANSFER_FROM_BUFFER);
-
-   case SVGA_3D_CMD_DX_SET_RENDERTARGETS:
-      _debug_printf("\tSVGA_3D_CMD_DX_SET_RENDERTARGETS\n");
-      {
-         const SVGA3dCmdDXSetRenderTargets *cmd =
-            (const SVGA3dCmdDXSetRenderTargets *) body;
-         _debug_printf("\t\t.depthStencilViewId = %u\n",
-                       cmd->depthStencilViewId);
-         body = (const uint8_t *) &cmd[1];
-         while (body + sizeof(SVGA3dRenderTargetViewId) <= next) {
-            _debug_printf("\t\t.renderTargetViewId = %u\n",
-                          *((SVGA3dRenderTargetViewId *) body));
-            body += sizeof(SVGA3dRenderTargetViewId);
-         }
-      }
-      break;
-
-   case SVGA_3D_CMD_SURFACE_DEFINE:
-      _debug_printf("\tSVGA_3D_CMD_SURFACE_DEFINE\n");
-      {
-         const SVGA3dCmdDefineSurface *cmd = (const SVGA3dCmdDefineSurface *)body;
-         dump_SVGA3dCmdDefineSurface(cmd);
-         body = (const uint8_t *)&cmd[1];
-         while(body + sizeof(SVGA3dSize) <= next) {
-            dump_SVGA3dSize((const SVGA3dSize *)body);
-            body += sizeof(SVGA3dSize);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_SURFACE_DESTROY:
-      _debug_printf("\tSVGA_3D_CMD_SURFACE_DESTROY\n");
-      {
-         const SVGA3dCmdDestroySurface *cmd = (const SVGA3dCmdDestroySurface *)body;
-         dump_SVGA3dCmdDestroySurface(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SURFACE_COPY:
-      _debug_printf("\tSVGA_3D_CMD_SURFACE_COPY\n");
-      {
-         const SVGA3dCmdSurfaceCopy *cmd = (const SVGA3dCmdSurfaceCopy *)body;
-         dump_SVGA3dCmdSurfaceCopy(cmd);
-         body = (const uint8_t *)&cmd[1];
-         while(body + sizeof(SVGA3dCopyBox) <= next) {
-            dump_SVGA3dCopyBox((const SVGA3dCopyBox *)body);
-            body += sizeof(SVGA3dCopyBox);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_SURFACE_STRETCHBLT:
-      _debug_printf("\tSVGA_3D_CMD_SURFACE_STRETCHBLT\n");
-      {
-         const SVGA3dCmdSurfaceStretchBlt *cmd = (const SVGA3dCmdSurfaceStretchBlt *)body;
-         dump_SVGA3dCmdSurfaceStretchBlt(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SURFACE_DMA:
-      _debug_printf("\tSVGA_3D_CMD_SURFACE_DMA\n");
-      {
-         const SVGA3dCmdSurfaceDMA *cmd = (const SVGA3dCmdSurfaceDMA *)body;
-         dump_SVGA3dCmdSurfaceDMA(cmd);
-         body = (const uint8_t *)&cmd[1];
-         while(body + sizeof(SVGA3dCopyBox) <= next) {
-            dump_SVGA3dCopyBox((const SVGA3dCopyBox *)body);
-            body += sizeof(SVGA3dCopyBox);
-         }
-         while(body + sizeof(SVGA3dCmdSurfaceDMASuffix) <= next) {
-            dump_SVGA3dCmdSurfaceDMASuffix((const SVGA3dCmdSurfaceDMASuffix *)body);
-            body += sizeof(SVGA3dCmdSurfaceDMASuffix);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_CONTEXT_DEFINE:
-      _debug_printf("\tSVGA_3D_CMD_CONTEXT_DEFINE\n");
-      {
-         const SVGA3dCmdDefineContext *cmd = (const SVGA3dCmdDefineContext *)body;
-         dump_SVGA3dCmdDefineContext(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_CONTEXT_DESTROY:
-      _debug_printf("\tSVGA_3D_CMD_CONTEXT_DESTROY\n");
-      {
-         const SVGA3dCmdDestroyContext *cmd = (const SVGA3dCmdDestroyContext *)body;
-         dump_SVGA3dCmdDestroyContext(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SETTRANSFORM:
-      _debug_printf("\tSVGA_3D_CMD_SETTRANSFORM\n");
-      {
-         const SVGA3dCmdSetTransform *cmd = (const SVGA3dCmdSetTransform *)body;
-         dump_SVGA3dCmdSetTransform(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SETZRANGE:
-      _debug_printf("\tSVGA_3D_CMD_SETZRANGE\n");
-      {
-         const SVGA3dCmdSetZRange *cmd = (const SVGA3dCmdSetZRange *)body;
-         dump_SVGA3dCmdSetZRange(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SETRENDERSTATE:
-      _debug_printf("\tSVGA_3D_CMD_SETRENDERSTATE\n");
-      {
-         const SVGA3dCmdSetRenderState *cmd = (const SVGA3dCmdSetRenderState *)body;
-         dump_SVGA3dCmdSetRenderState(cmd);
-         body = (const uint8_t *)&cmd[1];
-         while(body + sizeof(SVGA3dRenderState) <= next) {
-            dump_SVGA3dRenderState((const SVGA3dRenderState *)body);
-            body += sizeof(SVGA3dRenderState);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_SETRENDERTARGET:
-      _debug_printf("\tSVGA_3D_CMD_SETRENDERTARGET\n");
-      {
-         const SVGA3dCmdSetRenderTarget *cmd = (const SVGA3dCmdSetRenderTarget *)body;
-         dump_SVGA3dCmdSetRenderTarget(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SETTEXTURESTATE:
-      _debug_printf("\tSVGA_3D_CMD_SETTEXTURESTATE\n");
-      {
-         const SVGA3dCmdSetTextureState *cmd = (const SVGA3dCmdSetTextureState *)body;
-         dump_SVGA3dCmdSetTextureState(cmd);
-         body = (const uint8_t *)&cmd[1];
-         while(body + sizeof(SVGA3dTextureState) <= next) {
-            dump_SVGA3dTextureState((const SVGA3dTextureState *)body);
-            body += sizeof(SVGA3dTextureState);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_SETMATERIAL:
-      _debug_printf("\tSVGA_3D_CMD_SETMATERIAL\n");
-      {
-         const SVGA3dCmdSetMaterial *cmd = (const SVGA3dCmdSetMaterial *)body;
-         dump_SVGA3dCmdSetMaterial(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SETLIGHTDATA:
-      _debug_printf("\tSVGA_3D_CMD_SETLIGHTDATA\n");
-      {
-         const SVGA3dCmdSetLightData *cmd = (const SVGA3dCmdSetLightData *)body;
-         dump_SVGA3dCmdSetLightData(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SETLIGHTENABLED:
-      _debug_printf("\tSVGA_3D_CMD_SETLIGHTENABLED\n");
-      {
-         const SVGA3dCmdSetLightEnabled *cmd = (const SVGA3dCmdSetLightEnabled *)body;
-         dump_SVGA3dCmdSetLightEnabled(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SETVIEWPORT:
-      _debug_printf("\tSVGA_3D_CMD_SETVIEWPORT\n");
-      {
-         const SVGA3dCmdSetViewport *cmd = (const SVGA3dCmdSetViewport *)body;
-         dump_SVGA3dCmdSetViewport(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SETCLIPPLANE:
-      _debug_printf("\tSVGA_3D_CMD_SETCLIPPLANE\n");
-      {
-         const SVGA3dCmdSetClipPlane *cmd = (const SVGA3dCmdSetClipPlane *)body;
-         dump_SVGA3dCmdSetClipPlane(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_CLEAR:
-      _debug_printf("\tSVGA_3D_CMD_CLEAR\n");
-      {
-         const SVGA3dCmdClear *cmd = (const SVGA3dCmdClear *)body;
-         dump_SVGA3dCmdClear(cmd);
-         body = (const uint8_t *)&cmd[1];
-         while(body + sizeof(SVGA3dRect) <= next) {
-            dump_SVGA3dRect((const SVGA3dRect *)body);
-            body += sizeof(SVGA3dRect);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_PRESENT:
-      _debug_printf("\tSVGA_3D_CMD_PRESENT\n");
-      {
-         const SVGA3dCmdPresent *cmd = (const SVGA3dCmdPresent *)body;
-         dump_SVGA3dCmdPresent(cmd);
-         body = (const uint8_t *)&cmd[1];
-         while(body + sizeof(SVGA3dCopyRect) <= next) {
-            dump_SVGA3dCopyRect((const SVGA3dCopyRect *)body);
-            body += sizeof(SVGA3dCopyRect);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_SHADER_DEFINE:
-      _debug_printf("\tSVGA_3D_CMD_SHADER_DEFINE\n");
-      {
-         const SVGA3dCmdDefineShader *cmd = (const SVGA3dCmdDefineShader *)body;
-         dump_SVGA3dCmdDefineShader(cmd);
-         body = (const uint8_t *)&cmd[1];
-         //svga_shader_dump((const uint32_t *)body, 
-         //             (unsigned)(next - body)/sizeof(uint32_t),
-         //             FALSE );
-         body = next;
-      }
-      break;
-   case SVGA_3D_CMD_SHADER_DESTROY:
-      _debug_printf("\tSVGA_3D_CMD_SHADER_DESTROY\n");
-      {
-         const SVGA3dCmdDestroyShader *cmd = (const SVGA3dCmdDestroyShader *)body;
-         dump_SVGA3dCmdDestroyShader(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SET_SHADER:
-      _debug_printf("\tSVGA_3D_CMD_SET_SHADER\n");
-      {
-         const SVGA3dCmdSetShader *cmd = (const SVGA3dCmdSetShader *)body;
-         dump_SVGA3dCmdSetShader(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SET_SHADER_CONST:
-      _debug_printf("\tSVGA_3D_CMD_SET_SHADER_CONST\n");
-      {
-         const SVGA3dCmdSetShaderConst *cmd = (const SVGA3dCmdSetShaderConst *)body;
-         uint32 numConsts = 1 + (size - sizeof *cmd) / (4 * sizeof(uint32));
-         dump_SVGA3dCmdSetShaderConst(cmd, numConsts);
-         body = next;
-      }
-      break;
-   case SVGA_3D_CMD_DRAW_PRIMITIVES:
-      _debug_printf("\tSVGA_3D_CMD_DRAW_PRIMITIVES\n");
-      {
-         const SVGA3dCmdDrawPrimitives *cmd = (const SVGA3dCmdDrawPrimitives *)body;
-         unsigned i, j;
-         dump_SVGA3dCmdDrawPrimitives(cmd);
-         body = (const uint8_t *)&cmd[1];
-         for(i = 0; i < cmd->numVertexDecls; ++i) {
-            dump_SVGA3dVertexDecl((const SVGA3dVertexDecl *)body);
-            body += sizeof(SVGA3dVertexDecl);
-         }
-         for(j = 0; j < cmd->numRanges; ++j) {
-            dump_SVGA3dPrimitiveRange((const SVGA3dPrimitiveRange *)body);
-            body += sizeof(SVGA3dPrimitiveRange);
-         }
-         while(body + sizeof(SVGA3dVertexDivisor) <= next) {
-            dump_SVGA3dVertexDivisor((const SVGA3dVertexDivisor *)body);
-            body += sizeof(SVGA3dVertexDivisor);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_SETSCISSORRECT:
-      _debug_printf("\tSVGA_3D_CMD_SETSCISSORRECT\n");
-      {
-         const SVGA3dCmdSetScissorRect *cmd = (const SVGA3dCmdSetScissorRect *)body;
-         dump_SVGA3dCmdSetScissorRect(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_BEGIN_QUERY:
-      _debug_printf("\tSVGA_3D_CMD_BEGIN_QUERY\n");
-      {
-         const SVGA3dCmdBeginQuery *cmd = (const SVGA3dCmdBeginQuery *)body;
-         dump_SVGA3dCmdBeginQuery(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_END_QUERY:
-      _debug_printf("\tSVGA_3D_CMD_END_QUERY\n");
-      {
-         const SVGA3dCmdEndQuery *cmd = (const SVGA3dCmdEndQuery *)body;
-         dump_SVGA3dCmdEndQuery(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_WAIT_FOR_QUERY:
-      _debug_printf("\tSVGA_3D_CMD_WAIT_FOR_QUERY\n");
-      {
-         const SVGA3dCmdWaitForQuery *cmd = (const SVGA3dCmdWaitForQuery *)body;
-         dump_SVGA3dCmdWaitForQuery(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN:
-      _debug_printf("\tSVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN\n");
-      {
-         const SVGA3dCmdBlitSurfaceToScreen *cmd = (const SVGA3dCmdBlitSurfaceToScreen *)body;
-         dump_SVGA3dCmdBlitSurfaceToScreen(cmd);
-         body = (const uint8_t *)&cmd[1];
-         while(body + sizeof(SVGASignedRect) <= next) {
-            dump_SVGASignedRect((const SVGASignedRect *)body);
-            body += sizeof(SVGASignedRect);
-         }
-      }
-      break;
-   case SVGA_3D_CMD_DEFINE_GB_CONTEXT:
-      _debug_printf("\tSVGA_3D_CMD_DEFINE_GB_CONTEXT\n");
-      {
-         const SVGA3dCmdDefineGBContext *cmd = (const SVGA3dCmdDefineGBContext *) body;
-         dump_SVGA3dCmdDefineGBContext(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_BIND_GB_CONTEXT:
-      _debug_printf("\tSVGA_3D_CMD_BIND_GB_CONTEXT\n");
-      {
-         const SVGA3dCmdBindGBContext *cmd = (const SVGA3dCmdBindGBContext *) body;
-         dump_SVGA3dCmdBindGBContext(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_DESTROY_GB_CONTEXT:
-      _debug_printf("\tSVGA_3D_CMD_DESTROY_GB_CONTEXT\n");
-      {
-         const SVGA3dCmdDestroyGBContext *cmd = (const SVGA3dCmdDestroyGBContext *) body;
-         dump_SVGA3dCmdDestroyGBContext(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_DEFINE_GB_SHADER:
-      _debug_printf("\tSVGA_3D_CMD_DEFINE_GB_SHADER\n");
-      {
-         const SVGA3dCmdDefineGBShader *cmd = (const SVGA3dCmdDefineGBShader *) body;
-         dump_SVGA3dCmdDefineGBShader(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_BIND_GB_SHADER:
-      _debug_printf("\tSVGA_3D_CMD_BIND_GB_SHADER\n");
-      {
-         const SVGA3dCmdBindGBShader *cmd = (const SVGA3dCmdBindGBShader *) body;
-         dump_SVGA3dCmdBindGBShader(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_DESTROY_GB_SHADER:
-      _debug_printf("\tSVGA_3D_CMD_DESTROY_GB_SHADER\n");
-      {
-         const SVGA3dCmdDestroyGBShader *cmd = (const SVGA3dCmdDestroyGBShader *) body;
-         dump_SVGA3dCmdDestroyGBShader(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_BIND_GB_SURFACE:
-      _debug_printf("\tSVGA_3D_CMD_BIND_GB_SURFACE\n");
-      {
-         const SVGA3dCmdBindGBSurface *cmd = (const SVGA3dCmdBindGBSurface *) body;
-         dump_SVGA3dCmdBindGBSurface(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_UPDATE_GB_SURFACE:
-      _debug_printf("\tSVGA_3D_CMD_UPDATE_GB_SURFACE\n");
-      {
-         const SVGA3dCmdUpdateGBSurface *cmd = (const SVGA3dCmdUpdateGBSurface *) body;
-         dump_SVGA3dCmdUpdateGBSurface(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_READBACK_GB_IMAGE:
-      _debug_printf("\tSVGA_3D_CMD_READBACK_GB_IMAGE:\n");
-      {
-         const SVGA3dCmdReadbackGBImage *cmd = (SVGA3dCmdReadbackGBImage *) body;
-         dump_SVGA3dCmdReadbackGBImage(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_UPDATE_GB_IMAGE:
-      _debug_printf("\tSVGA_3D_CMD_UPDATE_GB_IMAGE\n");
-      {
-         const SVGA3dCmdUpdateGBImage *cmd = (const SVGA3dCmdUpdateGBImage *) body;
-         dump_SVGA3dCmdUpdateGBImage(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_INVALIDATE_GB_IMAGE:
-      _debug_printf("\tSVGA_3D_CMD_INVALIDATE_GB_IMAGE\n");
-      {
-         const SVGA3dCmdInvalidateGBImage *cmd = (const SVGA3dCmdInvalidateGBImage *) body;
-         dump_SVGA3dCmdInvalidateGBImage(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_INVALIDATE_GB_IMAGE_PARTIAL:
-      _debug_printf("\tSVGA_3D_CMD_INVALIDATE_GB_IMAGE_PARTIAL\n");
-      {
-         const SVGA3dCmdInvalidateGBImagePartial *cmd = (const SVGA3dCmdInvalidateGBImagePartial *) body;
-         dump_SVGA3dCmdInvalidateGBImagePartial(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_SET_GB_SHADERCONSTS_INLINE:
-      _debug_printf("\tSVGA_3D_CMD_SET_GB_SHADERCONSTS_INLINE\n");
-      {
-         /* XXX Note: re-using the SVGA3dCmdSetShaderConst code here */
-         const SVGA3dCmdSetGBShaderConstInline *cmd = (const SVGA3dCmdSetGBShaderConstInline *)body;
-         uint32 numConsts = (size - sizeof *cmd) / (4 * sizeof(uint32));
-         dump_SVGA3dCmdSetGBShaderConstInline(cmd, numConsts);
-         body = next;
-      }
-      break;
-   case SVGA_3D_CMD_INVALIDATE_GB_SURFACE:
-      _debug_printf("\tSVGA_3D_CMD_INVALIDATE_GB_SURFACE\n");
-      {
-         const SVGA3dCmdInvalidateGBSurface *cmd = (const SVGA3dCmdInvalidateGBSurface *)body;
-         dump_SVGA3dCmdInvalidateGBSurface(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   case SVGA_3D_CMD_INTRA_SURFACE_COPY:
-      _debug_printf("\tSVGA_3D_CMD_INTRA_SURFACE_COPY\n");
-      {
-         const SVGA3dCmdIntraSurfaceCopy *cmd = (const SVGA3dCmdIntraSurfaceCopy *)body;
-         dump_SVGA3dCmdIntraSurfaceCopy(cmd);
-         body = (const uint8_t *)&cmd[1];
-      }
-      break;
-   default:
-      _debug_printf("\t0x%08x\n", cmd_id);
-      break;
-   }
-
-   while(body + sizeof(uint32_t) <= next) {
-      _debug_printf("\t\t0x%08x\n", *(const uint32_t *)body);
-      body += sizeof(uint32_t);
-   }
-   while(body + sizeof(uint32_t) <= next)
-      _debug_printf("\t\t0x%02x\n", *body++);
+svga_dump_command(uint32_t cmd_id, const void *data, uint32_t size) {
+    return;
 }
 
 
 void            
-svga_dump_commands(const void *commands, uint32_t size)
-{
-   const uint8_t *next = commands;
-   const uint8_t *last = next + size;
-   
-   //assert(size % sizeof(uint32_t) == 0);
-   
-   while(next < last) {
-      const uint32_t cmd_id = *(const uint32_t *)next;
-
-      if(SVGA_3D_CMD_BASE <= cmd_id && cmd_id < SVGA_3D_CMD_MAX) {
-         const SVGA3dCmdHeader *header = (const SVGA3dCmdHeader *)next;
-         const uint8_t *body = (const uint8_t *)&header[1];
-
-         next = body + header->size;
-         if(next > last)
-            break;
-
-         svga_dump_command(cmd_id, body, header->size);
-      }
-      else if(cmd_id == SVGA_CMD_FENCE) {
-         _debug_printf("\tSVGA_CMD_FENCE\n");
-         _debug_printf("\t\t0x%08x\n", ((const uint32_t *)next)[1]);
-         next += 2*sizeof(uint32_t);
-      }
-      else {
-         _debug_printf("\t0x%08x\n", cmd_id);
-         next += sizeof(uint32_t);
-      }
-   }
+svga_dump_commands(const void *commands, uint32_t size) {
+    return;
 }
+
 #endif /* LOG_ENABLED */
diff --git a/src/VBox/Devices/Network/.DevE1000.cpp.swp b/src/VBox/Devices/Network/.DevE1000.cpp.swp
deleted file mode 100644
index 6b3d535d..00000000
Binary files a/src/VBox/Devices/Network/.DevE1000.cpp.swp and /dev/null differ
diff --git a/src/VBox/Devices/PC/ipxe/Makefile.kmk b/src/VBox/Devices/PC/ipxe/Makefile.kmk
index a9369d42..62d5cd65 100644
--- a/src/VBox/Devices/PC/ipxe/Makefile.kmk
+++ b/src/VBox/Devices/PC/ipxe/Makefile.kmk
@@ -100,7 +100,7 @@ else
  # iPXE - Template used to build the ROM binary.
  #
  TEMPLATE_iPxe         = iPXE code
- TEMPLATE_iPxe_TOOL    = $(VBOX_GCC32_TOOL)
+ TEMPLATE_iPxe_TOOL    = GXX32
  TEMPLATE_iPxe_LDTOOL  = iPxeLinker
  TEMPLATE_iPxe_LDFLAGS = \
 	-N \
diff --git a/src/VBox/HostDrivers/Support/SUPLib.cpp b/src/VBox/HostDrivers/Support/SUPLib.cpp
index 220eb4d4..b9211b8a 100644
--- a/src/VBox/HostDrivers/Support/SUPLib.cpp
+++ b/src/VBox/HostDrivers/Support/SUPLib.cpp
@@ -563,7 +563,6 @@ static int supInitFake(PSUPDRVSESSION *ppSession)
     return VERR_NO_MEMORY;
 }
 
-
 SUPR3DECL(int) SUPR3Term(bool fForced)
 {
     /*
diff --git a/src/VBox/Runtime/common/dbg/dbgstackdumpself.cpp b/src/VBox/Runtime/common/dbg/dbgstackdumpself.cpp
index ca82c467..df8085f2 100644
--- a/src/VBox/Runtime/common/dbg/dbgstackdumpself.cpp
+++ b/src/VBox/Runtime/common/dbg/dbgstackdumpself.cpp
@@ -60,6 +60,11 @@
 # include <iprt/utf16.h>
 # include <iprt/win/windows.h>
 #elif defined(RT_OS_LINUX) || defined(RT_OS_DARWIN)
+
+#ifdef MOONSHINE_FUZZING
+#define __USE_GNU
+#endif
+
 # include <dlfcn.h>
 #endif
 
diff --git a/src/VBox/Runtime/generic/RTLogWriteVmm-stub-generic.cpp b/src/VBox/Runtime/generic/RTLogWriteVmm-stub-generic.cpp
index dc840d04..dc08515f 100644
--- a/src/VBox/Runtime/generic/RTLogWriteVmm-stub-generic.cpp
+++ b/src/VBox/Runtime/generic/RTLogWriteVmm-stub-generic.cpp
@@ -34,7 +34,6 @@
  * SPDX-License-Identifier: GPL-3.0-only OR CDDL-1.0
  */
 
-
 /*********************************************************************************************************************************
 *   Header Files                                                                                                                 *
 *********************************************************************************************************************************/
diff --git a/src/VBox/Runtime/generic/env-generic.cpp b/src/VBox/Runtime/generic/env-generic.cpp
index 28781450..89532faf 100644
--- a/src/VBox/Runtime/generic/env-generic.cpp
+++ b/src/VBox/Runtime/generic/env-generic.cpp
@@ -143,7 +143,11 @@ static const char * const *rtEnvDefault(void)
 # ifdef RT_OS_DARWIN
     return *(_NSGetEnviron());
 # else
+#ifdef MOONSHINE_FUZZING
+    return __environ;
+#else
     return environ;
+#endif
 # endif
 }
 #endif
diff --git a/src/VBox/Runtime/include/internal/socket.h b/src/VBox/Runtime/include/internal/socket.h
index 6cb79de8..ff2737e6 100644
--- a/src/VBox/Runtime/include/internal/socket.h
+++ b/src/VBox/Runtime/include/internal/socket.h
@@ -65,7 +65,11 @@ RT_C_DECLS_BEGIN
 
 #ifndef IPRT_INTERNAL_SOCKET_POLLING_ONLY
 DECLHIDDEN(int) rtSocketResolverError(void);
+#ifdef MOONSHINE_FUZZING
+DECLHIDDEN(int) rtSocketCreateForNative(struct RTSOCKETINT **ppSocket, RTSOCKETNATIVE hNative, bool fLeaveOpen);
+#else
 DECLHIDDEN(int) rtSocketCreateForNative(RTSOCKETINT **ppSocket, RTSOCKETNATIVE hNative, bool fLeaveOpen);
+#endif
 DECLHIDDEN(int) rtSocketCreate(PRTSOCKET phSocket, int iDomain, int iType, int iProtocol, bool fInheritable);
 DECLHIDDEN(int) rtSocketCreateTcpPair(RTSOCKET *phServer, RTSOCKET *phClient);
 DECLHIDDEN(int) rtSocketBind(RTSOCKET hSocket, PCRTNETADDR pAddr);
diff --git a/src/VBox/Runtime/r3/posix/fileaio-posix.cpp b/src/VBox/Runtime/r3/posix/fileaio-posix.cpp
index 0e65089d..b04262e9 100644
--- a/src/VBox/Runtime/r3/posix/fileaio-posix.cpp
+++ b/src/VBox/Runtime/r3/posix/fileaio-posix.cpp
@@ -34,7 +34,6 @@
  * SPDX-License-Identifier: GPL-3.0-only OR CDDL-1.0
  */
 
-
 /*********************************************************************************************************************************
 *   Header Files                                                                                                                 *
 *********************************************************************************************************************************/
diff --git a/src/VBox/Runtime/r3/posix/semmutex-posix.cpp b/src/VBox/Runtime/r3/posix/semmutex-posix.cpp
index 9659572a..89684789 100644
--- a/src/VBox/Runtime/r3/posix/semmutex-posix.cpp
+++ b/src/VBox/Runtime/r3/posix/semmutex-posix.cpp
@@ -458,7 +458,11 @@ RTDECL(bool) RTSemMutexIsOwned(RTSEMMUTEX hMutexSem)
     /*
      * Validate.
      */
+#ifdef MOONSHINE_FUZZING
+    struct RTSEMMUTEXINTERNAL *pThis = hMutexSem;
+#else
     RTSEMMUTEXINTERNAL *pThis = hMutexSem;
+#endif
     AssertPtrReturn(pThis, false);
     AssertReturn(pThis->u32Magic == RTSEMMUTEX_MAGIC, false);
 
diff --git a/src/VBox/VMM/VMMR3/PDMDevHlp.cpp b/src/VBox/VMM/VMMR3/PDMDevHlp.cpp
index 6caea1d7..9761a46f 100644
--- a/src/VBox/VMM/VMMR3/PDMDevHlp.cpp
+++ b/src/VBox/VMM/VMMR3/PDMDevHlp.cpp
@@ -4942,7 +4942,8 @@ static DECLCALLBACK(PGIMMMIO2REGION) pdmR3DevHlp_GIMGetMmio2Regions(PPDMDEVINS p
 /**
  * The device helper structure for trusted devices.
  */
-const PDMDEVHLPR3 g_pdmR3DevHlpTrusted =
+#define MOONSHINE_EXPORT __attribute__((visibility("default")))
+MOONSHINE_EXPORT const PDMDEVHLPR3 g_pdmR3DevHlpTrusted =
 {
     PDM_DEVHLPR3_VERSION,
     pdmR3DevHlp_IoPortCreateEx,
