# Trigger the Vulnerability

This is out-of-bounds vulnerability in kernel TLS subsystem, specifically in the code that initial parse of incoming TLS message from socket buffer. Vulnerability resides in `tls_strp_copyin_frag`, this function is responsible for copying TLS message from socket buffer to its internal buffers.

Normally, when TCP receive queue contains complete of TLS header, kernel TLS just make a reference to skb inside TCP receive queue to its internal skb, even TLS hasn't receive fully of the TLS message. At some point, if there's only tiny buffer left (e.g under network preassure condition) for TCP socket buffer, kernel TLS tries to copy the socket buffer from TCP to its own internal socket buffer, it will free up current TCP socket buffer space so the connection doesn't stall. Both condition is fine, as long as kernel TLS already parse complete of TLS header, so kernel TLS know how many bytes it need reads to from TCP socket buffer.

The vulnerability is triggered when there's only tiny buffer left in TCP socket buffer so kernel TLS try to copy all the buffer to its internal skb and also kernel TLS fail to parse TLS header completely, in this condition when kernel fail to parse TLS header it keep the current connection alive and keep copying incoming data from TCP instead abort the connection. 

```c
static int tls_strp_copyin_frag(struct tls_strparser *strp, struct sk_buff *skb,
                struct sk_buff *in_skb, unsigned int offset,
                size_t in_len)
{
    size_t len, chunk;
    skb_frag_t *frag;
    int sz;
    frag = &skb_shinfo(skb)->frags[skb->len / PAGE_SIZE]; // [1]
    len = in_len;
    /* First make sure we got the header */
    if (!strp->stm.full_len) { // [2]
        /* Assume one page is more than enough for headers */
        chunk =    min_t(size_t, len, PAGE_SIZE - skb_frag_size(frag));
        WARN_ON_ONCE(skb_copy_bits(in_skb, offset,
                       skb_frag_address(frag) +
                       skb_frag_size(frag),
                       chunk));  // [3]
        skb->len += chunk;
        skb->data_len += chunk;
        skb_frag_size_add(frag, chunk);
        sz = tls_rx_msg_size(strp, skb); // [4]
        if (sz < 0)
            return sz;
    /*...*/ 
```

`tls_strp_copyin_frag` will called when incoming TCP socket buffer, it will copy the buffer to its own internal `skb`. At [1], it grab the page from its frags array, condition [2] will enter because kernel TLS haven't fully parse a whole TLS header succesfully to know the length of incoming TLS message, [3] will copy the incoming socket buffer to the page. At [4], `tls_rx_msg_size` will parse incoming TLS header, if fail it will just return without aborting current TLS connection.

Because connection still alive, `tls_strp_copyin_frag` can keep called again with `strp->stm.full_len` is 0 because `tls_rx_msg_size` is always return fail, it will happens until `skb->len` fills up the whole frags, until it grab the page from out-of-bounds of `frags` array. At this point the page is coming from out-of-bounds data of frags array. This test cases below demonstrate this:
```
```c
/* Use OOB+large send to trigger copy mode due to memory pressure.
 * OOB causes a short read.
 */
TEST_F(tls_err, oob_pressure)
{
    char buf[1<<16];
    int i;

    memrnd(buf, sizeof(buf));

    EXPECT_EQ(send(self->fd2, buf, 5, MSG_OOB), 5);
    EXPECT_EQ(send(self->fd2, buf, sizeof(buf), 0), sizeof(buf));
    for (i = 0; i < 64; i++)
        EXPECT_EQ(send(self->fd2, buf, 5, MSG_OOB), 5);
}
```


The out-of-bounds located on frags array, it's located at `skb_shinfo(skb)->frags`, `skb_shinfo(skb)` is from `skb->head + skb->end`. Depends on how many we allocate socket buffer. The frags itself is not initialized when skb allocated, so we can control via uninitialized data.

# Exploit
## Prepare uninit data with freed page
My plan is to fill the frags with old page pointer, so it will write to the old freed page it means it would be powerful page uaf write primitive. To fill the page I use vsock socket + page splice, it will splice the page to vsock skb frags, this feature is enabled on LTS version with vsock zero copy features, but in COS this feature not available, and I found `iter_file_splice_write` able to splice the page to same kmalloc cache as skb data (where the `frags` inside), this COS technique not available at LTS because skb data is allocate on `skb_small_head` cache. Actually both instances, and include mitigation able to use TCP skb, because it allow us to splice and fill the frags, but this idea didn't come to my head when writing this exploit.

I fill the uninit memory with the page memory comes from `aio`, we can use `io_setup` syscall to get the memory, and `io_destroy` to free the page. After the page fills up the memory, we can destroy the page, and the internal skb of kernel TLS will allocate same area, thus frags will contain old page pointer that comes from AIO before, we then trigger vulnerability to write to the page UAF.

## Spray pipe_buffer to reclaim freed page before page uaf write
Before trigger the page UAF write, I spray kernel object which is kmalloc-cg-192 to reclaim the page UAF with pipe_buffer. Using this bug, we able write the whole freed page, so I spray two pipe_buffer every slab page allocated (depends on how many obj per slab) and the rest we can allocate msg_msgseg, using help from dummy msg_msgseg we can spray so many order 0 slab_page that contain pipe_buffer inside.

## Page uaf write
I craft the malicious pipe_buffer obj and write it to the TLS socket, it will write the whole page to the victim freed page that already contain pipe_buffer. I close all the pipe and expect one of them is already overwritten with our payload. If our payload writtine, it will called our malicious `ops` and execute our stack pivot and ROP chain.

## ROP and post exploit
Our ROP payload will write `core_pattern` with `/proc/%P/fd/666`, and do msleep forever. We also prepare our binary at fd 666, another exploit thread will notice `core_pattern` change and will crash itself. Kernel core dump will execute our binary at fd 666 as root privileges and we able to read the flag.
