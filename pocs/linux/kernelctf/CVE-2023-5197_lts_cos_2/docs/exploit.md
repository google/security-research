## CVE-2023-5197

- The exploit abuses `nf_tables` transaction semantics and chain/rule deactivation to cause a UAF on an `nft_chain`:
  - A chain (“victim chain”) is referenced by an `immediate1 jump expression in a rule of another chain (“primitive chain”), which increments its use count.
  - Through a crafted sequence of creating and deleting rules/chains in the same transaction, the PoC causes deactivation to run against a chain twice in a way that decrements the victim chain’s use count back to zero while a stale reference still exists in the primitive chain.
  - The victim chain is then deleted and freed even though a rule still “jumps” to it. This frees:
    - The `nft_chain` object (in `kmalloc-128`).
    - Optionally, its large chain name string buffer (in `kmalloc-192`) when a long name is used.
  - Subsequent heap sprays reclaim those freed chunks with attacker-controlled data.

Conceptually, it is a refcount/lifetime bug: insufficient synchronization between rule list traversal during deactivation and the generation/use-count model for chains across a transaction.

Note: For LTS instance running on 6.1 kernel, `nf_tables` objects are allocated with `GFP_KERNEL_ACCOUNT`, so they will use `kmalloc-cg-*` caches instead.

## Exploit overview

- Goal: Gain kernel code execution from an unprivileged user inside a user+net namespace by exploiting the aforementioned bug that allows a use-after-free (UAF) of an `nft_chain` object. Then escalate privileges to root, switch into the host namespaces, and spawn a root shell.
- Target: Linux kernel `nf_tables` core (`netfilter`).
- Prerequisites:
  - User+net namespaces allowed.
  - `nftables` available in the namespace.

## Files and major helpers

- `util.h`
  - Thin wrappers around `libmnl`/`libnftnl` to:
    - Create/delete tables, chains, rules.
    - Build expressions (`immediate` jumps and `return`, `notrack`).
    - Batch and submit netlink messages, collect callbacks.
- `exploit.c`
  - End-to-end exploit orchestration in three staged phases:
    1) Leak kernel base address (defeat KASLR).
    2) Leak kernel heap pointer and a rule handle.
    3) Gain code execution and elevate to root, then escape namespaces.

## Exploit structure and stages

### Stage 0: Setup

- Namespace sandboxing: `unshare(CLONE_NEWUSER | CLONE_NEWNET)` to get `CAP_NET_ADMIN` within the new netns.
- Pin CPU to core 0 to keep slab allocations on a single per-CPU freelist for deterministic reclaim.
- Open `NETLINK_NETFILTER` socket.

These steps provide the necessary permissions to create `nftables` objects and make heap behavior reproducible.

### Stage 1: Leak kernel base (defeat KASLR)

1) Establish the UAF primitive
   - `vuln_setup(..., victim="c_free", primitive_is_base_chain=false)`:
     - Create a new table, a victim chain, a spray chain, and a primitive chain.
     - Add one rule to the primitive chain whose immediate expression jumps to the victim chain. This holds a reference to the victim.
   - `vuln_trigger`:
     - Create an “effect” chain with a rule that jumps to the victim; delete that rule in the same transaction; then create another chain with a rule referencing the effect chain and delete that, triggering deactivation traversal again.
     - This sequence decrements victim->use back to zero.
     - Then delete the victim chain in a follow-up batch. The primitive chain still has a rule that jumps to the now-freed victim chain, creating the UAF.

2) Spray `kmalloc-128` with `nft_rule` objects
   - `spray_nft_rule_kmalloc_128_for_leaking_kernel_base`: Adds many rules to the spray chain, each with multiple `notrack` expressions and small userdata so objects land in `kmalloc-128`.

3) Leak a function pointer to compute the base
   - `leak_kernel_base`: Fetch (dump) the rule under the primitive chain and walk its expressions.
   - The exploit leverages how expression data is serialized when dumping a rule: it reaches into the memory of the reclaimed chunk to read a function pointer associated with the sprayed `notrack` expressions.
   - Subtracting a known offset yields the kernel base.

Result: A KASLR-stable kernel base is computed without kernel memory read primitives, by abusing object layout and rule dump behavior.

### Stage 2: Leak kernel heap address and a rule handle

1) Recreate UAF with a large chain name
   - Repeat the setup/trigger but use a very long victim chain name that allocates its name buffer from `kmalloc-192`. When freed, this provides a larger, attacker-controlled slab slot later.

2) Spray `kmalloc-192` with large `nft_rule` userdata
   - `spray_nft_rule_kmalloc_192_for_leaking_kernel_heap`: Adds many rules whose large userdata pushes the rule object into `kmalloc-192`, designed to overlap with the freed victim chain’s name buffer.

3) Leak a heap pointer and a rule handle
   - `leak_kernel_heap`: Dump the primitive chain rule again and parse the memory blob as a `nft_rule` region. Read a `list_head` pointer to get a heap address. Also infer a neighboring rule handle.
   - `util_delete_leaked_rule`: Delete that “leaked” rule by handle to free its chunk and reserve a place to plant a fake object later.

Result: Obtain a stable `kmalloc-192` heap address and a valid rule handle, and free a target slab slot for controlled reuse.

### Stage 3: Gain kernel code execution and elevate

1) Plant a fake `nft_rule` with controlled `expr->ops` and a ROP payload
   - `spray_kmalloc_192_for_fake_nft_rule_and_rop(kernel_base, heap_addr)`:
     - Craft a `kmalloc-192` blob that looks like:
       - An `nft_rule` with a single expression (`nft_expr`).
       - The expression’s ops pointer is set to point into attacker data so that `ops->validate` points to a gadget in the kernel text (calculated from the leaked base).
       - Embed a ROP chain right after the expression.
       - Place a small JOP/stack-pivot gadget at a known displacement from the expression to pivot execution to the ROP chain.
     - Spray these as `nft_table`'s `udata` to fill `kmalloc-192` and reclaim the freed slot at `heap_addr`.

2) Trigger UAF on `nft_chain`
   - Repeat the setup/trigger but this time we set `primitive_is_base_chain=true`, so when we add a new rule to the primitive chain, it will mark the table as "should be validated".
     - The validate operation will traverse through all chains -> rules -> expressions belong to the table. If the expression is an `immediate` jump expression, it will recursively validate the target chain.

3) Plant a fake `nft_chain` to point at the fake rule
   - `spray_kmalloc_128_fake_nft_chain_for_code_execution(heap_addr)`:
     - Create a `kmalloc-128` object shaped like `nft_chain` with `rules.next` set to the heap address of the fake `nft_rule`.
     - Spray via `nft_table`'s udata to reclaim the freed `kmalloc-128` slot.

4) Trigger the validate call to enter JOP/ROP
   - `util_create_rule_to_trigger_expr_validate`:
     - Add a benign rule to the primitive chain. Kernel walks the (now fake) chain/rule list to validate expressions and calls `expr->ops->validate`.
     - The crafted `ops->validate` points to a JOP gadget that pivots into the embedded ROP chain.

5) ROP chain actions
   - `commit_creds(init_cred)`: set current task’s creds to root.
   - `switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)`: move the current task into the initial (host) namespaces.
   - Return to userspace via the kernel’s KPTI trampoline with registers populated to continue in usermode.

6) Post-exploitation in userspace
   - `post_exploit_escape_jail_and_spawn_root_shell`:
     - `setns` into PID, mount, and net namespaces of PID 1.
     - `execve(/bin/bash -i)` to spawn a root shell in the host.

Result: Kernel code execution → root credentials → host namespace context → interactive shell.
