## Requirements to trigger the vulnerability

- CAP_NET_ADMIN in a namespace is required
- Kernel configuration: CONFIG_NET_CLS_ROUTE4
- User namespaces required: Yes

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1109c00547fc66df45b9ff923544be4c1e1bec13

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b80b829e9e2c1b3f7aae34855e04d8f6ecaf13c8

## Affected kernel versions

Introduced in 3.18. Fixed in 6.5, 6.1.44, 5.15.125 and other stable trees.

## Affected component, subsystem

net/sched: cls_route

## Description

When route4_change() is called on an existing filter, data from the existing object is copied to the newly allocated one and then route4_set_parms
() is called on it:
```
        if (fold) {
                f->id = fold->id;
                f->iif = fold->iif;
[1]             f->res = fold->res;
                f->handle = fold->handle;

                f->tp = fold->tp;
                f->bkt = fold->bkt;
                new = false;
        }

        err = route4_set_parms(net, tp, base, f, handle, head, tb,
                               tca[TCA_RATE], new, flags, extack)
...
```

The copied data includes a "res" field which is a tcf_result structure containing a pointer to the target class of a given filter.

route4_set_parms() calls tcf_bind_filter() if TCA_ROUTE4_CLASSID is set:

```
        if (tb[TCA_ROUTE4_CLASSID]) {
                f->res.classid = nla_get_u32(tb[TCA_ROUTE4_CLASSID]);
[2]             tcf_bind_filter(tp, &f->res, base);
        }
```

tcf_bind_filter() calls .bind_tcf handler on the target class, but if f->res.class was already set it also calls .unbind_tcf on it:

```
static inline void
__tcf_bind_filter(struct Qdisc *q, struct tcf_result *r, unsigned long base)
{
        unsigned long cl;

        cl = q->ops->cl_ops->bind_tcf(q, base, r->classid);
        cl = __cls_set_class(&r->class, cl);
        if (cl)
[3]                q->ops->cl_ops->unbind_tcf(q, cl);
}
```


.bind_tcf/.unbind_tcf for most classful qdiscs just increase/decrease filter_cnt counter, which serves as a protection against class being destroyed, e.g.:
```
static void drr_unbind_tcf(struct Qdisc *sch, unsigned long arg)
{
        struct drr_class *cl = (struct drr_class *)arg;

        cl->filter_cnt--;
}

static int drr_delete_class(struct Qdisc *sch, unsigned long arg,
                            struct netlink_ext_ack *extack)
{
        struct drr_sched *q = qdisc_priv(sch);
        struct drr_class *cl = (struct drr_class *)arg;

        if (cl->filter_cnt > 0)
                return -EBUSY;
...
```

This leads to a use-after-free (dangling res.class pointer) in two scenarios:

#### Scenario 1

route4_change() is called on the filter with an already bound target class "c1" and there is no TCA_ROUTE4_CLASSID in the new parameters.
tcf_unbind_filter() is called on the old filter in [4].
filter_cnt of the class "c1" is decreased and it is possible to delete it, however the to the class c1 was copied to fnew in [1] and is still set 
in the new version of the filter.


#### Scenario 2

route4_change() is called on the filter with an already bound target class "c1", there is a TCA_ROUTE4_CLASSID in the new parameters, but it is set to the different class "c2"
Class "c1" is also bound to another filter "f2", so its filter_cnt is 2 at the start.

tcf_bind_filter() is called in [2] leading to the unbind_tcf call [3] on the "c1" class. filter_cnt of "c1" is now 1.
Finally, tcf_unbind_filter() is called in [4] leading to the second unbind_tcf on the "c1" class.
This sets the filter_cnt of the "c1" to 0, allowing it to be destroyed, but it is still bound to the "f2" filter.

