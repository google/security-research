# Vulneribility
The function `nf_tables_deactivate_set` does not set "set->dead = 1". This makes it possible to call `nft_setelem_data_deactivate` with a set element more than once.

## Requirements to trigger the vulnerability
 - Capabilities:  `CAP_NET_ADMIN` capability is required.
 - Kernel configuration: `CONFIG_NETFILTER`, `CONFIG_NF_TABLES`
 - Are user namespaces needed?: Yes
  
## Commit which introduced the vulnerability
 - [commit d60be2da67d172aecf866302c91ea11533eca4d9](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/net/netfilter/nf_tables_api.c?h=linux-6.1.y&id=d60be2da67d172aecf866302c91ea11533eca4d9)


## Commit which fixed the vulnerability
- [commit 16603605b667b70da974bea8216c93e7db043bf1](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter?id=16603605b667b70da974bea8216c93e7db043bf1)
- [commit 552705a3650bbf46a22b1adedc1b04181490fc36](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=552705a3650bbf46a22b1adedc1b04181490fc36)

After reading `vulnerability.md` or `cause analysis`, you may wonder why the root cause and patch do not seem to match. I can only talk about the vulnerability reporting process for this question.
I sent a vulnerability report to security@kernel.org at 2024.2.29 13:33: 
``` 
Hi, I've found a new vulnerability in Linux netfilter/nftable subsystem. In the function nf_tables_deactivate_set, it does not set "set->dead = 1". This makes it possible to call nft_setelem_data_deactivate with a set element more than once by following this step: 
1. Create a pipapo set with flag NFT_SET_TIMEOUT and NFT_SET_ANONYMOUS. 
2. Create a set element of this pipapo set with flag NFTA_SET_ELEM_EXPIRATION. 
3. Create a chain. 
4. Create a rule with nft_lookup expr, which will bind the pipapo set we create in step 1. 
5. Delete the chain And finally nft_setelem_data_deactivate will be called for the same set element both in nft_map_deactivate and in function pipapo_gc.

Attachment is the poc I wrote for this vulnerability, which leaks some kernel pointers. I tested it on linux 6.1.78.

Thanks,
lonial con
```
The email also attached a poc I wrote based on the trigger idea (it can cause the latest kernel at that time to produce crahs). I did not receive any reply emails afterwards.
On 2024.3.5, I noticed that the maintainer of netfilter pushed a patch to netfilter (https://patchwork.ozlabs.org/project/netfilter-devel/patch/20240301022605.146412-1-pablo@netfilter.org/). He pushed the corresponding patch without asking for any opinion from me.

The patch did make my poc not work, but this patch did not fix the core of the problem `set->dead = 1`. Therefore, I added two patch commits to `vulnerability.md`.
## Affected kernel versions
- 6.1.35 and later
- 5.15.121 and later

## Affected component, subsystem
- net/netfilter (nf_tables)

## Cause
- UAF

