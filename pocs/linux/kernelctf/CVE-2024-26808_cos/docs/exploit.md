# Linux kernel Netfilter Use-After-Free leads to LPE
## Vulnerability

The Linux Kernel Netfilter is a powerful framework that provides various networking-related operations, including packet filtering, network address translation (NAT), and port forwarding, within the Linux kernel. It is designed to work seamlessly with the Linux networking stack, offering a flexible and efficient mechanism for monitoring, modifying, or rejecting network packets.

The architecture of the Linux Kernel Netfilter is modular and highly flexible, designed to efficiently handle the processing of network packets through various stages of the networking stack. At its core, Netfilter is structured around a series of hooks within the Linux network stack where functions can be registered to intercept and manipulate network packets at different points in their journey through the stack. These hooks are strategically placed at critical points, such as when packets first enter the network interface, when they're about to be routed, and just before they leave the system.

The Netfilter framework within the Linux kernel includes various hooks for intercepting network packets at different stages of their processing. One such critical hook is the ingress hook. Positioned at the very beginning of the packet processing path, the ingress hook allows the Netfilter framework to examine and decide the fate of incoming packets before they hit the network stack for further processing.

Let's take a look at the source code when user wants to install a chain filter via netfilter socket

```c
static int nf_tables_addchain(struct nft_ctx *ctx, u8 family, u8 genmask,
                  u8 policy, u32 flags,
                  struct netlink_ext_ack *extack)
{
    ...
    if (nla[NFTA_CHAIN_HOOK]) {
        ...
        err = nft_chain_parse_hook(net, NULL, nla, &hook, family, flags,
                       extack);
        ...
    }
    ...
}
```

Based on data from user request, kernel will initialize a hook to add to the chain later

```c
static int nft_chain_parse_hook(struct net *net,
                struct nft_base_chain *basechain,
                const struct nlattr * const nla[],
                struct nft_chain_hook *hook, u8 family,
                u32 flags, struct netlink_ext_ack *extack)
{
    ...
    INIT_LIST_HEAD(&hook->list);
    if (nft_base_chain_netdev(family, hook->num)) {
        err = nft_chain_parse_netdev(net, ha, &hook->list, extack, flags);
        if (err < 0) {
            module_put(type->owner);
            return err;
        }
    }
    ...
}
```

If the current chain user want to install is a base chain from `netdev`, kernel will find a desired network device to attach to, since the document said

> the ingress hook is attached to a particular network interface.

```c
static struct nft_hook *nft_netdev_hook_alloc(struct net *net,
                          const struct nlattr *attr)
{
    struct net_device *dev;
    char ifname[IFNAMSIZ];
    struct nft_hook *hook;
    int err;

    hook = kmalloc(sizeof(struct nft_hook), GFP_KERNEL_ACCOUNT);
    if (!hook) {
        err = -ENOMEM;
        goto err_hook_alloc;
    }

    nla_strscpy(ifname, attr, IFNAMSIZ);
    /* nf_tables_netdev_event() is called under rtnl_mutex, this is
     * indirectly serializing all the other holders of the commit_mutex with
     * the rtnl_mutex.
     */
    dev = __dev_get_by_name(net, ifname);
    if (!dev) {
        err = -ENOENT;
        goto err_hook_dev;
    }
    hook->ops.dev = dev;

    return hook;

err_hook_dev:
    kfree(hook);
err_hook_alloc:
    return ERR_PTR(err);
}
```

We can see that the object `hook` holds a raw pointer of given network device [1]

On the other hand, when user wants to delete a network device from system via netlink socket, kernel will call the function `rtnl_dellink`:

```c
static int rtnl_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,
            struct netlink_ext_ack *extack)
{
    ...
    err = rtnl_delete_link(dev, portid, nlh);
    ...
}

int rtnl_delete_link(struct net_device *dev, u32 portid, const struct nlmsghdr *nlh)
{
    const struct rtnl_link_ops *ops;
    LIST_HEAD(list_kill);

    ops = dev->rtnl_link_ops;
    if (!ops || !ops->dellink)
        return -EOPNOTSUPP;

    ops->dellink(dev, &list_kill);
    unregister_netdevice_many_notify(&list_kill, portid, nlh);

    return 0;
}
```

It depends on kind of the network device, delete operation will be run into different callbacks. There are some default network device: ppp, tun, bridge, ..., but all of their callbacks eventually call to `unregister_netdevice_queue` function, which lead to function `unregister_netdevice_many_notify`.

```c
void unregister_netdevice_many_notify(struct list_head *head,
                      u32 portid, const struct nlmsghdr *nlh)
{
    ...
    list_for_each_entry(dev, head, unreg_list) {
        ...

        /* Notify protocols, that we are about to destroy
         * this device. They should clean all the things.
         */
        call_netdevice_notifiers(NETDEV_UNREGISTER, dev);
        ...

        /* Remove entries from kobject tree */
        netdev_unregister_kobject(dev);
    }

    list_del(head);
}
```

This function mainly focuses on uninitializing the device and free that object from kernel heap memory. And morevoer, it also calls to `call_netdevice_notifiers`, which notifies every handlers that subscribe to network device. These handlers are actually filter chains from netfilter subsystems, we can get their definitions in `nft_chain_filter.c`. Let's take a look at handler `nf_tables_netdev_notifier`

```c
static int nf_tables_netdev_event(struct notifier_block *this,
                  unsigned long event, void *ptr)
{
    struct net_device *dev = netdev_notifier_info_to_dev(ptr);
    struct nftables_pernet *nft_net;
    struct nft_table *table;
    struct nft_chain *chain, *nr;
    struct nft_ctx ctx = {
        .net    = dev_net(dev),
    };

    if (event != NETDEV_UNREGISTER &&
        event != NETDEV_CHANGENAME)
        return NOTIFY_DONE;

    nft_net = nft_pernet(ctx.net);
    mutex_lock(&nft_net->commit_mutex);
    list_for_each_entry(table, &nft_net->tables, list) {
        if (table->family != NFPROTO_NETDEV)
            continue;

        ctx.family = table->family;
        ctx.table = table;
        list_for_each_entry_safe(chain, nr, &table->chains, list) {
            if (!nft_is_base_chain(chain))
                continue;

            ctx.chain = chain;
            nft_netdev_event(event, dev, &ctx);
        }
    }
    mutex_unlock(&nft_net->commit_mutex);

    return NOTIFY_DONE;
}

static struct notifier_block nf_tables_netdev_notifier = {
    .notifier_call    = nf_tables_netdev_event,
};
```

So in conclusion, when we remove a network device, the handler for `netdev` event iterates through all tables in current network, it passes if the table doesn't belong to `NETDEV` family, otherwise it keeps going through all chains in the table and remove the hook from the chain if that hook binds to removed network device

```c
static void nft_netdev_event(unsigned long event, struct net_device *dev,
                 struct nft_ctx *ctx)
{
    struct nft_base_chain *basechain = nft_base_chain(ctx->chain);
    struct nft_hook *hook, *found = NULL;
    int n = 0;

    if (event != NETDEV_UNREGISTER)
        return;

    list_for_each_entry(hook, &basechain->hook_list, list) {
        if (hook->ops.dev == dev)
            found = hook;

        n++;
    }
    if (!found)
        return;

    if (n > 1) {
        nf_unregister_net_hook(ctx->net, &found->ops);
        list_del_rcu(&found->list);
        kfree_rcu(found, rcu);
        return;
    }

    /* UNREGISTER events are also happening on netns exit.
     *
     * Although nf_tables core releases all tables/chains, only this event
     * handler provides guarantee that hook->ops.dev is still accessible,
     * so we cannot skip exiting net namespaces.
     */
    __nft_release_basechain(ctx);
}
```

However, there are two types of chain that may refer to a network device, `NF_NETDEV_INGRESS` and `NF_INET_INGRESS`, but kernel only removes hooks from `NF_NETDEV_INGRESS` [2]

Now we need a place to use this freed network device. Investigating into how a chain would be removed, we meet some lines of code that are used to unregister hooks

```c
void nf_unregister_net_hook(struct net *net, const struct nf_hook_ops *reg)
{
    if (reg->pf == NFPROTO_INET) {
        if (reg->hooknum == NF_INET_INGRESS) {
            __nf_unregister_net_hook(net, NFPROTO_INET, reg);
        } else {
            __nf_unregister_net_hook(net, NFPROTO_IPV4, reg);
            __nf_unregister_net_hook(net, NFPROTO_IPV6, reg);
        }
    } else {
        __nf_unregister_net_hook(net, reg->pf, reg);
    }
}

static void __nf_unregister_net_hook(struct net *net, int pf,
                     const struct nf_hook_ops *reg)
{
    struct nf_hook_entries __rcu **pp;
    struct nf_hook_entries *p;

    pp = nf_hook_entry_head(net, pf, reg->hooknum, reg->dev);
    if (!pp)
        return;

    mutex_lock(&nf_hook_mutex);

    p = nf_entry_dereference(*pp);
    if (WARN_ON_ONCE(!p)) {
        mutex_unlock(&nf_hook_mutex);
        return;
    }

    if (nf_remove_net_hook(p, reg)) {
#ifdef CONFIG_NETFILTER_INGRESS
        if (nf_ingress_hook(reg, pf))
            net_dec_ingress_queue();
#endif
#ifdef CONFIG_NETFILTER_EGRESS
        if (nf_egress_hook(reg, pf))
            net_dec_egress_queue();
#endif
        nf_static_key_dec(reg, pf);
    } else {
        WARN_ONCE(1, "hook not found, pf %d num %d", pf, reg->hooknum);
    }

    p = __nf_hook_entries_try_shrink(p, pp);
    mutex_unlock(&nf_hook_mutex);
    if (!p)
        return;

    nf_queue_nf_hook_drop(net);
    nf_hook_entries_free(p);
}
```

So basically, kernel finds the first hook in given chain that satisfies conditions, including

```c
case NFPROTO_INET:
    if (WARN_ON_ONCE(hooknum != NF_INET_INGRESS))
        return NULL;
    if (!dev || dev_net(dev) != net) {
        WARN_ON_ONCE(1);
        return NULL;
    }
    return &dev->nf_hooks_ingress;
```

That means it accesses to network device attached to the hook [3]

Combine [1], [2] and [3], and we have an Use-After-Free vulnerability in kernel

## Triggering Vulnerabilty

First we create a dummy device by sending a creating request to netlink socket ( All the following steps can be reproduced with commandline tool `nft` and `ip`, or get from attached PoC )

```c
rt_newlink(nl_route, "UAF_DEVICE", 1337);
```

Then create a table and a chain that link to the created device

```c
create_table(nl_nf, NFPROTO_INET, "table");
create_chain(nl_nf, NFPROTO_INET, "table", "chain", NF_INET_INGRESS, 10, "UAF_DEVICE")
```

Remove the device

```c
rt_dellink(nl_route, 1337);
```

Now if we dump the chain information, we can get old-removed device name -> UAF triggered

## Exploitation

We leverage this vulnerablity into UAF Leak and arbitrary free depend on when to "use"

### UAF Leak

When we dump the chain information, we can get old-removed device name in function `nft_dump_basechain_hook` at line [1]. It allows us to get contents of reclaimed struct/object at the first 8 bytes as a string, so we need to take care the value/address we leak later doesn't contain null byte.

```C
static int nft_dump_basechain_hook(struct sk_buff *skb, int family,
                   const struct nft_base_chain *basechain,
                   const struct list_head *hook_list)
{
...

        list_for_each_entry(hook, hook_list, list) {
            if (!first)
                first = hook;

            if (nla_put_string(skb, NFTA_DEVICE_NAME,
                       hook->ops.dev->name))  //[1]
                goto nla_put_failure;
            n++;
        }
        nla_nest_end(skb, nest_devs);

        if (n == 1 &&
            nla_put_string(skb, NFTA_HOOK_DEV, first->ops.dev->name))
            goto nla_put_failure;
```

### Arbitrary free

When we delete the chain, it will call `__nf_unregister_net_hook` to find out the `struct nf_hook_entries` by freed net_device and later call `nf_hook_entries_free` to free our controllable value. But there is a limit, we need to make our crafted net_device's net to be the same net in line 2. Otherwise it will return NULL and early return without go into `nf_hook_entries_free`

```C
static struct nf_hook_entries __rcu **
nf_hook_entry_head(struct net *net, int pf, unsigned int hooknum,
           struct net_device *dev)
{

...
    case NFPROTO_INET:
        if (WARN_ON_ONCE(hooknum != NF_INET_INGRESS))
            return NULL;
        if (!dev || dev_net(dev) != net) { //[2]
            WARN_ON_ONCE(1);
            return NULL;
        }
        return &dev->nf_hooks_ingress;
```

### Overwrite core_pattern
One of methods to get privileged execution is overwrite `core_pattern` so our exploit will executed as root if any crash in user program is triggered. Using arbitrary free before, the exploit is free some `pipe_buffer` object and overwrite `pipe_buffer` with our own value.

In `pipe_buffer` object there's `page` member that represents any allocated physical page in memory. To know where `core_pattern`'s page object is, first we spill struct page of some kernel text to the `pipe_buffer`, the trick we do is by `vmsplice` vDSO address to the pipe. Then, by reading `page` from victim `pipe_buffer` we can calculate the `struct page` of `core_pattern` is located. We also overwrite `flags` with `PIPE_BUF_FLAG_CAN_MERGE`, so by writing to the pipe we can overwrite the content of the memory page, which is `core_pattern`.

### Root shell
After overwrite `core_pattern`, we can crash the program, and anything in `core_pattern` will be executed as root which is our root shell.

### Detailed summary of step by steps exploitation
With these two limited primitive, our exploit is in the following steps:

1. Cross cache to overwrite `net_device` object in kmalloc-cg-4k to `packet_fanout` object in kmalloc-4k. 
2. `packet_fanout` object has `net` address in the first 8 byte, we leak `net` using UAF leak primitive to satisfy condition `dev_net(dev) != net` when perform arbitrary free at step 6.
3. Using another UAF object, this time we overwrite `net_device` with `msg_msg` object, no need cross cache we use same kmalloc-cg-4k.
4. We fill `msg_msg.next` (first 8 byte offset) with kmalloc-cg-192 by send `msg_msg` with size 0x90 for every `msg_msg` that already placed in kmalloc-cg-4k.
5. kmalloc-cg-192 guarantee that the first byte doesn't contain null byte, so we can leak kmalloc-cg-192 `msg_msg` addr using UAF leak. 
6. Use arbitrary free to free a chunk in kmalloc-cg-192 we got before.
7. Reclaim it as `pipe_buffer` A.
8. Write 0x1000 bytes to pipe A, it will increase `pipe->head` so the next `vmspliced` page will happen at `&pipe->bufs[1]` and doesn't touch the important field of `msg_msgseg.next` that needs to be null which located at the first eight bytes.
9. Use arbitrary free again to free `pipe_buffer` A.
10. Reclaim `pipe_buffer` A as `msg_msgseg`, only the first eight bytes of `msg_msgseg` uncontrolled by user so it's better than `msg_msg` in this case.
11. Call syscall vmsplice to vDSO memory page into `pipe_buffer` A at offset 0x28 (because of increased `pipe->head` at step 8), this method gives `struct page` addr of kernel text to `pipe_buffer`.
12. Read from `msg_msgseg` to read content of `pipe_buffer` A.
13. Prepare the fake pipe buffer with `page` and `offset` value calculated point to the `core_pattern` `page`'s addr and set `PIPE_BUF_FLAG_CAN_MERGE` for the pipe flags.
14. Receive the `msg` object, the `msg_msgseg` object will freed, then we can modify `pipe_buffer` by spray `msg_msgseg` again with fake pipe buffer content.
15. Write to `pipe_buffer` A to overwrite `core_pattern` value.
16. Get root shell by triggering crash.
