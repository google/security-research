## Requirements to trigger the vulnerability

- Kernel configuration: CONFIG_TLS and one of [CONFIG_CRYPTO_PCRYPT, CONFIG_CRYPTO_CRYPTD]
- User namespaces required: no

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a42055e8d2c30d4decfc13ce943d09c7b9dad221

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e01e3934a1b2d122919f73bc6ddbe1cdafc4bbdb

## Affected kernel versions

Introduced in 4.20. Fixed in 6.1.83, 5.15.164 and other stable trees.

## Affected component, subsystem

net/tls

## Description

TLS encryption works by calling sendmsg() with plaintext as a message on a TLS configured socket.
AEAD encryption work is submitted to the crypto subsystem in tls_do_encryption(), setting tls_encrypt_done() as a callback and calling crypto_aead_encrypt().

If encryption is done asynchronously, crypto_aead_encrypt() returns immediately with EINPROGRESS value instead of waiting.
Execution then returns to tls_sw_sendmsg() which waits for the async crypto operations to be done using a completion mechanism.

When encryption is finished, the crypto subsystem calls tls_encrypt_done() callback function, which calls complete() allowing tls_sw_sendmsg() to exit. When sendmsg() returns, the socket is no longer locked and it is now possible to close it, which causes all associated objects to be freed.

Relevant tls_encrypt_done() code:

```
...

        spin_lock_bh(&ctx->encrypt_compl_lock);
        pending = atomic_dec_return(&ctx->encrypt_pending);

        if (!pending && ctx->async_notify)
[1]             complete(&ctx->async_wait.completion);
        spin_unlock_bh(&ctx->encrypt_compl_lock);

        if (!ready)
                return;

        /* Schedule the transmission */
        if (!test_and_set_bit(BIT_TX_SCHEDULED, &ctx->tx_bitmask))
[2]             schedule_delayed_work(&ctx->tx_work.work, 1);
}

```

The bug is a race condition - calling complete at [1] allows the socket to be closed, which causes the ctx object to be freed, but ctx is later used as an argument to schedule_delayed_work().

If attacker manages to close the socket and reallocate freed ctx with controlled data between points [1] and [2], he can easily get code execution - schedule_delayed_work() is scheduling a function specified in ctx->tx_work to be run after a delay.
