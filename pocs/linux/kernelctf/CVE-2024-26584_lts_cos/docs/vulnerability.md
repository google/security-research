## Requirements to trigger the vulnerability

- Kernel configuration: CONFIG_TLS and CONFIG_CRYPTO_CRYPTD
- User namespaces required: no

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=94524d8fc965a7a0facdef6d1b01d5ef6d71a802

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8590541473188741055d27b955db0777569438e3

## Affected kernel versions

Introduced in 4.2. Fixed in 6.1.78, 5.15.159 and other stable trees.

## Affected component, subsystem

net/tls

## Description

When TLS submits a request in async mode to the crypto API, this request is handled by cryptd and number of queued requests exceeds the maximum queue size (cryptd.cryptd_max_cpu_qlen) the API will enter "backlog mode" which has several consequences:

- crypto_aead_decrypt()/crypto_aead_encrypt() returns EBUSY which the TLS subsystem treats as a fatal error, causing the kfree() to be called on all of the TLS context, including the AEAD request object that is still being referenced in the cryptd queue (use-after-free).
- cryptd will call the async callback (tls_encrypt_done/tls_decrypt_done) twice, first with err == EINPROGRES and later with the actual error status of the finished request.  TLS callbacks are not prepared for this extra call, which leads to a double free when tls_decrypt_done() released physical pages used for storing cleartext and freed the AEAD request context object twice.
