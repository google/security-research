### Storing objects under a known address in kernel memory

There's a surprisingly simple way to store almost unlimited amount of data at a known kernel address, which makes tricks like using cpu_entry_area obsolete.

All data stored in the memory is accessible in kernel mode via direct physical memory mapping.
Virtual address of an object is the start of the direct mapping (page_offset_base) plus an offset based on the PFN of the physical page.
Physical memory addresses of heap slabs or user memory are easily predicted - only kernel code/data sections are randomized. 
Even if everything would be randomized, we could just spray most of the physical memory with our payload, defeating any such mitigation.

page_offset_base is randomized, but on systems with the PTI disabled we can use a side channel technique like prefetch to leak this address, same way we do with the start of the kernel code section.

There are many ways to store data in memory - I prefer using large xattrs on tmpfs. 
The maximum size is of one xattr 0xffff bytes and allocations over 0x2000 are served directly from the page allocator.
