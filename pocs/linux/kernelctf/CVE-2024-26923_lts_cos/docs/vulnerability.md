## Requirements to trigger the vulnerability

- Kernel configuration: CONFIG_UNIX
- User namespaces required: no

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1fd05ba5a2f2aa8e7b9b52ef55df850e2e7d54c9

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=47d8ac011fe1c9251070e1bd64cb10b48193ec51

## Affected kernel versions

Introduced in 3.0. Fixed in 6.1.87, 6.6.28 and other stable trees.

## Affected component, subsystem

net/unix

## Description

Garbage collector does not take into account the risk of embryo getting
enqueued during the garbage collection. If such embryo has a peer that
carries SCM_RIGHTS, two consecutive passes of scan_children() may see a
different set of children. Leading to an incorrectly elevated inflight
count, and then a dangling pointer within the gc_inflight_list.

sockets are AF_UNIX/SOCK_STREAM:
- S is an unconnected socket
- L is a listening in-flight socket bound to addr, not in fdtable
- V's fd will be passed via sendmsg(), gets inflight count bumped

```
connect(S, addr)            sendmsg(S, [V]); close(V)           __unix_gc()
----------------            -------------------------           -----------

NS = unix_create1()
skb1 = sock_wmalloc(NS)
L = unix_find_other(addr)
unix_state_lock(L)
unix_peer(S) = NS


                            // V count=1 inflight=0

                            NS = unix_peer(S)
                            skb2 = sock_alloc()
                            skb_queue_tail(NS, skb2[V])

                            // V became in-flight
                            // V count=2 inflight=1

                            close(V)

                            // V count=1 inflight=1
                            // GC candidate condition met

                                                            for u in gc_inflight_list:
                                                              if (total_refs == inflight_refs)
                                                                add u to gc_candidates

                                                            // gc_candidates={L, V}

                                                            for u in gc_candidates:
                                                              scan_children(u, dec_inflight)

                                                            // embryo (skb1) was not
                                                            // reachable from L yet, so V's
                                                            // inflight remains unchanged


__skb_queue_tail(L, skb1)
unix_state_unlock(L)


                                                            for u in gc_candidates:
                                                              if (u.inflight)
                                                                scan_children(u, inc_inflight_move_tail)

                                                            // V count=1 inflight=2 (!)

```
