# Vulnerability Details

- **Requirements**:
    - **Capabilities**: `CAP_NET_ADMIN`
    - **Kernel configuration**: `CONFIG_NET_SCH_SFQ=y`
    - **User namespaces required**: Yes
- **Introduced by**: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
- **Fixed by**: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b3bf8f63e6179076b57c9de660c9f80b5abefe70
- **Affected Version**: `2.6.12-rc2 - 6.15-rc1`
- **Affected Component**: `net/sched: sch_sfq`
- **Syscall to disable**: `unshare`
- **Cause**: Array out-of-bounds write
- **Description**: The SFQ limit can be indirectly set to one when other qdisc parameters are updated, which may lead to an underflow in the `sfq_dec()` function if the qdisc `qlen` is decremented from zero. This can result in a u16 value being written approximately 256KB out of bounds when `qlen` is used as an index in the `sfq_sched_data` `dep` array in `sfq_link()`, potentially enabling privilege escalation.

# Vulnerability Analysis

When a SFQ Qdisc is initialized, [sfq_change()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_sfq.c#L624) is called. Despite an initial check explicitly prohibiting a limit equal to one, the Qdisc limit can still be indirectly set to this value when other Qdisc parameters are updated:

```c
static int sfq_change(struct Qdisc *sch, struct nlattr *opt,
		      struct netlink_ext_ack *extack)
{
	// ...
	
	// Initial check prohibiting limit == 1
	if (ctl->limit == 1) {
		NL_SET_ERR_MSG_MOD(extack, "invalid limit");
		return -EINVAL;
	}
	
	// ...

	if (ctl->flows)
		q->maxflows = min_t(u32, ctl->flows, SFQ_MAX_FLOWS);
	if (ctl->divisor) {
		q->divisor = ctl->divisor;
		q->maxflows = min_t(u32, q->maxflows, q->divisor);
	}
	if (ctl_v1) {
		if (ctl_v1->depth)
			q->maxdepth = min_t(u32, ctl_v1->depth, SFQ_MAX_DEPTH);
		// ...
	}
	if (ctl->limit) {
		// Here if q->maxdepth = 1 and q->maxflows = 1
		// The ctl->limit == 1 check above can be bypassed and q->limit set to 1
		q->limit = min_t(u32, ctl->limit, q->maxdepth * q->maxflows);
		q->maxflows = min_t(u32, q->maxflows, q->limit);
	}
	
	// ...
}
```

`q->limit` determines the maximum number of packets in the Qdisc queue. In [sfq_enqueue()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_sfq.c#L339), when a new packet arrives, if the Qdisc queue length (aka `qlen`) exceeds this limit, the packet is dropped:

```c
static int
sfq_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
{
	// ...

	if (++sch->q.qlen <= q->limit)
		return NET_XMIT_SUCCESS;

	qlen = slot->qlen;
	dropped = sfq_drop(sch, to_free);

	// ...
}
```

If `q->limit` is set to one and packets are sent to the network interface in a burst, a complex chain of interactions between TBF and SFQ can lead to multiple bugs, including an array out-of-bounds write vulnerability.

Let's explore step by step what happens if we send three packets in a burst to a network interface configured as follows:

```bash {linenos=false}
qdisc tbf 1: root refcnt 2 rate 640bit burst 100b lat 124s 
qdisc sfq 2: parent 1:10 limit 1p quantum 1014b depth 1 divisor 1024
```

**Packet A is sent (skb_A)**

[tbf_enqueue()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_tbf.c#L245) is called, which in turn calls [sfq_enqueue()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_sfq.c#L339). The packet is correctly enqueued, SFQ qlen is incremented to 1:

```c
tbf_enqueue()
    qdisc_enqueue()
        sfq_enqueue() // SFQ qlen is 0
            slot = q->slots[0]
            slot_queue_add()
                slot->skblist_next = skb_A
                slot->skblist_prev = skb_A
            q->tail = slot
            ++sch->q.qlen // SFQ qlen = 1
            // SFQ qlen <= limit, skb_A is enqueued
```

[tbf_dequeue()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_tbf.c#L275) is called. Since the`sch->gso_skb` list is empty, [sfq_dequeue()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_sfq.c#L473) is invoked, and the packet correctly dequeued. SFQ qlen is decremented to 0. So far so good:

```c
tbf_dequeue()
    qdisc_peek_dequeued()
        skb_peek(&sch->gso_skb) // sch->gso_skb is empty
        sfq_dequeue() // SFQ qlen is 1
            slot = q->tail
            slot_dequeue_head()
                skb_A = slot->skblist_next
                slot->skblist_next = slot
                slot->skblist_prev = slot
            sch->q.qlen-- // SFQ qlen = 0
        __skb_queue_head(&sch->gso_skb, skb);
        sch->q.qlen++ // SFQ qlen = 1
    // TBF has enough tokens, so the packet can be dequeued
    qdisc_dequeue_peeked()
        skb_A = __skb_dequeue(&sch->gso_skb)
        sch->q.qlen-- // SFQ qlen = 0
```

**Packet B is sent (skb_B)**

`tbf_enqueue()` is called, which in turn calls `sfq_enqueue()`. The packet is correctly enqueued, SFQ qlen is incremented to 1:

```c
tbf_enqueue()
    qdisc_enqueue()
        sfq_enqueue() // SFQ qlen is 0
            slot = q->slots[0]
            slot_queue_add()
                slot->skblist_next = skb_B
                slot->skblist_prev = skb_B
            q->tail = slot
            ++sch->q.qlen // SFQ qlen = 1
            // SFQ qlen <= limit, skb_B is enqueued
```

`tbf_dequeue()` is called, which in turn calls `sfq_dequeue()`. The packet is correctly dequeued from SFQ, but TBF ran out of tokens, so it reschedules itself for later using [qdisc_watchdog_schedule_ns()](https://elixir.bootlin.com/linux/v6.6.84/source/include/net/pkt_sched.h#L78). The SFQ qlen remains 1, as packet B is still considered to be in the queue (it is actually in the `gso_skb` list):

```c
tbf_dequeue()
    qdisc_peek_dequeued()
        skb_peek(&sch->gso_skb) // sch->gso_skb is empty
        sfq_dequeue() // SFQ qlen is 1
            slot = q->tail
            slot_dequeue_head()
                skb_B = slot->skblist_next
                slot->skblist_next = slot
                slot->skblist_prev = slot
            sch->q.qlen-- // SFQ qlen = 0
        __skb_queue_head(&sch->gso_skb, skb);
        sch->q.qlen++ // SFQ qlen = 1 
    
    // TBF runs out of tokens, reschedules itself for later
    qdisc_watchdog_schedule_ns()
```

**Packet C is sent (skb_C)**

`tbf_enqueue()` is called, which in turn calls `sfq_enqueue()`. Packet C is added to the first SFQ slot, `q->tail` is set to `slot`, the SFQ qlen incremented from 1 (packet B is still enqueued!) to 2. However, since `qlen` is now greater than `q->limit`, the packet is dropped. 

[sfq_drop()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_sfq.c#L286) uses [slot_dequeue_tail()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_sfq.c#L250) to remove the packet from the slot. Now the `slot->skblist_next` and `slot->skblist_prev` fields, point to the slot itself. Finally, SFQ qlen is decremented to 1:

>Notice how `q->tail` is not `NULL` at this point, it still corresponds to `slot`, but now the `slot->skblist_next` and `slot->skblist_prev` point to the slot itself rather than to a valid `sk_buff`.

```c
tbf_enqueue()
    qdisc_enqueue()
        sfq_enqueue() // SFQ qlen = 1
            slot = q->slots[0]
            slot_queue_add()
                slot->skblist_next = skb_C
                slot->skblist_prev = skb_C
            q->tail = slot // [1]
            ++sch->q.qlen // SFQ qlen = 2
            // SFQ qlen > limit, skb_C is dropped
            sfq_drop()
                slot_dequeue_tail()
                    // skb_C removed from the slot
                    slot->skblist_next = slot
                    slot->skblist_prev = slot
                sch->q.qlen-- // SFQ qlen = 1
``` 

`tbf_dequeue()` attempts to dequeue packet B from the `sch->gso_skb` list, but it is still out of tokens, so it reschedules itself once again:

```c
tbf_dequeue()
    qdisc_peek_dequeued()
        skb_peek(&sch->gso_skb) // sch->gso_skb is _not_ empty (contains Packet B)
    // TBF is still out of tokens, reschedules itself for later
    qdisc_watchdog_schedule_ns()
```

**The first qdisc-watchdog timer fires**

Approximately 1 second later (the time depends on the TBF configuration), the Qdisc watchdog timer fires, and `tbf_dequeue()` is called again. Packet B is removed from the `sch->gso_skb` list and correctly dequeued. The SFQ qlen is decremented to 0:

```c
tbf_dequeue()
    qdisc_peek_dequeued()
        skb_peek(&sch->gso_skb) // sch->gso_skb is NOT empty
    qdisc_dequeue_peeked()
        skb_B = __skb_dequeue(&sch->gso_skb) // Remove the packet from sch->gso_skb
        sch->q.qlen-- // SFQ qlen = 0
```

**The second qdisc-watchdog timer fires (and things go bad)**

The second Qdisc watchdog timer fires, now the `sch->gso_skb` list is empty, so `sfq_dequeue()` is called. However, since `q->tail` is not `NULL`, `slot_dequeue_head()` is used to dequeue the skb. The issue arises because `slot_dequeue_tail()` in `sfq_drop()` set `slot->skblist_next` and `slot->skblist_prev` to the address of the `slot` itself, so a type confusion bug between a `sk_buff` and a `sfq_slot` occurs. 

[sfq_dec()](https://elixir.bootlin.com/linux/v6.6.84/source/net/sched/sch_sfq.c#L221) is then called and the SFQ slot qlen is decremented from zero, resulting in an underflow. The underflowed qlen is subsequently used as an index in the `q->dep` array (`q` here is a `sfq_sched_data` structure), and this is where the out-of-bounds write occurs:

```c
tbf_dequeue()
    qdisc_peek_dequeued()
        skb_peek(&sch->gso_skb) // sch->gso_skb is empty
        sfq_dequeue() // SFQ qlen = 0
            slot = q->tail
            slot_dequeue_head()
                skb = slot->skblist_next // but slot->skblist_next = slot, TYPE CONFUSION!
            sfq_dec()
                q->slots[0].qlen--; // SFQ qlen = 0xFFFF, UNDERFLOW!
                sfq_link()
                    qlen = slot->qlen // 0xFFFF
                    ...
                    q->dep[qlen].next = 0; // 0x0000 written OOB!

    // TBF runs out of tokens, reschedules itself for later
    qdisc_watchdog_schedule_ns()
``` 

The `sfq_sched_data` `dep` array can hold a maximum of `SFQ_MAX_DEPTH + 1` (127 + 1) objects, each 4 bytes in size.

`sfq_sched_data` corresponds to the `privdata` field of a `Qdisc` object. This field, a flexible array, is located 0x180 bytes within the Qdisc. The `dep` array offset in `sfq_sched_data` is 0x70 bytes.

When the underflowed qlen, 0xFFFF, is used as an index in the `dep` array, the u16 value (`0x0000`) is written `0x180 (sfq_sched_data offset within Qdisc) + 0x70 (dep array offset within sfq_sched_data) + 0xFFFF (underflowed qlen) * 4 (size of sfq_index) = 262636` bytes out of bounds after the vulnerable SFQ Qdisc.
