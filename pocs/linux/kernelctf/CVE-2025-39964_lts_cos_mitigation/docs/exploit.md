# STAR-2025-0046: Linux Kernel af_alg out-of-bounds access

## Summary
| **Product**             | Linux Kernel             |
| ----------------------- | ------------------------ |
| **Vendor**              | Linux                    |
| **Severity**            | High - Adversaries may exploit software vulnerabilities to elevate its privileges to root. |
| **Affected Versions**   | [Linux 2.6.38](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=8ff590903d5fc7f5a0a988c38267a3d08e6393a2) - upstream |
| **CVE Identifier**      |                          |
| **CVE Description**     | A out-of-bounds vulnerability in the Linux Kernel af_alg can be exploited to achieve local privilege escalation |
| **CWE Classification(s)**   | CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer |

## CVSS3.1 Scoring System
**Base Score:** 7.8 (High)  
**Vector String:** `CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H`
| **Metric**                   | **Value** |
| ---------------------------- | --------- |
| **Attack Vector (AV)**       | Local     |
| **Attack Complexity (AC)**   | Low       |
| **Privileges Required (PR)** | Low       |
| **User Interaction (UI)**    | None      |
| **Scope (S)**                | Unchanged |
| **Confidentiality \(C)**     | High      |
| **Integrity (I)**            | High      |
| **Availability (A)**         | High      |


## Description of the vulnerability

In `af_alg_sendmsg` function, we can craft context state (`af_alg_ctx`) that have `ctx->merge = 1` and also have last sgl entry that have `sgl->cur = 0`. From that condition we can trigger out-of-bounds in `af_alg_sendmsg` via this code:
```c
/* use the existing memory in an allocated page */
if (ctx->merge && !(msg->msg_flags & MSG_SPLICE_PAGES)) {
sgl = list_entry(ctx->tsgl_list.prev,
struct af_alg_tsgl, list);
sg = sgl->sg + sgl->cur - 1; // [1]
len = min_t(size_t, len,
   PAGE_SIZE - sg->offset - sg->length);

err = memcpy_from_msg(page_address(sg_page(sg)) +
     sg->offset + sg->length,
     msg, len);
```

If sgl->cur = 0 in this state, the calculation at [1] will underflow because `sgl->cur - 1` will be -1 and will point to previous heap chunk, with this codition we can craft such page address at previous chunk and achieve kernel arbitrary write via `memcpy_from_msg`.

This is how we made that such condition happens:

Let say we have situation where:
1. last sgl->cur = MAX_SGL_ENTS-1
2. ctx->merge = 0

In this code:
```C

if (!af_alg_writable(sk)) {
err = af_alg_wait_for_wmem(sk, msg->msg_flags); // [2]
if (err)
goto unlock;
}

/* allocate a new page */
len = min_t(unsigned long, len, af_alg_sndbuf(sk));

err = af_alg_alloc_tsgl(sk); // [3]
if (err)
goto unlock;

sgl = list_entry(ctx->tsgl_list.prev, struct af_alg_tsgl,
list);
sg = sgl->sg;
if (sgl->cur)
sg_unmark_end(sg + sgl->cur - 1);
```

Let say we have two threads do sendmsg, and will stuck at [2] waiting for send buffer available.

We release some buffer and one of the threads will release. This thread, will use the sg available in the last sgl because we have `sgl->cur = MAX_SGL_ENTS-1`. Then this thread will enter this code:
```c
do {
struct page *pg;
unsigned int i = sgl->cur;

plen = min_t(size_t, len, PAGE_SIZE);

pg = alloc_page(GFP_KERNEL);
pr_info("[DEBUG] plen %zd, ctx->merge: %d\n", plen, ctx->merge);
sg_assign_page(sg + i, pg);

err = memcpy_from_msg(
page_address(sg_page(sg + i)),
msg, plen);
...
sgl->cur++;
} while (len && sgl->cur < MAX_SGL_ENTS);

ctx->merge = plen & (PAGE_SIZE - 1); //[4]
```
Let say we send `len` below the PAGE_SIZE, so `ctx->merge` will set to 1, then this thread will finish.

In this state, we still have one more thread that stuck at `af_alg_wait_for_wmem` [2]. We will release some buffer, and make this thread continue.

Now sgl->cur is MAX_SGL_ENTS, it will alloc another sgl at `af_alg_alloc_tsgl` [3], so we have last sgl that have `sgl->cur = 0`. In this state, we passed invalid user space addr. So code will fail in this line:
```c
err = memcpy_from_msg(
page_address(sg_page(sg + i)),
msg, plen);
if (err) {
__free_page(sg_page(sg + i));
sg_assign_page(sg + i, NULL);
goto unlock; // [5]
}
```
This thread will finish, and the state of af_alg_ctx is having `ctx->merge = 1` and the last sgl with `sgl->cur = 0`. Next sendmsg will trigger out of bounds like we mention earlier.
## Proof-Of-Concept Crash log
* Run poc under Linux 6.12.43
```
[   13.816985] ==================================================================
[   13.822876] BUG: KASAN: slab-out-of-bounds in af_alg_sendmsg+0x1f38/0x2150
[   13.826941] Read of size 8 at addr ffff888012f1fff8 by task exploit/146
[   13.828699]
[   13.829129] CPU: 1 UID: 1000 PID: 146 Comm: exploit Not tainted 6.12.43 #3
[   13.829156] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.4
[   13.829184] Call Trace:
[   13.829198]  <TASK>
[   13.829201]  dump_stack_lvl+0x64/0x80
[   13.829211]  print_report+0xc4/0x640
[   13.829218]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
[   13.829222]  ? af_alg_sendmsg+0x1f38/0x2150
[   13.829227]  kasan_report+0xc6/0x100
[   13.829230]  ? af_alg_sendmsg+0x1f38/0x2150
[   13.829232]  af_alg_sendmsg+0x1f38/0x2150
[   13.829236]  ? tty_update_time+0x2ea/0x440
[   13.829239]  ? tty_read+0x340/0x540
[   13.829241]  ? __pfx_af_alg_sendmsg+0x10/0x10
[   13.829243]  ? __pfx_aa_sk_perm+0x10/0x10
[   13.829247]  ? fdget+0x58/0x3e0
[   13.829271]  __sys_sendto+0x3d8/0x460
[   13.829276]  ? __pfx___sys_sendto+0x10/0x10
[   13.829278]  ? vfs_read+0x6c3/0xb70
[   13.829282]  ? __asan_memset+0x23/0x50
[   13.829285]  ? ksys_read+0xfe/0x1d0
[   13.829287]  ? __pfx_ksys_read+0x10/0x10
[   13.829290]  ? up_read+0x18/0xa0
[   13.829293]  __x64_sys_sendto+0xe0/0x1c0
[   13.829295]  ? clear_bhb_loop+0x40/0x90
[   13.829299]  ? clear_bhb_loop+0x40/0x90
[   13.829301]  ? clear_bhb_loop+0x40/0x90
[   13.829304]  do_syscall_64+0x58/0x120
[   13.829307]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   13.829310] RIP: 0033:0x423eed
[   13.829314] Code: 02 48 c7 c0 ff ff ff ff eb b5 0f 1f 00 f3 0f 1e fa 80 3d 7d 11 09 00 00 419
[   13.829317] RSP: 002b:00007ffcc1b6a658 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
[   13.829374] RAX: ffffffffffffffda RBX: 0000000000000001 RCX: 0000000000423eed
[   13.829376] RDX: 0000000000000800 RSI: 00000000004b5b40 RDI: 0000000000000004
[   13.829377] RBP: 00007ffcc1b6a7c0 R08: 0000000000000000 R09: 0000000000000000
[   13.829378] R10: 0000000000008000 R11: 0000000000000246 R12: 00007ffcc1b6a8d8
[   13.829380] R13: 00007ffcc1b6a8e8 R14: 00000000004af828 R15: 0000000000000001
[   13.829382]  </TASK>
[   13.829383]
[   13.878763] Allocated by task 144:
[   13.879617]  kasan_save_stack+0x33/0x60
[   13.880750]  kasan_save_track+0x14/0x30
[   13.881689]  __kasan_slab_alloc+0x6e/0x70
[   13.882691]  kmem_cache_alloc_noprof+0x10e/0x2b0
[   13.883731]  getname_kernel+0x51/0x330
[   13.884791]  kern_path+0x17/0x50
[   13.885467]  unix_find_other+0x102/0x6a0
[   13.886774]  unix_dgram_connect+0x21f/0xc50
[   13.887809]  __sys_connect+0x103/0x130
[   13.888868]  __x64_sys_connect+0x72/0xb0
[   13.890409]  do_syscall_64+0x58/0x120
[   13.891238]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   13.892454]
[   13.892787] Freed by task 144:
[   13.893632]  kasan_save_stack+0x33/0x60
[   13.894562]  kasan_save_track+0x14/0x30
[   13.895426]  kasan_save_free_info+0x3b/0x60
[   13.896244]  __kasan_slab_free+0x37/0x50
[   13.896964]  kmem_cache_free+0x183/0x4b0
[   13.897873]  kern_path+0x39/0x50
[   13.898850]  unix_find_other+0x102/0x6a0
[   13.899886]  unix_dgram_connect+0x21f/0xc50
[   13.901424]  __sys_connect+0x103/0x130
[   13.902278]  __x64_sys_connect+0x72/0xb0
[   13.903163]  do_syscall_64+0x58/0x120
[   13.903869]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[   13.905231]
[   13.905709] The buggy address belongs to the object at ffff888012f1e600
[   13.905709]  which belongs to the cache names_cache of size 4096
[   13.908496] The buggy address is located 2552 bytes to the right of
[   13.908496]  allocated 4096-byte region [ffff888012f1e600, ffff888012f1f600)
[   13.911995]
[   13.912381] The buggy address belongs to the physical page:
[   13.913783] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x12f18
[   13.915745] head: order:3 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0
[   13.917829] flags: 0x100000000000040(head|node=0|zone=1)
[   13.919473] page_type: f5(slab)
[   13.920369] raw: 0100000000000040 ffff88800a3a03c0 dead000000000122 0000000000000000
[   13.921984] raw: 0000000000000000 0000000000070007 00000001f5000000 0000000000000000
[   13.923504] head: 0100000000000040 ffff88800a3a03c0 dead000000000122 0000000000000000
[   13.925136] head: 0000000000000000 0000000000070007 00000001f5000000 0000000000000000
[   13.927011] head: 0100000000000003 ffffea00004bc601 ffffffffffffffff 0000000000000000
[   13.928761] head: 0000000000000008 0000000000000000 00000000ffffffff 0000000000000000
[   13.930494] page dumped because: kasan: bad access detected
[   13.931957]
[   13.932564] Memory state around the buggy address:
[   13.934043]  ffff888012f1fe80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   13.935662]  ffff888012f1ff00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   13.937680] >ffff888012f1ff80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   13.939445]                                                                 ^
[   13.941597]  ffff888012f20000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   13.943583]  ffff888012f20080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   13.945124] ==================================================================
[   13.947164] Disabling lock debugging due to kernel taint
send4 -1
```