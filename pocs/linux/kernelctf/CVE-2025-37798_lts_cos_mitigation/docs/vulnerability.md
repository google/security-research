# CVE-2025-37798
## Overview
- Requirements:
    - Capabilites: CAP_NET_ADMIN
    - Kernel configuration: CONFIG_NET_SCHED=y CONFIG_NET_SCH_FQ_CODEL=y
    - User namespaces required: Yes
- Introduced by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4b549a2ef4bef9965d97cbd992ba67930cd3e0fe  
- Fixed by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=342debc12183b51773b3345ba267e9263bdfaaef
- Affected Version: v3.5-rc1 - v6.15-rc1
- Affected Component: netfilter
- Syscall to disable: unshare
- URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-37798
- Cause: Use After Free
- Description: A use-after-free vulnerability in the Linux Kernel net scheduler subsystem can be exploited to achieve local privilege escalation. By manipulating the network interface's maximum transmission unit, it is possible to drop packets in fq_codel_dequeue without notifying a parent qdisc. This corrupts internal qlen tracking, allowing classes to be removed while still referenced in their parent, causing a use-after-free vulnerability. We recommend upgrading past commit 342debc12183b51773b3345ba267e9263bdfaaef


## Analysis
In the net/sched fq_codel qdisc, dropped packets are improperly tracked. This discrepancy can be abused to obtain a UAF on a parent scheduler. This UAF can be exploited to achieve LPE.

### Details
The vulnerability lies in the `fq_codel_dequeue()` function.
```c
	skb = codel_dequeue(sch, &sch->qstats.backlog, &q->cparams,
			    &flow->cvars, &q->cstats, qdisc_pkt_len,
			    codel_get_enqueue_time, drop_func, dequeue_func);    // [1]

	if (!skb) {
		if ((head == &q->new_flows) && !list_empty(&q->old_flows))
			list_move_tail(&flow->flowchain, &q->old_flows);
		else
			list_del_init(&flow->flowchain);
		goto begin;
	}
	qdisc_bstats_update(sch, skb);
	flow->deficit -= qdisc_pkt_len(skb);

	if (q->cstats.drop_count && sch->q.qlen) {                      // [2]
		qdisc_tree_reduce_backlog(sch, q->cstats.drop_count,        // [3]
					  q->cstats.drop_len);
		q->cstats.drop_count = 0;
		q->cstats.drop_len = 0;
	}
	return skb;
```

At [1], `codel_dequeue()` will dequeue a single packet. However, if certain conditions ([4]) are met, it will also drop a number of packets ([5]).

```c
	drop = codel_should_drop(skb, ctx, vars, params, stats,
				 skb_len_func, skb_time_func, backlog, now);        // [4]
	// ...
	} else if (drop) {
		u32 delta;

		if (params->ecn && INET_ECN_set_ce(skb)) {
			stats->ecn_mark++;
		} else {
			stats->drop_len += skb_len_func(skb);
			drop_func(skb, ctx);
			stats->drop_count++;                                    // [5]

			skb = dequeue_func(vars, ctx);
			drop = codel_should_drop(skb, ctx, vars, params,
						 stats, skb_len_func,
						 skb_time_func, backlog, now);
		}
		vars->dropping = true;
		delta = vars->count - vars->lastcount;
		if (delta > 1 &&
		    codel_time_before(now - vars->drop_next,
				      16 * params->interval)) {
			vars->count = delta;
			codel_Newton_step(vars);
		} else {
			vars->count = 1;
			vars->rec_inv_sqrt = ~0U >> REC_INV_SQRT_SHIFT;
		}
		vars->lastcount = vars->count;
		vars->drop_next = codel_control_law(now, params->interval,
						    vars->rec_inv_sqrt);
	}
```

The number of dropped packets is maintained in `drop_count` ([5]). At [2], there is a check for whether any packets were dropped. It additionally checks that the scheduler is not empty (non-zero `qlen`). Only if both conditions are met, then the parent qdisc is notified of the dropped packets at [3].

By triggering the conditions in `codel_dequeue()` to drop packets in a manner that empties the fq_codel qdisc, it is possible to cause `drop_count > 0` and `qlen == 0` at [2], so the parent is never notified of the dropped packets.

The mismatch in qlen can be turned into a UAF in a classful parent (like drr), as found in other reports, e.g. https://web.git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=638ba5089324796c2ee49af10427459c2de35f71 and https://web.git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=647cef20e649c576dff271e018d5d15d998b629d. It is possible to escalate the UAF into a LPE.