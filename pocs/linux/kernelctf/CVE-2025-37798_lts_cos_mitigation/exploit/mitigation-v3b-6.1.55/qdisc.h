#ifndef PWN_QDISC_H
#define PWN_QDISC_H

char *PWN_TC_QDISC_INTERFACE = "lo";

int create_qdisc(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;

    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "drr");

    return netlink_send(sock_fd, nlh);
}

int create_qdisc_multiq(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "multiq");

    struct tc_multiq_qopt opt = {
        .bands = 3,
        .max_bands = 3}; // values don't actually matter, it's never used
    mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_multiq_qopt), &opt);

    return netlink_send(sock_fd, nlh);
}

int create_qdisc_plug4096(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;

    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "plug");

    struct tc_plug_qopt opt = {
        .limit = 4096}; // sufficient bytes to hold the largest packet we will send
    mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_plug_qopt), &opt);

    return netlink_send(sock_fd, nlh);
}

int create_qdisc_fqcodel(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "fq_codel");

    struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);
    mnl_attr_put_u32(nlh, TCA_FQ_CODEL_LIMIT, 0xffffffff);        // never hit
    mnl_attr_put_u32(nlh, TCA_FQ_CODEL_TARGET, 0);                // no delay
    mnl_attr_put_u32(nlh, TCA_FQ_CODEL_INTERVAL, 0);              // no delay
    mnl_attr_put_u32(nlh, TCA_FQ_CODEL_FLOWS, 1);                 // deterministic sorting
    mnl_attr_put_u32(nlh, TCA_FQ_CODEL_MEMORY_LIMIT, 0xffffffff); // never hit
    mnl_attr_nest_end(nlh, opts);

    return netlink_send(sock_fd, nlh);
}

int create_qdisc_hfsc_defaultclass(int sock_fd, __u32 my_handle, __u32 parent_handle, __u16 defcls)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "hfsc");

    struct tc_hfsc_qopt qopt = {
        .defcls = defcls};
    mnl_attr_put(nlh, TCA_OPTIONS, sizeof(qopt), &qopt);

    return netlink_send(sock_fd, nlh);
}

int modify_qdisc_plug_unplug(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;

    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "plug");

    struct tc_plug_qopt opt = {
        .action = TCQ_PLUG_RELEASE_INDEFINITE,
    };
    mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_plug_qopt), &opt);

    return netlink_send(sock_fd, nlh);
}

int modify_qdisc_plug_replug(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;

    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "plug");

    struct tc_plug_qopt opt = {
        .action = TCQ_PLUG_BUFFER,
    };
    mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_plug_qopt), &opt);

    return netlink_send(sock_fd, nlh);
}

int modify_qdisc_fqcodel(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "fq_codel");

    struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);

    mnl_attr_nest_end(nlh, opts);

    return netlink_send(sock_fd, nlh);
}

int create_class(const int sock_fd, const __u32 child_handle, const __u32 parent_handle)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_type = RTM_NEWTCLASS;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE | NLM_F_ACK;
    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;

    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = child_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "drr");

    struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);
    mnl_attr_nest_end(nlh, opts);

    return netlink_send(sock_fd, nlh);
}

int create_class_hfsc(const int sock_fd, const __u32 child_handle, const __u32 parent_handle, struct tc_service_curve *rsc, struct tc_service_curve *fsc, struct tc_service_curve *usc)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWTCLASS;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE | NLM_F_ACK;
    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;

    tcm->tcm_handle = child_handle;
    tcm->tcm_parent = parent_handle;
    mnl_attr_put_strz(nlh, TCA_KIND, "hfsc");
    struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);

    if (rsc)
        mnl_attr_put(nlh, TCA_HFSC_RSC, sizeof(struct tc_service_curve), rsc);
    if (fsc)
        mnl_attr_put(nlh, TCA_HFSC_FSC, sizeof(struct tc_service_curve), fsc);
    if (usc)
        mnl_attr_put(nlh, TCA_HFSC_USC, sizeof(struct tc_service_curve), usc);

    mnl_attr_nest_end(nlh, opts);

    return netlink_send(sock_fd, nlh);
}

int delete_class(int sock_fd, __u32 my_handle, __u32 parent_handle, const char *kind)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_DELTCLASS;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, kind);

    return netlink_send(sock_fd, nlh);
}

int delete_qdisc(int sock_fd, __u32 my_handle, __u32 parent_handle, const char *kind)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_DELQDISC;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, kind);

    return netlink_send(sock_fd, nlh);
}

#endif