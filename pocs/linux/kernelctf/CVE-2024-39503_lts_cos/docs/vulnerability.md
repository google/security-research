- Requirements:
    - Capabilites: CAP_NET_ADMIN
    - Kernel configuration: CONFIG_NETFILTER=y, CONFIG_IP_SET=y, CONFIG_IP_SET_LIST_SET=y
    - User namespaces required: Yes
- Introduced by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=97f7cf1cd80eeed3b7c808b7c12463295c751001
- Fixed by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4e7aaa6b82d63e8ddcbfb56b4fd3d014ca586f10
- Affected Version: v6.8- v6.10
- Affected Component: netfilter, ip_set
- URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39503
- Cause: Use-After-Free

From the patch commit:
There is a race condition between namespace cleanup in ipset and the garbage
collection of the list:set type. The namespace cleanup can destroy the list:set
type of sets while the gc of the set type is waiting to run in rcu cleanup. The
latter uses data from the destroyed set which thus leads to use after free.

Consider the following code:

```c
// net/netfilter/ipset/ip_set_core.c:

static void __net_exit
ip_set_net_exit(struct net *net)
{
    // ...
    ip_set(inst, i) = NULL;
    set->variant->cancel_gc(set);     [1]
    ip_set_destroy_set(set);    [2]
    // ...
}

static void
ip_set_destroy_set(struct ip_set *set)
{
    // ...
    kfree(set);            [3]
}
```

Along with the following list set specific code:

```c
// net/netfilter/ipset/ip_set_list_set.c

static void
__list_set_del_rcu(struct rcu_head * rcu)
{
    struct set_elem *e = container_of(rcu, struct set_elem, rcu);
    struct ip_set *set = e->set;

    ip_set_ext_destroy(set, e);      [4]
    kfree(e);
}

static void
list_set_del(struct ip_set *set, struct set_elem *e)
{
    struct list_set *map = set->data;

    // ...
    call_rcu(&e->rcu, __list_set_del_rcu);    [5]
}
```

As we can see in [5], the element is about to be destroyed by RCU cleanup in
`__list_set_del_rcu`. However the owning set is still referenced in the cleanup
path [4]. In combination with non-RCU free of the set in [2] and [3] this leads
to a brief time window in which the set may be used after free by the RCU callback.

This race seems impossible to win on its own, because cleanup paths run in-sync
in [2]. Additionally, the namespace cleanup runs after an RCU synchronization.
But there is an additional user of the set, specifically the GC which runs
periodically and essentially calls [5].

This leaves room for the following scenario:
```
CPU 0                  CPU 1
// cleanup_net()
synchronize_rcu();

                       GC runs, list_set_del [5]

ip_set_net_exit [2]
< GC is cleaned up >
ip_set_destroy_set [3]
< set is free now >

                       < rcu clean up runs >
                       __list_set_del_rcu [4]
                        boom, use-after-free
```
