CVE-2025-38350
--------------

Exploit documentation for CVE-2025-38350 against `cos-109-17800.519.18`.
This exploit borrows many concepts from my previous exploit against
CVE-2025-21700.

## Triggering the Vulnerability Into Use-After-Free

Similar to many exploits for tc related bugs we need to setup a suitable qdisc
structure in order to trigger a use-after-free. For the bug described in
`vulnerability.md` we will use the following (classes in lower case, qdiscs in
upper case, dummy classes added for stability, see below):

```
        DRR'(root)
       /       \
      /         \         ...         ...
     /           \          \           \
   drr          plug      dummy_0 ...  dummy_N
   DRR          PLUG
    |
   hfsc
   HFSC
    |
   netem
   NETEM
    |
   BLACKHOLE
```

As a root qdisc we will choose DRR. This is a convenient choice because it is a 
rather simple classful qdisc where so called "non-workconserving" children (i.e. 
children that may drop or delay on enqueue) do not implicate any state changes.
Usually any packet enqueue would result in a subsequent dequeue on this qdisc
right away (except for high load cases, which are hard to control reliably).
Using DRR allows us to create a "blocking" child which prevents any subsequent
dequeue operation on any child if the blocking child happens to be non-workconserving.
The exploit uses a PLUG qdisc as a non-workconserving child for controlled 
packet stack up.

As the parent qdisc to abuse the use-after-free on we will choose DRR (i.e.
class `drr` in the picture above). The bug itself is present in the HFSC qdisc
however the invalid state propagates to the parents. This means we can choose a
more convenient qdisc to "use after free". We will cover this in more detail in
the heap spray section later.
In order to trigger the buggy behaviour we need a qdisc which drops packets on
dequeue operation. The NETEM + BLACKHOLE combination serves this purpose.

```c
// net/sched/sch_drr.c
static int drr_enqueue(struct sk_buff *skb, struct Qdisc *sch,
		       struct sk_buff **to_free)
{
	/* snip .. */

	cl = drr_classify(skb, sch, &err); // [1.1]

	/* snip .. */

	err = qdisc_enqueue(skb, cl->qdisc, to_free); // [1.2]

	/* snip .. */

	if (!cl_is_active(cl)) {          // [1.3]
		list_add_tail(&cl->alist, &q->active);
		cl->deficit = cl->quantum;
	}

	sch->qstats.backlog += len;
	sch->q.qlen++;                    // [1.4]
	return err;
}

// net/sched/sch_hfsc.c
static int
hfsc_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
{
	/* snip .. */

	first = !cl->qdisc->q.qlen;
	err = qdisc_enqueue(skb, cl->qdisc, to_free); // [1.5]

	/* snip .. */

	sch->qstats.backlog += len;
	sch->q.qlen++;                   // [1.6]

	if (first && !cl_in_el_or_vttree(cl)) {
		/* snip .. */

		/*
		 * If this is the first packet, isolate the head so an eventual
		 * head drop before the first dequeue operation has no chance
		 * to invalidate the deadline.
		 */
		if (cl->cl_flags & HFSC_RSC)
			cl->qdisc->ops->peek(cl->qdisc); // [1.7]

	}

	return NET_XMIT_SUCCESS;
}
```

In order to understand the implications of the vulnerability it is best to
visualize the backlog adjustment events as a packet progresses through the qdisc
tree:
- Packet arrives on DRR->enqueue() and is classified for HFSC ([1.1])
- Packet descents into the child and arrives in HFSC->enqueue() ([1.2])
- After enqueue into NETEM ([1.5]), backlog of HFSC is adjusted ([1.6],
  HFSC.qlen == 1 at this point), and NETEM->peek() is called ([1.7])
- Due to the BLACKHOLE qdisc, the packet is immediately dropped during the
  peek() operation. NETEM invokes `qdisc_tree_reduce_backlog()`.
- It realizes the HFSC qdisc did indeed become empty (HFSC.qlen == 0), so
  invokes the parent DRR->notify() handler.
  But, DRR did not yet execute ([1.3]) nor ([1.4]) thus class is not yet active,
  so the notify() operation fails to achieve its purpose.
- Eventually we return to DRR->enqueue() completing steps ([1.3]) and ([1.4]).
  At this point the hfsc class is activated even though it should have been
  already disabled in the step before.

Note that this behaviour can be propagated throughout an arbitrary large stack
of DRR qdiscs, each mistakenly activating the class of its child.
Subsequently we can abuse the use-after-free on any such `struct drr_class` 
object after the child tree is deleted.

## From Use-After-Free to RIP control

DRR manages active classes (of type `struct drr_class`) in a simple linked list
(with head `struct drr_sched.active` and node in `struct drr_class.alist`).
During dequeue operation, `drr_dequeue` is called and will essentially (as the
qdisc name suggests) cycle through this list and serve packets from its children.
If a class is empty (or non-workconserving, i.e. `qdisc_peek()` returns `NULL`),
it will stop dequeuing:
```c
// net/sched/sch_drr.c
static struct sk_buff *drr_dequeue(struct Qdisc *sch)
{
	struct drr_sched *q = qdisc_priv(sch);
	struct drr_class *cl;
	struct sk_buff *skb;
	unsigned int len;

	if (list_empty(&q->active))
		goto out;
	while (1) {
		cl = list_first_entry(&q->active, struct drr_class, alist);
		skb = cl->qdisc->ops->peek(cl->qdisc);                       // [2.1]
		if (skb == NULL) {
			qdisc_warn_nonwc(__func__, cl->qdisc);
			goto out;
		}

		len = qdisc_pkt_len(skb);
		if (len <= cl->deficit) {
			// snip ..
			return skb;
		}

		cl->deficit += cl->quantum;
		list_move_tail(&cl->alist, &q->active);
	}
out:
	return NULL;
}
```
After triggering the vulnerability this leaves us with a use-after-free on the 
`struct drr_class`.
How can we use it? Recall that we used PLUG for schedule control. Thus we first 
have to manipulate the DRR schedule so that `plug` is not the active class 
anymore.
This implies list operations on `&cl->alist` which in turn prevents us from
modifying the free class object because list hardening (i.e. `CONFIG_DEBUG_LIST`)
will panic the kernel whenever this list pointer is corrupted.
If we were to modify the class object we would nescessarily have to modify the
list pointer.
To solve this issue we will look at the next level of indirection, specifically
the `qdisc` pointer ([2]) on the class object:
```c
struct drr_class {
	struct Qdisc_class_common	common;

	struct gnet_stats_basic_sync		bstats;
	struct gnet_stats_queue		qstats;
	struct net_rate_estimator __rcu *rate_est;
	struct list_head		alist;
	struct Qdisc			*qdisc;                     // [2.2]

	u32				quantum;                            // [3.a]
	u32				deficit;                            // [3.b]
};
```
If we keep the object intact `qdisc` will be another dangling pointer, this time
of type `struct Qdisc` ([2.2]). Leaving the class object as-is also implies that 
list hardening will be happy, so we just need a way to utilize the `qdisc` object.
This is easy enough, because our dequeue operation provides a basic RIP primitive
right away via the `qdisc->ops->peek` function pointer ([2.1]).

In order to leave the class object as untouched as possible we use the dummy
classes sketched above. By allocating a series of dummy classes, we bury the
victim object in a non-active slab on another CPU. This should prevent it
from being re-allocated by any of our spraying primitives or other random
allocations during the exploit.

## Heap Spray and RIP Primitive

In order to control the `peek` member, we have to reclaim qdisc object with a 
suitable object having a sane, controllable `ops` member.
This requires us to forge a kernel heap pointer which is usually non-trivial.
Thus the first trick will be to use `AF_PACKET` sockets with an attached
`PACKET_TX_RING` which creates pointer arrays in kernel. Each pointer in the array
points to fully user controllable memory, thus presents itself as the perfect
spraying primitive for our scenario.
See [here](https://www.willsroot.io/2022/08/reviving-exploits-against-cred-struct.html)
for more details on the primitive.

As mentioned in the first section, we will choose a DRR qdisc as the victim
object (instead of say the HFSC qdisc). This is due to the fact that the DRR
qdisc resides in a more favorable slab. The HFSC qdisc is in kmalloc-2k whereas
the DRR qdisc is in kmalloc-512. During qdisc allocation we get a lot of noise
in the kmalloc-2k slabs, thus stability drops if we were to try to reclaim the
HFSC qdisc.

Since we already have an RIP control primitive we only need a target. For this I
will re-use my "one gadget" technique described in great detail in the 
CVE-2025-21700 writeup.
Also note that this gadget does not need a KASLR bypass.

## Stability

The exploit is close to 100% stable.
