- Requirements:
    - Capabilities: CAP_NET_ADMIN
    - Kernel configuration: CONFIG_NET_SCHED=y, CONFIG_NET_SCH_HFSC=y
    - User namespaces required: Yes
- Introduced by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=12d0ad3be9c3
- Fixed by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=103406b38c600fec1fe375a77b27d87e314aea09
- Affected Version: 2.6.12-rc2 - v6.16-rc4
- Affected Component: tc
- URL: https://www.cve.org/CVERecord?id=CVE-2025-38350
- Cause: Use-After-Free


An issue was found in the HFSC qdisc which performed dequeue operations in the 
enqueue handler. This violates backlog adjustment API assumptions and can lead 
to stale class pointers causing use-after-frees. Citing from the attempted fix 
["sch_hfsc: Fix qlen accounting bug when using peek in hfsc_enqueue()"](https://lore.kernel.org/all/20250518222038.58538-2-xiyou.wangcong@gmail.com/):

> When enqueuing the first packet to an HFSC class, hfsc_enqueue() calls the
> child qdisc's peek() operation before incrementing sch->q.qlen and
> sch->qstats.backlog. If the child qdisc uses qdisc_peek_dequeued(), this may
> trigger an immediate dequeue and potential packet drop. In such cases,
> qdisc_tree_reduce_backlog() is called, but the HFSC qdisc's qlen and backlog
> have not yet been updated, leading to inconsistent queue accounting. This
> can leave an empty HFSC class in the active list, causing further
> consequences like use-after-free.

However the patch failed to address the nested case as well as other similar 
patterns with other qdiscs that cause a similar issue.

The following reproducer demonstrates the issue in the nested case:
```
ip link set dev lo up
tc qdisc add dev lo root handle 1: drr
tc filter add dev lo parent 1: basic classid 1:1
tc class add dev lo parent 1: classid 1:1 drr
tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1
tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0
tc qdisc add dev lo parent 2:1 handle 3: netem
tc qdisc add dev lo parent 3:1 handle 4: blackhole

echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888
tc class delete dev lo classid 1:1
echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888
```

The problem is that the backlog corruption propagates to the parent before 
parent is even expecting any backlog updates. Looking at f.e. DRR: Child is only 
made active after the enqueue completes. Because HFSC is messing with the backlog 
before the enqueue completed, DRR will simply make the class active even though 
it should have already removed the class from the active list due to 
`qdisc_tree_backlog_flush()`. This leaves the stale class in the active list 
and causes the UAF.
