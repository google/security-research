# Vulnerability

This vulnerability is about TLS receive path (tls_sw_recvmsg) mixed with its lower layer protocol which TCP receive path (tcp_recvmsg). When TLS receive data from TCP side, it will call `tls_strp_read_sock`:

```go
#0  tls_strp_read_sock (strp=0xffff888101f7fb58) at net/tls/tls_strp.c:505
#1  tls_strp_check_rcv (strp=0xffff888101f7fb58) at net/tls/tls_strp.c:543
#2  0xffffffff8257b565 in tls_data_ready (sk=0xffff888020204280) at net/tls/tls_sw.c:2448
#3  0xffffffff824f19d7 in tcp_data_queue (sk=sk@entry=0xffff888020204280, skb=skb@entry=0xffff8880203684e0) at net/ipv4/tcp_input.c:5333
#4  0xffffffff824f2506 in tcp_rcv_established (sk=sk@entry=0xffff888020204280, skb=skb@entry=0xffff8880203684e0) at net/ipv4/tcp_input.c:6287
#5  0xffffffff825014fe in tcp_v4_do_rcv (sk=sk@entry=0xffff888020204280, skb=skb@entry=0xffff8880203684e0) at net/ipv4/tcp_ipv4.c:1916
#6  0xffffffff8250479d in tcp_v4_rcv (skb=0xffff8880203684e0) at net/ipv4/tcp_ipv4.c:2351
#7  0xffffffff824ca1fb in ip_protocol_deliver_rcu (net=net@entry=0xffffffff85293440 <init_net>, skb=0xffff8880203684e0, protocol=<optimized out>) at net/ipv4/ip_input.c:205
#8  0xffffffff824ca3f9 in ip_local_deliver_finish (net=0xffffffff85293440 <init_net>, sk=<optimized out>, skb=<optimized out>) at net/ipv4/ip_input.c:233
#9  0xffffffff823297a9 in __netif_receive_skb_one_core (skb=<optimized out>, pfmemalloc=pfmemalloc@entry=0x0) at net/core/dev.c:5741
#10 0xffffffff82329a49 in __netif_receive_skb (skb=<optimized out>) at net/core/dev.c:5854
#11 process_backlog (napi=0xffff88811c436e08, quota=0x40) at net/core/dev.c:6190
#12 0xffffffff8232a6f8 in __napi_poll (n=0xffff888101f7fb58, n@entry=0xffff88811c436e08, repoll=repoll@entry=0xffffc90000003ebf) at net/core/dev.c:6841
#13 0xffffffff8232acd7 in napi_poll (repoll=0xffffc90000003ed8, n=0xffff88811c436e08) at net/core/dev.c:6910
#14 net_rx_action () at net/core/dev.c:7032
#15 0xffffffff811accd9 in handle_softirqs (ksirqd=<optimized out>) at kernel/softirq.c:579
#16 0xffffffff811ac80b in do_softirq () at kernel/softirq.c:480
```
`tls_strp_read_sock` will call `tls_strp_load_anchor_with_queue` and TLS will set up `strp->anchor` by get the first TCP socket buffer on the TCP receive queue and set it to `skb_shinfo(strp->anchor)->frag_list`:
```C
          tls_strp_load_anchor_with_queue()
            first = tcp_recv_skb(strp->sk, tp->copied_seq, &offset);
            ...
            skb_shinfo(strp->anchor)->frag_list = first;
```
The TCP socket buffer still remains on the tcp receive queue, `strp->anchor` just take the skb pointer for the decryption later at `tls_sw_recvmsg`. Problem is, if we have `tcp_recvmsg` runs when TCP packet comes, it will eat and free the skb while it still hold by `strp->anchor`. We can call `tcp_recvmsg` in seperate thread before install the TLS ULP on the TCP socket. So when `tcp_recvmsg` hang for waiting the packet comes (in seperate thread), then we install TLS to the TCP socket, then when TCP packet receive by the kernel, `tls_strp_read_sock` will get the TCP socket buffer after that `tcp_recvmsg` will eat and free the skb, so we have freed the SKB at `skb_shinfo(strp->anchor)->frag_list`.

# Exploitation
If we call `tls_sw_recvmsg` and finally it will reach `tls_decrypt_sg` there are a few places that it uses our freed skb. For example, `skb_to_sgvec` and `skb_nsg`:
```C
static int tls_decrypt_sg(struct sock *sk, struct iov_iter *out_iov,
			  struct scatterlist *out_sg,
			  struct tls_decrypt_arg *darg)
{

	struct sk_buff *skb = tls_strp_msg(ctx); // strp->anchor
        ....
	n_sgin = skb_nsg(skb, rxm->offset + prot->prepend_size,
			 rxm->full_len - prot->prepend_size);
        ...
	err = skb_to_sgvec(skb, &sgin[1],
			   rxm->offset + prot->prepend_size,
			   rxm->full_len - prot->prepend_size);
```
But there's no any meaningful operation to use it as exploitation because those function only perform UAF read when it read `skb_shinfo(skb)->frag_list` (our freed skb placed).

Another path that use our freed skb in `skb_shinf(skb)->frag_list` is via this path, we can reach this line when we perform async decryption:

```C
static int tls_decrypt_sg(struct sock *sk, struct iov_iter *out_iov,
			  struct scatterlist *out_sg,
			  struct tls_decrypt_arg *darg)
{
        ....
	if (unlikely(darg->async)) {
		err = tls_strp_msg_hold(&ctx->strp, &ctx->async_hold);
		if (err)
			__skb_queue_tail(&ctx->async_hold, darg->skb);
		return err;
	}
}
```
It will reach `skb_clone` path at `tls_strp_msg_hold`:
```C
int tls_strp_msg_hold(struct tls_strparser *strp, struct sk_buff_head *dst)
{
        struct skb_shared_info *shinfo = skb_shinfo(strp->anchor);
        ....
		struct sk_buff *iter, *clone;
		int chunk, len, offset;

		offset = strp->stm.offset;
		len = strp->stm.full_len;
		iter = shinfo->frag_list; // our freed skb

		while (len > 0) {
			if (iter->len <= offset) {
				offset -= iter->len;
				goto next;
			}

			chunk = iter->len - offset;
			offset = 0;

			clone = skb_clone(iter, strp->sk->sk_allocation);
			if (!clone)
				return -ENOMEM;
			__skb_queue_tail(dst, clone);

			len -= chunk;
next:
			iter = iter->next;
		}
	}
}
```

If we succesfully clone our freed skb, it will queued to the `ctx->async_hold`. After decryption finish, cloned skb that resides at `ctx->async_hold` will free at `__skb_queue_purge`.

```C
int tls_sw_recvmsg(struct sock *sk,
		   struct msghdr *msg,
		   size_t len,
		   int flags,
		   int *addr_len)
{
...
recv_end:
	if (async) {
		int ret;

		/* Wait for all previously submitted records to be decrypted */
		ret = tls_decrypt_async_wait(ctx);
		__skb_queue_purge(&ctx->async_hold);
}

static inline void __skb_queue_purge_reason(struct sk_buff_head *list,
					    enum skb_drop_reason reason)
{
	struct sk_buff *skb;

	while ((skb = __skb_dequeue(list)) != NULL)
		kfree_skb_reason(skb, reason);
}

static inline void __skb_queue_purge(struct sk_buff_head *list)
{
	__skb_queue_purge_reason(list, SKB_DROP_REASON_QUEUE_PURGE);
}
```

## COS and Mitigation exploit (Linux 6.1.x)

