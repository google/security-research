# Introduction
IP sets are a framework inside the Linux kernel. Depending on the type, an IP set may store IP addresses, networks, (TCP/UDP) port numbers, MAC addresses, interface names or combinations of them in a way, which ensures lightning speed when matching an entry against a set. One of the features called `bitmap:ip`. The bitmap:ip set type uses a memory range, where each bit represents one IP address and can store up to 65535 (B-class network) entries.

Linux kernel implemented it in `net/netfilter/ipset/ip_set_bitmap_ip.c`. We can use netlink to interact with this component.

# Vulnerability Overview
CVE-2024-53141 is vulnerability in ipset component. This bug is present in `bitmap_ip_uadt` function, that fails to handle `IPSET_ATTR_CIDR` parameters.

```C
static int
bitmap_ip_uadt(struct ip_set *set, struct nlattr *tb[],
	       enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
{
        ...
	if (tb[IPSET_ATTR_IP_TO]) {
		ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);
		if (ret)
			return ret;
		if (ip > ip_to) {
			swap(ip, ip_to);
			if (ip < map->first_ip) // [1]
				return -IPSET_ERR_BITMAP_RANGE;
		}       
	} else if (tb[IPSET_ATTR_CIDR]) {
		u8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);
                ...
		ip_set_mask_from_to(ip, ip_to, cidr); // [2]
	} else {
		ip_to = ip;
	}

	if (ip_to > map->last_ip) // [3]
		return -IPSET_ERR_BITMAP_RANGE;

	for (; !before(ip_to, ip); ip += map->hosts) { // [4]
		e.id = ip_to_id(map, ip);
		ret = adtfn(set, &e, &ext, &ext, flags);
```

When `tb[IPSET_ATTR_IP_TO]` is not present but `tb[IPSET_ATTR_CIDR]` exists, `ip` and `ip_to` calculated via `ip_set_mask_from_to` based on `tb[IPSET_ATTR_CIDR]`. It's possible to have `ip` less than the actual `map->first_ip` and there's no check of `ip` after that. Therefore, the loop at [4] can proceed outside range ip that allocated (`map->first_ip` until `map->last_ip`).


# Primitives
## OOB Write to Kernel Heap Leak

`adtfn` will resolve to `bitmap_ip_add` function (defined as `mtype_add` in `net/netfilter/ipset/ip_set_bitmap_gen.h`). It will fetch extension `x` from `map->extensions` with `e.id` as index.
```c
#define get_ext(set, map, id)	((map)->extensions + ((set)->dsize * (id)))

static int
mtype_add(struct ip_set *set, void *value, const struct ip_set_ext *ext,
	  struct ip_set_ext *mext, u32 flags)
{
	struct mtype *map = set->data;
	const struct mtype_adt_elem *e = value;
	void *x = get_ext(set, map, e->id);
	int ret = mtype_do_add(e, map, flags, dsize: set->dsize);
```
`e.id` comes from `ip_to_id` from previous function, if we craft such `id` it can lead to out-of-bounds later when that function perform on `x`.
```c
static u32
ip_to_id(const struct bitmap_ip *m, u32 ip)
{
	return ((ip & ip_set_hostmask(m->netmask)) - m->first_ip) / m->hosts;
}
```

By crafting `e.id` it can lead OOB write, for example when we set the comment in sets, it can spill the kernel heap address in the next chunk because `comment` in `ip_set_init_comment` is outside the range. 
```c
static int
mtype_add(struct ip_set *set, void *value, const struct ip_set_ext *ext,
	  struct ip_set_ext *mext, u32 flags)
{
	struct mtype *map = set->data;
	const struct mtype_adt_elem *e = value;
	void *x = get_ext(set, map, e->id);
	...
	if (SET_WITH_COMMENT(set))
		ip_set_init_comment(set, ext_comment(x, set), ext);
}
ip_set_init_comment(struct ip_set *set, struct ip_set_comment *comment,
		    const struct ip_set_ext *ext)
{
	...
	c = kmalloc(size: sizeof(*c) + len + 1, GFP_ATOMIC);
	...
	rcu_assign_pointer(comment->c, c);
}
```
This is the path that we used to leak kernel heap addr, by shaping heap to `..[skbuff][extensions][skbuff][skbuff]..` the OOB write of kernel addr will spilled to the next chunk which is socket buffer. By receiving socket buffer, it can contain kernel heap address so we can use it for the next step exploitation.

## OOB Write Arbitrary Value
Another type of OOB that we can use is OOB write with arbitrary value. This works using set that contain `counter`.
```c
static inline void
ip_set_init_counter(struct ip_set_counter *counter,
		    const struct ip_set_ext *ext)
{
	if (ext->bytes != ULLONG_MAX)
		atomic64_set(v: &(counter)->bytes, i: (long long)(ext->bytes));
	if (ext->packets != ULLONG_MAX)
		atomic64_set(v: &(counter)->packets, i: (long long)(ext->packets));
}
static int
mtype_add(struct ip_set *set, void *value, const struct ip_set_ext *ext,
	  struct ip_set_ext *mext, u32 flags)
{
	struct mtype *map = set->data;
	const struct mtype_adt_elem *e = value;
	void *x = get_ext(set, map, e->id);
	...
	if (SET_WITH_COUNTER(set))
		ip_set_init_counter(ext_counter(x, set), ext);
}
```
We can craft the value in `ext->bytes` or `ext->packets` then it will set to the outside the bounds of allocated heap chunk.

## OOB Write to Use-After-Free

# ROP Chain
