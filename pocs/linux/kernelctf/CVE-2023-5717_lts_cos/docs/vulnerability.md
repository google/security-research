There is a heap OOB write in Performance Events in `perf_read_group()`, which is reached when `read()` is called on an event created with the `PERF_FORMAT_GROUP` flag set in its `read_format` attribute.

`perf_read_group()` allocates a buffer using the passed event's `read_size`, then fills it by iterating over the event's `sibling_list` and its children's `sibling_list`s. If a child event has a larger `siblig_list` than the parent, it will overflow the allocated buffer. Memory after the end of the buffer will be incremented and possibly written to depending on the event's `read_format`.

This can be achieved by racing `perf_read_group()` with `perf_release_kernel()`, which is called when the last reference to an event's file descriptor is closed. `perf_release_kernel()` will first remove an event from its `sibling_list`, then release all locks before removing the children from their `sibling_list`s. This leaves a window during which the children's `sibling_list`s are longer than the parent's. If `perf_read_group()` is run on another event in the group during this window, the buffer overflow described above will happen.

Steps to trigger the vulnerability:

- Create a group of events with the `PERF_FORMAT_GROUP` flag set in their read_format attribute and their inherit attribute set to 1.
- Create a separate event with `inherit` set to 0. This will prevent the kernel from doing an optimization that makes the vulnerability harder to trigger.
- Fork off a thread from the monitored process. This will create the inherited group of child events.
- Call `read()` on one event in the group and `close()` on another.
- Repeat until successful.

The vulnerability was fixed in` 32671e3799ca ("perf: Disallow mis-matched inherited group reads")` in version 6.5.9. This commit says the bug was introduced with `fa8c269353d5 ("perf/core: Invert perf_read_group() loops")` in version 4.4 (back ported to 3.16). However the method for exploiting it described above relies on a later commit which reworked `perf_release_kernel()` (`commit c6e5b73242d2 ("perf: Synchronously clean up child events")` from version 4.5), and there may not be a way to exploit it earlier than this.

The vulnerability can be prevented by blocking the perf_event_open() syscall.