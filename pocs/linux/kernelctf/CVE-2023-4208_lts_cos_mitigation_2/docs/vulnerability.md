## Requirements to trigger the vulnerability

- CAP_NET_ADMIN in a namespace is required
- Kernel configuration: CONFIG_NET_CLS_U32
- User namespaces required: Yes

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=de5df63228fcfbd5bb7fd883774c18fec9e61f12

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3044b16e7c6fe5d24b1cdbcf1bd0a9d92d1ebd81

## Affected kernel versions

Introduced in 3.18. Fixed in 6.5, 6.1.44, 5.15.125 and other stable trees.

## Affected component, subsystem

net/sched: cls_u32

## Description

When u32_change() is called on an existing filter, the new object is allocated using u32_init_knode() and then u32_set_parms() is called on it:
```
...
                new = u32_init_knode(net, tp, n);
                if (!new)
                        return -ENOMEM;

                err = u32_set_parms(net, tp, base, new, tb,
                                    tca[TCA_RATE], flags, new->flags,
                                    extack);
...
```

u32_init_knode() copies data from the existing "n" filter, including the .res pointer:

```
static struct tc_u_knode *u32_init_knode(struct net *net, struct tcf_proto *tp,
                                         struct tc_u_knode *n)
{
...
        new = kzalloc(struct_size(new, sel.keys, s->nkeys), GFP_KERNEL);
        if (!new)
                return NULL;

...
[1]     new->res = n->res;
```


The copied data includes a "res" field which is a tcf_result structure containing a pointer to the target class of a given filter.

u32_set_parms() calls tcf_bind_filter() if TCA_U32_CLASSID is set:
```
        if (tb[TCA_U32_CLASSID]) {
                n->res.classid = nla_get_u32(tb[TCA_U32_CLASSID]);
[2]             tcf_bind_filter(tp, &n->res, base);
        }
```



tcf_bind_filter() calls .bind_tcf handler on the target class, but if n->res.class was already set it also calls .unbind_tcf on it:

```
static inline void
__tcf_bind_filter(struct Qdisc *q, struct tcf_result *r, unsigned long base)
{
        unsigned long cl;

        cl = q->ops->cl_ops->bind_tcf(q, base, r->classid);
        cl = __cls_set_class(&r->class, cl);
        if (cl)
[3]                q->ops->cl_ops->unbind_tcf(q, cl);
}
```


.bind_tcf/.unbind_tcf for most classful qdiscs just increase/decrease filter_cnt counter, which serves as a protection against class being destroyed, e.g.:
```
static void drr_unbind_tcf(struct Qdisc *sch, unsigned long arg)
{
        struct drr_class *cl = (struct drr_class *)arg;

        cl->filter_cnt--;
}

static int drr_delete_class(struct Qdisc *sch, unsigned long arg,
                            struct netlink_ext_ack *extack)
{
        struct drr_sched *q = qdisc_priv(sch);
        struct drr_class *cl = (struct drr_class *)arg;

        if (cl->filter_cnt > 0)
                return -EBUSY;
...
```

Finally, when the change of the existing filter is successful,  tcf_unbind_filter() is called on the old filter in u32_change():
```
...
                u32_replace_knode(tp, tp_c, new);
[4]             tcf_unbind_filter(tp, &n->res);
                tcf_exts_get_net(&n->exts);
                tcf_queue_work(&n->rwork, u32_delete_key_work);
                return 0;
...
```




This leads to a use-after-free (dangling res.class pointer) in two scenarios:

#### Scenario 1

u32_change() is called on the filter with an already bound target class "c1" and there is no TCA_U32_CLASSID in the new parameters.
tcf_unbind_filter() is called on the old filter in [4].
filter_cnt of the class "c1" is decreased and it is possible to delete it, however the to the class c1 was copied to fnew in [1] and is still set 
in the new version of the filter.


#### Scenario 2

u32_change() is called on the filter with an already bound target class "c1", there is a TCA_U32_CLASSID in the new parameters, but it is set to the different class "c2"
Class "c1" is also bound to another filter "f2", so its filter_cnt is 2 at the start.

tcf_bind_filter() is called in [2] leading to the unbind_tcf call [3] on the "c1" class. filter_cnt of "c1" is now 1.
Finally, tcf_unbind_filter() is called in [4] leading to the second unbind_tcf on the "c1" class.
This sets the filter_cnt of the "c1" to 0, allowing it to be destroyed, but it is still bound to the "f2" filter.

