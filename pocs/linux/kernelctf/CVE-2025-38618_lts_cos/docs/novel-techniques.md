FUSE or userfaultfd have been used to force an access to user memory in the kernel to fault and sleep for a controlled amount of time, making some race conditions easier to exploit. Neither of these methods are available in kernelCTF, but the `fallocate()` syscall lets us do something similar. When called with the `FALLOC_FL_PUNCH_HOLE` flag, `fallocate()` will deallocate the space used by a given file in the filesystem. If the file is memory-mapped, accesses to the memory map will fault and sleep until the deallocation finishes.

 By creating and deallocating a sufficiently large file, we can control approximately how long a user memory access will sleep for. There is an upper bound set by the maximum size of a file in the file system. On kernelCTF we can create a 20MB large temporary file.