It is possible for `vsock_bind()` to bind a stream vsock socket to the port `VMADDR_PORT_ANY`,  which is otherwise used to indicate that the socket is currently unbound. We can then successfully `connect()` to `VMADDR_PORT_ANY` from another vsock and cause `accept()` on the buggy vsock to return a peer vsock which also has port `VMADDR_PORT_ANY`. Calling `bind()` on this peer vsock results in an unnecessary refcount decrement leading to a use-after-free on the underlying `vsock_sock`. This bug was present since the introduction of VSOCK in version `3.9` and was fixed with commit `aba0c94f61ec ("vsock: Do not allow binding to VMADDR_PORT_ANY")` in version `6.16`.

The vulnerability occurs in the autobinding section of `__vsock_bind_connectible()`, which can be reached by setting `svm_port = VMADDR_PORT_ANY` in `bind()`:

```
static int __vsock_bind_connectible(struct vsock_sock *vsk,
                    struct sockaddr_vm *addr)
{
    static u32 port;
    struct sockaddr_vm new_addr;

    if (!port)
        port = get_random_u32_above(LAST_RESERVED_PORT);

    vsock_addr_init(&new_addr, addr->svm_cid, addr->svm_port);

    if (addr->svm_port == VMADDR_PORT_ANY) {
        bool found = false;
        unsigned int i;

        for (i = 0; i < MAX_PORT_RETRIES; i++) {
            if (port <= LAST_RESERVED_PORT)
                port = LAST_RESERVED_PORT + 1;

            new_addr.svm_port = port++;

            if (!__vsock_find_bound_socket(&new_addr)) {
                found = true;
                break;
            }
        }

        if (!found)
            return -EADDRNOTAVAIL;
    } else {
        /* ... */
    }

    vsock_addr_init(&vsk->local_addr, new_addr.svm_cid, new_addr.svm_port);

    /* Remove connection oriented sockets from the unbound list and add them
     * to the hash table for easy lookup by its address.  The unbound list
     * is simply an extra entry at the end of the hash table, a trick used
     * by AF_UNIX.
     */
    __vsock_remove_bound(vsk);
    __vsock_insert_bound(vsock_bound_sockets(&vsk->local_addr), vsk);

    return 0;
}
```
The static variable `port` will be assigned (if available) to the socket  and incremented. It is possible to increment `port` up to `VMADDR_PORT_ANY` by calling `bind()` enough times. The next socket we autobind will then be put on the bound list with port `VMADDR_PORT_ANY`. 

To exploit the vulnerability, we call `connect()` on another vsock with target port `VMADDR_PORT_ANY` and target cid `VM_CID_LOCAL`. This will result in `virtio_transport_recv_pkt()` being scheduled on the `vsock_loopback` work queue. As long as the buggy socket was bound with cid `VM_CID_LOCAL`, `virtio_transport_recv_pkt()` will find it on the list of bound sockets. If the buggy socket is in state `TCP_LISTEN`, a peer vsock with port `VMADDR_PORT_ANY` will be created in `virtio_transport_recv_listen()` to accept the connection. This socket will be assigned to the file descriptor returned by calling `accept()` on the buggy socket.

Unlike vsocks created through `socket()`, the vsock returned by `accept()` is not put on the list of unbound sockets when created. Placing a socket on this list takes a reference count which is released when the socket is bound in `__vsock_bind_connectible()`. If we can successfully bind the peer vsock, there will be an unnecessary refcount decrement when `vsock_bind_connectible()` attempts to remove it from the unbound list. Normally this would be impossible since it was already bound in `virtio_transport_recv_listen()`, but our vsock bypasses the `vsock_addr_bound()` check by having port `VMADDR_PORT_ANY`.

The requirement that the buggy socket be in state `TCP_LISTEN` complicates exploitation as `listen()` will return an error when called on a vsock with port `VMADDR_PORT_ANY`. The vulnerability can still be exploited by rebinding the buggy socket to a legitimate port and calling `listen()` on it in the window between the socket being retrieved in `virtio_transport_recv_pkt()` and its state being checked.

