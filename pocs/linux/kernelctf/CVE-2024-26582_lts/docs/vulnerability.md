## Requirements to trigger the vulnerability

- Kernel configuration: CONFIG_TLS and one of [CONFIG_CRYPTO_PCRYPT, CONFIG_CRYPTO_CRYPTD]
- User namespaces required: no

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fd31f3996af2627106e22a9f8072764fede51161

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=32b55c5ff9103b8508c1e04bfa5a08c64e7a925f

## Affected kernel versions

Introduced in 6.0. Fixed in 6.1.78 and other stable trees.

## Affected component, subsystem

net/tls

## Description

When TLS decryption is used in async mode tls_sw_recvmsg() tries to use a zero-copy mode if possible, but this only works if the caller has enough space to receive the entire cleartext message.
For partial reads a clear text skb is allocated in tls_decrypt_sg() instead.

Pointers to physical pages backing this skb are then copied into the sgvec passed to tls_do_decryption(), but reference count is not increased on these pages.

The skb is then added to the rx_list queue.

After decryption is finished, tls_decrypt_done() calls put_page() on these pages, triggering their release, but they are still referenced in the skb in the rx_list queue.

When another tls_sw_recvmsg() call is made on the same socket use-after-free happens, with data being read from the released physical pages backing the skb and when all data has been read, double-free happens, as consume_skb() tries to release the already released physical pages.
