# Vulnerability Details

- **Requirements**:
    - **Capabilities**: None
    - **Kernel configuration**: `CONFIG_TLS=y`, `CONFIG_CRYPTO_CRYPTD=y`
    - **User namespaces required**: No
- **Introduced by**: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=13114dc5543069f7b97991e3b79937b6da05f5b0
- **Fixed by**: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=41532b785e9d79636b3815a64ddf6a096647d011
- **Affected Version**: `6.1.84 - 6.1.148`
- **Affected Component**: `net/tls`
- **Syscall to disable**: `setsockopt(SOL_TLS)`
- **Cause**: Race Condition / Use-After-Free
- **Description**: A race condition exists in net/tls when TLS is configured to operate synchronously, but the crypto request is handled asynchronously by cryptd. In this case the request is enqueued on a per-CPU queue and crypto_aead_decrypt() in tls_do_decryption() returns -EINPROGRESS. The TLS path assumes the operation completed and proceeds to free the object. However, the structure is still accessible in the cryptd queue and when it is dequeued by the crypto worker, a UAF occurs. The vulnerability was implicitly fixed by commit 41532b785e9d79636b3815a64ddf6a096647d011 and backported to 6.6, but was never backported to 6.1.

# Vulnerability Analysis

A race condition and subsequent Use-After-Free can occur in the net/tls subsystem when TLS is configured to operate synchronously (for example, when [TLS 1.3 is used](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L2918)), but the crypto request is handled by [cryptd](https://cateee.net/lkddb/web-lkddb/CRYPTO_CRYPTD.html), the Linux kernel asynchronous crypto daemon.

We can follow the [tls_sw_recvmsg()](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L2060) path ([tls_sw_recvmsg()](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L2060) -> [tls_decrypt_sw()](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L1744) -> [tls_decrypt_sg()](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L1571)) to see what happens when `tls_decrypt_sg()` is called: 

```c
static int tls_decrypt_sg(struct sock *sk, struct iov_iter *out_iov,
			  struct scatterlist *out_sg,
			  struct tls_decrypt_arg *darg)
{
	// [...]

	aead_size = sizeof(*aead_req) + crypto_aead_reqsize(ctx->aead_recv);
	aead_size = ALIGN(aead_size, __alignof__(*dctx));
	mem = kmalloc(aead_size + struct_size(dctx, sg, size_add(n_sgin, n_sgout)),
		      sk->sk_allocation); // [1]
	if (!mem) {
		err = -ENOMEM;
		goto exit_free_skb;
	}

	aead_req = (struct aead_request *)mem;

	// [...]

	err = tls_do_decryption(sk, sgin, sgout, dctx->iv,
				data_len + prot->tail_size, aead_req, darg); // [2]
	if (err) {
		if (darg->async_done)
			goto exit_free_skb;
		goto exit_free_pages;
	}

	// [...]

exit_free_pages:
	for (; pages > 0; pages--)
		put_page(sg_page(&sgout[pages]));
exit_free:
	kfree(mem); // [3]
exit_free_skb:
	consume_skb(clear_skb);
	return err;
}
```

A crypto request [is allocated](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L1624) in [tls_decrypt_sg()](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L1571). `[1]`

The object is passed to [tls_do_decryption()](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L251) to perform synchronous decryption (in this example, TLS 1.3 is used, so the TLS RX context is [not async-capable](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L2918)) `[2]`

However, if the kernel is configured to use the cryptd daemon for AEAD requests, [crypto_aead_decrypt()](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/aead.c#L99) will call [cryptd_aead_enqueue()](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/cryptd.c#L767) which in turn calls [cryptd_enqueue_request()](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/cryptd.c#L130) -> [crypto_enqueue_request()](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/algapi.c#L933). In this function the request [is enqueued](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/algapi.c#L949) on a per-CPU queue and -EINPROGRESS is returned.

Back in [tls_do_decryption()](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L282), `crypto_aead_decrypt()` returns -EINPROGRESS, and the function treats that as success and returns 0:

```c
// [...]

	ret = crypto_aead_decrypt(aead_req);
	if (ret == -EINPROGRESS)
		return 0;

// [...]
```

At this point the TLS path assumes the request is complete and the crypto request object [is freed](https://elixir.bootlin.com/linux/v6.1.148/source/net/tls/tls_sw.c#L1737). `[3]`
```
...
  tls_sw_recvmsg()
    tls_decrypt_sw()
      tls_decrypt_sg()
        req = kmalloc() // alloc aead req
        tls_do_decryption(req)
           crypto_aead_decrypt(req)
             cryptd_aead_enqueue(req)
               cryptd_enqueue_request(req)
                 crypto_enqueue_request(req) // request enqueued, returns -EINPROGRESS

		// TLS assumes the decryption operation completed
		
		...

        kfree(req) // The request is freed but still in the cryptd queue
```

The problem arises because the request is still accessible in the cryptd [per-CPU queue](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/cryptd.c#L167).

```c
static void cryptd_queue_worker(struct work_struct *work)
{
	struct cryptd_cpu_queue *cpu_queue;
	struct crypto_async_request *req, *backlog;

	cpu_queue = container_of(work, struct cryptd_cpu_queue, work);

	local_bh_disable();
	backlog = crypto_get_backlog(&cpu_queue->queue);
	req = crypto_dequeue_request(&cpu_queue->queue); // [1]
	local_bh_enable();
	
	// [...]

	req->complete(req, 0); // [3]

	// [...]
}
```

```c
struct crypto_async_request *crypto_dequeue_request(struct crypto_queue *queue)
{
	struct list_head *request;

	// [...]

	request = queue->list.next;
	list_del(request); // [2]

	return list_entry(request, struct crypto_async_request, list);
}
```

After rescheduling, [cryptd_queue_worker()](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/cryptd.c#L162) is called. This, in turn, calls [crypto_dequeue_request()](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/cryptd.c#L162) to retrieve the request from the per‑CPU queue. `[1]`

The request [is unlinked](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/algapi.c#L980) from the per-CPU queue and returned, but because the object has already been freed, a use‑after‑free occurs.

The freed object is then returned to `cryptd_queue_worker()`. Here, the [req->complete()](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/cryptd.c#L181) function pointer ([cryptd_aead_decrypt()](https://elixir.bootlin.com/linux/v6.1.148/source/crypto/cryptd.c#L757)) is called to perform decryption, causing the second UAF.

```
...
  cryptd_queue_worker()
    crypto_dequeue_request()
	  req = queue->list.next;
      list_del(req); // UAF
	...
    req->complete(req, 0); // UAF  
```

Since the `crypto_async_request` object is freed at this point, an attacker can exploit the race condition to replace `req->complete()` with a ROP-gadget and hijack control flow when the corrupted function pointer is called by the cryptd worker.

The vulnerability was implicitly fixed by commit 41532b785e9d79636b3815a64ddf6a096647d011 and backported to 6.6, but was never backported to 6.1.