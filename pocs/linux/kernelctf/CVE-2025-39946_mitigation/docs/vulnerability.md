# CVE-2025-39946

- Requirements: 
    - Kernel configuration CONFIG_TLS
- Introduced by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=84c61fe1a75b4255df1e1e7c054c9e6d048da417
- Fixed by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0aeb54ac4cd5cf8f60131b4d9ec0b6dc9c27b20d
- Affected Versions: 6.0-rc1 - 6.17-rc7
- URL: https://www.cve.org/CVERecord?id=CVE-2025-39946

In the kernel TLS implementation an issue was found when processing invalid
TLS records under network pressure. This behavior can be achieved
deterministically by forcing short reads via out-of-band data. The kernel
test case demonstrates this:

```c
TEST_F(tls_err, oob_pressure)
{
    char buf[1<<16];
    int i;

    memrnd(buf, sizeof(buf));

    EXPECT_EQ(send(self->fd2, buf, 5, MSG_OOB), 5);
    EXPECT_EQ(send(self->fd2, buf, sizeof(buf), 0), sizeof(buf));
    for (i = 0; i < 64; i++)
        EXPECT_EQ(send(self->fd2, buf, 5, MSG_OOB), 5);
}
```

The problem manifests in the `tls_strp_copyin_frag` method. After entering
copy mode due to the initial short read and partially receiving the large
buffer, we continue to copy out chunks from said large buffer. Problem is
that TLS pre-allocated the `skb_shinfo(frags)` for only a fixed (small) TLS
record and fails to check whether the available fragments are already
exhausted ([1]). It then continues to copy the incoming data ([2]).
Finally, parsing the TLS header in `tls_rx_msg_size` is made to fail
returning an invalid size. This causes the copy loop to abort, however
fails to abort the full message ([3]). A following read triggered by other
incoming OOB messages forces reentry into `tls_strp_copyin_frag` eventually
exhausting the available fragments causing reads of uninitialized data or
out-of-bounds reads on the skb_shared_info structure.

```c
static int tls_strp_copyin_frag(struct tls_strparser *strp, struct sk_buff *skb,
                struct sk_buff *in_skb, unsigned int offset,
                size_t in_len)
{
    size_t len, chunk;
    skb_frag_t *frag;
    int sz;

    frag = &skb_shinfo(skb)->frags[skb->len / PAGE_SIZE]; // [1]

    len = in_len;
    /* First make sure we got the header */
    if (!strp->stm.full_len) {
        /* Assume one page is more than enough for headers */
        chunk =    min_t(size_t, len, PAGE_SIZE - skb_frag_size(frag));
        WARN_ON_ONCE(skb_copy_bits(in_skb, offset,
                       skb_frag_address(frag) +
                       skb_frag_size(frag),
                       chunk));  // [2]

        skb->len += chunk;
        skb->data_len += chunk;
        skb_frag_size_add(frag, chunk);

        sz = tls_rx_msg_size(strp, skb);
        if (sz < 0)
            return sz; // [3]
    /*...*/ 
```
