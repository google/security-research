# CVE-2025-39946

- Requirements: 
    - Kernel configuration CONFIG_TLS
- Introduced by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=84c61fe1a75b4255df1e1e7c054c9e6d048da417
- Fixed by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0aeb54ac4cd5cf8f60131b4d9ec0b6dc9c27b20d
- Affected Versions: 6.0-rc1 - 6.17-rc7
- URL: https://www.cve.org/CVERecord?id=CVE-2025-39946

In the kernel TLS implementation an issue was found when processing invalid
TLS records under network pressure. This behavior can be achieved
deterministically by forcing short reads via out-of-band data. The kernel
test case demonstrates this:

```c
TEST_F(tls_err, oob_pressure)
{
    char buf[1<<16];
    int i;

    memrnd(buf, sizeof(buf));

    EXPECT_EQ(send(self->fd2, buf, 5, MSG_OOB), 5);
    EXPECT_EQ(send(self->fd2, buf, sizeof(buf), 0), sizeof(buf));
    for (i = 0; i < 64; i++)
        EXPECT_EQ(send(self->fd2, buf, 5, MSG_OOB), 5);
}
```

The problem manifests in the `tls_strp_copyin_frag` method. After entering
copy mode due to the initial short read (which is not large enough for parsing
the tls message size just yet) and partially receiving the large buffer, we 
continue to copy out chunks from said large buffer. Problem is that TLS 
pre-allocated the `skb_shinfo->frags` for only a fixed (small) TLS record and 
fails to check whether the available fragments are already exhausted ([1]). 
It then continues to copy the incoming data ([2]) regardless.
Finally, parsing the TLS header in `tls_rx_msg_size` is made to fail
returning an invalid size. This causes the copy loop to abort ([3]), however
will not abort the full message (lower layer TCP receive is not interrupted). 
A following read triggered by other incoming OOB messages forces reentry into 
`tls_strp_copyin_frag` eventually exhausting the available fragments initialized 
causing reads of uninitialized data or out-of-bounds reads after the 
`skb_shared_info` structure. 
Since fragments are basically raw pages, this indirectly yields a page write 
primitive via uninitialized fragments ([2]) or potentially crafted out-of-bounds 
fragments.

```c
static int tls_strp_copyin_frag(struct tls_strparser *strp, struct sk_buff *skb,
                struct sk_buff *in_skb, unsigned int offset,
                size_t in_len)
{
    size_t len, chunk;
    skb_frag_t *frag;
    int sz;

    frag = &skb_shinfo(skb)->frags[skb->len / PAGE_SIZE]; // [1]

    len = in_len;
    /* First make sure we got the header */
    if (!strp->stm.full_len) {
        /* Assume one page is more than enough for headers */
        chunk =    min_t(size_t, len, PAGE_SIZE - skb_frag_size(frag));
        WARN_ON_ONCE(skb_copy_bits(in_skb, offset,
                       skb_frag_address(frag) +
                       skb_frag_size(frag),
                       chunk));  // [2]

        skb->len += chunk;
        skb->data_len += chunk;
        skb_frag_size_add(frag, chunk);

        sz = tls_rx_msg_size(strp, skb);
        if (sz < 0)
            return sz; // [3]
    /*...*/ 
```
