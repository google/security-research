# CVE-2023-52927

This documentation briefly describe the exploit. For more technical details, please look at the exploit source code.

In order to trigger the vulnerability, `CAP_NET_ADMIN` is required. We can use a namespace sandbox in order to achieve this condition.
Also for all allocations in the kernel heap we make do not span over multiple percpu slabs, we will pin our process to a single CPU.

## Triggering the vulnerability

We aim to pass a packet through the `nft_ct_set_zone_eval()` function to attach a `template nf_conn`, and then through `nf_nat_setup_info()` to link this `template nf_conn` to the `nf_nat_bysource` hash table.

The `nft_ct_set_zone_eval()` function can attach one of two types of `template nf_conn` to a packet:
- per-cpu template: Pre-allocated when initializing this expression.
- temporary template: allocated and used when the per-cpu template is busy.

The temporary `template nf_conn` is easier to free because it has `refcnt = 1` after being attached to the packet. Simply dropping the packet is enough to trigger function `nf_ct_destroy()` to free the `template nf_conn`.

To force the use of the temporary template, we first consume the per-cpu template with one packet, then queue that packet to userspace using the `nf_queue` module.

To carry the `template nf_conn` from `nft_ct_set_zone_eval()` to `nf_nat_setup_info()`, we register a series of callback functions to Netfilter hooks as follows:
- Create a base chain at the `NF_INET_LOCAL_OUT` hook with priority `NF_IP_PRI_CONNTRACK - 1`, containing a rule with the notrack expression.
- Create a base chain at the `NF_INET_LOCAL_OUT` hook with priority `NF_IP_PRI_CONNTRACK + 1`, containing a rule with the `nft_ct_set_zone_ops` expression.
    + The init function of this expression calls `nf_ct_netns_get()`, which registers `ipv4_conntrack_local()` callback at `NF_INET_LOCAL_OUT` hook with fixed priority `NF_IP_PRI_CONNTRACK`.
- Create a base NAT chain at any hook. The `nf_nat_ipv4_register_fn()` function is invoked to register `nf_nat_ipv4_out()` callback at `NF_INET_POST_ROUTING` hook with fixed priority `NF_IP_PRI_NAT_SRC`.

After all callback functions are registered, the Netfilter hook looks like this:

| **Callback**                                          | **Priority**                  |
| ----------------------------------------------------- | ----------------------------- |
| **Callbacks at `NF_INET_LOCAL_OUT` hook:**            |                               |
| `nft_notrack_eval()` (from notrack expression)        | `NF_IP_PRI_CONNTRACK - 1`     |
| `nf_conntrack_in()` (from `ipv4_conntrack_local()`)   | `NF_IP_PRI_CONNTRACK` (fixed) |
| `nft_ct_set_zone_eval()` (from `nft_ct_set_zone_ops`) | `NF_IP_PRI_CONNTRACK + 1`     |
| **Callbacks at `NF_INET_POST_ROUTING` hook:**         |                               |
| `nf_nat_setup_info()` (from `nf_nat_ipv4_out()`)      | `NF_IP_PRI_NAT_SRC` (fixed)   |


A packet that passes through `nft_notrack_eval()` will not be assigned a normal `nf_conn` by `nf_conntrack_in()`. Only packets without any `nf_conn` can get a `template nf_conn` from `nft_ct_set_zone_eval()`. \
We can't register `nft_ct_set_zone_eval()` before `nf_conntrack_in()`, because `nf_conntrack_in()` will replace the `template nf_conn` with a normal one.

Finally, by sending a packet, we can link a `template nf_conn` (from `nft_ct_set_zone_eval()`) to the `nf_nat_bysource` hash table. When the packet is dropped, a dangling pointer is left in the hash table.

## Leak kernel heap address

After the first `template nf_conn` is freed and left dangling in the `nf_nat_bysource` hash table, we link a second `template nf_conn` to the hash table to trigger a UAF write:

The address of `nat_bysource.next` field (offset `0x90`) of the second `template nf_conn` is written into `nat_bysource.pprev` field (offset `0x98`) of the freed chunk previously used by the first `template nf_conn`.

To exploit this UAF write, we need to reclaim the freed chunk with other object before triggering the UAF write.

We will use `nft_rule` as the spraying object to reclaim the freed chunk because:

- It is an elastic object so we can attack many caches (`kmalloc-cg-*`)
- The elastic portion are flattened expression array (up to 128 expressions) and arbitrary user data (up to 255 bytes)

But `template nf_conn` is allocated in `kmalloc-256`, so we use cross-cache technique to able to reclaim with `nft_rule`.

We construct `nft_rule` objects that contain one `nft_log` expression, padded with several `notrack` expressions to align the `prefix` field of `nft_log` with offset `0x98` in the chunk. And with some user data at the end so that to total length of the `nft_rule` struct is in range 193-256 bytes.

After spraying, we reclaim the freed chunk with one of our crafted `nft_rule` objects. Then we trigger the UAF write by linking the second `template nf_conn` into the hash table. As a result:

- The `prefix` field of the `nft_log` expression inside the `nft_rule` is overwritten with the address of `nat_bysource.next` field of the second `template nf_conn`.
- The `nat_bysource.next` of the second `template nf_conn` is pointing back to the `nft_rule`, forming a circular link.

By dumping all the `nft_rule` objects used for spraying, we can obtain:
- The address of the `nft_rule` that reclaimed the freed chunk used by the first `template nf_conn`.
- The handle of the `nft_rule` reclaimed the chunk.

## Leak kernel base address

Now that we have a heap leak and the `prefix` field is overwritten with the address the second `template nf_conn`, we can proceed to leak the kernel base address.

By deleting the `nft_rule` using its handle, the kernel will call `kfree(prefix)`, freeing the second `template nf_conn`. We can then reclaim this freed chunk and place a fake `nf_conn` there.

To leak a kernel address, we take control of the `ext` field in the second `template nf_conn`.

```c
struct nf_conn {
	// [skipped]

	/* Extensions */
	struct nf_ct_ext *ext;

	// [skipped]
};
```

The `struct nf_ct_ext` is used by `nf_conn` to store optional data:
```c
/* Extensions: optional stuff which isn't permanently in struct. */
struct nf_ct_ext {
	u8 offset[NF_CT_EXT_NUM];
	u8 len;
	unsigned int gen_id;
	char data[] __aligned(8);
};
```

There are `NF_CT_EXT_NUM` types of optional data. These optional data are stored in the `data` field, and each type is accessed using the corresponding offset stored in the `offset` array. The offset is relative to the start of `struct nf_ct_ext`:

```c
/* Use nf_ct_ext_find wrapper. This is only useful for unconfirmed entries. */
void *__nf_ct_ext_find(const struct nf_ct_ext *ext, u8 id)
{
	unsigned int gen_id = atomic_read(&nf_conntrack_ext_genid);
	unsigned int this_id = READ_ONCE(ext->gen_id);

	if (!__nf_ct_ext_exist(ext, id))
		return NULL;

	if (this_id == 0 || ext->gen_id == gen_id)
		return (void *)ext + ext->offset[id];

	return NULL;
}
```
One useful extension type is `NFT_CT_LABELS`:

```c
struct nf_conn_labels {
	unsigned long bits[NF_CT_LABELS_MAX_SIZE / sizeof(long)]; // NF_CT_LABELS_MAX_SIZE = 16
};
```

This is a 16-byte structure. Userspace can read and write this data.

To leak the kernel base address, we follow these three steps:

**Step 1: Reclaim the freed `nft_rule`**

We need reclaim the deleted `nft_rule`, since it is the only chunk whose address we already know. This time we spray using `userdata` of `nft_table`. We can store at most 256 bytes of arbitrary data.

Adjacent to this chunk in slab is another `nft_rule` object. So we place the fake `ext` metadata at the bottom of the chunk, right before the adjacent `nft_rule`. This fake `ext` is crafted with the offset for `NFT_CT_LABELS` pointing to the `nft_notrack_ops` inside the adjacent `nft_rule` (`nft_notrack_ops` was used as padding for `nft_log`).

**Step 2: Reclaim the second `template nf_conn` with a fake one**

Again, we use cross-cache to reclaim `template nf_conn` with object from another cache.

Since the `prefix` field points to the middle of the second `template nf_conn`, the chunk that gets freed consists of the bottom half of the second `template nf_conn` and the top half of the adjacent chunk. However, once the slab is recycled by the buddy allocator, the freelist is refreshed. This allows us to reclaim the entire chunk from the beginning.

We spray using `userdata` of `nft_table`, placing the address of the fake `ext` at the correct offset within our fake `nf_conn`.

**Step 3: Leak the kernel address**

After the `ext` pointer in the second `template nf_conn` points to our fake `ext`, we queue the packet associated with this `nf_conn` to userspace using `nf_queue`.

Userspace can then read the connlabel data, which now overlaps with `nft_notrack_ops`.

## RIP control and return to userspace

Userspace can update the connlabel data of a queued packet. This allows us to overwrite the contents of an adjacent chunk.

The address of this adjacent chunk can be calculated based on the previously leaked heap address.

We first delete the adjacent `nft_rule` then spray another `nft_rule`. This `nft_rule` includes `nft_notrack_ops` just like before, but this time, we place JOP gadget and ROP chain at the user data space.

We build a ROP chain that do `commit_creds(&init_cred)`, `switch_task_namespaces(find_task_by_vpid(getpid()), &init_nsproxy)` then return to userspace.

Next we update connlabel to overwrite the `nft_notrack_ops` pointer of the adjacent `nft_rule`. We need to align `ops->deactivate` with the JOP gadget.

After overwrite the ops pointer, we delete all the rule we used to spray, including the adjacent `nft_rule`. The adjacent `nft_rule` will be deactivated and the fake expression's `deactivate` routine will be called, which will trigger the JOP gadget then the ROP chain.

Returning to userspace, we use `setns` to escape from the jail then spawn a root shell using `execve`.
