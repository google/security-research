- Requirements:
    - Capabilities: CAP_NET_ADMIN
    - Kernel configuration: CONFIG_NET_SCHED=y
    - User namespaces required: Yes
- Introduced by: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
- Fixed by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bc50835e83f60f56e9bec2b392fb5544f250fb6f
- Affected Version: 2.6.12-rc2 - v6.12
- Affected Component: tc
- URL: https://www.cve.org/CVERecord?id=CVE-2025-21700
- Cause: Use-After-Free


In the tc subsystem an issue may arise when grafting a qdisc from one parent class
to another parent, because the kernel does not expect such behaviour.
Therefor this can lead to all sorts of issues. One example, which we will be abusing
here, is backlog adjustment, which in turn can lead to use-after-frees for the
parent.

Consider the following example qdisc structure:
```
        DRR (TC_H_ROOT)
         /    |    \
        /     |     \
       a      b      c ...
      DRR
       |
       aa
      FIFO
```

When grafting FIFO with parent class `aa` to `b`, via `RTM_NEWQDISC` and `NLM_F_REPLACE`,
we will hit the "graft" path in `tc_modify_qdisc()` in `net/sched/sch_api.c`,
eventually calling `qdisc_graft()`. Since a parent is present, the grafting logic
is fully delegated to the individual qdisc class ops with `cops->graft()`. The
typical implementation of this function will just call `qdisc_replace()` with the
incoming new qdisc.
Among other problems is that `sch->parent` is not properly fixed anywhere and thus
a stale parent id (i.e. `aa` in this case) is kept.

Consequently, notifications in `qdisc_tree_backlog()` can no longer be propagated
leading to f.e. use-after-frees (see [1]):
```c
void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
{
	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
	const struct Qdisc_class_ops *cops;
	unsigned long cl;
	u32 parentid;
	bool notify;
	int drops;

	if (n == 0 && len == 0)
		return;
	drops = max_t(int, n, 0);
	rcu_read_lock();
	while ((parentid = sch->parent)) {
		if (parentid == TC_H_ROOT)
			break;

		if (sch->flags & TCQ_F_NOPARENT)
			break;
		/* Notify parent qdisc only if child qdisc becomes empty.
		 *
		 * If child was empty even before update then backlog
		 * counter is screwed and we skip notification because
		 * parent class is already passive.
		 *
		 * If the original child was offloaded then it is allowed
		 * to be seem as empty, so the parent is notified anyway.
		 */
		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
						       !qdisc_is_offloaded);
		/* TODO: perform the search on a per txq basis */
		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
		if (sch == NULL) {                                           // [1]
			WARN_ON_ONCE(parentid != TC_H_ROOT);
			break;
		}
		cops = sch->ops->cl_ops;
		if (notify && cops->qlen_notify) {
			cl = cops->find(sch, parentid);
			cops->qlen_notify(sch, cl);
		}
		sch->q.qlen -= n;
		sch->qstats.backlog -= len;
		__qdisc_qstats_drop(sch, drops);
	}
	rcu_read_unlock();
}
```
