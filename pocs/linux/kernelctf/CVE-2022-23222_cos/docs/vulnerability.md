## Requirements to trigger the vulnerability

- Kernel configuration: CONFIG_BPF and CONFIG_BPF_SYSCALL
- User namespaces required: no

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=457f44363a8894135c85b7a9afd2bd8196db24ab

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64620e0a1e712a778095bd35cbb277dc2259281f

## Affected kernel versions

Introduced in 5.8. Fixed in 5.15.157 and other stable trees.

## Affected component, subsystem

bpf

## Description

Commit message explains the verifier issue well:

> Both bpf_ringbuf_submit() and bpf_ringbuf_discard() have ARG_PTR_TO_ALLOC_MEM
> in their bpf_func_proto definition as their first argument. They both expect
> the result from a prior bpf_ringbuf_reserve() call which has a return type of
> RET_PTR_TO_ALLOC_MEM_OR_NULL.
> 
> Meaning, after a NULL check in the code, the verifier will promote the register
> type in the non-NULL branch to a PTR_TO_MEM and in the NULL branch to a known
> zero scalar. Generally, pointer arithmetic on PTR_TO_MEM is allowed, so the
> latter could have an offset.
> 
> The ARG_PTR_TO_ALLOC_MEM expects a PTR_TO_MEM register type. However, the non-
> zero result from bpf_ringbuf_reserve() must be fed into either bpf_ringbuf_submit()
> or bpf_ringbuf_discard() but with the original offset given it will then read
> out the struct bpf_ringbuf_hdr mapping.
> 
> The verifier missed to enforce a zero offset, so that out of bounds access
> can be triggered which could be used to escalate privileges if unprivileged
> BPF was enabled (disabled by default in kernel).

bpf_ringbuf_submit() and bpf_ringbuf_discard() expect the argument to point to a valid ringbuf record and use it to calculate an address to a struct bpf_ringbuf_hdr without any further checks.

Because of the verifier bug described above we can cause bpf_ringbuf_submit()/bpf_ringbuf_discard() to interpret any data as bpf_ringbuf_hdr, causing out-of-bounds read/write issues leading to arbitrary code execution.

