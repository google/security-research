# CVE-2025-37890
## Overview
- Requirements:
    - Capabilites: CAP_NET_ADMIN
    - Kernel configuration: CONFIG_NET_SCHED=y CONFIG_NET_SCH_NETEM=y CONFIG_NET_SCH_HFSC=y
    - User namespaces required: Yes
- Introduced by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=37d9cf1a3ce35de3df6f7d209bfb1f50cf188cea  
- Fixed by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=141d34391abbb315d68556b7c67ad97885407547
- Affected Version: v5.0-rc3 - v6.15-rc4
- Affected Component: netfilter
- Syscall to disable: unshare
- URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-37890
- Cause: Improper Update of Reference Count
- Description: A use-after-free vulnerability in the Linux Kernel net scheduler subsystem can be exploited to achieve local privilege escalation. In the hfsc_enqueue routine, if the qdisc has a netem child, it is possible for the netem's re-entrant behaviour to doubly activate a child class. This corrupts internal tracking, leading to a use-after-free vulnerability. We recommend upgrading past commit 141d34391abbb315d68556b7c67ad97885407547.


## Analysis
There exists a race condition vulnerability between the net/sched prio and sfq scheduler. When reducing the number of bands in a prio qdisc, if one of the childs is a sfq qdisc, it is possible for duplicate decrease in qlen to be propagated up the tree. This can be abused to obtain a UAF on a parent hfsc scheduler. This UAF can be exploited to achieve LPE.

### Details
The vulnerability lies in the `netem_enqueue()` function when the netem qdisc is configured to duplicate incoming packets.
```c
	if (skb2) {
		struct Qdisc *rootq = qdisc_root_bh(sch);
		u32 dupsave = q->duplicate; /* prevent duplicating a dup... */

		q->duplicate = 0;
		rootq->enqueue(skb2, rootq, to_free);                                // [1]
		q->duplicate = dupsave;
		skb2 = NULL;
	}

	qdisc_qstats_backlog_inc(sch, skb);

	cb = netem_skb_cb(skb);

	if (q->gap == 0 ||		/* not doing reordering */
	    q->counter < q->gap - 1 ||	/* inside last reordering gap */
	    q->reorder < get_crandom(&q->reorder_cor, &q->prng)) {
			
		// [...]

		tfifo_enqueue(skb, sch);                                             // [2]
```

When the netem qdisc tries to duplicate a packet, it enqueues the packet into the root qdisc ([1]). This uses the synchronous enqueue function, where the duplicate packet is fed through the root qdisc, before it is directed back into the netem qdisc. Subsequently, `tfifo_enqueue()` is called at [2], which inserts the packet into the netem qdisc's internal queue and increases the qdisc's qlen. Crucially, the netem's qlen is only increased at [2].

A vulnerability exists when the netem qdisc is a child of a classful parent. Consider the qdisc hierarchy where the root qdisc is set as a hfsc qdisc, which has a netem qdisc as a child. In `hfsc_enqueue()`, there is first a check ([3]) if the child qdisc is empty. Then, it enqueues the packet into the child qdisc ([4]). After the enqueue succeeds, it activates the newly active child ([5]).

```c
	cl = hfsc_classify(skb, sch, &err);
	if (cl == NULL) {
		if (err & __NET_XMIT_BYPASS)
			qdisc_qstats_drop(sch);
		__qdisc_drop(skb, to_free);
		return err;
	}

	first = !cl->qdisc->q.qlen;                                              // [3]
	err = qdisc_enqueue(skb, cl->qdisc, to_free);                            // [4]
	if (unlikely(err != NET_XMIT_SUCCESS)) {
		if (net_xmit_drop_count(err)) {
			cl->qstats.drops++;
			qdisc_qstats_drop(sch);
		}
		return err;
	}

	if (first) {                                                             // [5]
		if (cl->cl_flags & HFSC_RSC)
			init_ed(cl, len);
		if (cl->cl_flags & HFSC_FSC)
			init_vf(cl, len);
		/*
		 * If this is the first packet, isolate the head so an eventual
		 * head drop before the first dequeue operation has no chance
		 * to invalidate the deadline.
		 */
		if (cl->cl_flags & HFSC_RSC)
			cl->qdisc->ops->peek(cl->qdisc);

	}
```

When the hfsc qdisc receives a packet to enqueue in an empty netem qdisc, `first = true` at [3] and the packet is enqueued in netem qdisc at [4]. In netem qdisc, `netem_enqueue()` is called, and the packet duplication ([1]) enqueues the packet in the root hfsc qdisc again, before it calls `tfifo_enqueue()` ([2]). So, when `hfsc_enqueue()` is called on the duplicate packet, the child netem qdisc still has `qlen = 0`. This results in `first = true` for the duplicate packet as well. Subsequently, both calls to `qdisc_enqueue()` ([4]) succeed and the new child activation occurs twice at [5].

This 're-entrant' behaviour is present in other classful qdiscs as well.

This bug can be used to manipulate classful qdisc's internal tracking and escalated into a LPE.