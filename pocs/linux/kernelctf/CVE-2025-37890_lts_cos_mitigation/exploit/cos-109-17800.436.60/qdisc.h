#ifndef PWN_QDISC_H
#define PWN_QDISC_H

char *PWN_TC_QDISC_INTERFACE = "lo";

int create_qdisc_pfifo(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "pfifo");

	return netlink_send(sock_fd, nlh);
}

int create_qdisc_hfsc(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "hfsc");

	struct tc_hfsc_qopt qopt = {};
	mnl_attr_put(nlh, TCA_OPTIONS, sizeof(qopt), &qopt);

	return netlink_send(sock_fd, nlh);
}

#define NLMSG_TAIL(nmsg) \
	((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int create_qdisc_netem(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "netem");

	// copied from iproute2-tc q_netem.c because this protocol has a different parser
	struct rtattr *tail = NLMSG_TAIL(nlh);

	struct tc_netem_qopt qopt = {
		.limit = 10, // doesn't matter as long as we can enqueue 2 packets
		.latency = 0,
		.jitter = 0,
		.loss = 0,
		.gap = 0,
		.duplicate = ~0, // always duplicate
	};

	mnl_attr_put(nlh, TCA_OPTIONS, sizeof(qopt), &qopt);

	tail->rta_len = (void *)NLMSG_TAIL(nlh) - (void *)tail;

	return netlink_send(sock_fd, nlh);
}

int create_class(const int sock_fd, const __u32 child_handle, const __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);
	nlh->nlmsg_type = RTM_NEWTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE | NLM_F_ACK;
	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;

	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = child_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "drr");

	struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);
	mnl_attr_nest_end(nlh, opts);

	return netlink_send(sock_fd, nlh);
}

int create_class_hfsc(const int sock_fd, const __u32 child_handle, const __u32 parent_handle, struct tc_service_curve *rsc, struct tc_service_curve *fsc, struct tc_service_curve *usc)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE | NLM_F_ACK;
	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;

	tcm->tcm_handle = child_handle;
	tcm->tcm_parent = parent_handle;
	mnl_attr_put_strz(nlh, TCA_KIND, "hfsc");
	struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);

	if (rsc)
		mnl_attr_put(nlh, TCA_HFSC_RSC, sizeof(struct tc_service_curve), rsc);
	if (fsc)
		mnl_attr_put(nlh, TCA_HFSC_FSC, sizeof(struct tc_service_curve), fsc);
	if (usc)
		mnl_attr_put(nlh, TCA_HFSC_USC, sizeof(struct tc_service_curve), usc);

	mnl_attr_nest_end(nlh, opts);

	return netlink_send(sock_fd, nlh);
}

int delete_class(int sock_fd, __u32 my_handle, __u32 parent_handle, const char *kind)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_DELTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, kind);

	return netlink_send(sock_fd, nlh);
}

#endif