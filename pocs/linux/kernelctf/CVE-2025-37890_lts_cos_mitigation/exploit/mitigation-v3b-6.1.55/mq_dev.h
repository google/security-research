#include <sys/ioctl.h>

// used in exploit.c
#define MQ_DEV "mq0"
const uint16_t MQ_DEV_SRC_PORT = 0x1718;
const uint16_t MQ_DEV_DST_PORT = 0x1920;

// Checksum calculation for IP header
unsigned short in_cksum(unsigned short *addr, int len)
{
    int nleft = len;
    int sum = 0;
    unsigned short *w = addr;
    unsigned short answer = 0;

    while (nleft > 1)
    {
        sum += *w++;
        nleft -= 2;
    }

    if (nleft == 1)
    {
        *(unsigned char *)(&answer) = *(unsigned char *)w;
        sum += answer;
    }

    sum = (sum >> 16) + (sum & 0xffff);
    sum += (sum >> 16);
    answer = ~sum;
    return answer;
}

/**
 * Create a UDP packet with Ethernet, IP, and UDP headers
 */
void create_udp_packet(uint8_t *buffer, size_t *size,
                       const uint8_t *src_mac, const uint8_t *dst_mac,
                       const char *src_ip, const char *dst_ip,
                       uint16_t src_port, uint16_t dst_port,
                       const void *payload, size_t payload_size)
{

    // Make sure we don't exceed buffer size
    if (sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct udphdr) + payload_size > 1500)
    {
        fprintf(stderr, "Payload too large for Ethernet frame\n");
        *size = 0;
        return;
    }

    // Packet components
    struct ethhdr *eth = (struct ethhdr *)buffer;
    struct iphdr *ip = (struct iphdr *)(buffer + sizeof(struct ethhdr));
    struct udphdr *udp = (struct udphdr *)(buffer + sizeof(struct ethhdr) + sizeof(struct iphdr));
    uint8_t *data = buffer + sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct udphdr);

    // Clear buffer
    memset(buffer, 0, 1500);

    // Ethernet header
    memcpy(eth->h_dest, dst_mac, ETH_ALEN);
    memcpy(eth->h_source, src_mac, ETH_ALEN);
    eth->h_proto = htons(ETH_P_IP);

    // IP header
    ip->ihl = 5;     // Header length in 32-bit words (5 = 20 bytes)
    ip->version = 4; // IPv4
    ip->tos = 0;     // Type of service (0 = normal)
    ip->tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + payload_size);
    ip->id = htons(rand() & 0xFFFF); // Random ID
    ip->frag_off = 0;                // No fragmentation
    ip->ttl = 64;                    // Time to live
    ip->protocol = IPPROTO_UDP;      // UDP protocol
    ip->check = 0;                   // Will calculate later
    ip->saddr = inet_addr(src_ip);   // Source IP
    ip->daddr = inet_addr(dst_ip);   // Destination IP

    // Calculate IP checksum
    ip->check = in_cksum((unsigned short *)ip, sizeof(struct iphdr));

    // UDP header
    udp->source = htons(src_port);
    udp->dest = htons(dst_port);
    udp->len = htons(sizeof(struct udphdr) + payload_size);
    udp->check = 0; // We'll leave UDP checksum as 0 (optional for IPv4)

    // Copy payload
    memcpy(data, payload, payload_size);

    // Set final size
    *size = sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct udphdr) + payload_size;

    // Ensure minimum Ethernet frame size
    if (*size < ETH_ZLEN)
    {
        *size = ETH_ZLEN;
    }
}

int send_packet_to_interface(const char *ifname, unsigned int queue_id, const void *packet, size_t packet_size)
{
    int sock_fd;
    struct sockaddr_ll socket_address;
    struct ifreq if_req;
    int ret = -1;

    // Create a raw socket
    sock_fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sock_fd < 0)
    {
        perror("socket creation failed");
        return -1;
    }

    // Get interface index
    memset(&if_req, 0, sizeof(if_req));
    strncpy(if_req.ifr_name, ifname, IFNAMSIZ - 1);
    if (ioctl(sock_fd, SIOCGIFINDEX, &if_req) < 0)
    {
        perror("SIOCGIFINDEX");
        close(sock_fd);
        return -1;
    }

    // Set up socket address structure
    memset(&socket_address, 0, sizeof(socket_address));
    socket_address.sll_family = AF_PACKET;
    socket_address.sll_protocol = htons(ETH_P_ALL);
    socket_address.sll_ifindex = if_req.ifr_ifindex;
    socket_address.sll_halen = ETH_ALEN;

    // Try to set queue selection via priority
    // int priority = queue_id;
    if (setsockopt(sock_fd, SOL_SOCKET, SO_PRIORITY, &queue_id, sizeof(queue_id)) < 0)
    {
        fprintf(stderr, "Warning: Setting priority failed: %s\n", strerror(errno));
    }

    // Send the packet
    ret = sendto(sock_fd, packet, packet_size, 0,
                 (struct sockaddr *)&socket_address, sizeof(socket_address));

    if (ret < 0)
    {
        perror("sendto failed");
        close(sock_fd);
        return -1;
    }

    close(sock_fd);
    return 0;
}

static int _send_mq_dev(uint16_t src_port, uint16_t dst_port, const char *payload, const size_t payload_size, unsigned int queue_id)
{
    // MAC addresses
    uint8_t src_mac[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55}; // Source MAC
    uint8_t dst_mac[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; // Broadcast

    // IP addresses
    char src_ip[] = "192.168.1.100";
    char dst_ip[] = "192.168.1.255"; // Broadcast

    // Buffer for our packet
    uint8_t packet[1500];
    size_t packet_size;

    // Create the UDP packet
    create_udp_packet(packet, &packet_size,
                      src_mac, dst_mac,
                      src_ip, dst_ip,
                      src_port, dst_port,
                      payload, payload_size);
    if (packet_size == 0)
    {
        fprintf(stderr, "Failed to create packet\n");
        return 1;
    }

    // Send the packet
    if (send_packet_to_interface(MQ_DEV, queue_id, packet, packet_size) != 0)
    {
        fprintf(stderr, "Failed to send packet\n");
        return 1;
    }

    return 0;
}

int send_mq_dev_raw_with_payload(unsigned int prio, const char *payload, const size_t payload_size)
{
    return _send_mq_dev(MQ_DEV_SRC_PORT, MQ_DEV_DST_PORT, payload, payload_size, prio);
}

#define send_mq_dev_raw(prio) send_mq_dev_raw_with_payload(prio, "", 0)