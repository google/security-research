## Requirements to trigger the vulnerability

- CAP_NET_ADMIN in a namespace is required
- Kernel configuration: CONFIG_NET_CLS_FW
- User namespaces required: Yes

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e35a8ee5993ba81fd6c092f6827458c60406255b

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=76e42ae831991c828cffa8c37736ebfb831ad5ec

## Affected kernel versions

Introduced in 3.18. Fixed in 6.5, 6.1.44, 5.15.125 and other stable trees.

## Affected component, subsystem

net/sched: cls_fw

## Description

When fw_change() is called on an existing filter, data from the existing object is copied to the newly allocated one and then fw_set_parms
() is called on it:
```
        fnew = kzalloc(sizeof(struct fw_filter), GFP_KERNEL);
        if (!fnew)
                return -ENOBUFS;

        fnew->id = f->id;
[1]     fnew->res = f->res;
        fnew->ifindex = f->ifindex;
        fnew->tp = f->tp;

        ...
        err = fw_set_parms(net, tp, fnew, tb, tca, base, flags, extack);

```

The copied data includes a "res" field which is a tcf_result structure containing a pointer to the target class of a given filter.

fw_set_parms() calls tcf_bind_filter() if TCA_FW_CLASSID is set:

```
        if (tb[TCA_FW_CLASSID]) {
                f->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);
[2]             tcf_bind_filter(tp, &f->res, base);
        }
```

tcf_bind_filter() calls .bind_tcf handler on the target class, but if f->res.class was already set it also calls .unbind_tcf on it:

```
static inline void
__tcf_bind_filter(struct Qdisc *q, struct tcf_result *r, unsigned long base)
{
        unsigned long cl;

        cl = q->ops->cl_ops->bind_tcf(q, base, r->classid);
        cl = __cls_set_class(&r->class, cl);
        if (cl)
[3]                q->ops->cl_ops->unbind_tcf(q, cl);
}
```


.bind_tcf/.unbind_tcf for most classful qdiscs just increase/decrease filter_cnt counter, which serves as a protection against class being destroyed, e.g.:
```
static void drr_unbind_tcf(struct Qdisc *sch, unsigned long arg)
{
        struct drr_class *cl = (struct drr_class *)arg;

        cl->filter_cnt--;
}

static int drr_delete_class(struct Qdisc *sch, unsigned long arg,
                            struct netlink_ext_ack *extack)
{
        struct drr_sched *q = qdisc_priv(sch);
        struct drr_class *cl = (struct drr_class *)arg;

        if (cl->filter_cnt > 0)
                return -EBUSY;
...
```

This leads to a use-after-free (dangling res.class pointer) in two scenarios:

#### Scenario 1

fw_change() is called on the filter with an already bound target class "c1" and there is no TCA_FW_CLASSID in the new parameters.
tcf_unbind_filter() is called on the old filter in [4].
filter_cnt of the class "c1" is decreased and it is possible to delete it, however the to the class c1 was copied to fnew in [1] and is still set 
in the new version of the filter.


#### Scenario 2

fw_change() is called on the filter with an already bound target class "c1", there is a TCA_FW_CLASSID in the new parameters, but it is set to the different class "c2"
Class "c1" is also bound to another filter "f2", so its filter_cnt is 2 at the start.

tcf_bind_filter() is called in [2] leading to the unbind_tcf call [3] on the "c1" class. filter_cnt of "c1" is now 1.
Finally, tcf_unbind_filter() is called in [4] leading to the second unbind_tcf on the "c1" class.
This sets the filter_cnt of the "c1" to 0, allowing it to be destroyed, but it is still bound to the "f2" filter.

