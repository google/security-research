- Requirements:
    - Capabilities: CAP_NET_ADMIN
    - Kernel configuration: CONFIG_NET_SCHED=y, CONFIG_NET_SCH_CHOKE=y
    - User namespaces required: Yes
- Introduced by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=45e144339ac59971eb44be32e1282760aaabe861
- Fixed by: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5eb7de8cd58e73851cd37ff8d0666517d9926948
- Affected Version: v2.6.39 - v6.12
- Affected Component: tc, sch_choke
- URL: https://www.cve.org/CVERecord?id=CVE-2024-53164
- Cause: Use-After-Free


In the tc subsystem, specifically the CHOKe scheduler, an ordering logic error
around the usage of `qdisc_tree_reduce_backlog()` caused clean ups to be missed
leading to use-after-free.
The `qdisc_tree_reduce_backlog()` function is supposed to propagate qdisc length
state changes from children to their parents. Aside from simply updating statistical
counters it is also responsible for notifying parents when one of their children
is becoming empty so that the parent can perform clean up operations. Prior to the
patch, a use in CHOKe was improperly keeping `qlen` state updates ([2]) from being
visible to `qdisc_tree_reduce_backlog()` ([1]) thus preventing parent from being
notified:

```c
static void choke_drop_by_idx(struct Qdisc *sch, unsigned int idx,
			      struct sk_buff **to_free)
{
	struct choke_sched_data *q = qdisc_priv(sch);
	struct sk_buff *skb = q->tab[idx];

	// ...

	qdisc_qstats_backlog_dec(sch, skb);
	qdisc_tree_reduce_backlog(sch, 1, qdisc_pkt_len(skb));  [1]
	qdisc_drop(skb, sch, to_free);
	--sch->q.qlen;                                          [2]
}
```

With the missed notification path highlighted in `qdisc_tree_reduce_backlog()`
([3] and [4]):
```c
void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
{
	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
	const struct Qdisc_class_ops *cops;
	unsigned long cl;
	u32 parentid;
	bool notify;
	int drops;

	if (n == 0 && len == 0)
		return;
	drops = max_t(int, n, 0);
	rcu_read_lock();
	while ((parentid = sch->parent)) {
		if (parentid == TC_H_ROOT)
			break;

		if (sch->flags & TCQ_F_NOPARENT)
			break;
		/* Notify parent qdisc only if child qdisc becomes empty.
		 *
		 * If child was empty even before update then backlog
		 * counter is screwed and we skip notification because
		 * parent class is already passive.
		 *
		 * If the original child was offloaded then it is allowed
		 * to be seem as empty, so the parent is notified anyway.
		 */
		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&                 // [3]
						       !qdisc_is_offloaded);
		/* TODO: perform the search on a per txq basis */
		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
		if (sch == NULL) {
			WARN_ON_ONCE(parentid != TC_H_ROOT);
			break;
		}
		cops = sch->ops->cl_ops;
		if (notify && cops->qlen_notify) {                           // [4]
			cl = cops->find(sch, parentid);
			cops->qlen_notify(sch, cl);
		}
		sch->q.qlen -= n;
		sch->qstats.backlog -= len;
		__qdisc_qstats_drop(sch, drops);
	}
	rcu_read_unlock();
}
```


With the notification and its associated clean up missing, user can delete the
child choke qdisc while the parent keeps a (then dangling) reference to it causing
a use-after-free.
