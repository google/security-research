# Linux Kernel Netfilter Use-After-Free Leads to LPE

## Vulnerability

The Netfilter framework in the Linux kernel is a powerful tool that provides various network-related operations, including packet filtering, Network Address Translation (NAT), and port forwarding, all implemented within the Linux kernel. It is designed to seamlessly integrate with the Linux network stack, offering a flexible and efficient mechanism for monitoring, modifying, or rejecting network packets.

The architecture of Netfilter in the Linux kernel is modular and highly flexible, aiming to efficiently process network packets at different stages of the network stack. The core structure of Netfilter revolves around a series of hooks in the Linux network stack, where functions can be registered to intercept and manipulate packets at various points during their transmission through the stack. These hooks are strategically placed at key positions, such as when a packet first enters the network interface, when it is about to be routed, and just before it leaves the system.

The Netfilter framework in the Linux kernel includes multiple hooks for intercepting network packets at different processing stages. One of the key hooks is the inbound hook. Located at the starting point of the packet processing path, the inbound hook allows the Netfilter framework to inspect and determine the fate of a packet before it reaches the network stack for further processing.

Let's look at the source code for updating a chain (herein, the chain refers to the basechain of a netdev) through a Netfilter socket:


```c
static int nf_tables_updchain(struct nft_ctx *ctx, u8 genmask, u8 policy,
			      u32 flags, const struct nlattr *attr,
			      struct netlink_ext_ack *extack)
{
	const struct nlattr * const *nla = ctx->nla;
	struct nft_base_chain *basechain = NULL;
	struct nft_table *table = ctx->table;
	struct nft_chain *chain = ctx->chain;
	struct nft_chain_hook hook = {};
	struct nft_stats *stats = NULL;
	struct nft_hook *h, *next;
	struct nf_hook_ops *ops;
	struct nft_trans *trans;
	bool unregister = false;
	int err;

	if (chain->flags ^ flags)
		return -EOPNOTSUPP;

	INIT_LIST_HEAD(&hook.list);

	if (nla[NFTA_CHAIN_HOOK]) {
		if (!nft_is_base_chain(chain)) {
			NL_SET_BAD_ATTR(extack, attr);
			return -EEXIST;
		}

		basechain = nft_base_chain(chain);
		err = nft_chain_parse_hook(ctx->net, basechain, nla, &hook,
					   ctx->family, flags, extack);
		if (err < 0)
			return err;

		if (basechain->type != hook.type) {
			nft_chain_release_hook(&hook);
			NL_SET_BAD_ATTR(extack, attr);
			return -EEXIST;
		}

		if (nft_base_chain_netdev(ctx->family, basechain->ops.hooknum)) {
			list_for_each_entry_safe(h, next, &hook.list, list) {
				h->ops.pf	= basechain->ops.pf;
				h->ops.hooknum	= basechain->ops.hooknum;
				h->ops.priority	= basechain->ops.priority;
				h->ops.priv	= basechain->ops.priv;
				h->ops.hook	= basechain->ops.hook;

				if (nft_hook_list_find(&basechain->hook_list, h)) { // [1]
					list_del(&h->list);
					kfree(h);
				}
			}
		} else {
			ops = &basechain->ops;
			if (ops->hooknum != hook.num ||
			    ops->priority != hook.priority) {
				nft_chain_release_hook(&hook);
				NL_SET_BAD_ATTR(extack, attr);
				return -EEXIST;
			}
		}
	}

	if (nla[NFTA_CHAIN_HANDLE] &&
	    nla[NFTA_CHAIN_NAME]) {
		struct nft_chain *chain2;

		chain2 = nft_chain_lookup(ctx->net, table,
					  nla[NFTA_CHAIN_NAME], genmask);
		if (!IS_ERR(chain2)) {
			NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);
			err = -EEXIST;
			goto err_hooks;
		}
	}

	if (table->flags & __NFT_TABLE_F_UPDATE &&
	    !list_empty(&hook.list)) {
		NL_SET_BAD_ATTR(extack, attr);
		err = -EOPNOTSUPP;
		goto err_hooks;
	}

	if (!(table->flags & NFT_TABLE_F_DORMANT) &&
	    nft_is_base_chain(chain) &&
	    !list_empty(&hook.list)) {
		basechain = nft_base_chain(chain);
		ops = &basechain->ops;

		if (nft_base_chain_netdev(table->family, basechain->ops.hooknum)) {
			err = nft_netdev_register_hooks(ctx->net, &hook.list); // [2]
			if (err < 0)
				goto err_hooks;

			unregister = true;
		}
	}

	if (nla[NFTA_CHAIN_COUNTERS]) {
		if (!nft_is_base_chain(chain)) {
			err = -EOPNOTSUPP;
			goto err_hooks;
		}

		stats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);
		if (IS_ERR(stats)) {
			err = PTR_ERR(stats);
			goto err_hooks;
		}
	}

	err = -ENOMEM;
	trans = nft_trans_alloc(ctx, NFT_MSG_NEWCHAIN,
				sizeof(struct nft_trans_chain));
	if (trans == NULL)
		goto err_trans;

	nft_trans_chain_stats(trans) = stats;
	nft_trans_chain_update(trans) = true;

	if (nla[NFTA_CHAIN_POLICY])
		nft_trans_chain_policy(trans) = policy;
	else
		nft_trans_chain_policy(trans) = -1;

	if (nla[NFTA_CHAIN_HANDLE] &&
	    nla[NFTA_CHAIN_NAME]) {
		struct nftables_pernet *nft_net = nft_pernet(ctx->net);
		struct nft_trans *tmp;
		char *name;

		err = -ENOMEM;
		name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL_ACCOUNT);
		if (!name)
			goto err_trans;

		err = -EEXIST;
		list_for_each_entry(tmp, &nft_net->commit_list, list) {
			if (tmp->msg_type == NFT_MSG_NEWCHAIN &&
			    tmp->ctx.table == table &&
			    nft_trans_chain_update(tmp) &&
			    nft_trans_chain_name(tmp) &&
			    strcmp(name, nft_trans_chain_name(tmp)) == 0) {
				NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_NAME]);
				kfree(name);
				goto err_trans;
			}
		}

		nft_trans_chain_name(trans) = name;
	}

	nft_trans_basechain(trans) = basechain;
	INIT_LIST_HEAD(&nft_trans_chain_hooks(trans));
	list_splice(&hook.list, &nft_trans_chain_hooks(trans)); // [3]
	if (nla[NFTA_CHAIN_HOOK])
		module_put(hook.type->owner);

	nft_trans_commit_list_add_tail(ctx->net, trans);

	return 0;

err_trans:
	free_percpu(stats);
	kfree(trans);
err_hooks:
	if (nla[NFTA_CHAIN_HOOK]) {
		list_for_each_entry_safe(h, next, &hook.list, list) {
			if (unregister)
				nf_unregister_net_hook(ctx->net, &h->ops);
			list_del(&h->list);
			kfree_rcu(h, rcu);
		}
		module_put(hook.type->owner);
	}

	return err;
}
```

At [1], it checks whether the currently parsed hook has the same device name as any existing hook in the basechain's hook list.

At [2], the newly registered hooks are registered to the device.

At [3], the newly registered hooks are moved to the trans->hook linked list.

Let's then look at the commit function:


```c
static int nf_tables_commit(struct net *net, struct sk_buff *skb)
{
	struct nftables_pernet *nft_net = nft_pernet(net);
	struct nft_trans *trans, *next;
	unsigned int base_seq, gc_seq;
	LIST_HEAD(set_update_list);
	struct nft_trans_elem *te;
	struct nft_chain *chain;
	struct nft_table *table;
	LIST_HEAD(adl);
	int err;

	if (list_empty(&nft_net->commit_list)) {
		mutex_unlock(&nft_net->commit_mutex);
		return 0;
	}

	list_for_each_entry(trans, &nft_net->binding_list, binding_list) {
		switch (trans->msg_type) {
		case NFT_MSG_NEWSET:
			if (!nft_trans_set_update(trans) &&
			    nft_set_is_anonymous(nft_trans_set(trans)) &&
			    !nft_trans_set_bound(trans)) {
				pr_warn_once("nftables ruleset with unbound set\n");
				return -EINVAL;
			}
			break;
		case NFT_MSG_NEWCHAIN:
			if (!nft_trans_chain_update(trans) &&
			    nft_chain_binding(nft_trans_chain(trans)) &&
			    !nft_trans_chain_bound(trans)) {
				pr_warn_once("nftables ruleset with unbound chain\n");
				return -EINVAL;
			}
			break;
		}
	}

	/* 0. Validate ruleset, otherwise roll back for error reporting. */
	if (nf_tables_validate(net) < 0) {
		nft_net->validate_state = NFT_VALIDATE_DO;
		return -EAGAIN;
	}

	err = nft_flow_rule_offload_commit(net);
	if (err < 0)
		return err;

	/* 1.  Allocate space for next generation rules_gen_X[] */
	list_for_each_entry_safe(trans, next, &nft_net->commit_list, list) {
		int ret;

		ret = nf_tables_commit_audit_alloc(&adl, trans->ctx.table);
		if (ret) {
			nf_tables_commit_chain_prepare_cancel(net);
			nf_tables_commit_audit_free(&adl);
			return ret;
		}
		if (trans->msg_type == NFT_MSG_NEWRULE ||
		    trans->msg_type == NFT_MSG_DELRULE) {
			chain = trans->ctx.chain;

			ret = nf_tables_commit_chain_prepare(net, chain);
			if (ret < 0) {
				nf_tables_commit_chain_prepare_cancel(net);
				nf_tables_commit_audit_free(&adl);
				return ret;
			}
		}
	}

	/* step 2.  Make rules_gen_X visible to packet path */
	list_for_each_entry(table, &nft_net->tables, list) {
		list_for_each_entry(chain, &table->chains, list)
			nf_tables_commit_chain(net, chain);
	}

	/*
	 * Bump generation counter, invalidate any dump in progress.
	 * Cannot fail after this point.
	 */
	base_seq = READ_ONCE(nft_net->base_seq);
	while (++base_seq == 0)
		;

	WRITE_ONCE(nft_net->base_seq, base_seq);

	gc_seq = nft_gc_seq_begin(nft_net);

	/* step 3. Start new generation, rules_gen_X now in use. */
	net->nft.gencursor = nft_gencursor_next(net);

	list_for_each_entry_safe(trans, next, &nft_net->commit_list, list) {
		nf_tables_commit_audit_collect(&adl, trans->ctx.table,
					       trans->msg_type);
		switch (trans->msg_type) {
		case NFT_MSG_NEWTABLE:
			if (nft_trans_table_update(trans)) {
				if (!(trans->ctx.table->flags & __NFT_TABLE_F_UPDATE)) {
					nft_trans_destroy(trans);
					break;
				}
				if (trans->ctx.table->flags & NFT_TABLE_F_DORMANT)
					nf_tables_table_disable(net, trans->ctx.table);

				trans->ctx.table->flags &= ~__NFT_TABLE_F_UPDATE;
			} else {
				nft_clear(net, trans->ctx.table);
			}
			nf_tables_table_notify(&trans->ctx, NFT_MSG_NEWTABLE);
			nft_trans_destroy(trans);
			break;
		case NFT_MSG_DELTABLE:
		case NFT_MSG_DESTROYTABLE:
			list_del_rcu(&trans->ctx.table->list);
			nf_tables_table_notify(&trans->ctx, trans->msg_type);
			break;
		case NFT_MSG_NEWCHAIN:
			if (nft_trans_chain_update(trans)) {
				nft_chain_commit_update(trans);
				nf_tables_chain_notify(&trans->ctx, NFT_MSG_NEWCHAIN,
						       &nft_trans_chain_hooks(trans));
				list_splice(&nft_trans_chain_hooks(trans), // []
					    &nft_trans_basechain(trans)->hook_list);
				/* trans destroyed after rcu grace period */
			} else {
				nft_chain_commit_drop_policy(trans);
				nft_clear(net, trans->ctx.chain);
				nf_tables_chain_notify(&trans->ctx, NFT_MSG_NEWCHAIN, NULL);
				nft_trans_destroy(trans);
			}
			break;
		case NFT_MSG_DELCHAIN:
		case NFT_MSG_DESTROYCHAIN:
			if (nft_trans_chain_update(trans)) {
				nf_tables_chain_notify(&trans->ctx, NFT_MSG_DELCHAIN,
						       &nft_trans_chain_hooks(trans));
				if (!(trans->ctx.table->flags & NFT_TABLE_F_DORMANT)) {
					nft_netdev_unregister_hooks(net,
								    &nft_trans_chain_hooks(trans),
								    true);
				}
			} else {
				nft_chain_del(trans->ctx.chain);
				nf_tables_chain_notify(&trans->ctx, NFT_MSG_DELCHAIN,
						       NULL);
				nf_tables_unregister_hook(trans->ctx.net,
							  trans->ctx.table,
							  trans->ctx.chain);
			}
			break;
		case NFT_MSG_NEWRULE:
			nft_clear(trans->ctx.net, nft_trans_rule(trans));
			nf_tables_rule_notify(&trans->ctx,
					      nft_trans_rule(trans),
					      NFT_MSG_NEWRULE);
			if (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)
				nft_flow_rule_destroy(nft_trans_flow_rule(trans));

			nft_trans_destroy(trans);
			break;
		case NFT_MSG_DELRULE:
		case NFT_MSG_DESTROYRULE:
			list_del_rcu(&nft_trans_rule(trans)->list);
			nf_tables_rule_notify(&trans->ctx,
					      nft_trans_rule(trans),
					      trans->msg_type);
			nft_rule_expr_deactivate(&trans->ctx,
						 nft_trans_rule(trans),
						 NFT_TRANS_COMMIT);

			if (trans->ctx.chain->flags & NFT_CHAIN_HW_OFFLOAD)
				nft_flow_rule_destroy(nft_trans_flow_rule(trans));
			break;
		case NFT_MSG_NEWSET:
			if (nft_trans_set_update(trans)) {
				struct nft_set *set = nft_trans_set(trans);

				WRITE_ONCE(set->timeout, nft_trans_set_timeout(trans));
				WRITE_ONCE(set->gc_int, nft_trans_set_gc_int(trans));

				if (nft_trans_set_size(trans))
					WRITE_ONCE(set->size, nft_trans_set_size(trans));
			} else {
				nft_clear(net, nft_trans_set(trans));
				/* This avoids hitting -EBUSY when deleting the table
				 * from the transaction.
				 */
				if (nft_set_is_anonymous(nft_trans_set(trans)) &&
				    !list_empty(&nft_trans_set(trans)->bindings))
					nft_use_dec(&trans->ctx.table->use);
			}
			nf_tables_set_notify(&trans->ctx, nft_trans_set(trans),
					     NFT_MSG_NEWSET, GFP_KERNEL);
			nft_trans_destroy(trans);
			break;
		case NFT_MSG_DELSET:
		case NFT_MSG_DESTROYSET:
			nft_trans_set(trans)->dead = 1;
			list_del_rcu(&nft_trans_set(trans)->list);
			nf_tables_set_notify(&trans->ctx, nft_trans_set(trans),
					     trans->msg_type, GFP_KERNEL);
			break;
		case NFT_MSG_NEWSETELEM:
			te = (struct nft_trans_elem *)trans->data;

			nft_setelem_activate(net, te->set, &te->elem);
			nf_tables_setelem_notify(&trans->ctx, te->set,
						 &te->elem,
						 NFT_MSG_NEWSETELEM);
			if (te->set->ops->commit &&
			    list_empty(&te->set->pending_update)) {
				list_add_tail(&te->set->pending_update,
					      &set_update_list);
			}
			nft_trans_destroy(trans);
			break;
		case NFT_MSG_DELSETELEM:
		case NFT_MSG_DESTROYSETELEM:
			te = (struct nft_trans_elem *)trans->data;

			nf_tables_setelem_notify(&trans->ctx, te->set,
						 &te->elem,
						 trans->msg_type);
			nft_setelem_remove(net, te->set, &te->elem);
			if (!nft_setelem_is_catchall(te->set, &te->elem)) {
				atomic_dec(&te->set->nelems);
				te->set->ndeact--;
			}
			if (te->set->ops->commit &&
			    list_empty(&te->set->pending_update)) {
				list_add_tail(&te->set->pending_update,
					      &set_update_list);
			}
			break;
		case NFT_MSG_NEWOBJ:
			if (nft_trans_obj_update(trans)) {
				nft_obj_commit_update(trans);
				nf_tables_obj_notify(&trans->ctx,
						     nft_trans_obj(trans),
						     NFT_MSG_NEWOBJ);
			} else {
				nft_clear(net, nft_trans_obj(trans));
				nf_tables_obj_notify(&trans->ctx,
						     nft_trans_obj(trans),
						     NFT_MSG_NEWOBJ);
				nft_trans_destroy(trans);
			}
			break;
		case NFT_MSG_DELOBJ:
		case NFT_MSG_DESTROYOBJ:
			nft_obj_del(nft_trans_obj(trans));
			nf_tables_obj_notify(&trans->ctx, nft_trans_obj(trans),
					     trans->msg_type);
			break;
		case NFT_MSG_NEWFLOWTABLE:
			if (nft_trans_flowtable_update(trans)) {
				nft_trans_flowtable(trans)->data.flags =
					nft_trans_flowtable_flags(trans);
				nf_tables_flowtable_notify(&trans->ctx,
							   nft_trans_flowtable(trans),
							   &nft_trans_flowtable_hooks(trans),
							   NFT_MSG_NEWFLOWTABLE);
				list_splice(&nft_trans_flowtable_hooks(trans),
					    &nft_trans_flowtable(trans)->hook_list);
			} else {
				nft_clear(net, nft_trans_flowtable(trans));
				nf_tables_flowtable_notify(&trans->ctx,
							   nft_trans_flowtable(trans),
							   NULL,
							   NFT_MSG_NEWFLOWTABLE);
			}
			nft_trans_destroy(trans);
			break;
		case NFT_MSG_DELFLOWTABLE:
		case NFT_MSG_DESTROYFLOWTABLE:
			if (nft_trans_flowtable_update(trans)) {
				nf_tables_flowtable_notify(&trans->ctx,
							   nft_trans_flowtable(trans),
							   &nft_trans_flowtable_hooks(trans),
							   trans->msg_type);
				nft_unregister_flowtable_net_hooks(net,
								   nft_trans_flowtable(trans),
								   &nft_trans_flowtable_hooks(trans));
			} else {
				list_del_rcu(&nft_trans_flowtable(trans)->list);
				nf_tables_flowtable_notify(&trans->ctx,
							   nft_trans_flowtable(trans),
							   NULL,
							   trans->msg_type);
				nft_unregister_flowtable_net_hooks(net,
						nft_trans_flowtable(trans),
						&nft_trans_flowtable(trans)->hook_list);
			}
			break;
		}
	}

	nft_set_commit_update(&set_update_list);

	nft_commit_notify(net, NETLINK_CB(skb).portid);
	nf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);
	nf_tables_commit_audit_log(&adl, nft_net->base_seq);

	nft_gc_seq_end(nft_net, gc_seq);
	nft_net->validate_state = NFT_VALIDATE_SKIP;
	nf_tables_commit_release(net);

	return 0;
}
```

At [4], the trans->hooks linked list is moved into the basechain.

It can be seen that when creating a new hook, only comparisons are made with hooks in the basechain's hook list, and no comparisons are made with hooks in the trans of the commit list. This allows two hooks pointing to the same device to exist in the same chain.

On the other hand, when a user deletes a network device from the system through a netlink socket, the kernel will call the function rtnl_dellink:

```c
static int rtnl_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,
            struct netlink_ext_ack *extack)
{
    ...
    err = rtnl_delete_link(dev, portid, nlh);
    ...
}

int rtnl_delete_link(struct net_device *dev, u32 portid, const struct nlmsghdr *nlh)
{
    const struct rtnl_link_ops *ops;
    LIST_HEAD(list_kill);

    ops = dev->rtnl_link_ops;
    if (!ops || !ops->dellink)
        return -EOPNOTSUPP;

    ops->dellink(dev, &list_kill);
    unregister_netdevice_many_notify(&list_kill, portid, nlh);

    return 0;
}
```

Depending on the type of network device, the deletion operation will enter different callbacks. There are some default network devices: ppp, tun, bridge, ..., but all their callbacks will eventually call the unregister_netdevice_queue function, which leads to the execution of the unregister_netdevice_many_notify function.


```c
void unregister_netdevice_many_notify(struct list_head *head,
                      u32 portid, const struct nlmsghdr *nlh)
{
    ...
    list_for_each_entry(dev, head, unreg_list) {
        ...

        /* Notify protocols, that we are about to destroy
         * this device. They should clean all the things.
         */
        call_netdevice_notifiers(NETDEV_UNREGISTER, dev);
        ...

        /* Remove entries from kobject tree */
        netdev_unregister_kobject(dev);
    }

    list_del(head);
}
```

This function mainly focuses on uninitializing the device and freeing the object from the kernel heap memory. In addition, it calls call_netdevice_notifiers, which notifies all processors subscribed to network devices. These processors are actually filter chains from the netfilter subsystem, and their definitions can be found in nft_chain_filter.c. Let's look at the processor nf_tables_netdev_notifier.


```c
static struct notifier_block nf_tables_netdev_notifier = {
	.notifier_call	= nf_tables_netdev_event,
};

static int nf_tables_netdev_event(struct notifier_block *this,
				  unsigned long event, void *ptr)
{
	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
	struct nft_base_chain *basechain;
	struct nftables_pernet *nft_net;
	struct nft_chain *chain, *nr;
	struct nft_table *table;
	struct nft_ctx ctx = {
		.net	= dev_net(dev),
	};

	if (event != NETDEV_UNREGISTER &&
	    event != NETDEV_CHANGENAME)
		return NOTIFY_DONE;

	nft_net = nft_pernet(ctx.net);
	mutex_lock(&nft_net->commit_mutex);
	list_for_each_entry(table, &nft_net->tables, list) { // [5]
		if (table->family != NFPROTO_NETDEV &&
		    table->family != NFPROTO_INET)
			continue;

		ctx.family = table->family;
		ctx.table = table;
		list_for_each_entry_safe(chain, nr, &table->chains, list) { // [6]
			if (!nft_is_base_chain(chain))
				continue;

			basechain = nft_base_chain(chain);
			if (table->family == NFPROTO_INET &&
			    basechain->ops.hooknum != NF_INET_INGRESS)
				continue;

			ctx.chain = chain;
			nft_netdev_event(event, dev, &ctx);
		}
	}
	mutex_unlock(&nft_net->commit_mutex);

	return NOTIFY_DONE;
}
```

At [5], all tables in the current namespace are traversed. If their protocol family is not `NFPROTO_NETDEV` or `NFPROTO_INET`, they are skipped.

At [6], all chains in the current table are traversed. If a chain is not a basechain, it is skipped directly.

So, to summarize, when we remove a network device, the processor for the netdev event traverses all tables in the current network. If the table does not belong to the NFPROTO_NETDEV or NFPROTO_INET protocol families, it is skipped directly; otherwise, it traverses all chains in the table. If a chain is not a basechain, it is skipped directly; if it is a basechain, the nft_netdev_event function is eventually called to remove the hook.


```c
static void nft_netdev_event(unsigned long event, struct net_device *dev,
			     struct nft_ctx *ctx)
{
	struct nft_base_chain *basechain = nft_base_chain(ctx->chain);
	struct nft_hook *hook, *found = NULL;
	int n = 0;

	if (event != NETDEV_UNREGISTER)
		return;

	list_for_each_entry(hook, &basechain->hook_list, list) {
		if (hook->ops.dev == dev)
			found = hook;

		n++;
	}
	if (!found)
		return;

	if (n > 1) {
		if (!(ctx->chain->table->flags & NFT_TABLE_F_DORMANT))
			nf_unregister_net_hook(ctx->net, &found->ops);

		list_del_rcu(&found->list);
		kfree_rcu(found, rcu);
		return;
	}

	/* UNREGISTER events are also happening on netns exit.
	 *
	 * Although nf_tables core releases all tables/chains, only this event
	 * handler provides guarantee that hook->ops.dev is still accessible,
	 * so we cannot skip exiting net namespaces.
	 */
	__nft_release_basechain(ctx);
}
```

However, the nft_netdev_event function for removing hooks will only find and remove the first hook pointing to the device in the current chain. Therefore, even after the device is deleted, there remains a hook pointing to the device.

Now we need a place to use this freed network device. When a chain is deleted through a Netfilter socket, the __nf_unregister_net_hook function is called:


```c
static void __nf_unregister_net_hook(struct net *net, int pf,
				     const struct nf_hook_ops *reg)
{
	struct nf_hook_entries __rcu **pp;
	struct nf_hook_entries *p;

	pp = nf_hook_entry_head(net, pf, reg->hooknum, reg->dev);
	if (!pp)
		return;

	mutex_lock(&nf_hook_mutex);

	p = nf_entry_dereference(*pp);
	if (WARN_ON_ONCE(!p)) {
		mutex_unlock(&nf_hook_mutex);
		return;
	}

	if (nf_remove_net_hook(p, reg)) {
#ifdef CONFIG_NETFILTER_INGRESS
		if (nf_ingress_hook(reg, pf))
			net_dec_ingress_queue();
#endif
#ifdef CONFIG_NETFILTER_EGRESS
		if (nf_egress_hook(reg, pf))
			net_dec_egress_queue();
#endif
		nf_static_key_dec(reg, pf);
	} else {
		WARN_ONCE(1, "hook not found, pf %d num %d", pf, reg->hooknum);
	}

	p = __nf_hook_entries_try_shrink(p, pp);
	mutex_unlock(&nf_hook_mutex);
	if (!p)
		return;

	nf_queue_nf_hook_drop(net);
	nf_hook_entries_free(p);
}
```

In this function, the already freed dev device is accessed:

```c
case NFPROTO_INET:
    if (WARN_ON_ONCE(hooknum != NF_INET_INGRESS))
        return NULL;
    if (!dev || dev_net(dev) != net) {
        WARN_ON_ONCE(1);
        return NULL;
    }
    return &dev->nf_hooks_ingress;
```

To sum up, we have a Use-After-Free vulnerability in the kernel.


## Triggering Vulnerabilty

First, we create a virtual device by sending a creation request to the netlink socket:


```c
rt_newlink(nl_route, "y4g7", 1337);
```

Create a table and a chain, and update the chain twice in the same session so that two hooks point to the same device:


```c
batch = mnl_nlmsg_batch_start(buf, buf_size);
nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
mnl_nlmsg_batch_next(batch);

create_basechain(batch, seq++, table1_name, chain1_name, 0, 0xff);
update_basechain(batch, seq++, table1_name, chain1_name, "y4g7");
update_basechain(batch, seq++, table1_name, chain1_name, "y4g7");

nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
mnl_nlmsg_batch_next(batch);
mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch));
```

Remove the device:

```c
rt_dellink(nl_route, 1337);
```

Now we can trigger the UAF by dumping this chain to get the name of the already removed device.


## Exploitation

### UAF Leak

When we dump the information of the chain that triggered the UAF earlier, the name of the old freed device can be obtained in the nft_dump_basechain_hook function, which allows us to leak the content of the first eight bytes of the structure as a string.


```c
static int nft_dump_basechain_hook(struct sk_buff *skb, int family,
				   const struct nft_base_chain *basechain,
				   const struct list_head *hook_list)
{
	// ......

		list_for_each_entry_rcu(hook, hook_list, list) {
			if (!first)
				first = hook;

			if (nla_put_string(skb, NFTA_DEVICE_NAME,
					   hook->ops.dev->name))
				goto nla_put_failure;
			n++;
		}
		// ......
}
```

### Arbitrary free

When we delete the chain, __nf_unregister_net_hook is called to find the struct nf_hook_entries through the freed net_device, and then nf_hook_entries_free is called to free a value under our control. However, there is a restriction: we need to make the net of our constructed net_device the same as the net in the current namespace. Otherwise, it will return NULL and exit early without entering nf_hook_entries_free.


```c
case NFPROTO_INET:
    if (WARN_ON_ONCE(hooknum != NF_INET_INGRESS))
        return NULL;
    if (!dev || dev_net(dev) != net) { // keyline
        WARN_ON_ONCE(1);
        return NULL;
    }
    return &dev->nf_hooks_ingress;
```

#### Overwrite core_pattern

One way to gain privileged execution is to overwrite core_pattern, so that if a user program crashes, our exploit will execute as root. Through the arbitrary free used earlier, the exploit frees some pipe_buffer objects and overwrites the pipe_buffer with our own values.

The pipe_buffer object has a page member, which represents any physical page allocated in memory. To know the location of the struct page object of core_pattern, we first overflow the struct page of some kernel text into the pipe_buffer. The technique we use is to write data into the pipe through the vmsplice vDSO address. Then, by reading the page from the victim pipe_buffer, we can calculate the position of core_pattern. We also overwrite flags with PIPE_BUF_FLAG_CAN_MERGE, so by writing data to the pipe, we can overwrite the content of the memory page, i.e., core_pattern.


#### Root shell

After overwriting core_pattern, we can crash a program, and whatever is in core_pattern will execute as root, which is our root shell.


#### Detailed summary of step by steps exploitation

1. 1. Cross-cache overwrite the `net_device` object in kmalloc-cg-4k to the `packet_fanout` object in kmalloc-4k.

2. 2. The `packet_fanout` object has the `net` address in the first 8 bytes. We use the UAF vulnerability to leak `net` through original operations, preparing for our subsequent arbitrary free.

3. 3. Use another UAF object; this time we overwrite `net_device` with a `msg_msg` object, no cross-cache needed, using the same kmalloc-cg-4k.

4. 4. We fill `msg_msg.next` (first 8-byte offset) with kmalloc-cg-192, and by sending the `msg_msg` with a size of 0x90, operate on each `msg_msg` already placed in kmalloc-cg-4k.

5. 5. kmalloc-cg-192 ensures the first byte does not contain a null byte, so we can use the UAF vulnerability to leak the `msg_msg` address of kmalloc-cg-192.

6. 6. Use the arbitrary free function to free the chunk we obtained in kmalloc-cg-192.

7. 7. Spray `pipe_buffer` to take over the freed heap chunk from the previous step and alias it as `pipe_buffer` A.

8. 8. Write 0x1000 bytes to pipe A, which will increase `pipe->head`, making the next `vmspliced` page occur at `&pipe->bufs[1]` and not touch the important field `msg_msgseg.next` that needs to be zeroed, which is located in the first eight bytes.

9. 9. Use arbitrary free again to free `pipe_buffer` A.

10. 10. Reclaim `pipe_buffer` as `msg_msgseg`; since `msg_msgseg` only has the first eight bytes not under user control, it is better than `msg_msg` in this case.

11. 11. Call the `vmsplice` system call to map the vDSO memory page to offset 0x28 of `pipe_buffer` A (because `pipe->head` was increased in step 8). This method provides the address of the `struct page` kernel text to `pipe_buffer`.

12. 12. Read from the `msg_msgseg` object to read the content of `pipe_buffer` A.

13. 13. Prepare a `fake_pipe_buffer` using the calculated values of `page` and `offset` to point to the address of the `core_pattern` `page`, and set `PIPE_BUF_FLAG_CAN_MERGE` as the pipe flag.

14. 14. Receive the `msg` object; the `msg_msgseg` object will be freed, and then we can modify `pipe_buffer` by spraying `msg_msgseg` with `fake_pipe_buffer` again.

15. 15. Write to `pipe_buffer` A to overwrite the `core_pattern` value.

16. 16. Obtain a root shell by triggering a crash.