## Requirements to trigger the vulnerability

- CAP_NET_ADMIN in a namespace is required
- Kernel configuration: CONFIG_NET_SCH_PLUG + CONFIG_NET_SCH_QFQ
- User namespaces required: Yes

## Commit which introduced the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=462dbc9101acd38e92eda93c0726857517a24bbd

## Commit which fixed the vulnerability

https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8fc134fee27f2263988ae38920bc03da416b03d8

## Affected kernel versions

Introduced in 3.8. Fixed in 6.5, 6.1.54, 5.15.132 and other stable trees.

## Affected component, subsystem

net/sched: sch_qfq/sch_plug

## Description

sch_plug is a non-work-conserving qdisc. When in "plugged" state, plug_dequeue will return NULL.

Its .peek handler is:
```
static inline struct sk_buff *qdisc_peek_head(struct Qdisc *sch)
{
        const struct qdisc_skb_head *qh = &sch->q;

        return qh->head;
}
```

this function is not suitable for non-work-conserving qdisc. Those have a different generic handler:

```
/* generic pseudo peek method for non-work-conserving qdisc */
static inline struct sk_buff *qdisc_peek_dequeued(struct Qdisc *sch)
{
        struct sk_buff *skb = skb_peek(&sch->gso_skb);

        /* we can reuse ->gso_skb because peek isn't called for root qdiscs */
        if (!skb) {
                skb = sch->dequeue(sch);

                if (skb) {
                        __skb_queue_head(&sch->gso_skb, skb);
                        /* it's still part of the queue */
                        qdisc_qstats_backlog_inc(sch, skb);
                        sch->q.qlen++;
                }
        }

        return skb;
}

```

This is clearly a bug. However, in most configurations it has no serious consequences.

The situation changes when sch_plug's parent qdisc is sch_qfq.

Since the major rewrite done in commit 462dbc9101acd38e92eda93c0726857517a24bbd sch_qfq no longer checks the return value of the qdisc_dequeue_pee
ked() call.

Relevant code:

```
static struct sk_buff *qfq_dequeue(struct Qdisc *sch)
{
...
                skb = qfq_peek_skb(in_serv_agg, &cl, &len);
        }
        if (!skb)
                return NULL;

        agg_dequeue(in_serv_agg, cl, len);

..

        return skb;

static inline struct sk_buff *qfq_peek_skb(struct qfq_aggregate *agg,
                                           struct qfq_class **cl,
                                           unsigned int *len)
{
        struct sk_buff *skb;

        *cl = list_first_entry(&agg->active, struct qfq_class, alist);
[1]     skb = (*cl)->qdisc->ops->peek((*cl)->qdisc);
        if (skb == NULL)
                WARN_ONCE(1, "qfq_dequeue: non-workconserving leaf\n");
        else
                *len = qdisc_pkt_len(skb);

        return skb;
}

static void agg_dequeue(struct qfq_aggregate *agg,
                        struct qfq_class *cl, unsigned int len)
{
[2]     qdisc_dequeue_peeked(cl->qdisc);

        cl->deficit -= (int) len;

        if (cl->qdisc->q.qlen == 0) /* no more packets, remove from list */
                list_del(&cl->alist);
        else if (cl->deficit < qdisc_pkt_len(cl->qdisc->ops->peek(cl->qdisc))) {
                cl->deficit += agg->lmax;
                list_move_tail(&cl->alist, &agg->active);
        }
}

/* use instead of qdisc->dequeue() for all qdiscs queried with ->peek() */
static inline struct sk_buff *qdisc_dequeue_peeked(struct Qdisc *sch)
{
        struct sk_buff *skb = skb_peek(&sch->gso_skb);

        if (skb) {
                skb = __skb_dequeue(&sch->gso_skb);
                if (qdisc_is_percpu_stats(sch)) {
                        qdisc_qstats_cpu_backlog_dec(sch, skb);
                        qdisc_qstats_cpu_qlen_dec(sch);
                } else {
                        qdisc_qstats_backlog_dec(sch, skb);
                        sch->q.qlen--;
                }
        } else {
[3]             skb = sch->dequeue(sch);
        }

        return skb;
}

```

When qfq_dequeue() is called and the inner qdisc is the sch_plug in "plugged" state, [1] will return a valid skb.

qfq will then attempt to dequeue previously peeked skb through [2] and [3], but because sch_plug is "plugged", it will return NULL without changin
g its queue state.

Unfortunately, because qfq doesn't check the return value of qdisc_dequeue_peeked(), it's unable to react to that fact and returns the previously 
peeked (but not dequeued) skb.

The end result is that the same skb is returned from qfq_dequeue() over and over, flooding the network driver with packets.

Soon enough the skb is freed by the driver or the receive code of the network stack (in case of loopback), causing a use-after-free.
