# CVE-2025-38083
## Overview
First, use prefetch sidechannel to bypass KASLR. Then, use the race condition to underflow a hfsc qdisc qlen. Then, obtain a UAF hfsc class. We can then perform a write-what-where to achieve ROP.
For Mitigation instance, the path to triggering the vulnerability is the same, but we end up with a UAF qfq class instead. Then, we use a type confusion to achieve ROP.

## Setup qdisc hierachy
The core of the strategy is to use the prio-sfq interaction (duplicate qlen decrease) to underflow the qlen of the parent qdisc to the prio. Our target qdisc (whose qlen we underflow) is the child of a hfsc qdisc, granting a UAF hfsc class. In order to achieve this scenario, we must setup a hierachy/tree of qdiscs. It is easier to understand this hierachy from a modular perspective, so I have broken up the qdisc tree into separate subtrees (main, vuln, spam).

```
vuln:
      1:0 (prio)
  /  /    \    \
1:1  1:3  1:4  1:2
      |    |
    spam  3:0 (hfsc)
         /   \
       3:1   3:2
        |     |
  (sfq) 7:0   6:0 (plug)

main:
     99:0 (hfsc)
    /    \
   99:1  99:2
     |
   100:0
   /   \
100:1  100:3
   |     |
 vuln  102:0
```

The "main" tree is the overarching hierachy, with a root hfsc qdisc 99:0. When the bug is triggered in the "vuln" tree, we will propagate the qlen underflow from 1:0 into a UAF on the 99:0 classes.
The "vuln" tree has a root prio qdisc 1:0. The purpose of this setup is to underflow the prio's qlen to -1.
The "spam" tree referenced by "vuln" will be elaborated on later, but it can be swapped out for similar setups.

### Setup "vuln" tree
This subtree contains the vulnerable prio-sfq interaction. We will trigger the bug by making the sfq qdisc (7:0) drop packets concurrently as we reduce the number of prio (1:0) children -- this is the race condition explained in the vulnerability analysis.

By creating a sfq qdisc with 2 flows and 2 slots (i.e. limit of 4 packets) and sending 4 packets into the qdisc, sfq_perturbation() will drop 1 packet immediately. A second packet will be dropped after a few perturbations. TODO: code snippet. This number is not constant as sfq_perturbation's rehashing relies on randomness, but its variance does not affect the exploit. For the race condition, we will aim to coincide this second drop with prio_tune().

In order to force sfq_perturbation() to drop the packets we send into the sfq qdisc, those packets must not have been dequeued prior. To achieve this, we use a hfsc parent (3:0) to the sfq qdisc, that itself has a non-work-conserving plug qdisc. By sending a single packet into the plug qdisc, subsequent packets sent into the sfq qdisc will not be dequeued as the hfsc parent will always first try to dequeue from the plug qdisc and fail. Usefully, the hfsc qdisc does not affect the qlen propagation in any other way.

This sets us up to hit the race condition:
1. Send 1 packet into 6:0 (plug) for non-work-conserving effects
2. Send 4 packets into 7:0 (sfq) to trigger sfq_perturbation() to drop packets
3. Decrease the number of prio (1:0) children from 4 -> 2

```
CPU 0                CPU 1
 |                   [a]
[b]                   |
 |                   [c]
[d]                   |

[a]: sfq_perturbation() drops its first packet
[b]: prio_tune() called, lock acquired
[c]: sfq_perturbation() drops its second packet
[d]: prio_tune() completes, child qdisc is deleted
```

### Hitting the race condition
However, empirically, the race window is not large enough. To resolve this issue, we use a two-part approach: make the perturbation timer hit as frequently as possible and increase the race window size.

In order to make the perturbation timer hit frequently, we can make use of a second bug. There is an integer overflow in sfq_change().

```c
	WRITE_ONCE(q->perturb_period, ctl->perturb_period * HZ);
```

While the perturb_period is typically at least 1 HZ, by supplying a large input, we can overflow its value to create an extremely small delay. (in fact, we can even make the perturb_period negative). This bug was reported in the same report as the TOCTOU vulnerability, and patched in 7ca52541c05c832d32b112274f81a985101f9ba8.

In order to increase the race window (between [3] and [4] from the vulnerability analysis),
```c
	sch_tree_unlock(sch);                                   // [3]

	for (i = q->bands; i < oldbands; i++)
		qdisc_put(q->queues[i]);                            // [4]
```

Notice that if there are multiple prio bands to be deleted, the qdisc attached to the first band is destroyed first, in sequential order till the last qdisc. By creating a 'large' qdisc in one of the earlier prio bands, resetting the 'large' qdisc incurs a delay before reaching the sfq qdisc in the later prio bands -- this is the "spam" subtree. By attaching the "spam" subtree to class 1:3, it will be reset before the victim class 1:4 (contain the prio-sfq setup), increasing the race window size, i.e. giving more time for the perturbation timer to trigger.

One possible "spam" setup is using another sfq with many packets enqueued. When the "spam" sfq qdisc is reset, it iterates through each packet, dequeueing them individually.
```c
static void
sfq_reset(struct Qdisc *sch)
{
	struct sk_buff *skb;

	while ((skb = sfq_dequeue(sch)) != NULL)
		rtnl_kfree_skbs(skb, skb);
}
```
> There are many possible "spam" setups. Another setup could involve a hfsc qdisc with many nested classes.

Here is the actual "spam" subtree:
```
    2:0 (hfsc)
   /        \ 
2:1          2:2
 |            |
(sfq) 4:0    5:0 (plug)
```

Again, the plug qdisc (5:0) is used to ensure that the packets enqueued into the sfq qdisc (4:0) are not immediately dequeued. This subtree is setup in `setup_spam_tree()`.


This gives us the final sequence:
1. Send 1 packet into 5:0 (plug) for non-work-conserving effects
2. Send many packets into 4:0 (sfq) as "spam"
3. Send 1 packet into 6:0 (plug) for non-work-conserving effects
4. Send 4 packets into 7:0 (sfq) to trigger sfq_perturbation() to drop packets
5. Decrease the number of prio (1:0) children from 4 -> 2

```
CPU 0                CPU 1
 |                   [a]
[b]                   |
 |                    |
[c]                   |
 |                   [d]
[e]                   |

[a]: sfq_perturbation() drops its first packet
[b]: prio_tune() called, lock acquired
[c]: prio_tune() resets and deletes child hfsc qdisc ("spam" subtree)
[d]: sfq_perturbation() drops its second packet
[e]: prio_tune() completes, child prio qdisc is deleted
```

When we win this race, the duplicate qlen deduction causes the prio's qlen to underflow to 4294967295 (~0U).

### Repeating the race
We first check if we win the race by using the dump qdisc command, which returns a qdisc's qlen. If the qlen is not the desired underflowed value, we will reset our race attempt. Since the race introduces no side-effects, we can retry an attempt by deleting the prio qdisc (1:0), recreating the vuln subtree and trying again. In local tests, the race usually takes fewer than 100 resets to hit.

The logic of setting up the race, attempting the race, and resetting the race is encapsulated in `underflow_prio_qlen()`.

## Setup UAF
Here is the main hierachy ("main" tree):
```
     99:0 (hfsc)
    /    \
   99:1  99:2
     |
   100:0 (hfsc)
   /   \
100:1  100:3
   |     |
 vuln  102:0 (plug)
 ```

The goal is to get a UAF on the hfsc class 99:1. We perform the following steps in `setup_uaf()`:
1. Set up the main tree (`setup_main_tree()`). In this setup, we also send 2 packets into 102:0 (plug). The 2 plugged packets act as a buffer. These packets ensure that the hfsc qdisc (100:0) is never empty, even during the prio-sfq interaction, which ends up contributing -1 qlen. Without the 2 plugged packets, when we trigger the prio-sfq interaction, the hfsc qdisc (100:0) will be detected as empty, and thus the hfsc class 99:1 will be unlinked, preventing subsequent UAF.
2. Hit the race condition (as explained above), causing the "vuln" subtree root prio qdisc to have qlen = -1. This means that the parent hfsc (100:0) has qlen = 1 (2 from the plug, -1 from the prio)
3. Delete the plug qdisc (102:0). This calls `qdisc_purge_queue()`, which propagates the 2 dropped packets up the qdisc hierachy with `qdisc_tree_reduce_backlog()`. The 2 packets are subtracted from the parent hfsc (100:0) qlen = 1, underflowing its qlen. Crucially, because the 2 packets are dropped together, the parent qlen drops from 1 to -1, never reaching qlen = 0 and so avoids being detected as empty.
```c
static inline void qdisc_purge_queue(struct Qdisc *sch)
{
	__u32 qlen, backlog;

	qdisc_qstats_qlen_backlog(sch, &qlen, &backlog);
	qdisc_reset(sch);
	qdisc_tree_reduce_backlog(sch, qlen, backlog);
}
```
4. Send 1 packet into the "vuln" subtree prio qdisc. Specifically, we can add a new plug qdisc to the prio and send to that. This returns all qlens to 0.
This step ensures that when the class is deleted in step 5, and `qdisc_purge_queue()` calls `qdisc_tree_reduce_backlog()`, the qlen passed in the call is zero, so `qdisc_tree_reduce_backlog()` will not notify the hfsc parent that the child is now empty.
```c
void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
{
	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
	const struct Qdisc_class_ops *cops;
	unsigned long cl;
	u32 parentid;
	bool notify;
	int drops;

	if (n == 0 && len == 0)
		return;
	drops = max_t(int, n, 0);
	rcu_read_lock();
	while ((parentid = sch->parent)) {
		if (parentid == TC_H_ROOT)
			break;

		if (sch->flags & TCQ_F_NOPARENT)
			break;
		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&              // parent is notified if (n)
						       !qdisc_is_offloaded);
		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
		if (sch == NULL) {
			WARN_ON_ONCE(parentid != TC_H_ROOT);
			break;
		}
		cops = sch->ops->cl_ops;
		if (notify && cops->qlen_notify) {
			cl = cops->find(sch, parentid);
			cops->qlen_notify(sch, cl);
		}
		sch->q.qlen -= n;
		sch->qstats.backlog -= len;
		__qdisc_qstats_drop(sch, drops);
	}
	rcu_read_unlock();
}
```

5. Delete hfsc class 99:1.

At this point, we have a dangling reference to the hfsc_class in the hfsc qdisc 99:0.

## LPE
From this point on, there are many documented strategies to achieve LPE.

For COS, we use the strategy outlined in [CVE-2023-4623](https://github.com/google/security-research/blob/66053d865bf43b3e8d379f41f353e3b125cf4524/pocs/linux/kernelctf/CVE-2023-4623_lts_cos/docs/exploit.md#write-what-where). There are 2 differences in our exploit: we use `struct user_key_payload` to reclaim instead of `simple_xattr`, and a different ROP chain. First, in `spray_keyring()`, reclaim the UAF class with `struct user_key_payload`, which contents we can [control](https://bsauce.github.io/2021/09/26/kernel-exploit-%E6%9C%89%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93/#5-add_key). This is elastic size, and allocated with `GFP_KERNEL`, so it is allocated in the same cache as the hfsc_class (in fact, all qdisc classes are allocated with `GFP_KERNEL`).

```c
static int
hfsc_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
		  struct nlattr **tca, unsigned long *arg,
		  struct netlink_ext_ack *extack)
{
	// [...]
	cl = kzalloc(sizeof(struct hfsc_class), GFP_KERNEL);
```

```c
int user_preparse(struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload;
	size_t datalen = prep->datalen;

	if (datalen <= 0 || datalen > 32767 || !prep->data)
		return -EINVAL;

	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
```


This method manipulates internal hfsc_class pointers to obtain a 8-byte write-what-where (the pointers are set in `prep_key_desc()`). We use the write-what-where to overwrite the `qfq_qdisc_ops.change()` pointer, and perform ROP. Using available rop gadgets, we overwrite core_pattern with our program path using copy_from_user then simply call msleep. Another thread of our exploit notice the /proc/sys/kernel/core_pattern changes, it will try to crash itself so our exploit will executed as high privilege and gives us root shell to get the flag.

## Mitigation exploit
For Mitigation, we use the strategy introduced by Lion Ackermann in [CVE-2025-21700](https://github.com/liona24/security-research/blob/CVE-2025-21700/pocs/linux/kernelctf/CVE-2025-21700_lts_cos_mitigation/docs/exploit.md#mitigation-instance). The strategy involves confusing drr_class with qfq_class to obtain RIP control. As such, we wish to obtain a UAF qfq_class instead of the hfsc_class obtained above. It is simple to do so, we can simply make the main tree a child of the target qfq qdisc:
```
   f0:0 (qfq)
  /    \
f0:1  f0:2
  |
main
```

We construct this new tree in the function `setup_root_hierachy()`. Performing all the same actions on the main subtree allows us to delete the qfq_class f0:1, while leaving a dangling reference to it. This gives us a UAF qfq_class, and the subsequent exploit follows that of CVE-2025-21700. For clarity, we perform the reclaimation of the qfq_class on a separate device, so that it does not interfere with the vulnerable hierachy. Specifically, in `do_reclaim_qfq_class()`, we reclaim the UAF `qfq_class` with sprayed `drr_class`.

For storing the ROP chain, we choose to use [`kernfs_pr_cont_buf`](https://github.com/zerozenxlabs/ZDI-24-020?tab=readme-ov-file#bypassing-smap) because this gives us more space to craft required structs and a ROP chain. We use the xtables binary to populate the buffer with the command: `./xtables iptables -A OUTPUT -m cgroup --path <payload>`. In the exploit code, this is done in `send_kernfs_data()`.. The kernel codepath ends up in:
```c
static char kernfs_pr_cont_buf[PATH_MAX];	/* protected by pr_cont_lock */

static struct kernfs_node *kernfs_walk_ns(struct kernfs_node *parent,
					  const unsigned char *path,                          // path is the user-specified payload
					  const void *ns)
{
	ssize_t len;
	char *p, *name;

	lockdep_assert_held_read(&kernfs_root(parent)->kernfs_rwsem);

	spin_lock_irq(&kernfs_pr_cont_lock);

	len = strscpy(kernfs_pr_cont_buf, path, sizeof(kernfs_pr_cont_buf));  // it is copied into kernfs_pr_cont_buf

	if (len < 0) {
		spin_unlock_irq(&kernfs_pr_cont_lock);
		return NULL;
	}

	p = kernfs_pr_cont_buf;

	while ((name = strsep(&p, "/")) && parent) {                          // result: first few slashes are replaced with nulls
		if (*name == '\0')
			continue;
		parent = kernfs_find_ns(parent, name, ns);
	}

	spin_unlock_irq(&kernfs_pr_cont_lock);

	return parent;
}
```

> This has a few limitations that we account for: the `strscpy()` call means no null bytes in payload (not an issue), and the `strsep()` call replaces the first few forward slash characters with nulls (we can simply add a few slashes to the start of the payload) as it looks up the parent.

Finally, we perform a ROP to core_pattern overwrite. Comparing to the COS ROP chain, instead of msleep, we enter an infinite loop as calling msleep will cause the kernel to detect that we have corrupted timer context.