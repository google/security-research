#ifndef PWN_QDISC_H
#define PWN_QDISC_H

char *PWN_TC_QDISC_INTERFACE = "lo";

int create_qdisc(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;

	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "drr");

	return netlink_send(sock_fd, nlh);
}

int create_qdisc_plug1024(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;

	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "plug");

	struct tc_plug_qopt opt = {
		.limit = 1024};
	mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_plug_qopt), &opt);

	return netlink_send(sock_fd, nlh);
}

int modify_qdisc_plug_unplug(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;

	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "plug");

	struct tc_plug_qopt opt = {
		.action = TCQ_PLUG_RELEASE_INDEFINITE,
	};
	mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_plug_qopt), &opt);

	return netlink_send(sock_fd, nlh);
}

int create_qdisc_prio(int sock_fd, __u32 my_handle, __u32 parent_handle, int bands)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;

	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "prio");

	struct tc_prio_qopt opt = {
		.bands = bands,
		.priomap = {0}};
	mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_prio_qopt), &opt);

	return netlink_send(sock_fd, nlh);
}

int create_qdisc_sfq(int sock_fd, __u32 my_handle, __u32 parent_handle, __u32 perturb_period)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "sfq");

	// setting options to 0 makes sfq_init ignore them
	struct tc_sfq_qopt_v1 opt = {
		.v0 = {
			.perturb_period = perturb_period,
			.flows = 2, // maxflows (# of slots)
			.divisor = 2,
			.limit = 0,
			.quantum = 0},
		.depth = 2 // maxdepth (limit for each slot)
	};
	mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_sfq_qopt_v1), &opt);

	return netlink_send(sock_fd, nlh);
}

int create_qdisc_sfq_spam(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "sfq");

	// setting options to 0 makes sfq_init ignore them
	struct tc_sfq_qopt_v1 opt = {
		.v0 = {
			.perturb_period = 0,
			.flows = (0x10000 - 127 - 1), // maxflows (# of slots)
			.divisor = 65536,
			.limit = 0xffffffff,
			.quantum = 0},
		.depth = 127 // maxdepth (limit for each slot)
	};
	mnl_attr_put(nlh, TCA_OPTIONS, sizeof(struct tc_sfq_qopt_v1), &opt);

	return netlink_send(sock_fd, nlh);
}

#define NLMSG_TAIL(nmsg) \
	((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int create_qdisc_hfsc_defaultclass(int sock_fd, __u32 my_handle, __u32 parent_handle, __u16 defcls)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "hfsc");

	struct tc_hfsc_qopt qopt = {
		.defcls = defcls};
	mnl_attr_put(nlh, TCA_OPTIONS, sizeof(qopt), &qopt);

	return netlink_send(sock_fd, nlh);
}

int create_qdisc_pfifo(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "pfifo");

	return netlink_send(sock_fd, nlh);
}

int create_qdisc_qfq(int sock_fd, __u32 my_handle, __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWQDISC;

	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_ACK | NLM_F_CREATE;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "qfq");

	return netlink_send(sock_fd, nlh);
}

int delete_qdisc(int sock_fd, __u32 my_handle, __u32 parent_handle, const char *kind)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_DELQDISC;

	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, kind);

	return netlink_send(sock_fd, nlh);
}

int create_class(const int sock_fd, const __u32 child_handle, const __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);
	nlh->nlmsg_type = RTM_NEWTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE | NLM_F_ACK;
	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;

	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = child_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "drr");

	struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);
	mnl_attr_nest_end(nlh, opts);

	return netlink_send(sock_fd, nlh);
}

int create_class_hfsc(const int sock_fd, const __u32 child_handle, const __u32 parent_handle, struct tc_service_curve *rsc, struct tc_service_curve *fsc, struct tc_service_curve *usc)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE | NLM_F_ACK;
	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;

	tcm->tcm_handle = child_handle;
	tcm->tcm_parent = parent_handle;
	mnl_attr_put_strz(nlh, TCA_KIND, "hfsc");
	struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);

	if (rsc)
		mnl_attr_put(nlh, TCA_HFSC_RSC, sizeof(struct tc_service_curve), rsc);
	if (fsc)
		mnl_attr_put(nlh, TCA_HFSC_FSC, sizeof(struct tc_service_curve), fsc);
	if (usc)
		mnl_attr_put(nlh, TCA_HFSC_USC, sizeof(struct tc_service_curve), usc);

	mnl_attr_nest_end(nlh, opts);

	return netlink_send(sock_fd, nlh);
}

int create_class_qfq(const int sock_fd, const __u32 child_handle, const __u32 parent_handle)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);
	nlh->nlmsg_type = RTM_NEWTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE | NLM_F_ACK;
	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;

	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = child_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, "qfq");

	struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);
	mnl_attr_put_u32(nlh, TCA_QFQ_WEIGHT, 1);
	mnl_attr_put_u32(nlh, TCA_QFQ_LMAX, 50000);

	mnl_attr_nest_end(nlh, opts);

	return netlink_send(sock_fd, nlh);
}

int modify_class_drr_quantum(const int sock_fd, const __u32 child_handle, const __u32 parent_handle, const __u32 quantum)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_NEWTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_ACK;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;

	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = child_handle;
	tcm->tcm_parent = parent_handle;
	mnl_attr_put_strz(nlh, TCA_KIND, "drr");

	struct nlattr *opts = mnl_attr_nest_start(nlh, TCA_OPTIONS);
	mnl_attr_put_u32(nlh, TCA_DRR_QUANTUM, quantum);
	mnl_attr_nest_end(nlh, opts);

	return netlink_send(sock_fd, nlh);
}

int delete_class(int sock_fd, __u32 my_handle, __u32 parent_handle, const char *kind)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_DELTCLASS;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;
	tcm->tcm_handle = my_handle;
	tcm->tcm_parent = parent_handle;

	mnl_attr_put_strz(nlh, TCA_KIND, kind);

	return netlink_send(sock_fd, nlh);
}

// section to dump qdisc (get qlen/backlog)
// Function to parse TC attributes
static void parse_tc_attrs(struct rtattr *tb[], int max, void *buf, int len)
{
	memset(tb, 0, sizeof(struct rtattr *) * (max + 1));

	struct rtattr *rta = buf;
	while (RTA_OK(rta, len))
	{
		if (rta->rta_type <= max)
			tb[rta->rta_type] = rta;
		rta = RTA_NEXT(rta, len);
	}
}

struct qdisc_stats
{
	unsigned int backlog;
	unsigned int qlen;
	unsigned int handle;
};

static void dump_qdisc_v2_callback_parser(char *buf, void *result_)
{
	struct nlmsghdr *n = (struct nlmsghdr *)buf;
	struct tcmsg *t = NLMSG_DATA(n);
	int len = n->nlmsg_len;
	struct rtattr *tb[TCA_MAX + 1];
	struct qdisc_util *q;
	char abuf[256];
	(void)q;
	(void)abuf;

	if (n->nlmsg_type != RTM_NEWQDISC)
	{
		fatal("wrong type");
	}
	len -= NLMSG_LENGTH(sizeof(*t));
	if (len < 0)
	{
		fprintf(stderr, "Wrong len %d\n", len);
		fatal("bad");
	}
	parse_tc_attrs(tb, TCA_MAX, TCA_RTA(t), len);
	if (tb[TCA_STATS])
	{
		struct tc_stats st = {};
/* handle case where kernel returns more/less than we know about */
#define MIN_my(a, b) (((a) < (b)) ? (a) : (b))
		memcpy(&st, RTA_DATA(tb[TCA_STATS]), MIN_my(RTA_PAYLOAD(tb[TCA_STATS]), sizeof(st)));
		struct qdisc_stats *stats = result_;
		stats->backlog = st.backlog;
		stats->qlen = st.qlen;
	}
	else
	{
		fatal("no stats");
	}
}

static void dump_qdisc_v2_callback(char *nlbuf, size_t len, void *result_)
{
	struct nlmsghdr *nlh = (struct nlmsghdr *)nlbuf;

	// Process all messages in the received buffer
	for (; NLMSG_OK(nlh, len); nlh = NLMSG_NEXT(nlh, len))
	{
		// Check for end of message
		if (nlh->nlmsg_type == NLMSG_DONE)
			break;

		// Skip error messages, already handled
		if (nlh->nlmsg_type == NLMSG_ERROR)
			continue;

		// Only process QDISC responses
		if (nlh->nlmsg_type != RTM_NEWQDISC)
			continue;

		// Get the tcmsg structure
		struct tcmsg *tcm = NLMSG_DATA(nlh);

		// Skip if not the qdisc we're looking for
		if (tcm->tcm_handle != ((struct qdisc_stats *)result_)->handle)
			continue;

		dump_qdisc_v2_callback_parser((char *)nlh, result_);
		return;
	}

	((struct qdisc_stats *)result_)->handle = ~0u;
}

int dump_qdisc_v2(int sock_fd, __u32 my_handle, struct qdisc_stats *stats)
{
	char buf[0x1000] = {0};
	struct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);

	nlh->nlmsg_type = RTM_GETQDISC;
	nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;

	struct tcmsg *tcm = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
	tcm->tcm_family = AF_UNSPEC;
	unsigned int ifindex = if_nametoindex(PWN_TC_QDISC_INTERFACE);
	if (ifindex == 0)
		fatal("ifindex");
	tcm->tcm_ifindex = ifindex;

	const size_t o_buf_sz = 9192;
	char *o_buf = calloc(1, o_buf_sz);
	if (!o_buf)
		fatal("calloc o_buf");

	stats->handle = my_handle;

	struct netlink_send_cb_struct cb_info = {
		.cb = dump_qdisc_v2_callback,
		.cb_out = stats};
	int res = __netlink_send(sock_fd, nlh, nlh->nlmsg_len, o_buf, o_buf_sz, 1, &cb_info);
	free(o_buf);
	if (stats->handle == ~0u)
	{
		// error from dump_qdisc_v2_callback - the specified handle was not found
		return 1;
	}
	return res;
}

#endif