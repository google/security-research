#!/usr/bin/env python3
"""
Test module for CVE Parser

This module contains test cases and sample data generation
to demonstrate and validate the CVE parser functionality.
"""

import json
import os
import tempfile
import unittest
from pathlib import Path

from cve_parser import CVEParser


class TestCVEParser(unittest.TestCase):
    """Test cases for the CVE parser."""
    
    def setUp(self):
        """Set up test environment with sample repository structure."""
        # Create temporary directories
        self.test_dir = tempfile.mkdtemp()
        self.repo_dir = Path(self.test_dir) / "test_repo"
        self.output_dir = Path(self.test_dir) / "output"
        
        # Create test repository structure
        self._create_test_repository()
    
    def tearDown(self):
        """Clean up test environment."""
        import shutil
        shutil.rmtree(self.test_dir)
    
    def _create_test_repository(self):
        """Create a sample repository structure with test files."""
        # Create directory structure
        kernel_dir = self.repo_dir / "kernel" / "CVE-2023-12345"
        android_dir = self.repo_dir / "android" / "memory_corruption"
        chromium_dir = self.repo_dir / "chromium" / "browser_bug"
        exploits_dir = self.repo_dir / "exploits" / "kernel_exploit"
        
        for dir_path in [kernel_dir, android_dir, chromium_dir, exploits_dir]:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        # Create test files with CVE references
        test_files = [
            {
                'path': kernel_dir / "README.md",
                'content': """# Kernel Vulnerability CVE-2023-12345

This is a test vulnerability report for CVE-2023-12345.
The issue was discovered on 2023-01-15.

## Details
- Component: Linux Kernel
- CVE ID: CVE-2023-12345
- Also related to: CVE-2023-54321

Date: 2023-01-15
"""
            },
            {
                'path': android_dir / "vulnerability_report.txt",
                'content': """Android Memory Corruption Issue

CVE-2022-98765 affects Android framework.
Published: 2022-12-01

This vulnerability is also related to CVE-2022-11111.
"""
            },
            {
                'path': chromium_dir / "browser_issue_2023-03-20.md",
                'content': """# Chromium Browser Bug

This file documents CVE-2023-33333.
The issue affects Chrome browser versions.

No other CVE references in this file.
"""
            },
            {
                'path': exploits_dir / "exploit.patch",
                'content': """--- a/kernel/module.c
+++ b/kernel/module.c
@@ -1,5 +1,5 @@
 /* Exploit for CVE-2023-77777 */
 
 // This patch demonstrates the vulnerability
 // CVE-2023-77777 allows privilege escalation
"""
            },
            {
                'path': self.repo_dir / "README.md",
                'content': """# Security Research Repository

This repository contains security research.
No CVE references in the main README.
"""
            }
        ]
        
        # Write test files
        for file_info in test_files:
            with open(file_info['path'], 'w', encoding='utf-8') as f:
                f.write(file_info['content'])
    
    def test_initialization(self):
        """Test CVE parser initialization."""
        parser = CVEParser(str(self.repo_dir), str(self.output_dir))
        
        self.assertEqual(parser.repo_dir, self.repo_dir)
        self.assertEqual(parser.output_dir, self.output_dir)
        self.assertTrue(self.output_dir.exists())
    
    def test_initialization_invalid_repo(self):
        """Test initialization with invalid repository path."""
        with self.assertRaises(FileNotFoundError):
            CVEParser("/nonexistent/path", str(self.output_dir))
    
    def test_cve_pattern_detection(self):
        """Test CVE pattern regex."""
        test_cases = [
            ("CVE-2023-12345", True),
            ("CVE-2022-98765", True),
            ("CVE-1999-0001", True),
            ("CVE-2023-1234567", True),  # 7 digits
            ("CVE-2023-123", False),     # too few digits
            ("CVE-23-12345", False),     # invalid year format
            ("cve-2023-12345", False),   # lowercase
            ("Not a CVE", False),
        ]
        
        for text, should_match in test_cases:
            matches = CVEParser.CVE_PATTERN.findall(text)
            if should_match:
                self.assertTrue(matches, f"Should match: {text}")
                self.assertEqual(matches[0], text)
            else:
                self.assertFalse(matches, f"Should not match: {text}")
    
    def test_date_extraction_from_filename(self):
        """Test date extraction from filenames."""
        parser = CVEParser(str(self.repo_dir), str(self.output_dir))
        
        test_cases = [
            ("report_2023-01-15.md", "2023-01-15"),
            ("bug_2022_12_01.txt", "2022_12_01"),
            ("vulnerability_20230320.patch", "20230320"),
            ("no_date_file.md", None),
            ("mixed_2023-01-15_report.txt", "2023-01-15"),
        ]
        
        for filename, expected_date in test_cases:
            result = parser._guess_date_from_filename(filename)
            self.assertEqual(result, expected_date, f"Failed for: {filename}")
    
    def test_component_extraction(self):
        """Test component extraction from file paths."""
        parser = CVEParser(str(self.repo_dir), str(self.output_dir))
        
        test_cases = [
            (self.repo_dir / "kernel" / "bug" / "file.md", "kernel"),
            (self.repo_dir / "android" / "vuln" / "report.txt", "android"),
            (self.repo_dir / "chromium" / "issue.md", "chromium"),
            (self.repo_dir / "exploits" / "exploit.patch", "exploits"),
        ]
        
        for file_path, expected_component in test_cases:
            result = parser._get_component_from_path(file_path)
            self.assertEqual(result, expected_component)
    
    def test_full_scan(self):
        """Test complete repository scanning."""
        parser = CVEParser(str(self.repo_dir), str(self.output_dir))
        parser.scan_repository()
        
        # Check that CVEs were found
        self.assertGreater(len(parser.cve_data), 0)
        
        # Verify expected CVEs are found
        found_cves = {entry['cve_id'] for entry in parser.cve_data}
        expected_cves = {
            'CVE-2023-12345', 'CVE-2023-54321',  # from kernel README
            'CVE-2022-98765', 'CVE-2022-11111',  # from android report
            'CVE-2023-33333',                    # from chromium bug
            'CVE-2023-77777'                     # from exploit patch
        }
        
        self.assertTrue(expected_cves.issubset(found_cves))
        
        # Check component classification
        components = {entry['component'] for entry in parser.cve_data}
        expected_components = {'kernel', 'android', 'chromium', 'exploits'}
        self.assertTrue(expected_components.issubset(components))
    
    def test_folder_filtering(self):
        """Test scanning with specific folder filtering."""
        # Test scanning only kernel folder
        parser = CVEParser(str(self.repo_dir), str(self.output_dir), folders=['kernel'])
        parser.scan_repository()
        
        # Should only find CVEs from kernel folder
        components = {entry['component'] for entry in parser.cve_data}
        self.assertEqual(components, {'kernel'})
        
        found_cves = {entry['cve_id'] for entry in parser.cve_data}
        kernel_cves = {'CVE-2023-12345', 'CVE-2023-54321'}
        self.assertTrue(kernel_cves.issubset(found_cves))
    
    def test_json_output(self):
        """Test JSON file generation."""
        parser = CVEParser(str(self.repo_dir), str(self.output_dir))
        parser.scan_repository()
        parser.save_json()
        
        # Check that JSON file was created
        json_file = self.output_dir / "cve_data.json"
        self.assertTrue(json_file.exists())
        
        # Verify JSON content
        with open(json_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        self.assertIsInstance(data, list)
        self.assertGreater(len(data), 0)
        
        # Check structure of first entry
        first_entry = data[0]
        required_fields = {'cve_id', 'component', 'file_path'}
        self.assertTrue(required_fields.issubset(first_entry.keys()))
    
    def test_csv_output(self):
        """Test CSV file generation."""
        parser = CVEParser(str(self.repo_dir), str(self.output_dir))
        parser.scan_repository()
        parser.save_csv()
        
        # Check that CSV file was created
        csv_file = self.output_dir / "cve_data.csv"
        self.assertTrue(csv_file.exists())
        
        # Verify CSV content
        with open(csv_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Check for header row
        self.assertIn('cve_id', content)
        self.assertIn('component', content)
        self.assertIn('file_path', content)
        
        # Check for some expected CVE data
        self.assertIn('CVE-2023-12345', content)
        self.assertIn('kernel', content)
    
    def test_html_report(self):
        """Test HTML report generation."""
        parser = CVEParser(str(self.repo_dir), str(self.output_dir))
        parser.scan_repository()
        parser.save_html_report()
        
        # Check that HTML file was created
        html_file = self.output_dir / "cve_report.html"
        self.assertTrue(html_file.exists())
        
        # Verify HTML content
        with open(html_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Check for expected HTML structure
        self.assertIn('<html', content)
        self.assertIn('CVE Analysis Report', content)
        self.assertIn('Summary Statistics', content)
        self.assertIn('CVE Count by Component', content)
    
    def test_summary_report(self):
        """Test summary statistics generation."""
        parser = CVEParser(str(self.repo_dir), str(self.output_dir))
        parser.scan_repository()
        summary = parser.generate_summary_report()
        
        # Check summary structure
        required_keys = {'total_cve_references', 'unique_cves', 'components', 'scan_timestamp'}
        self.assertTrue(required_keys.issubset(summary.keys()))
        
        # Verify counts
        self.assertGreater(summary['total_cve_references'], 0)
        self.assertGreater(summary['unique_cves'], 0)
        self.assertGreater(len(summary['components']), 0)
        
        # Check that components have counts
        for component, count in summary['components'].items():
            self.assertGreater(count, 0)


def create_sample_dataset():
    """Create a sample dataset for demonstration purposes."""
    print("Creating sample dataset for testing...")
    
    # Create sample directory structure
    sample_dir = Path("sample_security_research")
    
    if sample_dir.exists():
        import shutil
        shutil.rmtree(sample_dir)
    
    # Create directories
    dirs_to_create = [
        "kernel/CVE-2023-1001",
        "kernel/CVE-2023-1002", 
        "android/framework_bug",
        "android/media_vuln",
        "chromium/renderer_issue",
        "exploits/privilege_escalation"
    ]
    
    for dir_path in dirs_to_create:
        (sample_dir / dir_path).mkdir(parents=True, exist_ok=True)
    
    # Create sample files
    sample_files = [
        {
            'path': sample_dir / "kernel/CVE-2023-1001/README.md",
            'content': """# Kernel Use-After-Free Vulnerability

**CVE ID:** CVE-2023-1001

## Summary
This vulnerability affects the Linux kernel networking subsystem.
Related to CVE-2023-1000.

**Reported:** 2023-03-15
**Component:** kernel/net
"""
        },
        {
            'path': sample_dir / "kernel/CVE-2023-1002/exploit.patch",
            'content': """diff --git a/kernel/module.c b/kernel/module.c
index 1234567..abcdefg 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -10,3 +10,4 @@
 /* Exploit for CVE-2023-1002 */
+/* This demonstrates the vulnerability */
"""
        },
        {
            'path': sample_dir / "android/framework_bug/report_2023-02-20.txt",
            'content': """Android Framework Vulnerability Report

CVE-2023-2001: Memory corruption in Android framework
CVE-2023-2002: Information disclosure vulnerability

Date: 2023-02-20
Severity: High
"""
        },
        {
            'path': sample_dir / "android/media_vuln/analysis.md",
            'content': """# Android Media Framework Analysis

This document analyzes CVE-2022-9999 in the Android media framework.

## Impact
The vulnerability CVE-2022-9999 allows arbitrary code execution.
"""
        },
        {
            'path': sample_dir / "chromium/renderer_issue/bug_report.txt",
            'content': """Chromium Renderer Bug Report

Issue: CVE-2023-3001
Component: Blink renderer
Reported: 2023-04-10

This affects CVE-2023-3001 and potentially CVE-2023-3002.
"""
        },
        {
            'path': sample_dir / "exploits/privilege_escalation/poc.md",
            'content': """# Privilege Escalation Exploit

## CVE Information
- Primary: CVE-2023-4001  
- Related: CVE-2023-4002, CVE-2023-4003

## Proof of Concept
This demonstrates exploitation of CVE-2023-4001.

Published: 2023-05-01
"""
        }
    ]
    
    # Write sample files
    for file_info in sample_files:
        with open(file_info['path'], 'w', encoding='utf-8') as f:
            f.write(file_info['content'])
    
    print(f"Sample dataset created in: {sample_dir}")
    print("You can now test the parser with:")
    print(f"python cve_parser.py --repo-dir {sample_dir} --output-dir ./sample_output --html-report")
    
    return sample_dir


if __name__ == "__main__":
    # Check command line arguments
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "--create-sample":
        create_sample_dataset()
    else:
        # Run tests
        unittest.main() 